Don Siegfriedt <siggy@cinesite.com>

     $d               # delete the last line of the file
     /[0-9]\{3\}/p    # print lines with 3 consecutive digits
     5!s/ham/cheese/  # except on line 5, replace 'ham' with 'cheese'
     /awk/!s/aaa/bb/  # unless 'awk' is found, replace 'aaa' with 'bb'
     17,/foo/d        # delete all lines from line 17 up to 'foo'

*****
2. Common one-line sed scripts

  A separate document of over 70 handy "one-line" sed commands is
  available at <http://www.cornerstonemag.com/sed/sed1line.txt>. Here
  are fourteen of the most common sed commands for one-line use.
  MS-DOS users should replace single quotes ('...') with double
  quotes ("...") in these examples. A specific filename ("file")
  usually follows the script, though the input may also come via
  piping ("sort somefile | sed 'somescript'").

  # 1. Double space a file
  sed G file

  # 2. Triple space a file
  sed 'G;G' file

  # 3. Under UNIX: convert DOS newlines (CR/LF) to Unix format
  sed 's/.$//' file    # assumes that all lines end with CR/LF
  sed 's/^M$// file    # in bash/tcsh, press Ctrl-V then Ctrl-M

  # 4. Under DOS: convert Unix newlines (LF) to DOS format
  sed 's/$//' file                     # method 1
  sed -n p file                        # method 2

  # 5. Delete leading whitespace (spaces/tabs) from front of each line
  # (this aligns all text flush left). '^t' represents a true tab
  # character. Under bash or tcsh, press Ctrl-V then Ctrl-I.
  sed 's/^[ ^t]*//' file

  # 6. Delete trailing whitespace (spaces/tabs) from end of each line
  sed 's/[ ^t]*$//' file               # see note on '^t', above

  # 7. Delete BOTH leading and trailing whitespace from each line
  sed 's/^[ ^t]*//;s/[ ^]*$//' file    # see note on '^t', above

  # 8. Substitute "foo" with "bar" on each line
  sed 's/foo/bar/' file        # replaces only 1st instance in a line
  sed 's/foo/bar/4' file       # replaces only 4th instance in a line
  sed 's/foo/bar/g' file       # replaces ALL instances within a line

  # 9. Substitute "foo" with "bar" ONLY for lines which contain "baz"
  sed '/baz/s/foo/bar/g' file

  # 10. Delete all CONSECUTIVE blank lines from file except the first.
  # This method also deletes all blank lines from top and end of file.
  # (emulates "cat -s")
  sed '/./,/^$/!d' file       # this allows 0 blanks at top, 1 at EOF
  sed '/^$/N;/\n$/D' file     # this allows 1 blank at top, 0 at EOF

  # 11. Delete all leading blank lines at top of file (only).
  sed '/./,$!d' file

  # 12. Delete all trailing blank lines at end of file (only).
  sed -e :a -e '/^\n*$/N;/\n$/ba' file

  # 13. If a line ends with a backslash, join the next line to it.
  sed -e :a -e '/\\$/N; s/\\\n//; ta' file

  # 14. If a line begins with an equal sign, append it to the
  # previous line (and replace the "=" with a single space).
  sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D' file

****
Remove all the ^Ms using the following line:

tr -d '\r' < file-in > file-out
*****
delete # (comments) from specific line

sed /10.1.10.21/s/#// /home/siggy/resolv.siggy
*****
# remove most HTML tags (accommodates multiple-line tags)
 sed -e :a -e 's/<[^<]*>/ /g;/</{N;s/\n/ /;ba;}'

Sed is often used as a find-and-replace tool.

      sed 's/Glenn/Harold/g' oldfile >newfile

Next, I found that sed could show me only (say) lines 12-18 of a
   file and not show me the rest. This was very handy when I needed to
   review only part of a long file and I didn't want to alter it.

      sed -n 12,18p myfile   # the 'p' stands for print

o match a block of two or more lines, there are 3 basic choices:
 (1) use the 'N' command to add the Next line to the pattern space;
 (2) use the 'H' command at least twice to append the current line
 to the Hold space, and then retrieve the lines from the hold space
 with x, g, or G; or (3) use address ranges (see section 3.3, above)
 to match lines between two specified addresses.
   
 Choices (1) and (2) will put an \n into the pattern space, where it
 can be addressed as desired ('s/ABC\nXYZ/alphabet/g'). One example
 of using 'N' to delete a block of lines appears in section 4.13
 ("How do I delete a block of specific consecutive lines?"). This
 example can be modified by changing the delete command to something
 else, like 'p' (print), 'i' (insert), 'c' (change), 'a' (append),
 or 's' (substitute).

 Choice (3) will not put an \n into the pattern space, but it does
 match a block of consecutive lines, so it may be that you don't
 even need the \n to find what you're looking for. Since GNU sed
 version 3.02.80 now supports this syntax:

    sed '/start/,+4d'  # to delete "start" plus the next 4 lines,

 in addition to the traditional '/from here/,/to there/{...}' range
 addresses, it may be possible to avoid the use of \n entirely.

2.9 How do i append before the regular expression line?

For more extensive information, please refer to the sed and awk man files.

If i had to add to a document that needed to have appended before the we might do a:

/< BODY >/i\
Hello World\
This one has happened b4\.

This can be quite useful especially for redundant tasks. It is up to you to take 
the foundation of anything and expand its consciousness:) The above works providing 
what experiment and learn. 

2.10 How do i insert after the regular expression line?

For more extensive information, please refer to the sed and awk man files.

this very simular to the insert example that was illustrated above. Just do a:

/< BODY>/a\
Hello World\
This one comes after\.

So that means at this time you are now able to alter text on a specific line basis, 
add text before a specific line or after a specific line.

2.11 How do i change a specific pattern in lines?

For more extensive information, please refer to the sed and awk man files.

Change is very powerful so consider that you needed to make all your file Header 
tags a bit smaller or rather more accurately deeper subheadings. How would you do 
that so they all were say from < H1> to < H3> ??? Well this is how although i leave 
the advanced logic to the reader's imagination and workmanship.

/< H1>/c\
< H3>

This would change everything when it came to the < H1> tag this tag would no longer be 
< H1> rather it would globally now be called < H3> which is a lot smaller or deeper 
depending on how you look at things.

    * The '^' character means the beginning of the line.

>sed 's/^Thu /Thursday/' filename 

# The '$' character means the end of the line.

>sed 's/ $//' filename

You can "replace" the end of the line, like this:

>sed 's/$/EOL/' filename 

http://www.cs.hmc.edu/tech_docs/qref/sed.html

http://queen.rett.polimi.it/~paolob/seders/tutorials/do_it_with_sed.txt

http://queen.rett.polimi.it/~paolob/seders/tutorials/

append	[line-address]a\
	text
insert	[line-address]i\
	text
change	[address]c\
	text

http://www.math.fu-berlin.de/~leitner/sed/tutorial.html

http://www.student.northpark.edu/pemente/sed/sed1line.txt

http://www-h.eng.cam.ac.uk/help/tpl/unix/sed.html

*****
to look at poboxx's /var/log/messages without dhcpd errors

sed /dhcpd/d /home/siggy/TMP/messages | more

*****
to make a machine list (from ypcat hosts)

ypcat hosts | awk '{print $3, $4}' | sort -fuo ~siggy/hostlist

-f ignore case
-u unique
-o output file

on laurel

cat  /etc/NIS/hosts | awk '{print $3, $5}' | sort -fu

will give you a list with machine type (for the most part) if 
the machine has no aliases

*****
To remove all instaces of "gate-<whatever>" in a file

sed s/gate-\*//g gen3n > blorf1

*****
To get a list of users (ONLY) and output to a file...
ypcat passwd | awk -F":" '{print $1}' | sort -fuo /home/siggy/<filename>
*****
22Dec05 for SED version 4.1.2-4 (so far)

To add line to the correct place in a fstab file.....

#cat fstab | grep data | sed '2/i\ adding-new-stuff-here\n2ndline to be added' 
cow:/stuff1             /data/stuff1            ext3    defaults        0 0
adding-new-stuff-here
2ndline to be added
manfred:/stuff2         /data/stuff2            ext3    defaults        0 0
pavel:/stuff3           /data/stuff3            ext3    defaults        1 1
hagen:stuff4            /data/stuff4            ext3    defaults        1 1
*****
The range for deletions can be regular expressions pairs to mark the begin and end of the operation. Or it can be a single regular expression. Deleting all lines that start with a "#" is easy:

sed '/^#/ d'

Removing comments and blank lines takes two commands. The first removes every character from the "#" to the end of the line, and the second deletes all blank lines:

sed -e 's/#.*//' -e '/^$/ d'

A third one should be added to remove all blanks and tabs immediately before the end of line:

sed -e 's/#.*//' -e 's/[ ^I]*$//' -e '/^$/ d' 

*****

7May08  --siggy

sed '/SYSOPS/s/$/\nSTOROPS         ALL=(ALL)      NOPASSWD\: ALL/' /Etc/sudoers > /tmp/siggy-test

sed '/SECURITY=/s/$/\nUser_Alias      STOROPS=%StorOps/' /etc/sudoers > /tmp/siggy-test

# together it looks like this
sed -e '/SECURITY=/s/$/\nUser_Alias      STOROPS=%StorOps/' -e '/SYSOPS/s/$/\nSTOROPS         ALL=(ALL)      NOPASSWD\: ALL/' /etc/sudoers > /tmp/siggy-test

*****
2Sep08  --siggy

to add (insert) a blank line, every 10 lines (number of lines = number of n;)

sed "n;n;n;n;n;n;n;n;n;G;"  ORD-new-prod-list.txt

*****
12sep08  --siggy some stuff for DNS creation of an et/hosts type file from DNS map

cat db.admin.edmunds.com | awk '{print $4"\t\t"$1}' | sed s/$/.admin.edmunds.com/ > etc-hosts-admin
sed /^$/d etc-hosts-admin > etc-hosts-admin.1
5)  This will edit the options file to make sure all the subnets get created correctly
        cat etc-hosts-admin.1 | awk '{print $1}' | awk -F. '{print $1"."$2"."$3}' | sort -u | grep 10. | sed s/^/-n" "/ >> h2n-options 
sed -e /\;/d -e /^$/d -e /CNAME/d db.admin.edmunds.com.bk091208  > blah

sed -e /\;/d -e /^$/d -e /CNAME/d db.admin.edmunds.com.bk091208 | awk '{print $4"\t\t"$1}' | sed s/$/.siggy.test.com/ > blah

sed -e /\;/d -e /^$/d -e /CNAME/d -e '1,13d' db.admin.edmunds.com.bk091208 | awk '{print $4"\t\t"$1}' | sed s/$/.siggy.test.com/ > blah

*****
12sep08  --siggy  to delete the top 10 lines  

sed '1,10d'
*****
-------------------------------------------------------------------------
HANDY ONE-LINERS FOR SED (Unix stream editor)               Apr. 26, 2004
compiled by Eric Pement - pemente[at]northpark[dot]edu        version 5.4
Latest version of this file is usually at:
   http://sed.sourceforge.net/sed1line.txt
   http://www.student.northpark.edu/pemente/sed/sed1line.txt
This file is also available in Portuguese at:
   http://www.lrv.ufsc.br/wmaker/sed_ptBR.html

FILE SPACING:

 # double space a file
 sed G

 # double space a file which already has blank lines in it. Output file
 # should contain no more than one blank line between lines of text.
 sed '/^$/d;G'

 # triple space a file
 sed 'G;G'

 # undo double-spacing (assumes even-numbered lines are always blank)
 sed 'n;d'

 # insert a blank line above every line which matches "regex"
 sed '/regex/{x;p;x;}'

 # insert a blank line below every line which matches "regex"
 sed '/regex/G'

 # insert a blank line above and below every line which matches "regex"
 sed '/regex/{x;p;x;G;}'

NUMBERING:

 # number each line of a file (simple left alignment). Using a tab (see
 # note on '\t' at end of file) instead of space will preserve margins.
 sed = filename | sed 'N;s/\n/\t/'

 # number each line of a file (number on left, right-aligned)
 sed = filename | sed 'N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /'

 # number each line of file, but only print numbers if line is not blank
 sed '/./=' filename | sed '/./N; s/\n/ /'

 # count lines (emulates "wc -l")
 sed -n '$='

TEXT CONVERSION AND SUBSTITUTION:

 # IN UNIX ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format
 sed 's/.$//'               # assumes that all lines end with CR/LF
 sed 's/^M$//'              # in bash/tcsh, press Ctrl-V then Ctrl-M
 sed 's/\x0D$//'            # gsed 3.02.80, but top script is easier

 # IN UNIX ENVIRONMENT: convert Unix newlines (LF) to DOS format
 sed "s/$/`echo -e \\\r`/"            # command line under ksh
 sed 's/$'"/`echo \\\r`/"             # command line under bash
 sed "s/$/`echo \\\r`/"               # command line under zsh
 sed 's/$/\r/'                        # gsed 3.02.80

 # IN DOS ENVIRONMENT: convert Unix newlines (LF) to DOS format
 sed "s/$//"                          # method 1
 sed -n p                             # method 2

 # IN DOS ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format
 # Can only be done with UnxUtils sed, version 4.0.7 or higher.
 # Cannot be done with other DOS versions of sed. Use "tr" instead.
 sed "s/\r//" infile >outfile         # UnxUtils sed v4.0.7 or higher
 tr -d \r <infile >outfile            # GNU tr version 1.22 or higher

 # delete leading whitespace (spaces, tabs) from front of each line
 # aligns all text flush left
 sed 's/^[ \t]*//'                    # see note on '\t' at end of file

 # delete trailing whitespace (spaces, tabs) from end of each line
 sed 's/[ \t]*$//'                    # see note on '\t' at end of file

 # delete BOTH leading and trailing whitespace from each line
 sed 's/^[ \t]*//;s/[ \t]*$//'

 # insert 5 blank spaces at beginning of each line (make page offset)
 sed 's/^/     /'

 # align all text flush right on a 79-column width
 sed -e :a -e 's/^.\{1,78\}$/ &/;ta'  # set at 78 plus 1 space

 # center all text in the middle of 79-column width. In method 1,
 # spaces at the beginning of the line are significant, and trailing
 # spaces are appended at the end of the line. In method 2, spaces at
 # the beginning of the line are discarded in centering the line, and
 # no trailing spaces appear at the end of lines.
 sed  -e :a -e 's/^.\{1,77\}$/ & /;ta'                     # method 1
 sed  -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/'  # method 2

 # substitute (find and replace) "foo" with "bar" on each line
 sed 's/foo/bar/'             # replaces only 1st instance in a line
 sed 's/foo/bar/4'            # replaces only 4th instance in a line
 sed 's/foo/bar/g'            # replaces ALL instances in a line
 sed 's/\(.*\)foo\(.*foo\)/\1bar\2/' # replace the next-to-last case
 sed 's/\(.*\)foo/\1bar/'            # replace only the last case

 # substitute "foo" with "bar" ONLY for lines which contain "baz"
 sed '/baz/s/foo/bar/g'

 # substitute "foo" with "bar" EXCEPT for lines which contain "baz"
 sed '/baz/!s/foo/bar/g'

 # change "scarlet" or "ruby" or "puce" to "red"
 sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'   # most seds
 gsed 's/scarlet\|ruby\|puce/red/g'                # GNU sed only

 # reverse order of lines (emulates "tac")
 # bug/feature in HHsed v1.5 causes blank lines to be deleted
 sed '1!G;h;$!d'               # method 1
 sed -n '1!G;h;$p'             # method 2

 # reverse each character on the line (emulates "rev")
 sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//'

 # join pairs of lines side-by-side (like "paste")
 sed '$!N;s/\n/ /'

 # if a line ends with a backslash, append the next line to it
 sed -e :a -e '/\\$/N; s/\\\n//; ta'

 # if a line begins with an equal sign, append it to the previous line
 # and replace the "=" with a single space
 sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'

 # add commas to numeric strings, changing "1234567" to "1,234,567"
 gsed ':a;s/\B[0-9]\{3\}\>/,&/;ta'                     # GNU sed
 sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'  # other seds

 # add commas to numbers with decimal points and minus signs (GNU sed)
 gsed ':a;s/\(^\|[^0-9.]\)\([0-9]\+\)\([0-9]\{3\}\)/\1\2,\3/g;ta'

 # add a blank line every 5 lines (after lines 5, 10, 15, 20, etc.)
 gsed '0~5G'                  # GNU sed only
 sed 'n;n;n;n;G;'             # other seds

SELECTIVE PRINTING OF CERTAIN LINES:

 # print first 10 lines of file (emulates behavior of "head")
 sed 10q

 # print first line of file (emulates "head -1")
 sed q

 # print the last 10 lines of a file (emulates "tail")
 sed -e :a -e '$q;N;11,$D;ba'

 # print the last 2 lines of a file (emulates "tail -2")
 sed '$!N;$!D'

 # print the last line of a file (emulates "tail -1")
 sed '$!d'                    # method 1
 sed -n '$p'                  # method 2

 # print only lines which match regular expression (emulates "grep")
 sed -n '/regexp/p'           # method 1
 sed '/regexp/!d'             # method 2

 # print only lines which do NOT match regexp (emulates "grep -v")
 sed -n '/regexp/!p'          # method 1, corresponds to above
 sed '/regexp/d'              # method 2, simpler syntax

 # print the line immediately before a regexp, but not the line
 # containing the regexp
 sed -n '/regexp/{g;1!p;};h'

 # print the line immediately after a regexp, but not the line
 # containing the regexp
 sed -n '/regexp/{n;p;}'

 # print 1 line of context before and after regexp, with line number
 # indicating where the regexp occurred (similar to "grep -A1 -B1")
 sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h

 # grep for AAA and BBB and CCC (in any order)
 sed '/AAA/!d; /BBB/!d; /CCC/!d'

 # grep for AAA and BBB and CCC (in that order)
 sed '/AAA.*BBB.*CCC/!d'

 # grep for AAA or BBB or CCC (emulates "egrep")
 sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d    # most seds
 gsed '/AAA\|BBB\|CCC/!d'                        # GNU sed only

 # print paragraph if it contains AAA (blank lines separate paragraphs)
 # HHsed v1.5 must insert a 'G;' after 'x;' in the next 3 scripts below
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'

 # print paragraph if it contains AAA and BBB and CCC (in any order)
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d'

 # print paragraph if it contains AAA or BBB or CCC
 sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
 gsed '/./{H;$!d;};x;/AAA\|BBB\|CCC/b;d'         # GNU sed only

 # print only lines of 65 characters or longer
 sed -n '/^.\{65\}/p'

 # print only lines of less than 65 characters
 sed -n '/^.\{65\}/!p'        # method 1, corresponds to above
 sed '/^.\{65\}/d'            # method 2, simpler syntax

 # print section of file from regular expression to end of file
 sed -n '/regexp/,$p'

 # print section of file based on line numbers (lines 8-12, inclusive)
 sed -n '8,12p'               # method 1
 sed '8,12!d'                 # method 2

 # print line number 52
 sed -n '52p'                 # method 1
 sed '52!d'                   # method 2
 sed '52q;d'                  # method 3, efficient on large files

 # beginning at line 3, print every 7th line
 gsed -n '3~7p'               # GNU sed only
 sed -n '3,${p;n;n;n;n;n;n;}' # other seds

 # print section of file between two regular expressions (inclusive)
 sed -n '/Iowa/,/Montana/p'             # case sensitive

SELECTIVE DELETION OF CERTAIN LINES:

 # print all of file EXCEPT section between 2 regular expressions
 sed '/Iowa/,/Montana/d'

 # delete duplicate, consecutive lines from a file (emulates "uniq").
 # First line in a set of duplicate lines is kept, rest are deleted.
 sed '$!N; /^\(.*\)\n\1$/!P; D'

 # delete duplicate, nonconsecutive lines from a file. Beware not to
 # overflow the buffer size of the hold space, or else use GNU sed.
 sed -n 'G; s/\n/&&/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P'

 # delete all lines except duplicate lines (emulates "uniq -d").
 sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'

 # delete the first 10 lines of a file
 sed '1,10d'

 # delete the last line of a file
 sed '$d'

 # delete the last 2 lines of a file
 sed 'N;$!P;$!D;$d'

 # delete the last 10 lines of a file
 sed -e :a -e '$d;N;2,10ba' -e 'P;D'   # method 1
 sed -n -e :a -e '1,10!{P;N;D;};N;ba'  # method 2

 # delete every 8th line
 gsed '0~8d'                           # GNU sed only
 sed 'n;n;n;n;n;n;n;d;'                # other seds

 # delete ALL blank lines from a file (same as "grep '.' ")
 sed '/^$/d'                           # method 1
 sed '/./!d'                           # method 2

 # delete all CONSECUTIVE blank lines from file except the first; also
 # deletes all blank lines from top and end of file (emulates "cat -s")
 sed '/./,/^$/!d'          # method 1, allows 0 blanks at top, 1 at EOF
 sed '/^$/N;/\n$/D'        # method 2, allows 1 blank at top, 0 at EOF

 # delete all CONSECUTIVE blank lines from file except the first 2:
 sed '/^$/N;/\n$/N;//D'

 # delete all leading blank lines at top of file
 sed '/./,$!d'

 # delete all trailing blank lines at end of file
 sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'  # works on all seds
 sed -e :a -e '/^\n*$/N;/\n$/ba'        # ditto, except for gsed 3.02*

 # delete the last line of each paragraph
 sed -n '/^$/{p;h;};/./{x;/./p;}'

SPECIAL APPLICATIONS:

 # remove nroff overstrikes (char, backspace) from man pages. The 'echo'
 # command may need an -e switch if you use Unix System V or bash shell.
 sed "s/.`echo \\\b`//g"    # double quotes required for Unix environment
 sed 's/.^H//g'             # in bash/tcsh, press Ctrl-V and then Ctrl-H
 sed 's/.\x08//g'           # hex expression for sed v1.5

 # get Usenet/e-mail message header
 sed '/^$/q'                # deletes everything after first blank line

 # get Usenet/e-mail message body
 sed '1,/^$/d'              # deletes everything up to first blank line

 # get Subject header, but remove initial "Subject: " portion
 sed '/^Subject: */!d; s///;q'

 # get return address header
 sed '/^Reply-To:/q; /^From:/h; /./d;g;q'

 # parse out the address proper. Pulls out the e-mail address by itself
 # from the 1-line return address header (see preceding script)
 sed 's/ *(.*)//; s/>.*//; s/.*[:<] *//'

 # add a leading angle bracket and space to each line (quote a message)
 sed 's/^/> /'

 # delete leading angle bracket & space from each line (unquote a message)
 sed 's/^> //'

 # remove most HTML tags (accommodates multiple-line tags)
 sed -e :a -e 's/<[^>]*>//g;/</N;//ba'

 # extract multi-part uuencoded binaries, removing extraneous header
 # info, so that only the uuencoded portion remains. Files passed to
 # sed must be passed in the proper order. Version 1 can be entered
 # from the command line; version 2 can be made into an executable
 # Unix shell script. (Modified from a script by Rahul Dhesi.)
 sed '/^end/,/^begin/d' file1 file2 ... fileX | uudecode   # vers. 1
 sed '/^end/,/^begin/d' "$@" | uudecode                    # vers. 2

 # zip up each .TXT file individually, deleting the source file and
 # setting the name of each .ZIP file to the basename of the .TXT file
 # (under DOS: the "dir /b" switch returns bare filenames in all caps).
 echo @echo off >zipup.bat
 dir /b *.txt | sed "s/^\(.*\)\.TXT/pkzip -mo \1 \1.TXT/" >>zipup.bat

TYPICAL USE: Sed takes one or more editing commands and applies all of
them, in sequence, to each line of input. After all the commands have
been applied to the first input line, that line is output and a second
input line is taken for processing, and the cycle repeats. The
preceding examples assume that input comes from the standard input
device (i.e, the console, normally this will be piped input). One or
more filenames can be appended to the command line if the input does
not come from stdin. Output is sent to stdout (the screen). Thus:

 cat filename | sed '10q'        # uses piped input
 sed '10q' filename              # same effect, avoids a useless "cat"
 sed '10q' filename > newfile    # redirects output to disk

For additional syntax instructions, including the way to apply editing
commands from a disk file instead of the command line, consult "sed &
awk, 2nd Edition," by Dale Dougherty and Arnold Robbins (O'Reilly,
1997; http://www.ora.com), "UNIX Text Processing," by Dale Dougherty
and Tim O'Reilly (Hayden Books, 1987) or the tutorials by Mike Arst
distributed in U-SEDIT2.ZIP (many sites). To fully exploit the power
of sed, one must understand "regular expressions." For this, see
"Mastering Regular Expressions" by Jeffrey Friedl (O'Reilly, 1997).
The manual ("man") pages on Unix systems may be helpful (try "man
sed", "man regexp", or the subsection on regular expressions in "man
ed"), but man pages are notoriously difficult. They are not written to
teach sed use or regexps to first-time users, but as a reference text
for those already acquainted with these tools.

QUOTING SYNTAX: The preceding examples use single quotes ('...')
instead of double quotes ("...") to enclose editing commands, since
sed is typically used on a Unix platform. Single quotes prevent the
Unix shell from intrepreting the dollar sign ($) and backquotes
(`...`), which are expanded by the shell if they are enclosed in
double quotes. Users of the "csh" shell and derivatives will also need
to quote the exclamation mark (!) with the backslash (i.e., \!) to
properly run the examples listed above, even within single quotes.
Versions of sed written for DOS invariably require double quotes
("...") instead of single quotes to enclose editing commands.

USE OF '\t' IN SED SCRIPTS: For clarity in documentation, we have used
the expression '\t' to indicate a tab character (0x09) in the scripts.
However, most versions of sed do not recognize the '\t' abbreviation,
so when typing these scripts from the command line, you should press
the TAB key instead. '\t' is supported as a regular expression
metacharacter in awk, perl, and HHsed, sedmod, and GNU sed v3.02.80.

VERSIONS OF SED: Versions of sed do differ, and some slight syntax
variation is to be expected. In particular, most do not support the
use of labels (:name) or branch instructions (b,t) within editing
commands, except at the end of those commands. We have used the syntax
which will be portable to most users of sed, even though the popular
GNU versions of sed allow a more succinct syntax. When the reader sees
a fairly long command such as this:

   sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d

it is heartening to know that GNU sed will let you reduce it to:

   sed '/AAA/b;/BBB/b;/CCC/b;d'      # or even
   sed '/AAA\|BBB\|CCC/b;d'

In addition, remember that while many versions of sed accept a command
like "/one/ s/RE1/RE2/", some do NOT allow "/one/! s/RE1/RE2/", which
contains space before the 's'. Omit the space when typing the command.

OPTIMIZING FOR SPEED: If execution speed needs to be increased (due to
large input files or slow processors or hard disks), substitution will
be executed more quickly if the "find" expression is specified before
giving the "s/.../.../" instruction. Thus:

   sed 's/foo/bar/g' filename         # standard replace command
   sed '/foo/ s/foo/bar/g' filename   # executes more quickly
   sed '/foo/ s//bar/g' filename      # shorthand sed syntax

On line selection or deletion in which you only need to output lines
from the first part of the file, a "quit" command (q) in the script
will drastically reduce processing time for large files. Thus:

   sed -n '45,50p' filename           # print line nos. 45-50 of a file
   sed -n '51q;45,50p' filename       # same, but executes much faster

If you have any additional scripts to contribute or if you find errors
in this document, please send e-mail to the compiler. Indicate the
version of sed you used, the operating system it was compiled for, and
the nature of the problem. Various scripts in this file were written
or contributed by:

 Al Aab <af137@freenet.toronto.on.ca>   # "seders" list moderator
 Edgar Allen <era@sky.net>              # various
 Yiorgos Adamopoulos <adamo@softlab.ece.ntua.gr>
 Dale Dougherty <dale@songline.com>     # author of "sed & awk"
 Carlos Duarte <cdua@algos.inesc.pt>    # author of "do it with sed"
 Eric Pement <pemente@northpark.edu>    # author of this document
 Ken Pizzini <ken@halcyon.com>          # author of GNU sed v3.02
 S.G. Ravenhall <stew.ravenhall@totalise.co.uk> # great de-html script
 Greg Ubben <gsu@romulus.ncsc.mil>      # many contributions & much help
-------------------------------------------------------------------------

cat db.nfs.media.edmunds.com-10jun08-SIGGY | awk '{print $1}'| sed '1,14d'| sort | sed /^$/d > nfs-med-SIG

-------------------------------------------------------------------------
16jun08  --siggy

from notes

sed '12,$d' <filename> > output-filename
    deletes from line 12 to EOF
-------------------------------------------------------------------------
16dec08  --siggy

to ad a line after pattern

sed/db/G filename > new-filename

to add a line before matching pattern

sed '/db/{x;p;x}' filename > new-filename
-------------------------------------------------------------------------

5jun09  --siggy

delete the last 2 lines of a file

sed 'N;$!P;$!D;$d'

-------------------------------------------------------------------------
8Feb11  --siggy Case insensative edits

The trailing "I" make it case insensative

sed -i s/xxxxx/$NEWHOSTNAME/I /etc/sysconfig/network
-------------------------------------------------------------------------
4Apr11  --siggy

From : http://tldp.org/LDP/abs/html/string-manipulation.html

${string%%substring}

    Deletes longest match of $substring from back of $string.

    stringZ=abcABC123ABCabc
    #                    ||     shortest
    #        |------------|     longest

    echo ${stringZ%b*c}      # abcABC123ABCa
    # Strip out shortest match between 'b' and 'c', from back of $stringZ.

    echo ${stringZ%%b*c}     # a
    # Strip out longest match between 'b' and 'c', from back of $stringZ.
-------------------------------------------------------------------------
18Apr11  --siggy

to add a line to a specific place

sed -i '35 i\passwd_compat:    nis' /etc/nsswitch.conf

tic "line number" insert <text> tic filename
-------------------------------------------------------------------------
21Apr11  --siggy  validating a MAC address

ifconfig eth0 | grep HWaddr | awk '{print $5}' | sed "/^\([0-9A-Z][0-9A-Z]:\)\{5\}[0-9A-Z][0-9A-Z]$/p"
-------------------------------------------------------------------------
1jun11  --siggy  remove first 4 characters

$ echo $NTBC
1_-_Neworld.mp3
$ echo $NTBC |sed 's/^.\{4\}//'
Neworld.mp3

-------------------------------------------------------------------------
7Oct11  --siggy  edit by character

Code Listing 1.3: Specifying lines command will be applied to

sed -e '1,10s/enchantment/entrapment/g' myfile2.txt
-------------------------------------------------------------------------
27Nov12  --siggy find blank lines that have whitespace

/\s+$/
-------------------------------------------------------------------------
10May13  --siggy   delete the leading "/" (slash) on each line

sed 's/^\///g' repo-list
-------------------------------------------------------------------------
31Oct13  --siggy   delete the last character

sed -i s/.$// machine-inventory.csv

    . is a regex meta char to match anything (except newline)
    $ is the end of line anchor.

By using the $ we force the . to match the last char
This will remove the last char, be it anything:
-------------------------------------------------------------------------

8May08
http://www.cs.hmc.edu/qref/sed.html

HMC Homepage <http://www.hmc.edu> CS Home <http://www.cs.hmc.edu>


    An introduction to sed

* This qref is written for a semi-knowledgable UNIX user who has just
come up against a problem and has been advised to use /sed/ to solve it.
Perhaps one of the examples can be quickly modified for immediate use. *
------------------------------------------------------------------------

    * For More Info <#info>
    * Introduction <#intro>
    * The Basics <#basics>
    * Using regular expressions <#regexp>
    * Substitution and Saving <#subsav>
    * Sed from a file <#sedscr> 
------------------------------------------------------------------------
    For More Info

A good reference for sed is the O'Reilly handbook for /sed and awk/.
There should be a copy available in the CS Department library. Further
references are the /UNIX in a Nutshell/ and /UNIX Power Tools/ books,
also in the CS Department library.
------------------------------------------------------------------------
    Introduction

    * /sed/ reads from a file or from its standard input, and outputs to
      its standard output. You will generally want to redirect that into
      a file, but that is not done in these examples just because it
      takes up space. sed does not get along with non-text files, like
      executables and FrameMaker files. If you need to edit those, use a
      binary editor like hexl-mode in emacs.
    * The most frustrating thing about trying to learn sed is getting
      your program past the shell's parser. The proper way is to use
      single quotes around the program, like so:

      *>*sed 's/fubar/foobar/' filename

      The single quotes protect almost everything from the shell. In csh
      or tcsh, you still have to watch out for exclamation marks, but
      other than that, you're safe.

    * The second most frustrating thing about trying to learn /sed/ is
      the lovely error messages:

      	sed 's/fubar/foobar' filename
      	sed: command garbled: s/fubar/foobar

    * The GNU version of /sed/ generally has better error messages:

      	gsed 's/fubar/foobar' filename
      	gsed: Unterminated `s' command

      So, if you're having problems getting /sed/ syntax correct, switch
      to /gsed/ for a while. 

back to the top <#menu>
------------------------------------------------------------------------
    Some basics:

In all probability, the command you need most is the "s" command. It
Substitutes one thing for another. The simplest way to do this is like
the above examples:

*>*sed 's/color/colour/g' filename

The "g" at the end stands for "global". What it really means, though, is
to replace every occurence on the line. If you leave it off, only the
first occurence on each line will be changed.

You will encounter problems if you attempt to use the following
characters in the string to replace:

	.*[]^$\

These characters mean special things. If you mean to replace literal
occurences of those characters, preface them with a backslash. So, don't do

*>*sed 's/[J.S. Bach {$ for music}]/[Bach, J.S {$ for music}]/' filename

Instead, do

*>*sed 's/\[J\.S\. Bach {\$ for music}\]/[Bach, J.S {$ for music}]/'
filename

Note that this does not apply to the replacement string.

What if you want to perform more than one such replacement at a time?
You would try something like this:

*>*sed 's/color/colour/g' 's/flavor/flavour/g' filename

but it wouldn't work. sed would look for a file named "g" in the
directory "s/flavor/flavour". The "-e" flag to sed makes it realize that
the next option is a part of the script, instead of a filename. You also
must use it for the first part of the script, when you have more than
one part. So, you would use

*>*sed -e 's/color/colour/g' -e 's/flavor/flavour/g' filename

If you only had one replacement to do, you could still use the "-e"
flag, but you don't need to.

The various commands are applied in the order given to sed, so if you ran

*>*sed -e 's/color/colour/g' -e 's/colour/color/g' filename

it would turn "color" to "colour" and then back to "color". So, all
occurences of "color" or "colour" would end up as "color". This is an
inefficient way to do that, though.

What if you want to replace something that contains a '/' character?
This is a common problem with filenames. You could escape each one, like
so:

*>*sed 's/\/usr\/bin/\/bin/g' filename

This is not fun for long pathnames. There is a nice alternative: /sed/
will treat the character immediately after the 's' as the separator, so
you could do something like

*>*sed 's#/usr/bin#/bin#g' filename

back to the top <#menu>
------------------------------------------------------------------------
      Using regular expressions

/sed/ can use regular expressions just like /ed/(1) can. Here are some
common uses of regular expressions.

    * The '^' character means the beginning of the line.

      *>*sed 's/^Thu /Thursday/' filename

      will turn "Thu " into "Thursday", but only at the beginning of the
      line. Note that the "g" flag is not used, since you can't have
      multiple beginnings of a line. Also note that you don't need to
      put the '^' in the replacement string.

    * The '$' character means the end of the line.

      *>*sed 's/ $//' filename

      will replace any space character that occurs at the end of a line.
      Again, the "g" flag is not used, and the '$' is not used in the
      replacement string.

      You can "replace" the end of the line, like this:

      *>*sed 's/$/EOL/' filename

      This does not form one long line, but it puts the string "EOL" at
      the end of each line.

      You can match a blank line by specifying an end-of-line
      immediately after a beginning-of-line:

      *>*sed 's/^$/this used to be a blank line/' filename

    * The '.' character means "any character". This does not mean the
      beginning or end of a line, though. If you were using a log file
      which had the date in the form "Wed Dec 31 16:00:00 1969" and
      wanted to erase the dates and times from a certain month and year,
      you could use

      *>*sed 's/Apr .. ..:..:.. 1980/Apr 1980/g' filename

    * The square brackets "[]" are used to specify any one of a number
      of characters. This is useful when you don't know if a letter will
      be upper or lower case:

      *>*sed 's/[Oo]pen[Ww]in/openwin/g' filename

    * You can specify a range of characters using a '-' inside the
      square brackets. This will include any character between (in ASCII
      terms) the two listed. If you wanted to delete middle initials,
      you could use

      *>*sed 's/ [A-Z]\. / /g' filename

      Notice that the literal period had to be escaped, as mentioned
      above. Also, we had to go from two spaces (one on each side of the
      middle initial) to one.

    * If you want to exclude a set or range of characters, use the '^'
      character as the first thing inside the brackets:

      *>*sed 's/ [^A-DHM-Z]\. / /g' filename

      This will delete any middle initials that are not
      A,B,C,D,H,M,N,...,Z.

    * The '*' character means "any number of the previous character".
      This applies both to literal characters and to characters that are
      a result of using "[]" or '.'. For example,

      *>*sed 's/ *$//' filename

      deletes all trailing spaces from each line, while

      *>*sed 's/[ ]*$//' filename

      deletes any sequence of trailing tabs and spaces. It also works
      when using "[^]":

      *>*sed 's/[ ][^ ]*$//' filename

      deletes the last word (sequence of non-spaces) on each line.

      It is important to know that '*' will match zero occurences. If
      you need to match an integer, for example,

      *>*sed 's/ [0-9]* / integer /g' filename

      will turn " " into " integer ", which is not what you want. In
      this case, you should use

      *>*sed 's/ [0-9][0-9]* / integer /g' filename

      which will demand at least one digit.

    * The combination ".*" means any number of any character. So,

      *>*sed 's/col.*lapse/collapse/g' filename

      will act on any line which contains the letters "col" and then
      "lapse", no matter what is in between. The '*' character is
      greedy: it takes as many characters as it can. So, the above
      script would turn

      	a b col d e f lapse h i j k lapse m n

      into

      	a b collapse m n

      instead of

      	a b collapse h i j k lapse m n

back to the top <#menu>
------------------------------------------------------------------------
      Substitution and Saving

Up to this point, we have concentrated on deleting things that we match
with "[]" and '.'. That's because we had no way of saving what we
matched. The "\(" and "\)" operators will save whatever is found between
them. Notice that these parentheses must be preceded by a backslash,
while the characters ^$[].*\ don't need a backslash to act in a
non-literal fashion. The first pair of "\(\)" saves into a place called
"\1", and the second pair into "\2", and so on.

*>*sed 's/^\([A-Z][A-Za-z]*\), \([A-Z][A-Za-z]*\)/\2 \1/' filename

will turn "Lastname, Firstname" into "Firstname Lastname". Notice how
the comma is placed outside the first pair of "\(\)" so it doesn't get
inclued in the last name. Otherwise, the result would be "Firstname
Lastname,".

Sometimes you will want to apply a substitution only to lines that meet
some criteria that you can't specify in the string to be replaced. You
do this using something called an "address". It comes before the "s"
command. You can limit the command to a range of lines:

*>*sed '1,20s/foobar/fubar/g' filename

The line count is cumulative across files, and starts at 1.

You might want to apply a change only to lines that contain a string:

*>*sed '/^Aug/s/Mon /Monday /g' filename

Or to lines that don't contain a string:

    * using sh or ksh or bash,

      *>>*sed '/^Aug/!s/Mon /Monday /g' filename

      using csh or tcsh,

      *>*sed '/^Aug/\!s/Mon /Monday /g' filename

You can also apply the command to all lines between (and including) a
start string and a stop string:

*>*sed '/^Aug/,/^Oct/s/Mon /Monday /g' filename

Normally sed reads a line, processes it, and prints it out. If you only
want to see the lines that your command acted upon, then you don't want
it to print out everyting. The "-n" flag will stop sed from printing
after processing. So,

*>*sed -n 's/fubar/foobar/g' filename

will print nothing at all. You must use the 'p' flag to the 's' command
to make it print out what it has processed:

*>*sed -n 's/fubar/foobar/gp' filename
-----------------------------------------------------------------------
      Sed from a file

If your sed script is getting long, you can put it into a file, like so:

	# This file is named "sample.sed"
	# comments can only appear in a block at the beginning
	s/color/colour/g
	s/flavor/flavour/g
	s/theater/theatre/g

Then call sed with the "-f" flag:

*>*sed -f sample.sed filename

Or, you can make an executable sed script:

	#!/usr/bin/sed -f
	# This file is named "sample2.sed"
	s/color/colour/g
	s/flavor/flavour/g
	s/theater/theatre/g

then give it execute permissions:

*>*chmod u+x sample2.sed

and then call it like so:

*>*./sample2.sed filename

back to the top <#menu>

This documentation was originally written by Andrew M. Ross.
------------------------------------------------------------------------
Copyright (c) HMC Computer Science Department. Permission is granted to
copy, distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.1 or any later version published
by the Free Software Foundation; with the no Invariant Sections, with no
Front-Cover Texts, and with no Back-Cover Texts. A copy of the license
is included in the section entitled ``GNU Free Documentation License
<http://www.gnu.org/copyleft/fdl.html>.''

*HMC Computer Science Department*
Contact Information </contact.html>

Last Modified Tuesday, 22-May-2001 15:28:43 PDT

---
3Aaug17 sed replace a "," with a newline

cat log.txt | tr ',' '\n'
---
5Apr18
tr can be used to delete characters.
| tr -d '"'

@@@ find text inside double quotes
grep -o '".*"' somefile | sed 's/"//g'

sed 's/^"\(.*\)".*/\1/' a


---

