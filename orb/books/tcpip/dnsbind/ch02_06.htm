<HTML><HEAD><TITLE>[Chapter 2] 2.6 Resolution</TITLE><METANAME="DC.title"CONTENT="DNS &amp; BIND"><METANAME="DC.creator"CONTENT="Cricket Liu &amp; Paul Albitz"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-01-06T18:23:54Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-512-2"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch02_01.htm"TITLE="2. How Does DNS Work?"><LINKREL="prev"HREF="ch02_05.htm"TITLE="2.5 Resolvers"><LINKREL="next"HREF="ch02_07.htm"TITLE="2.7 Caching"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="DNS &amp; BIND"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="DNS &amp; BIND"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/dsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch02_05.htm"TITLE="2.5 Resolvers"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 2.5 Resolvers"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 2<BR>How Does <SPANCLASS="acronym">DNS</SPAN> Work?</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch02_07.htm"TITLE="2.7 Caching"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 2.7 Caching"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="AUTOID-1429">2.6 Resolution</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="DNS3-IDX-2-RESOLUTION"></A><ACLASS="indexterm"NAME="AUTOID-1434"></A><ACLASS="indexterm"NAME="AUTOID-1437"></A><ACLASS="indexterm"NAME="AUTOID-1441"></A><ACLASS="indexterm"NAME="AUTOID-1444"></A>Name servers are adept at retrieving data from the domain namespace. They have to be, given the limited intelligence of someresolvers. Not only can they give you data about zones for whichthey're authoritative, they can also search through the domain namespace to find data for which they're not authoritative. This processis called <ICLASS="firstterm">name resolution</I> or simply<ICLASS="firstterm">resolution</I>.</P><PCLASS="para">Because the name space is structured as an inverted tree, a nameserver needs only one piece of information to find its way to anypoint in the tree: the domain names and addresses of the root nameservers (is that more than one piece?). A name server can issue aquery to a root name server for any name in the domain name space, andthe root name server will start the name server on its way.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-1450">2.6.1 Root Name Servers</A></H3><PCLASS="para">The<ACLASS="indexterm"NAME="DNS3-IDX-2-ROOT-NAME-SERVERS"></A><ACLASS="indexterm"NAME="DNS3-IDX-2-TOP-LEVEL-DOMAINS-ROOT-NAME-SERVERS"></A><ACLASS="indexterm"NAME="DNS3-IDX-2-NAME-SERVERS-ROOT-NAME-SERVERS"></A>root name servers know where there are authoritative name servers foreach of the top-level domains.  (In fact, most of the root name servers<EMCLASS="emphasis">are</EM> authoritative for the generic top-leveldomains.) Given a query about any domain name, the root name serverscan at least provide the names and addresses of the name servers thatare authoritative for the top-level domain that the domain name isin. And the top-level name servers can provide the list of nameservers that are authoritative for the second-level domain that thedomain name is in. Each name server queried gives the querierinformation about how to get <SPANCLASS="quote">"closer"</SPAN> to the answer it'sseeking, or it provides the answer itself.</P><PCLASS="para">The root name servers are clearly important toresolution. Because they're so important, <SPANCLASS="acronym">DNS</SPAN>provides mechanisms&nbsp;- such as caching, which we'll discuss alittle later&nbsp;- to help offload the root name servers. But in theabsence of other information, resolution has to start at the root nameservers. This makes the root name servers crucial to the operation of<SPANCLASS="acronym">DNS</SPAN>; if all the Internet root name servers wereunreachable for an extended period, all resolution on the Internetwould fail.  To protect against this, the Internet has thirteen rootname servers (as of this writing) spread across different parts of thenetwork.  Two are on the <SPANCLASS="acronym">MILNET</SPAN>, theU.S. military's portion of the Internet; one is on<SPANCLASS="acronym">SPAN</SPAN>, <SPANCLASS="acronym">NASA</SPAN>'s internet; two arein Europe; and one is in Japan.</P><PCLASS="para">Being the focal point for so many queries keeps the roots busy;even with thirteen, the<ACLASS="indexterm"NAME="AUTOID-1470"></A>traffic to each root name server is very high. A recent informal pollof root name server administrators showed some roots receivingthousands of queries per second.</P><PCLASS="para">Despite the load placed on root name servers, resolution on theInternet works quite well. <ACLASS="xref"HREF="ch02_06.htm#DNS3-CHP-2-FIG-12"TITLE="Resolution of girigiri.gbrmpa.gov.au on the Internet">Figure 2.12</A> showsthe resolution process for the address of a real host in a realdomain, including how the process corresponds to traversing the domainname space tree.</P><H4CLASS="figure"><ACLASS="title"NAME="DNS3-CHP-2-FIG-12">Figure 2.12: Resolution of girigiri.gbrmpa.gov.au on the Internet</A></H4><IMGCLASS="graphic"SRC="figs/dns3_0212.gif"ALT="Figure 2.12"><PCLASS="para">The local name server queries a root name server for the addressof <ICLASS="systemitem.sitename">girigiri.gbrmpa.gov.au</I> andis referred to the <ICLASS="systemitem.sitename">au</I> nameservers. The local name server asks an <ICLASS="systemitem.sitename">au</I> name server the same question, and isreferred to the <ICLASS="systemitem.sitename">gov.au</I> nameservers. The <ICLASS="systemitem.sitename">gov.au</I> nameserver refers the local name server to the <ICLASS="systemitem.sitename">gbrmpa.gov.au</I> name servers. Finally, thelocal name server asks a <ICLASS="systemitem.sitename">gbrmpa.gov.au</I> name server for the addressand gets the answer.</P><ACLASS="indexterm"NAME="AUTOID-1486"></A><ACLASS="indexterm"NAME="AUTOID-1487"></A><ACLASS="indexterm"NAME="AUTOID-1488"></A></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-1489">2.6.2 Recursion</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="DNS3-IDX-2-RECURSIVE-RESOLUTION"></A><ACLASS="indexterm"NAME="DNS3-IDX-2-QUERIES-RECURSIVE"></A><ACLASS="indexterm"NAME="DNS3-IDX-2-RESOLUTION-RECURSIVE"></A><ACLASS="indexterm"NAME="AUTOID-1500"></A><ACLASS="indexterm"NAME="AUTOID-1504"></A>You may have noticed a big difference in the amount of work done bythe name servers in the previous example. Four of the name serverssimply returned the best answer they already had&nbsp;- mostlyreferrals to other name servers&nbsp;- to the queries theyreceived. They didn't have to send their own queries to find the datarequested. But one name server&nbsp;- the one queried by theresolver&nbsp;- had to follow successive referrals until it received ananswer.</P><PCLASS="para">Why couldn't the local name server simply have referred theresolver to another name server? Because a stub resolver wouldn't havehad the intelligence to follow a referral.  And how did the nameserver know not to answer with a referral?  Because the resolverissued a <EMCLASS="emphasis">recursive</EM> query.</P><PCLASS="para">Queries come in two flavors, <ICLASS="firstterm">recursive</I>and <ICLASS="firstterm">iterative</I>, also called<ACLASS="indexterm"NAME="DNS3-IDX-2-NONRECURSIVE-ITERATIVE-RESOLUTION"></A><ACLASS="indexterm"NAME="DNS3-IDX-2-NONRECURSIVE-ITERATIVE-RESOLUTION2"></A><ACLASS="indexterm"NAME="DNS3-IDX-2-QUERIES-ITERATIVE-NONRECURSIVE"></A><ACLASS="indexterm"NAME="DNS3-IDX-2-RESOLUTION-ITERATIVE-NONRECURSIVE"></A><ICLASS="firstterm">nonrecursive</I>. Recursive queries place most ofthe burden of resolution on a single nameserver. <ICLASS="firstterm">Recursion</I>, or <ICLASS="firstterm">recursiveresolution</I>, is just a name for the resolution process usedby a name server when it receives recursive queries.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-1526"></A><ACLASS="indexterm"NAME="AUTOID-1529"></A><ACLASS="indexterm"NAME="AUTOID-1531"></A><ICLASS="firstterm">Iteration</I>, or <ICLASS="firstterm">iterativeresolution</I>, on the other hand, refers to the resolutionprocess used by a name server when it receives iterativequeries.</P><PCLASS="para">In recursion a resolver sends a recursive query to a name serverfor information about a particular domain name. The queried nameserver is then obliged to respond with the requested data or with anerror stating that data of the requested type don't exist or that thedomain name specified doesn't exist.[8] The name server can't just refer the querier to adifferent name server, because the query was recursive.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] The <SPANCLASS="acronym">BIND</SPAN> 8 name server can be configured torefuse recursive queries; see <ACLASS="xref"HREF="ch10_01.htm"TITLE="Advanced Features and Security">Chapter 10, <CITECLASS="chapter">Advanced Features and Security</CITE></A>, for how andwhy you'd want to do this.</P></BLOCKQUOTE><PCLASS="para">If the queried name server isn't authoritative for the datarequested, it will have to query other name servers to find theanswer. It could send recursive queries to those name servers, therebyobliging them to find the answer and return it (and passing thebuck). Or it could send iterative queries and possibly be referred toother name servers <SPANCLASS="quote">"closer"</SPAN> to the domain name it'slooking for. Current implementations are polite and do the latter,following the referrals until an answer is found.[9]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] The exception is a name server configured to forward allunresolved queries to a designated name server, called a<ICLASS="firstterm">forwarder</I>. See <ACLASS="xref"HREF="ch10_01.htm"TITLE="Advanced Features and Security">Chapter 10</A> for more information onusing forwarders.</P></BLOCKQUOTE><PCLASS="para">A name server that receives a recursive query that it can'tanswer itself will query the <SPANCLASS="quote">"closest known"</SPAN> nameservers.  The<ACLASS="indexterm"NAME="AUTOID-1548"></A><ACLASS="indexterm"NAME="AUTOID-1550"></A>closest known name servers are the servers authoritativefor the zone closest to the domain name being looked up.  For example,if the name server receives a recursive query for the address of thedomain name <ICLASS="systemitem.sitename">girigiri.gbrmpa.gov.au</I>, it will firstcheck whether it knows the name servers for <ICLASS="systemitem.sitename">girigiri.gbrmpa.gov.au</I>.  If it does, itwill send the query to one of them. If not, it will check whether itknows the name servers for <ICLASS="systemitem.sitename">gbrmpa.gov.au</I>, and after that <ICLASS="systemitem.sitename">gov.au</I>, and then <ICLASS="systemitem.sitename">au</I>.  The default, where the check isguaranteed to stop, is the root zone, since every name server knowsthe domain names and addresses of the root name servers.</P><PCLASS="para">Using the closest known name servers ensures that the resolutionprocess is as short as possible.  A <ICLASS="systemitem.sitename">berkeley.edu</I> name server receiving arecursive query for the address of <ICLASS="systemitem.sitename">waxwing.ce.berkeley.edu</I> shouldn't have toconsult the root name servers; it can simply follow delegationinformation directly to the <ICLASS="systemitem.sitename">ce.berkeley.edu</I> name servers. Likewise, aname server that has just looked up a domain name in <ICLASS="systemitem.sitename">ce.berkeley.edu</I> shouldn't have to startresolution at the roots to look up another <ICLASS="systemitem.sitename">ce.berkeley.edu</I> (or <ICLASS="systemitem.sitename">berkeley.edu</I>) domain name; we'll show howthis works in the upcoming section on caching.</P><PCLASS="para">The name server that receives the recursive query always sendsthe same query that the resolver sends it, for example, for theaddress of <ICLASS="systemitem.sitename">waxwing.ce.berkeley.edu</I>.  It never sendsexplicit queries for the name servers for <ICLASS="systemitem.sitename">ce.berkeley.edu</I> or <ICLASS="systemitem.sitename">berkeley.edu</I>, though this information isalso stored in the name space. Sending explicit queries could causeproblems: There may be no <ICLASS="systemitem.sitename">ce.berkeley.edu</I> name servers (that is,<ICLASS="systemitem.sitename">ce.berkeley.edu</I> may be partof the <ICLASS="systemitem.sitename">berkeley.edu</I>zone). Also, it's always possible that an <ICLASS="systemitem.sitename">edu</I> or <ICLASS="systemitem.sitename">berkeley.edu</I> name server would know<ICLASS="systemitem.sitename">waxwing.ce.berkeley.edu</I>'saddress.  An explicit query for the <ICLASS="systemitem.sitename">berkeley.edu</I> or <ICLASS="systemitem.sitename">ce.berkeley.edu</I> name servers would missthis information.</P><ACLASS="indexterm"NAME="AUTOID-1577"></A><ACLASS="indexterm"NAME="AUTOID-1578"></A><ACLASS="indexterm"NAME="AUTOID-1579"></A></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-1580">2.6.3 Iteration</A></H3><PCLASS="para">Iterative<ACLASS="indexterm"NAME="AUTOID-1583"></A>resolution, on the other hand, doesn't require nearly as much work onthe part of the queried name server. In iterative resolution, a nameserver simply gives the best answer <EMCLASS="emphasis">it alreadyknows</EM> back to the querier. No additional querying isrequired. The queried name server consults its local data (includingits cache, which we're about to talk about), looking for the datarequested. If it doesn't find the data there, it makes its bestattempt to give the querier data that will help it continue theresolution process. Usually these are the domain names and addressesof the closest known name servers.</P><PCLASS="para">What this amounts to is a resolution process that, taken as awhole, looks like <ACLASS="xref"HREF="ch02_06.htm#DNS3-CHP-2-FIG-13"TITLE="The resolution process">Figure 2.13</A>.</P><H4CLASS="figure"><ACLASS="title"NAME="DNS3-CHP-2-FIG-13">Figure 2.13: The resolution process</A></H4><IMGCLASS="graphic"SRC="figs/dns3_0213.gif"ALT="Figure 2.13"><PCLASS="para">A resolver queries a local name server, which then queries anumber of other name servers in pursuit of an answer for theresolver. Each name server it queries refers it to another name serverthat is authoritative for a zone further down in the name space andcloser to the domain name sought. Finally, the local name serverqueries the authoritative name server, which returns an answer.<ACLASS="indexterm"NAME="AUTOID-1593"></A><ACLASS="indexterm"NAME="AUTOID-1594"></A><ACLASS="indexterm"NAME="AUTOID-1595"></A><ACLASS="indexterm"NAME="AUTOID-1596"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-1597">2.6.4 Mapping Addresses to Names</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="DNS3-IDX-2-ADDRESSES-MAPPING-TO-NAMES"></A><ACLASS="indexterm"NAME="DNS3-IDX-2-MAPPING-ADDRESSES-TO-NAMES"></A><ACLASS="indexterm"NAME="DNS3-IDX-2-DOMAIN-NAMES-MAPPING-ADDRESSES-TO"></A><ACLASS="indexterm"NAME="AUTOID-1609"></A>One major piece of functionality missing from the resolution processas explained so far is how addresses get mapped back tonames. Address-to-name mapping is used to produce output that iseasier for humans to read and interpret (in log files, forinstance). It's also used in some authorizationchecks. <SPANCLASS="acronym">UNIX</SPAN> hosts map addresses to domain names tocompare against entries in <ICLASS="filename">.rhosts</I> and<ICLASS="filename">hosts.equiv</I> files, for example. When using hosttables, address-to-name mapping is trivial. It requires astraightforward sequential search through the host table for anaddress. The search returns the official host name listed. In<SPANCLASS="acronym">DNS</SPAN>, however, address-to-name mapping isn't sosimple.  Data, including addresses, in the domain name space areindexed by name. Given a domain name, finding an address is relativelyeasy.  But finding the domain name that maps to a given address wouldseem to require an exhaustive search of the data attached to everydomain name in the tree.</P><PCLASS="para">Actually, there's a better solution that's both clever andeffective. Because it's easy to find data once you're given the domainname that indexes that data, why not create a part of the domain namespace that uses addresses as labels?  In the Internet's domain namespace, this portion of the name space is the<ACLASS="indexterm"NAME="AUTOID-1617"></A><ICLASS="systemitem.sitename">in-addr.arpa</I> domain.</P><PCLASS="para">Nodes in the <ICLASS="systemitem.sitename">in-addr.arpa</I> domain are labelled afterthe numbers in the dotted-octet representation of<SPANCLASS="acronym">IP</SPAN> addresses.<ACLASS="indexterm"NAME="AUTOID-1623"></A><ACLASS="indexterm"NAME="AUTOID-1625"></A>(Dotted-octet representation refers to the common method of expressing32-bit <SPANCLASS="acronym">IP</SPAN> addresses as four numbers in the range 0to 255, separated by dots.) The <ICLASS="systemitem.sitename">in-addr.arpa</I> domain, for example, couldhave up to 256 subdomains, one corresponding to each possible value inthe first octet of an <SPANCLASS="acronym">IP</SPAN> address. Each of thesesubdomains could have up to 256 subdomains of its own, correspondingto the possible values of the second octet. Finally, at the fourthlevel down, there are resource records attached to the final octetgiving the full domain name of the host or network at that<SPANCLASS="acronym">IP</SPAN> address. That makes for an awfully big domain:<ICLASS="systemitem.sitename">in-addr.arpa</I>, shown in <ACLASS="xref"HREF="ch02_06.htm#DNS3-CHP-2-FIG-14"TITLE="addr.arpa domain">Figure 2.14</A>, is roomy enough for every<SPANCLASS="acronym">IP</SPAN> address on the Internet.</P><H4CLASS="figure"><ACLASS="title"NAME="DNS3-CHP-2-FIG-14">Figure 2.14: addr.arpa domain</A></H4><IMGCLASS="graphic"SRC="figs/dns3_0214.gif"ALT="Figure 2.14"><PCLASS="para">Note that when read in a domain name, the <SPANCLASS="acronym">IP</SPAN>address appears backward because the name is read from leaf to root.For example, if <ICLASS="systemitem.sitename">winnie.corp.hp.com</I>'s<SPANCLASS="acronym">IP</SPAN> address is 15.16.192.152, the corresponding<ICLASS="systemitem.sitename">in-addr.arpa</I> subdomain is<ICLASS="systemitem.sitename">152.192.16.15.in-addr.arpa</I>,which maps back to the domain name <ICLASS="systemitem.sitename">winnie.corp.hp.com</I>.</P><PCLASS="para"><SPANCLASS="acronym">IP</SPAN> addresses could have been represented theopposite way in the name space, with the first octet of the<SPANCLASS="acronym">IP</SPAN> address at the bottom of the <ICLASS="systemitem.sitename">in-addr.arpa</I> domain. That way, the<SPANCLASS="acronym">IP</SPAN> address would have read correctly (forward) inthe domain name.</P><PCLASS="para"><SPANCLASS="acronym">IP</SPAN> addresses are hierarchical, however, justlike domain names. Network numbers are doled out much as domain namesare, and administrators can then subnet their address space andfurther delegate numbering. The difference is that<SPANCLASS="acronym">IP</SPAN> addresses get more specific from left to right,while domain names get less specific from left to right. <ACLASS="xref"HREF="ch02_06.htm#DNS3-CHP-2-FIG-15"TITLE="Hierarchical names and addresses">Figure 2.15</A> shows what we mean.</P><H4CLASS="figure"><ACLASS="title"NAME="DNS3-CHP-2-FIG-15">Figure 2.15: Hierarchical names and addresses</A></H4><IMGCLASS="graphic"SRC="figs/dns3_0215.gif"ALT="Figure 2.15"><PCLASS="para">Making the first octets in the <SPANCLASS="acronym">IP</SPAN> addressappear highest in the tree gives administrators the ability todelegate authority for <ICLASS="systemitem.sitename">in-addr.arpa</I> domains along networklines. For example, the <ICLASS="systemitem.sitename">15.in-addr.arpa</I> domain, which containsthe reverse mapping information for all hosts whose<SPANCLASS="acronym">IP</SPAN> addresses start with 15, can be delegated to theadministrators of network 15.0.0.0. This would be impossible if theoctets appeared in the opposite order. If the <SPANCLASS="acronym">IP</SPAN>addresses were represented the other way around, <ICLASS="systemitem.sitename">15.in-addr.arpa</I> would consist of everyhost whose <SPANCLASS="acronym">IP</SPAN> address <EMCLASS="emphasis">ended</EM>with 15&nbsp;- not a practical domain to try to delegate.<ACLASS="indexterm"NAME="AUTOID-1665"></A><ACLASS="indexterm"NAME="AUTOID-1666"></A><ACLASS="indexterm"NAME="AUTOID-1667"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-1668">2.6.5 Inverse Queries</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-1671"></A><ACLASS="indexterm"NAME="AUTOID-1674"></A><ACLASS="indexterm"NAME="AUTOID-1676"></A><ACLASS="indexterm"NAME="AUTOID-1679"></A><ACLASS="indexterm"NAME="AUTOID-1682"></A>The <ICLASS="systemitem.sitename">in-addr.arpa</I> name spaceis clearly only useful for <SPANCLASS="acronym">IP</SPAN> address-to-domainname mapping.  Searching for a domain name that indexes an<EMCLASS="emphasis">arbitrary</EM> piece of data&nbsp;- something besidesan address&nbsp;- in the domain name space would require anotherspecialized name space like <ICLASS="systemitem.sitename">in-addr.arpa</I> or an exhaustivesearch.</P><PCLASS="para">That exhaustive search is to some extent possible, and it'scalled an <ICLASS="firstterm">inverse query</I>. An inverse query is a search for the domainname that indexes a given datum. It's processed solely by the nameserver receiving the query. That name server searches all of its localdata for the item sought and returns the domain name that indexes it,if possible. If it can't find the data, it gives up. No attempt ismade to forward the query to another name server.</P><PCLASS="para">Because any one name server only knows about part of the overalldomain name space, an inverse query is never guaranteed to return ananswer. For example, if a name server receives an inverse query for an<SPANCLASS="acronym">IP</SPAN> address it knows nothing about, it can't returnan answer, but it also doesn't know that the <SPANCLASS="acronym">IP</SPAN>address doesn't exist, because it only holds part of the<SPANCLASS="acronym">DNS</SPAN> database. What's more, the implementation ofinverse queries is optional according to the <SPANCLASS="acronym">DNS</SPAN>specification; <SPANCLASS="acronym">BIND</SPAN> 4.9.7 still contains the codethat implements inverse queries, but it's commented out bydefault. <SPANCLASS="acronym">BIND</SPAN> 8 no longer includes that code atall, though it does recognize inverse queries and can make up fakeresponses to them.[10] That's fine with us, because very little software (such asarchaic versions of <KBDCLASS="command">nslookup</KBD>) actually still usesinverse queries.<ACLASS="indexterm"NAME="AUTOID-1702"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[10]  For details on this functionality, see <ACLASS="xref"HREF="ch11_07.htm#QUERY-REFUSED"TITLE="Query Refused">Section 11.7.4, "Query Refused"</A>.</P></BLOCKQUOTE></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch02_05.htm"TITLE="2.5 Resolvers"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 2.5 Resolvers"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="DNS &amp; BIND"><IMGSRC="../gifs/txthome.gif"ALT="DNS &amp; BIND"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch02_07.htm"TITLE="2.7 Caching"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 2.7 Caching"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">2.5 Resolvers</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">2.7 Caching</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>