<HTML><HEAD><TITLE>[Chapter 4] 4.8 Running a Slave Name Server</TITLE><METANAME="DC.title"CONTENT="DNS &amp; BIND"><METANAME="DC.creator"CONTENT="Cricket Liu &amp; Paul Albitz"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-01-06T18:27:55Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-512-2"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch04_01.htm"TITLE="4. Setting Up BIND"><LINKREL="prev"HREF="ch04_07.htm"TITLE="4.7 Running a Primary Master Name Server"><LINKREL="next"HREF="ch04_09.htm"TITLE="4.9 Adding More Domains"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="DNS &amp; BIND"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="DNS &amp; BIND"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/dsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_07.htm"TITLE="4.7 Running a Primary Master Name Server"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.7 Running a Primary Master Name Server"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 4<BR>Setting Up <SPANCLASS="acronym">BIND</SPAN></FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_09.htm"TITLE="4.9 Adding More Domains"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.9 Adding More Domains"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="AUTOID-3846">4.8 Running a Slave Name Server</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="DNS3-IDX-4-SLAVE-SECONDARY-MASTER-NAME-SERVERS"></A>You need to set up another name server for robustness. You can (andprobably will) set up more than two name servers. Two servers are theminimum. If you have only one name server and it goes down, no one canlook up names. A second name server splits the load with the firstserver or handles the whole load if the first server is down. You<EMCLASS="emphasis">could</EM> set up another primary master name server,but we don't recommend it. Set up a slave name server.  You can alwayschange a slave name server into a primary master name server later ifyou decide that you want to expend the extra work it takes to runmultiple primary master name servers.</P><PCLASS="para">How does a server know if it is a primary master or a slave fora zone?  The <ICLASS="filename">named.conf</I> file tells the server itis a primary master or a slave on a per-zone basis. The<ACLASS="indexterm"NAME="AUTOID-3854"></A><SPANCLASS="acronym">NS</SPAN> records don't tell us which servers are the primarymaster for a zone and which servers are slave for a zone&nbsp;- they only saywho the servers are.  (Globally, <SPANCLASS="acronym">DNS</SPAN> doesn't care;as far as the actual name resolution goes, slave servers are as goodas primary master servers.)</P><PCLASS="para">What is different between a primary master name server and aslave name server? The crucial difference is where the server gets itsdata. A primary master name server reads its data from files. A slavename server loads its data over the network from another nameserver. This process is called a<ACLASS="indexterm"NAME="AUTOID-3859"></A><ICLASS="firstterm">zone transfer</I>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-3864"></A>A slave name server is not limited to loading zones from a<EMCLASS="emphasis">primary master</EM> name server; a slave server canload from another <EMCLASS="emphasis">slave</EM> server.</P><PCLASS="para">The big advantage of slave name servers is that you onlymaintain one set of the <SPANCLASS="acronym">DNS</SPAN> database files, theones on the primary master name server. You don't have to worry aboutsynchronizing the files among name servers; the slaves do that foryou. The caveat is that a slave does not resynchronize instantly. Itpolls to see if it is current. The polling interval is one of thosenumbers in the <SPANCLASS="acronym">SOA</SPAN> record that we haven't explainedyet.  (<SPANCLASS="acronym">BIND</SPAN> version 8 speeds up the distribution ofzone data, which we will describe later.)</P><PCLASS="para">A slave name server doesn't need to retrieve<EMCLASS="emphasis">all</EM> of its db files over the network; theoverhead files, <ICLASS="filename">db.cache</I> and<ICLASS="filename">db.127.0.0</I>, are the same as on a primary master,so keep a local copy on the slave. That means that a slave name serveris a <EMCLASS="emphasis">primary master</EM> for <ICLASS="systemitem.sitename">0.0.127.in-addr.arpa</I>.  Well, you<EMCLASS="emphasis">could</EM> make it a slave for <ICLASS="systemitem.sitename">0.0.127.in-addr.arpa</I>, but that data neverchanges&nbsp;- it might as well be a primary master.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-3880">4.8.1 Setup</A></H3><PCLASS="para">To set up your slave name server, create a directory for the dbfiles on the slave name server host (e.g.,<ICLASS="filename">/usr/local/named</I>) and copy over the files<ICLASS="filename">/etc/named.conf</I>, <ICLASS="filename">db.cache</I>,and <ICLASS="filename">db.127.0.0</I>:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <CODECLASS="userinput"><B>rcp /etc/named.conf host:/etc</B></CODE># <CODECLASS="userinput"><B>rcp db.cache db.127.0.0 <CODECLASS="replaceable"><I>host:db-file-directory</I></CODE></B></CODE></PRE></BLOCKQUOTE><PCLASS="para">You must modify <ICLASS="filename">/etc/named.conf</I> on theslave name server host. For version 4, change every occurrence ofprimary to secondary except for <ICLASS="systemitem.sitename">0.0.127.in-addr.arpa</I>.  Before thefilename on each of these lines, add the <SPANCLASS="acronym">IP</SPAN> addressof the primary master server you just set up. For example, if theoriginal version 4 configuration file line was this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">primary  movie.edu      db.movie</PRE></BLOCKQUOTE><PCLASS="para">then the modified line looks like:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">secondary  movie.edu      192.249.249.3 db.movie</PRE></BLOCKQUOTE><PCLASS="para">If the original version 8 configuration file line was:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">zone &quot;movie.edu&quot; in {      type master;      file &quot;db.movie&quot;;};</PRE></BLOCKQUOTE><PCLASS="para">change master to slave and add a masters line with the<SPANCLASS="acronym">IP</SPAN> address of the master server:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">zone &quot;movie.edu&quot; in {      type slave;      file &quot;db.movie&quot;;      masters { 192.249.249.3; };};</PRE></BLOCKQUOTE><PCLASS="para">This tells the name server that it is a slave for the zone<ICLASS="systemitem.sitename">movie.edu</I> and that it shouldtrack the version of this zone that is being kept on the host192.249.249.3.  The slave name server will keep a backup copy of thiszone in the local file <ICLASS="filename">db.movie</I>.</P><PCLASS="para">For Movie U., we set up our slave name server on <ICLASS="systemitem.sitename">wormhole</I>.  Recall that the configurationfile on <ICLASS="systemitem.sitename">terminator</I> (theprimary master) looked like this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">directory /usr/local/namedprimary  movie.edu                db.movieprimary  249.249.192.in-addr.arpa db.192.249.249primary  253.253.192.in-addr.arpa db.192.253.253primary  0.0.127.in-addr.arpa     db.127.0.0cache    .                        db.cache</PRE></BLOCKQUOTE><PCLASS="para">We copied <ICLASS="filename">/etc/named.conf</I>,<ICLASS="filename">db.cache</I>, and <ICLASS="filename">db.127.0.0</I> to<ICLASS="systemitem.sitename">wormhole</I> and edited theconfiguration file as described above. The version 4 configurationfile on <ICLASS="systemitem.sitename">wormhole</I> now lookslike this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">directory /usr/local/namedsecondary  movie.edu                192.249.249.3 db.moviesecondary  249.249.192.in-addr.arpa 192.249.249.3 db.192.249.249secondary  253.253.192.in-addr.arpa 192.249.249.3 db.192.253.253primary    0.0.127.in-addr.arpa     db.127.0.0cache      .                        db.cache</PRE></BLOCKQUOTE><PCLASS="para">The equivalent version 8 configuration file looks likethis:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">options {        directory &quot;/usr/local/named&quot;;};zone &quot;movie.edu&quot; in {        type slave;        file &quot;db.movie&quot;;        masters { 192.249.249.3; };};zone &quot;249.249.192.in-addr.arpa&quot; in {        type slave;        file &quot;db.192.249.249&quot;;        masters { 192.249.249.3; };};zone &quot;253.253.192.in-addr.arpa&quot; in {        type slave;        file &quot;db.192.253.253&quot;;        masters { 192.249.249.3; };};zone &quot;0.0.127.in-addr.arpa&quot; in {        type master;        file &quot;db.127.0.0&quot;;};zone &quot;.&quot; in {        type hint;        file &quot;db.cache&quot;;};&#13;</PRE></BLOCKQUOTE><PCLASS="para">This causes the name server on <ICLASS="systemitem.sitename">wormhole</I> to load <ICLASS="systemitem.sitename">movie.edu</I>, <ICLASS="systemitem.sitename">249.249.192.in-addr.arpa</I>, and <ICLASS="systemitem.sitename">253.253.192.in-addr.arpa</I> over the networkfrom 192.249.249.3 (<ICLASS="systemitem.sitename">terminator</I>).  It also saves a backup copyof these files in <ICLASS="filename">/usr/local/named</I>.  You may findit handy to isolate the backup files in a subdirectory or to name themwith a unique suffix like <ICLASS="filename">.bak</I>; on rareoccasions, you may have to delete all of the backup files manually.We'll cover more on backup files later.</P><PCLASS="para">Start up the slave name server. Check for error messages in the<KBDCLASS="command">syslog</KBD> file as you did for the primary masterserver. As on the primary master, the command to start up a nameserver is:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <CODECLASS="userinput"><B>/etc/named</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">One extra check to make on the slave that you didn't have tomake on the primary master is to see that the name server created thebackup files. Shortly after we started our slave name server on<ICLASS="systemitem.sitename">wormhole</I>, we saw<ICLASS="filename">db.movie</I>, <ICLASS="filename">db.192.249.249</I>,and <ICLASS="filename">db.192.253.253</I> show up in the<ICLASS="filename">/usr/local/named</I> directory.  This means the slavehas successfully loaded these zones from the primary master and hassaved a backup copy.</P><PCLASS="para">To complete setting up your slave name server, try looking upthe same names you looked up when the primary master server wasstarted. This time <KBDCLASS="command">nslookup</KBD> must be run on theslave name server host so that the slave server is queried.  If yourslave is working fine, add the proper lines to your system startupfiles so that the slave name server is started when your system bootsup and <KBDCLASS="command">hostname</KBD>(1) is set to a domain name.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-3940">4.8.2 Backup Files</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-3943"></A><ACLASS="indexterm"NAME="AUTOID-3946"></A><ACLASS="indexterm"NAME="AUTOID-3949"></A>Slave servers are not <EMCLASS="emphasis">required</EM> to save a backupcopy of the zone data. If there is a backup copy, the slave serverreads it on startup and later checks with the master server to see ifthe master server has a newer copy, instead of loading a new copy ofthe zone immediately. If the master server has a newer copy, the slavepulls it over and saves it in the backup file.</P><PCLASS="para">Why save a backup copy? Suppose the master server is down whenthe slave starts up. The slave will be unable to transfer the zone andtherefore won't function as a server for that zone until the masterserver is up. With a backup copy, the slave has some data, although itmight be slightly out of date. Since the slave does not rely on themaster server always being up, it is a more robust system.</P><PCLASS="para">To run without a backup copy, omit the filename at the end ofthe <ICLASS="function">secondary</I> lines in the version 4 configuration file. In version 8,remove the <ICLASS="function">file</I> line.  We recommend having all your slave servers savebackup copies, though. There is very little extra cost to having abackup file, but there is a very high cost if you get caught without abackup file when you need it most.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-3957">4.8.3 Multiple Master Servers</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-3960"></A><ACLASS="indexterm"NAME="AUTOID-3963"></A><ACLASS="indexterm"NAME="AUTOID-3966"></A>Are there other ways to make your slave server configuration morerobust? Yes, you can specify up to ten <SPANCLASS="acronym">IP</SPAN> addressesof master servers. In a version 4 configuration file, just add themafter the first <SPANCLASS="acronym">IP</SPAN> address, before the backupfilename.  In a version 8 configuration file, add them after the first<SPANCLASS="acronym">IP</SPAN> address and terminate them withsemicolons:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">masters { 192.249.249.3; 192.249.249.4; };</PRE></BLOCKQUOTE><PCLASS="para">The slave will try the master server at each<SPANCLASS="acronym">IP</SPAN> address, in the order listed, until itsuccessfully transfers the zone. The intent of this feature is toallow you to list all the <SPANCLASS="acronym">IP</SPAN> addresses of the hostrunning the primary master for the zone if that host ismultihomed. But, since there is no check made that the contactedserver is a primary master or slave, you can list the<SPANCLASS="acronym">IP</SPAN> addresses of hosts running slave servers for thezone, if that makes sense for your setup.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-3977">4.8.4 <SPANCLASS="acronym">SOA</SPAN> Values</A></H3><PCLASS="para">Remember this<ACLASS="indexterm"NAME="DNS3-IDX-4-AUTHORITY-FOR-DOMAINS-SOA-RECORDS-2"></A><ACLASS="indexterm"NAME="DNS3-IDX-4-SUBDOMAINS-SOA-RECORDS-2"></A><ACLASS="indexterm"NAME="DNS3-IDX-4-SOA-RECORDS-2"></A><ACLASS="indexterm"NAME="DNS3-IDX-4-ZONES-SOA-RECORDS-2"></A><ACLASS="indexterm"NAME="DNS3-IDX-4-PERFORMANCE-SOA-VALUES"></A><SPANCLASS="acronym">SOA</SPAN> record?</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">movie.edu. IN SOA terminator.movie.edu. al.robocop.movie.edu. (                          1        ; Serial                          10800    ; Refresh after 3 hours                          3600     ; Retry after 1 hour                          604800   ; Expire after 1 week                          86400 )  ; Minimum TTL of 1 day</PRE></BLOCKQUOTE><PCLASS="para">We never explained what the values in between the parentheseswere for.</P><PCLASS="para">The serial number applies to all the data within the zone. Wechose to start our serial number at 1, a logical place to start. But,many people find it more useful to use the date in the serial numberinstead, like 1997102301. This format is<SPANCLASS="acronym">YYYYMMDDNN</SPAN>, where Y is the year, M is the month, Dis the day, and <SPANCLASS="acronym">NN</SPAN> is a count of how many times thezone data were modified that day. Whatever you choose, it's importantthat this number always increase when you update your zonedata.</P><PCLASS="para">When a slave name server contacts a master server for zone data,it first asks for the serial number on the data. If the slave's serialnumber is lower than the master server's, the slave's zone data areout of date. In this case, the slave pulls a new copy of thezone. When a slave starts up and there is no backup file to read, italways loads the zone. As you might guess, when you modify the dbfiles on the primary master, you must increment the serialnumber. Updating your db files is covered in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Maintaining BIND">Chapter 7</A>.</P><PCLASS="para">The next four fields specify various time intervals inseconds:</P><DLCLASS="variablelist"><DTCLASS="term">refresh</DT><DDCLASS="listitem"><PCLASS="para">The<ACLASS="indexterm"NAME="AUTOID-4009"></A>refresh interval tells the slave how often to check that its data areup to date. To give you an idea of the system load this featurecauses, a slave will make one <SPANCLASS="acronym">SOA</SPAN> query per zoneper refresh interval. The value we choose, three hours, is reasonablyaggressive. Most users will tolerate a delay of half of a working dayfor things like name server data to propagate when they are waitingfor their new workstation to be operational. If you provide one-dayservice for your site, consider raising this value to eight hours. Ifyour data don't change very often, or if all of your slaves are spreadover long distances (as the root name servers are), consider a valuethat is even longer: 24 hours.</P></DD><DTCLASS="term">retry</DT><DDCLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4016"></A>If the slave fails to reach the master name server(s) after therefresh period (the host(s) could be down), then it starts trying toconnect every <ICLASS="parameter">retry</I> seconds. Normally, the retry interval is shorterthan the refresh interval, but it doesn't have to be.</P></DD><DTCLASS="term">expire</DT><DDCLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4023"></A>If the slave fails to contact the master server(s) for <ICLASS="parameter">expire</I> seconds,the slave expires its data. Expiring the data means the slave stopsgiving out answers about the data because the data are too old to beuseful. Essentially, this field says: at some point, the data are soold that having <EMCLASS="emphasis">no</EM> data is better than having stale data.  Expiretimes on the order of a week are common&nbsp;- longer (up to a month) if youfrequently have problems reaching your updating source. The expirationtime should always be much larger than the retry and refreshintervals; if the expire time is smaller than the refresh interval,your slaves will expire their data before trying to load newdata.</P></DD><DTCLASS="term"><SPANCLASS="acronym">TTL</SPAN></DT><DDCLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4032"></A><ACLASS="indexterm"NAME="AUTOID-4034"></A><ACLASS="indexterm"NAME="AUTOID-4036"></A><ACLASS="indexterm"NAME="AUTOID-4038"></A><SPANCLASS="acronym">TTL</SPAN> stands for <ICLASS="firstterm">time to live</I>. This value applies toall the resource records in the db file. The name server supplies this<SPANCLASS="acronym">TTL</SPAN> in query responses, allowing other servers tocache the data for the <SPANCLASS="acronym">TTL</SPAN> interval. If your datadon't change much, you might consider using a minimum<SPANCLASS="acronym">TTL</SPAN> of several days. One week is about the longestvalue that makes sense. A value as short as one hour can be used, butit is not recommended because of the amount of <SPANCLASS="acronym">DNS</SPAN>traffic it causes.</P></DD></DL><PCLASS="para">What values you choose for your <SPANCLASS="acronym">SOA</SPAN> recordwill depend upon the needs of your site. In general, longer timescause less load on your systems and lengthen the propagation ofchanges; shorter times increase the load on your systems and speed upthe propagation of changes. The values we use in this book should workwell for most sites. <SPANCLASS="acronym">RFC</SPAN> 1537 recommends thefollowing values for top-level domainservers:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">       86400 ;  Refresh        24 hours        7200 ;  Retry           2 hours     2592000 ;  Expire         30 days      345600 ;  Minimum TTL     4 days</PRE></BLOCKQUOTE><PCLASS="para">There is one implementation feature you need to be awareof. Older versions (pre-4.8.3) of <SPANCLASS="acronym">BIND</SPAN> slavesstopped answering queries during a zone load. As a result,<SPANCLASS="acronym">BIND</SPAN> was modified to spread out the zone loads,reducing the periods of unavailability. So, even if you set a lowrefresh interval, your slaves may not check as often as yourequest. <SPANCLASS="acronym">BIND</SPAN> attempts a certain number of zoneloads and then waits 15 minutes before trying another batch.</P><PCLASS="para">Now that we've told you all about how slave servers poll to keeptheir data up-to-date, <SPANCLASS="acronym">BIND</SPAN> version 8 changed howzone data propagates!  The polling feature is still there, but version8 adds a notification when zone data changes.  If both your primarymaster server and your slaves are version 8, the primary master willnotify the slave that a zone has changed within 15 minutes of loadinga new copy of that zone.  The notification causes the slave server toshorten the refresh interval and attempt to load the zone immediately.We'll discuss this more in<ACLASS="indexterm"NAME="AUTOID-4057"></A><ACLASS="indexterm"NAME="AUTOID-4058"></A><ACLASS="indexterm"NAME="AUTOID-4059"></A><ACLASS="indexterm"NAME="AUTOID-4060"></A><ACLASS="indexterm"NAME="AUTOID-4061"></A><ACLASS="xref"HREF="ch10_01.htm"TITLE="Advanced Features and Security">Chapter 10</A>.<ACLASS="indexterm"NAME="AUTOID-4063"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_07.htm"TITLE="4.7 Running a Primary Master Name Server"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.7 Running a Primary Master Name Server"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="DNS &amp; BIND"><IMGSRC="../gifs/txthome.gif"ALT="DNS &amp; BIND"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_09.htm"TITLE="4.9 Adding More Domains"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.9 Adding More Domains"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">4.7 Running a Primary Master Name Server</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">4.9 Adding More Domains</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>