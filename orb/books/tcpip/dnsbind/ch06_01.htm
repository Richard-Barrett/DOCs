<HTML><HEAD><TITLE>[Chapter 6] Configuring Hosts</TITLE><METANAME="DC.title"CONTENT="DNS &amp; BIND"><METANAME="DC.creator"CONTENT="Cricket Liu &amp; Paul Albitz"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-01-06T18:28:32Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-512-2"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="index.htm"TITLE="DNS &amp; BIND"><LINKREL="prev"HREF="ch05_03.htm"TITLE="5.3 The MX Algorithm"><LINKREL="next"HREF="ch06_02.htm"TITLE="6.2 Sample Resolver Configurations"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="DNS &amp; BIND"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="DNS &amp; BIND"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/dsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_03.htm"TITLE="5.3 The MX Algorithm"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.3 The MX Algorithm"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 6</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Sample Resolver Configurations"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.2 Sample Resolver Configurations"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="CHAPTER"><H1CLASS="chapter"><ACLASS="title"NAME="DNS3-CHP-6">6. Configuring Hosts</A></H1><DIVCLASS="htmltoc"><P><B>Contents:</B><BR><ACLASS="sect1"HREF="#AUTOID-4427"TITLE="6.1 The Resolver">The Resolver</A><BR><ACLASS="sect1"HREF="ch06_02.htm"TITLE="6.2 Sample Resolver Configurations">Sample Resolver Configurations</A><BR><ACLASS="sect1"HREF="ch06_03.htm"TITLE="6.3 Minimizing Pain and Suffering">Minimizing Pain and Suffering</A><BR><ACLASS="sect1"HREF="ch06_04.htm"TITLE="6.4 Vendor-Specific Options">Vendor-Specific Options</A></P><P></P></DIV><DIVCLASS="epigraph"><PCLASS="para"ALIGN="right"><I>They were indeed a queer-looking party that assembled on thebank&nbsp;- the birds with draggled feathers, the animals with theirfur clinging close to them, and all dripping wet, cross, anduncomfortable.</I></P></DIV><PCLASS="para"><ACLASS="indexterm"NAME="DNS3-IDX-6-HOSTS-CONFIGURING-TO-USE-DNS"></A><ACLASS="indexterm"NAME="DNS3-IDX-6-CONFIGURING-HOSTS-TO-USE-DNS"></A><ACLASS="indexterm"NAME="DNS3-IDX-6-DNS-DOMAIN-NAME-SYSTEM-CONFIGURING-HOSTS-FOR"></A>Now that you or someone else in your organization has set up nameservers for your zones, you'll want to configure the hosts on yournetwork to use them. That involves configuring those hosts'resolvers. You should also check files like<ICLASS="filename">hosts.equiv</I> and <ICLASS="filename">.rhosts</I> andmake any changes dictated by using <SPANCLASS="acronym">DNS</SPAN>; you mayneed to convert some of the host names in these files to domainnames. And you may also want to add aliases, both for your users'convenience and to minimize the shock of the conversion to<SPANCLASS="acronym">DNS</SPAN>.</P><PCLASS="para">This chapter covers these topics, and also describes configuringthe resolver in many common versions of <SPANCLASS="acronym">UNIX</SPAN> andin Microsoft's Windows 95 and Windows <SPANCLASS="acronym">NT</SPAN>.</P><DIVCLASS="sect1"><H2CLASS="sect1"><ACLASS="title"NAME="AUTOID-4427">6.1 The Resolver</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="DNS3-IDX-6-RESOLVERS"></A>We introduced resolvers way back in <ACLASS="xref"HREF="ch02_01.htm"TITLE="How Does DNS Work?">Chapter 2, <CITECLASS="chapter">How Does <SPANCLASS="acronym">DNS</SPAN> Work?</CITE></A>, butwe didn't say much more about them. The resolver, you'll remember, isthe client half of the Domain Name System. It's responsible fortranslating a program's request for host information into a query to aname server and for translating the response into an answer for theprogram.</P><PCLASS="para">We haven't done any resolver configuration yet, because theoccasion for it hasn't arisen. When we set up our name servers in<ACLASS="xref"HREF="ch04_01.htm"TITLE="Setting Up BIND">Chapter 4, <CITECLASS="chapter">Setting Up <SPANCLASS="acronym">BIND</SPAN></CITE></A>, the resolver's default behavior workedjust fine for our purposes. But if we'd needed the resolver to do morethan what it does by default, or to behave differently from thedefault, we would have had to configure the resolver.</P><PCLASS="para">There's one thing we should mention up front: what we'lldescribe in the next few sections is the behavior of the vanilla<SPANCLASS="acronym">DNS</SPAN> 8.1.2 resolver in the absence of other namingservices. Not all resolvers behave quite this way; some vendors stillship resolvers based on earlier versions of the <SPANCLASS="acronym">DNS</SPAN>code, and some have implemented special resolver functionality thatlets you modify the resolver algorithm.  Whenever we think it'simportant, we'll point out differences between the behavior of the8.1.2 <SPANCLASS="acronym">DNS</SPAN> resolver and that of earlier resolvers,particularly the 4.8.3 resolver, which is what many vendors wereshipping when we last updated this book. We'll cover various vendors'extensions later in this chapter.</P><PCLASS="para">So what exactly does the resolver allow you to configure? Mostresolvers let you configure at least three aspects of the resolver'sbehavior: the default domain, the search list, and the name server(s)that the resolver queries.  Many <SPANCLASS="acronym">UNIX</SPAN> vendors allowyou to configure other resolver behavior, too, through nonstandardextensions to <SPANCLASS="acronym">DNS</SPAN>. Sometimes these extensions arenecessary to cope with other software, like Sun's Network InformationService (<SPANCLASS="acronym">NIS</SPAN>); sometimes they're simply value addedby the vendor.[1]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] <SPANCLASS="acronym">NIS</SPAN> used to be called <SPANCLASS="quote">"YellowPages,"</SPAN> or <SPANCLASS="quote">"<SPANCLASS="acronym">YP</SPAN>,"</SPAN> but waschanged to <SPANCLASS="acronym">NIS</SPAN> because the British phone companyhad a copyright on the name Yellow Pages.</P></BLOCKQUOTE><PCLASS="para">Almost all resolver configuration is done in the file<ACLASS="indexterm"NAME="AUTOID-4451"></A><ACLASS="indexterm"NAME="AUTOID-4453"></A><ACLASS="indexterm"NAME="AUTOID-4456"></A><ACLASS="indexterm"NAME="AUTOID-4459"></A><ICLASS="filename">/etc/resolv.conf</I> (this may be<ICLASS="filename">/usr/etc/resolv.conf</I> or something similar on yourhost&nbsp;- check the <KBDCLASS="command">resolver</KBD> manual page, usuallyin section 4 or 5, to make sure). There are five main<ICLASS="firstterm">directives</I> you can use in<ICLASS="filename">resolv.conf</I>: the<ICLASS="structfield">domain</I> directive, the<ICLASS="structfield">search</I> directive, the<ICLASS="structfield">nameserver</I> directive, the<ICLASS="structfield">sortlist</I> directive, and the<ICLASS="structfield">options</I> directive.  These directivescontrol the behavior of the resolver. There are other, vendor-specificdirectives available on some versions of<SPANCLASS="acronym">UNIX</SPAN>&nbsp;- we'll discuss them at the end of thischapter.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-4473">6.1.1 The Default Domain</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4476"></A><ACLASS="indexterm"NAME="AUTOID-4478"></A><ACLASS="indexterm"NAME="AUTOID-4481"></A>The default domain is the domain considered <SPANCLASS="quote">"local"</SPAN> tothe host. For example, when you add an entry like:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">relay mark</PRE></BLOCKQUOTE><PCLASS="para">to your <ICLASS="filename">.rhosts</I> file, the name <ICLASS="systemitem.sitename">relay</I> is assumed to be in your defaultdomain.  This makes a lot more sense than allowing access to everyhost on the Internet whose domain name starts with <ICLASS="systemitem.sitename">relay</I>.  Other authorization files like<ICLASS="filename">hosts.equiv</I> and <ICLASS="filename">hosts.lpd</I>work the same way.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4493"></A><ACLASS="indexterm"NAME="AUTOID-4496"></A>Normally, the default domain is determined from the host's<KBDCLASS="command">hostname</KBD>; the default domain is everythingafter the first <SPANCLASS="quote">"."</SPAN> in the name. If the name doesn'tcontain a <SPANCLASS="quote">"."</SPAN>, the default domain is assumed to be theroot domain. So the <KBDCLASS="command">hostname</KBD> <ICLASS="systemitem.sitename">asylum.sf.ca.us</I> implies a default domain of<ICLASS="systemitem.sitename">sf.ca.us</I>, while the<KBDCLASS="command">hostname</KBD> <ICLASS="systemitem.sitename">dogbert</I> implies a root defaultdomain&nbsp;- which probably isn't correct, given that there are nohosts immediately under the root domain.</P><PCLASS="para">You can also set the default domain with the<ACLASS="indexterm"NAME="AUTOID-4508"></A><ICLASS="structfield">domain</I> directive in<ICLASS="filename">resolv.conf</I>.  If the<ICLASS="structfield">domain</I> directive is specified, it overridesthe domain in the <KBDCLASS="command">hostname</KBD>.</P><PCLASS="para">The domain directive has a very simple syntax, but you've got toget it right, since the resolver doesn't report errors. The keyword<ICLASS="structfield">domain</I> starts the line in column one,followed by whitespace (one or more blanks or tabs), then the name ofthe default domain. The default domain should be written without atrailing dot, like this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">domain colospgs.co.us</PRE></BLOCKQUOTE><PCLASS="para">In older versions of the <SPANCLASS="acronym">DNS</SPAN> resolver (thosebefore <SPANCLASS="acronym">DNS</SPAN> 4.9.3), trailing spaces <EMCLASS="emphasis">arenot allowed</EM> on the line, and will cause your default domainto be set to a name ending with one or more spaces, which is almostcertainly not what you want. And there's yet another way to set thedefault domain&nbsp;- via the<ACLASS="indexterm"NAME="AUTOID-4521"></A><ICLASS="envar">LOCALDOMAIN</I> environmentvariable. <ICLASS="envar">LOCALDOMAIN</I> is handy because you can set iton a per-user basis. For example, you might have a big, massivelyparallel box in your corporate computing center to which employeesfrom all over the world log in. Each may do most of his work in adifferent company subdomain. With <ICLASS="envar">LOCALDOMAIN</I>, eachemployee can set his default domain to the appropriate domain in hisshell startup file.</P><PCLASS="para">Which method should you use&nbsp;- <KBDCLASS="command">hostname</KBD>,the <ICLASS="structfield">domain</I> directive, or<ICLASS="envar">LOCALDOMAIN</I>? We prefer using<KBDCLASS="command">hostname</KBD>, but primarily because that's the wayBerkeley does it, and it seems <SPANCLASS="quote">"cleaner"</SPAN> in that itrequires less explicit configuration. Also, some Berkeley software,particularly software that uses the<ICLASS="function">ruserok()</I> library call to authenticateusers, allows short host names in files like<ICLASS="filename">hosts.equiv</I> only if <KBDCLASS="command">hostname</KBD>is set to the full domain name.</P><PCLASS="para">If you run software that can't tolerate long<KBDCLASS="command">hostnames</KBD>, though, you can use the<ICLASS="structfield">domain</I> directive. The<KBDCLASS="command">hostname</KBD> command will continue to return a shortname, and the resolver will fill in the domain from<ICLASS="filename">resolv.conf</I>. You may even find occasion to use<ICLASS="envar">LOCALDOMAIN</I> on a host with lots of users.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-4542">6.1.2 The Search List</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="DNS3-IDX-6-SEARCH-LIST"></A><ACLASS="indexterm"NAME="DNS3-IDX-6-DEFAULT-SEARCH-LIST"></A>The default domain, whether derived from <KBDCLASS="command">hostname</KBD>or <ICLASS="filename">resolv.conf</I>, also determines the default<ICLASS="firstterm">search list</I>. The search list was designed tomake users' lives a little easier by saving them some typing. The ideais to search one or more domains for names typed at the command linethat might be incomplete&nbsp;- that is, that might not be fullyqualified domain names.<ACLASS="indexterm"NAME="AUTOID-4552"></A><ACLASS="indexterm"NAME="AUTOID-4554"></A></P><PCLASS="para">Most <SPANCLASS="acronym">UNIX</SPAN> networking commands that take adomain name as an argument, like <KBDCLASS="command">telnet</KBD>,<KBDCLASS="command">ftp</KBD>, <KBDCLASS="command">rlogin</KBD>, and<KBDCLASS="command">rsh</KBD>, apply the search list to thosearguments.</P><PCLASS="para">Both the way the default search list is derived and the way thesearch list is applied changed from <SPANCLASS="acronym">DNS</SPAN> 4.8.3 to<SPANCLASS="acronym">DNS</SPAN> 4.9.  If your resolver is an older make, you'llstill see the 4.8.3 behavior, but if you've got a newer model,including <SPANCLASS="acronym">DNS</SPAN> 8.1.2,[2] you'll see the improvements in the 4.9 resolver.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] Though the <SPANCLASS="acronym">ISC</SPAN> added lots of new serverfunctionality in <SPANCLASS="acronym">DNS</SPAN> 8, the resolver is nearlyidentical to the <SPANCLASS="acronym">DNS</SPAN> 4.9 resolver.</P></BLOCKQUOTE><PCLASS="para">With any <SPANCLASS="acronym">DNS</SPAN> resolver, a user can indicatethat a domain name is fully qualified by adding a trailing dot toit.[3] For example, the trailing dot in the command:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] Note that we said that the resolver can handle a trailingdot. Some programs, particularly <SPANCLASS="acronym">UNIX</SPAN> mail useragents, don't deal correctly with a trailing dot in emailaddresses. They cough even before they hand the domain name in theaddress to the resolver.</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>telnet ftp.ora.com.</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">means <SPANCLASS="quote">"don't bother searching any other domains; thisdomain name is fully qualified."</SPAN> This is analogous to theleading slash in full pathnames in the <SPANCLASS="acronym">UNIX</SPAN> and<SPANCLASS="acronym">MS-DOS</SPAN> filesystems. Pathnames without a leadingslash are interpreted as relative to the current working directory,while pathnames with a leading slash are absolute, anchored at theroot.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="AUTOID-4583">6.1.2.1 The <SPANCLASS="acronym">DNS</SPAN> 4.8.3 search list</A></H4><PCLASS="para">With <SPANCLASS="acronym">DNS</SPAN> 4.8.3 resolvers, the default searchlist includes the default domain and each of its parent domains withtwo or more labels. Therefore, on a host running a 4.8.3 resolver andconfigured with:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">domain cv.hp.com</PRE></BLOCKQUOTE><PCLASS="para">the default search list would contain first <ICLASS="systemitem.sitename">cv.hp.com</I>, the default domain, then<ICLASS="systemitem.sitename">hp.com</I>, the default domain'sparent, but not <ICLASS="systemitem.sitename">com</I>, as it onlyhas one label.[4] The name is looked up as is, after the resolver appendseach element of the search list, and only if the name typed containsat least one dot.  Thus, a user typing:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] One reason older <SPANCLASS="acronym">DNS</SPAN> resolvers didn't appendjust the top-level domain is that there were&nbsp;- and stillare&nbsp;- very few hosts at the second level of the Internet's namespace, so tacking on just <ICLASS="systemitem.sitename">com</I>or <ICLASS="systemitem.sitename">edu</I> to <ICLASS="systemitem.sitename">foo</I> is unlikely to result in the domainname of a real host. Also, looking up the address of a <ICLASS="systemitem.sitename">foo.com</I> or <ICLASS="systemitem.sitename">foo.edu</I> might well require sending a queryto a root name server, which taxes the roots and can betime-consuming.</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>telnet pronto.cv.hp.com</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">will cause lookups of <ICLASS="systemitem.sitename">pronto.cv.hp.com.cv.hp.com</I> and <ICLASS="systemitem.sitename">pronto.cv.hp.com.hp.com</I> before the resolverlooks up <ICLASS="systemitem.sitename">pronto.cv.hp.com</I> byitself.  A user typing:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>telnet asap</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">on the same host would cause the resolver to look up <ICLASS="systemitem.sitename">asap.cv.hp.com</I> and <ICLASS="systemitem.sitename">asap.hp.com</I>, but not just <ICLASS="systemitem.sitename">asap</I>, since the name typed(<SPANCLASS="quote">"<ICLASS="systemitem.sitename">asap</I>"</SPAN>)contains no dots.</P><PCLASS="para">Note that application of the search list stops as soon as aprospective domain name turns up the data being looked up. In the<ICLASS="systemitem.sitename">asap</I> example, the search listwould never get around to appending <ICLASS="systemitem.sitename">hp.com</I> if <ICLASS="systemitem.sitename">asap.cv.hp.com</I> resolved to anaddress.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="AUTOID-4619">6.1.2.2 The <SPANCLASS="acronym">DNS</SPAN> 4.9 and later search list</A></H4><PCLASS="para">With <SPANCLASS="acronym">DNS</SPAN> 4.9, the default search listincludes just the default domain.  So, if you configure a hostwith:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">domain cv.hp.com</PRE></BLOCKQUOTE><PCLASS="para">the default search list would contain just <ICLASS="systemitem.sitename">cv.hp.com</I>.  Also, in a change from earlierresolvers, the search list is usually applied<EMCLASS="emphasis">after</EM> the name is tried as is. As long as theargument you type has at least one dot in it, it's looked up exactlyas you typed it <EMCLASS="emphasis">before</EM> any element of the searchlist is appended. If that lookup fails, the search list isapplied. Even if the argument has no dots in it (that is, it's asingle label name), it's tried as-is, after the resolver appends theelements of the search list.</P><PCLASS="para">Why is it better to try the argument<ICLASS="foreignphrase">literatim</I> first? From experience, thedesigners of <SPANCLASS="acronym">DNS</SPAN> found that, more often than not,if a user bothered to type in a name with even a single dot in it, hewas probably typing in a fully qualified domain name without thetrailing dot. With older search list behavior, the resolver would sendseveral fruitless queries before ever trying the name as typed.</P><PCLASS="para">Therefore, with a 4.9 resolver, a user typing:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>telnet pronto.cv.hp.com</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">would have <ICLASS="systemitem.sitename">pronto.cv.hp.com</I> looked up first (there arethree dots in the argument). If that query failed, the resolver wouldtry <ICLASS="systemitem.sitename">pronto.cv.hp.com.cv.hp.com</I>.A user typing:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>telnet asap</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">on the same host would cause the resolver to look up <ICLASS="systemitem.sitename">asap.cv.hp.com</I> first, since the namedoesn't contain a dot, and then just <ICLASS="systemitem.sitename">asap</I>.<ACLASS="indexterm"NAME="AUTOID-4643"></A><ACLASS="indexterm"NAME="AUTOID-4644"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-4645">6.1.3 The search Directive</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4648"></A>What if you don't like the default search list you get when you setyour default domain? In <SPANCLASS="acronym">DNS</SPAN> 4.8.3 and all newerresolvers, you can set the search list explicitly, domain by domain,in the order you want the domains searched. You do this with the<ICLASS="structfield">search</I> directive.</P><PCLASS="para">The syntax of the <ICLASS="structfield">search</I> directive isvery similar to that of the <ICLASS="structfield">domain</I>directive, except that it can take multiple domain names asarguments. The keyword <ICLASS="structfield">search</I> starts theline in column one, followed by from one to six domain names, in theorder you want them searched. The first domain in the list isinterpreted as the default domain, so the<ICLASS="structfield">search</I> and<ICLASS="structfield">domain</I> directives are mutuallyexclusive. If you use both in <ICLASS="filename">resolv.conf</I>, theone that appears last will override the other.</P><PCLASS="para">The directive:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">search corp.hp.com paloalto.hp.com hp.com</PRE></BLOCKQUOTE><PCLASS="para">for example, would instruct the resolver to search the<ICLASS="systemitem.sitename">corp.hp.com</I> domain first, then<ICLASS="systemitem.sitename">paloalto.hp.com</I>, and then bothdomains' parent, <ICLASS="systemitem.sitename">hp.com</I>.</P><PCLASS="para">This directive might be useful on a host whose users accesshosts in both <ICLASS="systemitem.sitename">corp.hp.com</I> and<ICLASS="systemitem.sitename">paloalto.hp.com</I> frequently.  Onthe other hand, on a <SPANCLASS="acronym">DNS</SPAN> 4.8.3 resolver, thedirective:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">search corp.hp.com</PRE></BLOCKQUOTE><PCLASS="para">would have the resolver skip searching the default domain'sparent domain when the search list is applied. (On a 4.9 resolver, theparent domain isn't in the search list, so this is no different fromthe default behavior.) This might be useful if the host's users onlyaccess hosts in the local domain, or if connectivity to the parentname servers isn't good (because it minimizes unnecessary queries tothe parent name servers).</P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> If you use the<ACLASS="indexterm"NAME="AUTOID-4673"></A><ICLASS="structfield">domain</I> directive and update your resolverto <SPANCLASS="acronym">DNS</SPAN> version 4.9 or later, users who relied onyour default domain's parent being in the search list may believe theresolver has suddenly broken. You can restore the old behavior byusing the <ICLASS="structfield">search</I> directive to configureyour resolver to use the same search list that it would have builtbefore. For example, under <SPANCLASS="acronym">DNS</SPAN> 4.9 or<SPANCLASS="acronym">DNS</SPAN> 8, you can replace <EMCLASS="emphasis">domainnsr.hp.com</EM> with <EMCLASS="emphasis">search nsr.hp.comhp.com</EM> and get the same functionality.</P></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-4682">6.1.4 The nameserver Directive</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="DNS3-IDX-6-NAMESERVER-DIRECTIVE"></A><ACLASS="indexterm"NAME="DNS3-IDX-6-NAME-SERVERS-SELECTING-FOR-RESOLVER"></A>Back in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Setting Up BIND">Chapter 4</A>, we talked about two types of nameservers: primary master name servers and slave name servers. But whatif you don't want to run a name server on a host, yet still want touse <SPANCLASS="acronym">DNS</SPAN>?  Or, for that matter, what if you<EMCLASS="emphasis">can't</EM> run a name server on a host (because theoperating system doesn't support it, for example)? Surely you don'thave to run a name server on <EMCLASS="emphasis">every</EM> host,right?</P><PCLASS="para">No, of course you don't. By default, the resolver looks for aname server running on the local host&nbsp;- which is why we could use<KBDCLASS="command">nslookup</KBD> on <ICLASS="systemitem.sitename">terminator</I> and <ICLASS="systemitem.sitename">wormhole</I> right after we configured theirname servers. You can, however, instruct the resolver to look toanother host for name service. This configuration is called a<ACLASS="indexterm"NAME="AUTOID-4698"></A><ICLASS="firstterm"><SPANCLASS="acronym">DNS</SPAN> client</I> in the<CITECLASS="citetitle"><SPANCLASS="acronym">BIND</SPAN> Operations Guide</CITE>.</P><PCLASS="para">The <ICLASS="structfield">nameserver</I> directive (yep, allone word) tells the resolver the <SPANCLASS="acronym">IP</SPAN> address of aname server to query. For example, the line:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">nameserver 15.32.17.2</PRE></BLOCKQUOTE><PCLASS="para">instructs the resolver to send queries to the name serverrunning at <SPANCLASS="acronym">IP</SPAN> address 15.32.17.2, instead of to thelocal host. This means that on hosts that don't run name servers, youcan use the <ICLASS="structfield">nameserver</I> directive to pointthem at a remote name server. Typically, you would configure theresolvers on your hosts to query your own name servers.</P><PCLASS="para">However, since name servers before <SPANCLASS="acronym">DNS</SPAN> 4.9don't have any notion of access control, you can configure yourresolver to query almost anyone's name server. Of course, configuringyour host to use someone else's name server without first askingpermission is presumptuous, if not downright rude, and using one ofyour own will usually give you better performance, so we'll considerthis only an emergency option.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4715"></A><ACLASS="indexterm"NAME="AUTOID-4718"></A>You can also configure the resolver to query the host's local nameserver, by using either the local host's <SPANCLASS="acronym">IP</SPAN> addressor the zero address.  The zero address, 0.0.0.0, is interpreted bymost <SPANCLASS="acronym">TCP</SPAN>/<SPANCLASS="acronym">IP</SPAN> implementations tomean <SPANCLASS="quote">"this host."</SPAN> The host's real <SPANCLASS="acronym">IP</SPAN>address, of course, also means <SPANCLASS="quote">"this host."</SPAN> On hosts thatdon't understand the zero address, you can use the loopback address,127.0.0.1.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4727"></A><ACLASS="indexterm"NAME="AUTOID-4730"></A>Now what if the name server your resolver queries is down? Isn't thereany way to specify a backup? Do you just fall back to using the hosttable?</P><PCLASS="para">The resolver will also allow you to specify up to three (count'em, three) name servers using multiple<ICLASS="structfield">nameserver</I> directives. The resolver willquery those name servers, in the order listed, until it receives ananswer or times out. The number of name servers you configure dictatesother aspects of the resolver's behavior, too.</P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> If you use multiple <ICLASS="structfield">nameserver</I>directives, <EMCLASS="emphasis">don't</EM> use the<ACLASS="indexterm"NAME="AUTOID-4739"></A><ACLASS="indexterm"NAME="AUTOID-4741"></A><ACLASS="indexterm"NAME="AUTOID-4744"></A>loopback address! There's a bug in some Berkeley-derived<SPANCLASS="acronym">TCP</SPAN>/<SPANCLASS="acronym">IP</SPAN> implementations that cancause problems with <SPANCLASS="acronym">DNS</SPAN> if the local name server isdown.  The resolver's connected datagram socket won't rebind to a newlocal address if the local name server isn't running, and consequentlythe resolver will send query packets to the fallback remote nameservers with a source address of 127.0.0.1. When the remote nameservers try to reply, they'll end up sending the reply packets tothemselves.</P></BLOCKQUOTE><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="AUTOID-4750">6.1.4.1 One name server configured</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4753"></A><ACLASS="indexterm"NAME="AUTOID-4756"></A>If there's only one name server configured, the resolver queries thatname server with a timeout of five seconds.  The timeout is the lengthof time the resolver will wait for a response from the name serverbefore sending another query. If the resolver encounters an<ACLASS="indexterm"NAME="AUTOID-4759"></A>error that indicates the name server is really down or unreachable, orif it times out, it will double the timeout and query the name serveragain. The errors that would cause this include:[5]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] When we say <SPANCLASS="quote">"one name server configured,"</SPAN> thatmeans either one <ICLASS="structfield">nameserver</I> directive in<ICLASS="filename">resolv.conf</I> or no<ICLASS="structfield">nameserver</I> directive with a name serverrunning locally.</P></BLOCKQUOTE><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Receipt of an<SPANCLASS="acronym">ICMP</SPAN><ACLASS="indexterm"NAME="AUTOID-4772"></A><ACLASS="indexterm"NAME="AUTOID-4774"></A><ACLASS="indexterm"NAME="AUTOID-4776"></A><TTCLASS="computeroutput">port unreachable</TT> message, which meansthat no name server is listening on the name server port</P></LI><LICLASS="listitem"><PCLASS="para">Receipt of an <SPANCLASS="acronym">ICMP</SPAN> <TTCLASS="computeroutput">hostunreachable</TT> or <TTCLASS="computeroutput">networkunreachable</TT> message, which means that queries can'tbe sent to the destination <SPANCLASS="acronym">IP</SPAN> address</P></LI></UL><PCLASS="para">If the domain name or data don't exist, the resolver doesn'tretry the query. Theoretically, at least, each name server should havean equivalent <SPANCLASS="quote">"view"</SPAN> of the name space; there's no reasonto believe one and not another. So if one name server tells you that agiven domain name doesn't exist, or that the type of data you'relooking for doesn't exist for the domain name you specified, any othername server should give you the same answer.[6] If the resolver receives a network error<EMCLASS="emphasis">each</EM> time it sends a query (for a total of fourerrors), it falls back to using the host table. Note that these are<EMCLASS="emphasis">errors</EM>, not timeouts. If it times out on even onequery, the resolver returns a null answer and does not fall back to<ICLASS="filename">/etc/hosts</I>.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] The built-in latency of <SPANCLASS="acronym">DNS</SPAN> makes this asmall fib&nbsp;- a primary can have authority for a zone and havedifferent data from a slave that also has authority for the zone. Theprimary may have just loaded new zone data from disk, while the slavemay not have had time to transfer the new zone data from theprimary. Both name servers return authoritative answers for the zone,but the primary may know about a brand-new host that the slave doesn'tyet know about.</P></BLOCKQUOTE></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="AUTOID-4793">6.1.4.2 More than one name server configured</A></H4><PCLASS="para">With more than one name server configured, the behavior is alittle different.  Here's what happens: the resolver starts byquerying the first name server in the list, with a timeout of fiveseconds, just as in the single name server case. If the resolver timesout or receives a network error, it will fall back to the next nameserver, waiting the same five seconds for that nameserver. Unfortunately, the resolver won't receive many of the possibleerrors; the socket the resolver uses is <SPANCLASS="quote">"unconnected,"</SPAN>since it must be able to receive responses from any of the nameservers it queries, and unconnected sockets don't receive<SPANCLASS="acronym">ICMP</SPAN> error messages. If the resolver queries allthe configured name servers, to no avail, it updates the timeouts andcycles through them again.</P><PCLASS="para">The resolver timeout for the next round of queries is based onthe number of name servers configured in<ICLASS="filename">resolv.conf</I>.  The timeout for the second round ofqueries is ten seconds divided by the number of name serversconfigured, rounded down. Each successive round's timeout is doublethe previous timeout. After three sets of retransmissions (a total offour timeouts for every name server configured), the resolver gives uptrying to query name servers.</P><PCLASS="para">For you mathophobes, <ACLASS="xref"HREF="ch06_01.htm#DNS3-CHP-6-TAB-1"TITLE="Resolver Timeouts">Table 6.1</A> showswhat the timeouts look like when you have one, two, or three nameservers configured.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="DNS3-CHP-6-TAB-1">Table 6.1: Resolver Timeouts</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para"></P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Name Servers Configured</P></TH></TR><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Retry</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">1</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">2</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">3</P></TH></TR></THEAD><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Total</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">75s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">80s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">81s</P></TD></TR><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">0</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">5s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">(2x) 5s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">(3x) 5s</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">1</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">10s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">(2x) 5s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">(3x) 3s</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">2</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">20s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">(2x) 10s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">(3x) 6s</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">3</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">40s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">(2x) 20s</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">(3x) 13s</P></TD></TR></TBODY></TABLE><PCLASS="para">(Note that this is how <SPANCLASS="acronym">DNS</SPAN> versions 4.9 andlater behave. The behavior of older versions of <SPANCLASS="acronym">DNS</SPAN>is similar, but not necessarily identical.)</P><PCLASS="para">So if you configure three servers, the resolver queries thefirst server, with a timeout period of five seconds. If that querytimes out, the resolver queries the second server with the sametimeout, and similarly for the third.  If the resolver cycles throughall three servers, it doubles the timeout period and divides by three(to three seconds, 10/3 rounded down) and queries the first serveragain.</P><PCLASS="para">Do these times seem awfully long? Remember, this describes aworst-case scenario. With properly-functioning name servers running ontolerably fast hosts, your resolvers should get their answers back inwell under a second.  Only if all the configured servers are reallybusy or they or your network is down will the resolver ever make itall the way through the retransmission cycle and give up.</P><PCLASS="para">What does the resolver do after it gives up? It times out andreturns an error. Typically this results in an error like:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>telnet tootsie</B></CODE>tootsie: Host name lookup failure</PRE></BLOCKQUOTE><PCLASS="para">Of course, it'll take at least 75 seconds of waiting to see thismessage, so be patient.<ACLASS="indexterm"NAME="AUTOID-4880"></A><ACLASS="indexterm"NAME="AUTOID-4881"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-4882">6.1.5 The sortlist Directive</A></H3><PCLASS="para">The<ACLASS="indexterm"NAME="AUTOID-4885"></A><ACLASS="indexterm"NAME="AUTOID-4887"></A><ACLASS="indexterm"NAME="AUTOID-4889"></A><ICLASS="structfield">sortlist</I> directive is a mechanism in<SPANCLASS="acronym">DNS</SPAN> 4.9 and later resolvers that lets you specifysubnets and networks for the resolver to prefer if it receivesmultiple addresses as the result of a query. In some cases, you'llhave reason to want your host to use a particular network to get tocertain destinations.  For example, say your workstation and your<SPANCLASS="acronym">NFS</SPAN> server have two network interfaces each: one onan Ethernet, subnet 128.32.1; and one on an <SPANCLASS="acronym">FDDI</SPAN>ring, subnet 128.32.42. If you leave your workstation's resolver toits own devices, it's anybody's guess which of the<SPANCLASS="acronym">NFS</SPAN> server's <SPANCLASS="acronym">IP</SPAN> addresses you'lluse for a mount&nbsp;- presumably, the first one in a reply packet fromthe name server. To make sure you try the interface on the<SPANCLASS="acronym">FDDI</SPAN> ring first, you can add a<ICLASS="structfield">sortlist</I> directive to<ICLASS="filename">resolv.conf</I> that sorts the address on 128.32.42to the preferred position in the structure passed back toprograms:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sortlist 128.32.42.0/255.255.255.0</PRE></BLOCKQUOTE><PCLASS="para">The argument after the slash is the subnet mask for the subnetin question. To prefer an entire network, you can omit the slash andthe subnet mask:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sortlist 128.32.0.0</PRE></BLOCKQUOTE><PCLASS="para">The resolver will assume you mean the entire class B network128.32. (The resolver derives the default unsubnetted net mask for thenetwork from the first few bits of the <SPANCLASS="acronym">IP</SPAN>address.)</P><PCLASS="para">And, of course, you can specify several subnets and networks toprefer over others:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sortlist 128.32.42.0/255.255.255.0 15.0.0.0</PRE></BLOCKQUOTE><PCLASS="para">The resolver sorts any addresses in a reply that match thesearguments into the order in which they appear in the directive, andappends addresses that don't match to the end.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-4909">6.1.6 The options Directive</A></H3><PCLASS="para">The<ACLASS="indexterm"NAME="AUTOID-4912"></A><ACLASS="indexterm"NAME="AUTOID-4914"></A><ACLASS="indexterm"NAME="AUTOID-4916"></A><ICLASS="structfield">options</I> directive was introduced with<SPANCLASS="acronym">DNS</SPAN> 4.9. <ICLASS="structfield">options</I> willlet you tweak two internal resolver settings. The first is the debugflag, <ICLASS="envar">RES_DEBUG</I>. The directive:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">options debug<ACLASS="indexterm"NAME="AUTOID-4924"></A><ACLASS="indexterm"NAME="AUTOID-4926"></A></PRE></BLOCKQUOTE><PCLASS="para">sets <ICLASS="envar">RES_DEBUG</I>, producing lots of excitingdebugging information on standard output, assuming your resolver wasconfigured with <ICLASS="envar">DEBUG</I> defined. (Actually, that may notbe a good assumption, since most vendors compile their stock resolverswithout <ICLASS="envar">DEBUG</I> defined.)  This is very useful if you'reattempting to diagnose a problem with your resolver or with nameservice in general, but very annoying otherwise.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4934"></A>The second setting you can modify is<ACLASS="indexterm"NAME="AUTOID-4937"></A><ACLASS="indexterm"NAME="AUTOID-4939"></A><ACLASS="indexterm"NAME="AUTOID-4942"></A><ICLASS="structfield">ndots</I>, which sets the minimum number ofdots a domain name argument must have so that the resolver will lookit up <EMCLASS="emphasis">before</EM> applying the search list. Bydefault, one or more dots will do; this is equivalent to<EMCLASS="emphasis">ndots:1</EM>. The resolver will try the domain name astyped first as long as the name has any dots in it. You can raise thethreshold if you believe your users are more likely to type partialdomain names that will need the search list applied. For example, ifyour default domain is <ICLASS="systemitem.sitename">mit.edu</I>and your users are accustomed to typing:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>ftp prep.ai</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">and having <ICLASS="systemitem.sitename">mit.edu</I>automatically appended to produce <ICLASS="systemitem.sitename">prep.ai.mit.edu</I>, then you may want to raise<ICLASS="structfield">ndots</I> to two so that your users won'tunwittingly cause lookups to the root name servers for names in thetop-level <ICLASS="systemitem.sitename">ai</I> domain. You coulddo this with:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">options ndots:2</PRE></BLOCKQUOTE><PCLASS="para">You can combine both option settings on the same line in<ICLASS="filename">resolv.conf</I>, like so:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">options debug ndots:2</PRE></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-4960">6.1.7 Comments</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4963"></A><ACLASS="indexterm"NAME="AUTOID-4966"></A><ACLASS="indexterm"NAME="AUTOID-4968"></A>Also introduced with <SPANCLASS="acronym">DNS</SPAN> 4.9 resolvers, and abouttime, if you ask us, is the ability to put comments in the<ICLASS="filename">resolv.conf</I> file.<ACLASS="indexterm"NAME="AUTOID-4972"></A><ACLASS="indexterm"NAME="AUTOID-4974"></A>Lines that begin with a pound sign or semi-colon in the first columnare interpreted as comments and ignored by the resolver.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-4976">6.1.8 A Note on the 4.9 Resolver Directives</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4979"></A><ACLASS="indexterm"NAME="AUTOID-4982"></A><ACLASS="indexterm"NAME="AUTOID-4985"></A>If you're just moving to a <SPANCLASS="acronym">DNS</SPAN> 4.9.3 or 4.9.4resolver, be careful when using the new directives. You may still haveolder resolver code statically linked into programs on yourhost. Often, this isn't a problem because <SPANCLASS="acronym">UNIX</SPAN>resolvers ignore directives they don't understand. But don't count onall programs on your host obeying the new directive.</P><PCLASS="para">If you're running on a host with programs that include reallyold resolver code, before 4.8.3, and you'd still like to use the<ICLASS="structfield">search</I> directive with programs that cantake advantage of it, here's a trick: use both a<ICLASS="structfield">domain</I> directive and a<ICLASS="structfield">search</I> directive in<ICLASS="filename">resolv.conf</I>, with the<ICLASS="structfield">domain</I> directive first. Old resolvers willread the <ICLASS="structfield">domain</I> directive and ignore the<ICLASS="structfield">search</I> directive, because they won'trecognize it. New resolvers will read the<ICLASS="structfield">domain</I> directive, but the following<ICLASS="structfield">search</I> directive will override itsbehavior.<ACLASS="indexterm"NAME="AUTOID-5000"></A></P></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_03.htm"TITLE="5.3 The MX Algorithm"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.3 The MX Algorithm"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="DNS &amp; BIND"><IMGSRC="../gifs/txthome.gif"ALT="DNS &amp; BIND"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Sample Resolver Configurations"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.2 Sample Resolver Configurations"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">5.3 The MX Algorithm</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">6.2 Sample Resolver Configurations</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>