<HTML><HEAD><TITLE>[Chapter 14] Programming with the Resolver and Name Server Library Routines</TITLE><METANAME="DC.title"CONTENT="DNS &amp; BIND"><METANAME="DC.creator"CONTENT="Cricket Liu &amp; Paul Albitz"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-01-06T18:41:17Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-512-2"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="index.htm"TITLE="DNS &amp; BIND"><LINKREL="prev"HREF="ch13_06.htm"TITLE="13.6 Problem Symptoms"><LINKREL="next"HREF="ch14_02.htm"TITLE="14.2 C Programming with the Resolver Library Routines"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="DNS &amp; BIND"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="DNS &amp; BIND"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/dsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch13_06.htm"TITLE="13.6 Problem Symptoms"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 13.6 Problem Symptoms"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 14</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch14_02.htm"TITLE="14.2 C Programming with the Resolver Library Routines"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 14.2 C Programming with the Resolver Library Routines"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="CHAPTER"><H1CLASS="chapter"><ACLASS="title"NAME="DNS3-CHP-14">14. Programming with the Resolver and Name Server LibraryRoutines</A></H1><DIVCLASS="htmltoc"><P><B>Contents:</B><BR><ACLASS="sect1"HREF="#AUTOID-15082"TITLE="14.1 Shell Script Programming with nslookup">Shell Script Programming with nslookup</A><BR><ACLASS="sect1"HREF="ch14_02.htm"TITLE="14.2 C Programming with the Resolver Library Routines">C Programming with the Resolver Library Routines</A><BR><ACLASS="sect1"HREF="ch14_03.htm"TITLE="14.3 Perl Programming with Net::DNS">Perl Programming with Net::DNS</A></P><P></P></DIV><DIVCLASS="epigraph"><PCLASS="para"ALIGN="right"><I>&quot;I know what you're thinking about,&quot; said Tweedledum; &quot;but it isn't so, nohow.&quot;</I></P><PCLASS="para"ALIGN="right"><I>&quot;Contrariwise,&quot; continued Tweedledee, &quot;if it was so, it might be; and if it were so, it would be; but as it isn't, it ain't. That's logic.&quot;</I></P></DIV><PCLASS="para"><ACLASS="indexterm"NAME="CH14.PROGRAMRESOLVERS2"></A><ACLASS="indexterm"NAME="CH14.PROGRAMRESOLVERS1"></A>I bet you think resolver programmingis hard. Contrariwise! It isn't very hard, really. The format of<SPANCLASS="acronym">DNS</SPAN> packets is quite straightforward&nbsp;- you don't have to deal with<SPANCLASS="acronym">ASN</SPAN>.1[1]at all, as you have to do with <SPANCLASS="acronym">SNMP</SPAN>. And you have nifty libraryroutines to make parsing <SPANCLASS="acronym">DNS</SPAN> packets easy. We've included portionsof <SPANCLASS="acronym">RFC</SPAN> 1035 in <ACLASS="xref"HREF="appa_01.htm"TITLE="DNS Message Format and Resource Records">Appendix A, <CITECLASS="appendix">DNS Message Format and ResourceRecords</CITE></A>.However, you might find it handy to have a copy of <SPANCLASS="acronym">RFC</SPAN> 1035 to lookat while we are going through this chapter; at least have a copyof it nearby when you write your own <SPANCLASS="acronym">DNS</SPAN> program.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] <SPANCLASS="acronym">ASN</SPAN>.1 stands for Abstract Syntax Notation. <SPANCLASS="acronym">ASN</SPAN>.1is a language for encoding object types, accepted as an internationalstandard by the International Organization for Standardization.</P></BLOCKQUOTE><DIVCLASS="sect1"><H2CLASS="sect1"><ACLASS="title"NAME="AUTOID-15082">14.1 Shell Script Programming with nslookup</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="CH14.SHELL1"></A><ACLASS="indexterm"NAME="CH14.SHELL2"></A>Before you go off and write aC program to do your <SPANCLASS="acronym">DNS</SPAN> chore, you should write the program asa shell script using <EMCLASS="emphasis">nslookup</EM>. There are goodreasons to start with a shell script:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">You'll write the shell script muchfaster than you'll write the C program. </P></LI><LICLASS="listitem"><PCLASS="para">If you are not comfortable with <SPANCLASS="acronym">DNS</SPAN>, you can workout the muck in your program's logic with a quick shell script prototype.When you finally write the C program, you can focus on the additionalcontrol you have with C, rather than spending your time reworkingthe basic functionality. </P></LI><LICLASS="listitem"><PCLASS="para">You might find out that the shell script versiondoes your task well enough so that you don't have to write the Cprogram after all. Not only is the coding time shorter, but shellscripts are easier to maintain if you stick with them for the longrun.</P></LI></UL><PCLASS="para">If you prefer Perl overplain old shell programming, you can do that too.  At the end ofthis chapter, we'll show you how to use the Perl Net::<SPANCLASS="acronym">DNS</SPAN> modulewritten by Michael Fuhr.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-15102">14.1.1 A Typical Problem</A></H3><PCLASS="para">Before you write aprogram, you have to have a problem to solve. Let's suppose youwant your network management system to watch over your primary andsecondary name servers. You want it to notify you of several problems:a name server that is not running (it might have died), a name serverthat is not authoritative for a domain that it is supposed to beauthoritative for (the boot file might have been messed up), ora name server that has fallen behind in updating its data (the primary'sserial number might have been decreased accidentally). </P><PCLASS="para">Eachof these problems is easily detectable. If a name server is notrunning on a host, the host will send back an<ACLASS="indexterm"NAME="AUTOID-15106"></A><SPANCLASS="acronym">ICMP</SPAN><EMCLASS="emphasis">port unreachable</EM> message.You can find this out with both <EMCLASS="emphasis">nslookup</EM> andthe resolver routines. Checking if a name server is authoritativefor a domain is easy: ask it for the domain's<ACLASS="indexterm"NAME="AUTOID-15111"></A><SPANCLASS="acronym">SOA</SPAN> record. If the answer is nonauthoritative,or the name server does not have the <SPANCLASS="acronym">SOA</SPAN> record, there is a problem.You'll have to ask for the <SPANCLASS="acronym">SOA</SPAN> record in a<ACLASS="indexterm"NAME="AUTOID-15116"></A><ACLASS="indexterm"NAME="AUTOID-15118"></A><ACLASS="indexterm"NAME="AUTOID-15120"></A><EMCLASS="emphasis">nonrecursive</EM> queryso that the name server doesn't go off and look up the <SPANCLASS="acronym">SOA</SPAN> recordfrom another server. Once you have the <SPANCLASS="acronym">SOA</SPAN> record, you can extractthe serial number.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-15126">14.1.2 Solving This Problem with a Script</A></H3><PCLASS="para">Thisproblem requires a program that takes the domain name of a zoneas an argument, looks up the name servers for that zone, and thenqueries each of those name servers for the <SPANCLASS="acronym">SOA</SPAN> record for the zone.The response will show if the server is authoritative, and it willshow the zone's serial number. If there is no response, the programneeds to determine if a name server is even running on the host.Once this program is written, it needs to be called for every zoneyou want to watch over. Since this program looks up the name servers(by looking up the <SPANCLASS="acronym">NS</SPAN> records for the zone), we assume that youhave listed all your name servers in <SPANCLASS="acronym">NS</SPAN> records in your zone data.If that is not the case, then you will have to change this programto take a list of name servers from the command line.</P><PCLASS="para">Let'swrite the basic program as a shell script that uses <EMCLASS="emphasis">nslookup</EM>.First, we must figure out what the output of <EMCLASS="emphasis">nslookup</EM> lookslike, so that we can parse it with <SPANCLASS="acronym">UNIX</SPAN> tools. We'll look up <SPANCLASS="acronym">NS</SPAN>records to find out which servers are supposed to be authoritativefor a zone, both when the server is authoritative for the <SPANCLASS="acronym">NS</SPAN> recordsand when it isn't:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>nslookup</B></CODE>Default Server:  relay.hp.comAddress:  15.255.152.2&gt; <CODECLASS="userinput"><B>set type=ns</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">Find out what the response looks like when the server is notauthoritative for the NS records:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">&gt; <CODECLASS="userinput"><B>mit.edu.</B></CODE>Server:  relay.hp.comAddress:  15.255.152.2Non-authoritative answer:mit.edu nameserver = <SPANCLASS="acronym">STRAWB</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>mit.edu nameserver = W20<SPANCLASS="acronym">NS</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>mit.edu nameserver = <SPANCLASS="acronym">BITSY</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>Authoritative answers can be found from:<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN> nameserver = <SPANCLASS="acronym">STRAWB</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN><SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN> nameserver = W20<SPANCLASS="acronym">NS</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN><SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN> nameserver = <SPANCLASS="acronym">BITSY</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN><SPANCLASS="acronym">STRAWB</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>  internet address = 18.71.0.151W20<SPANCLASS="acronym">NS</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>   internet address = 18.70.0.160BITSY.MIT.EDU   internet address = 18.72.0.3</PRE></BLOCKQUOTE><PCLASS="para">Find out what the response looks like when the server isauthoritative for the <SPANCLASS="acronym">NS</SPAN> records:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">&gt; <CODECLASS="userinput"><B>server strawb.mit.edu.</B></CODE>Default Server:  strawb.mit.eduAddress:  18.71.0.151&gt; <CODECLASS="userinput"><B>mit.edu.</B></CODE>Server:  strawb.mit.eduAddress:  18.71.0.151mit.edu nameserver = <SPANCLASS="acronym">BITSY</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>mit.edu nameserver = <SPANCLASS="acronym">STRAWB</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>mit.edu nameserver = W20<SPANCLASS="acronym">NS</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN><SPANCLASS="acronym">BITSY</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>   internet address = 18.72.0.3<SPANCLASS="acronym">STRAWB</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>  internet address = 18.71.0.151W20<SPANCLASS="acronym">NS</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>   internet address = 18.70.0.160</PRE></BLOCKQUOTE><PCLASS="para">You can see from this output that we can grab thename server names by looking for the lines that contain <KBDCLASS="command">nameserver</KBD> andsaving the last field. When the server was not authoritative forthe <SPANCLASS="acronym">NS</SPAN> records, it printed them twice, so we'll have to weed outduplicates.</P><PCLASS="para">Next, we look up the <SPANCLASS="acronym">SOA</SPAN> record for thezone, both when the server is authoritative for the <SPANCLASS="acronym">SOA</SPAN> record andwhen it isn't. We turn off<ACLASS="indexterm"NAME="AUTOID-15203"></A><EMCLASS="emphasis">recurse</EM> so the name server doesn't go off andquery an authoritative name server for the <SPANCLASS="acronym">SOA</SPAN>:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>nslookup</B></CODE>Default Server:  relay.hp.comAddress:  15.255.152.2&gt; <CODECLASS="userinput"><B>set type=soa</B></CODE>&gt; <CODECLASS="userinput"><B>set norecurse</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">Find out what the response looks like when the server does not have the <SPANCLASS="acronym">SOA</SPAN> record:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">&gt; <CODECLASS="userinput"><B>mit.edu.</B></CODE>Server:  relay.hp.comAddress:  15.255.152.2Authoritative answers can be found from:MIT.EDU nameserver = STRAWB.MIT.EDUMIT.EDU nameserver = W20NS.MIT.EDUMIT.EDU nameserver = BITSY.MIT.EDUSTRAWB.MIT.EDU  internet address = 18.71.0.151W20NS.MIT.EDU   internet address = 18.70.0.160BITSY.MIT.EDU   internet address = 18.72.0.3</PRE></BLOCKQUOTE><PCLASS="para">Find out what the response looks like when the server is authoritative for the zone: </P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">&gt; <CODECLASS="userinput"><B>server strawb.mit.edu.</B></CODE>Default Server:  strawb.mit.eduAddress:  18.71.0.151&gt; <CODECLASS="userinput"><B>mit.edu.</B></CODE>Server:  strawb.mit.eduAddress:  18.71.0.151mit.edu        origin = <SPANCLASS="acronym">BITSY</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>        mail addr = <SPANCLASS="acronym">NETWORK</SPAN>-<SPANCLASS="acronym">REQUEST</SPAN>.<SPANCLASS="acronym">BITSY</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN>        serial = 378        refresh = 3600 (1 hour)        retry   = 300 (5 mins)        expire  = 3600000 (41 days 16 hours)        minimum ttl = 21600 (6 hours)</PRE></BLOCKQUOTE><PCLASS="para">When the name server was not authoritative for the zone,it returned references to other name servers. If the name serverhad previously looked up the <SPANCLASS="acronym">SOA</SPAN> record and cached it, the nameserver would have returned the <SPANCLASS="acronym">SOA</SPAN> record and said it was &quot;non-authoritative.&quot;We need to check for both cases. When the name server returns the<SPANCLASS="acronym">SOA</SPAN> record and it is authoritative, we can grab the serial numberfrom the line that contains <KBDCLASS="command">serial</KBD>.</P><PCLASS="para">Now,we need to see what <EMCLASS="emphasis">nslookup</EM> returns when noname server is running on a host. We'll change servers to a hostthat does not normally run a name server and look up an <SPANCLASS="acronym">SOA</SPAN> record:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>nslookup</B></CODE>Default Server:  relay.hp.comAddress:  15.255.152.2&gt; <CODECLASS="userinput"><B>server galt.cs.purdue.edu.</B></CODE>Default Server:  galt.cs.purdue.eduAddress:  128.10.2.39&gt; <CODECLASS="userinput"><B>set type=soa</B></CODE>&gt; <CODECLASS="userinput"><B>mit.edu.</B></CODE>Server:  galt.cs.purdue.eduAddress:  128.10.2.39*** galt.cs.purdue.edu can't find mit.edu.: No response from server</PRE></BLOCKQUOTE><PCLASS="para">Last, we need to see what <EMCLASS="emphasis">nslookup</EM> returnsif a host is not responding. We can test this by switching serversto an unused <SPANCLASS="acronym">IP</SPAN> address on our <SPANCLASS="acronym">LAN</SPAN>: </P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>nslookup</B></CODE>Default Server:  relay.hp.comAddress:  15.255.152.2&gt; <CODECLASS="userinput"><B>server 15.255.152.100</B></CODE>Default Server:  [15.255.152.100]Address:  15.255.152.100&gt; <CODECLASS="userinput"><B>set type=soa</B></CODE>&gt; <CODECLASS="userinput"><B>mit.edu.</B></CODE>Server:  [15.255.152.100]Address:  15.255.152.100*** Request to [15.255.152.100] timed-out</PRE></BLOCKQUOTE><PCLASS="para">In the last two error cases, the error message was writtento <EMCLASS="emphasis">stderr</EM>. We can make use of that fact whenwriting our shell script. Now we are ready to compose the shellscript. We'll call it <EMCLASS="emphasis">check_soa</EM>:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#!/bin/shif test &quot;$1&quot; = &quot;&quot;then    echo usage: $0 domain    exit 1fi<SPANCLASS="acronym">DOMAIN</SPAN>=$1## Use nslookup to discover the nameservers for this domain ($1).# Use awk to grab the name server names from the nameserver lines.# (The names are always in the last field.)  Use sort -u to weed out# duplicates; we don't actually care about collation.#<SPANCLASS="acronym">SERVERS</SPAN>=`nslookup -type=ns $<SPANCLASS="acronym">DOMAIN</SPAN> |\                 awk '/nameserver/ {print $<SPANCLASS="acronym">NF</SPAN>}' | sort -u`if test &quot;$<SPANCLASS="acronym">SERVERS</SPAN>&quot; = &quot;&quot;then    #    # Didn't find any servers.  Just quit silently; nslookup will    # have detected this error and printed a message.  That will    # suffice.    #    exit 1fi## Check each server's <SPANCLASS="acronym">SOA</SPAN> serial number.  The output from# nslookup is saved in two tmp files: nso.$$ (standard output)# and nse.$$ (standard error).  These files are rewritten on# every iteration.  Turn off defname and search since we# should be dealing with fully qualified names.## <SPANCLASS="acronym">NOTE</SPAN>: this loop is rather long; don't be fooled.#for i in $<SPANCLASS="acronym">SERVERS</SPAN>do  nslookup &gt;/tmp/nso.$$ 2&gt;/tmp/nse.$$ &lt;&lt;-<SPANCLASS="acronym">EOF</SPAN>    server $i    set nosearch    set nodefname    set norecurse    set q=soa    $<SPANCLASS="acronym">DOMAIN</SPAN><SPANCLASS="acronym">EOF</SPAN>  #  # Does this response indicate that the current server ($i) is  # authoritative?  The server is <SPANCLASS="acronym">NOT</SPAN> authoritative if (a) the  # response says so, or (b) the response tells you to find  # authoritative info elsewhere.  #  if egrep &quot;Non-authoritative|Authoritative answers can be&quot; \                                          /tmp/nso.$$ &gt;/dev/null  then    echo $i is not authoritative for $<SPANCLASS="acronym">DOMAIN</SPAN>    continue  fi  #  # We know the server is authoritative; extract the serial number.  #  <SPANCLASS="acronym">SERIAL</SPAN>=`cat /tmp/nso.$$ | grep serial | sed -e &quot;s/.*= //&quot;`  if test &quot;$<SPANCLASS="acronym">SERIAL</SPAN>&quot; = &quot;&quot;  then    #    # We get here if <SPANCLASS="acronym">SERIAL</SPAN> is null.  In this case, there should    # be an error message from nslookup; so cat the &quot;standard    # error&quot; file.    #    cat /tmp/nse.$$  else    #    # Report the server's name and its serial number.    #    echo $i has serial number $<SPANCLASS="acronym">SERIAL</SPAN>  fidone  # end of the &quot;for&quot; loop## Delete the temporary files.#rm -f /tmp/nso.$$ /tmp/nse.$$</PRE></BLOCKQUOTE><PCLASS="para">Here is what the output looks like:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>check_soa mit.edu</B></CODE><SPANCLASS="acronym">BITSY</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN> has serial number 378<SPANCLASS="acronym">STRAWB</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN> has serial number 378W20<SPANCLASS="acronym">NS</SPAN>.<SPANCLASS="acronym">MIT</SPAN>.<SPANCLASS="acronym">EDU</SPAN> has serial number 378</PRE></BLOCKQUOTE><PCLASS="para">If you are pressed for time, this short tool will solveyour problem, and you can go on to other work. If you find thatyou are checking lots of zones and that this tool is too slow, you'llwant to convert it to a C program. Also, if you want more controlover the error messages&nbsp;- rather than relying on <EMCLASS="emphasis">nslookup</EM> forerror messages&nbsp;- then you'll have to write a C program. We'll do justthat, later on in this chapter.</P></DIV><ACLASS="indexterm"NAME="AUTOID-15284"></A><ACLASS="indexterm"NAME="AUTOID-15285"></A></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch13_06.htm"TITLE="13.6 Problem Symptoms"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 13.6 Problem Symptoms"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="DNS &amp; BIND"><IMGSRC="../gifs/txthome.gif"ALT="DNS &amp; BIND"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch14_02.htm"TITLE="14.2 C Programming with the Resolver Library Routines"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 14.2 C Programming with the Resolver Library Routines"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">13.6 Problem Symptoms</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">14.2 C Programming with the Resolver Library Routines</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>