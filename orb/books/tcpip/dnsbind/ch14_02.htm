<HTML><HEAD><TITLE>[Chapter 14] 14.2 C Programming with the Resolver Library Routines</TITLE><METANAME="DC.title"CONTENT="DNS &amp; BIND"><METANAME="DC.creator"CONTENT="Cricket Liu &amp; Paul Albitz"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-01-06T18:41:30Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-512-2"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch14_01.htm"TITLE="14. Programming with the Resolver and Name Server Library Routines"><LINKREL="prev"HREF="ch14_01.htm"TITLE="14.1 Shell Script Programming with nslookup"><LINKREL="next"HREF="ch14_03.htm"TITLE="14.3 Perl Programming with Net::DNS"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="DNS &amp; BIND"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="DNS &amp; BIND"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/dsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch14_01.htm"TITLE="14.1 Shell Script Programming with nslookup"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 14.1 Shell Script Programming with nslookup"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 14<BR>Programming with the Resolver and Name Server LibraryRoutines</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch14_03.htm"TITLE="14.3 Perl Programming with Net::DNS"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 14.3 Perl Programming with Net::DNS"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="AUTOID-15286">14.2 C Programming with the Resolver Library Routines</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="CH14.CPROGRAMMING1"></A><ACLASS="indexterm"NAME="CH14.CPROGRAMMING2"></A>Beforewriting any code, though, you need to be familiar with the <SPANCLASS="acronym">DNS</SPAN> packetformat and the resolver library routines. In the shell script wejust wrote, <EMCLASS="emphasis">nslookup</EM> parsed the <SPANCLASS="acronym">DNS</SPAN> packet.In a C program, you have to do the parsing. Let's start this sectionon programming by looking at the <SPANCLASS="acronym">DNS</SPAN> packet format.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-15298">14.2.1 <SPANCLASS="acronym">DNS</SPAN> Packet Format</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15302"></A><ACLASS="indexterm"NAME="AUTOID-15305"></A><ACLASS="indexterm"NAME="AUTOID-15308"></A>You'veseen the <SPANCLASS="acronym">DNS</SPAN> packet format before, in <ACLASS="xref"HREF="ch11_01.htm"TITLE="nslookup">Chapter 11, <CITECLASS="chapter">nslookup</CITE></A>. It lookslike this:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Header section</P></LI><LICLASS="listitem"><PCLASS="para">Question section</P></LI><LICLASS="listitem"><PCLASS="para">Answer section</P></LI><LICLASS="listitem"><PCLASS="para">Authority section</P></LI><LICLASS="listitem"><PCLASS="para">Additional section</P></LI></OL><PCLASS="para">The format of the<ACLASS="indexterm"NAME="AUTOID-15325"></A>header section is described in <SPANCLASS="acronym">RFC</SPAN> 1035 on pages 26-28 and in <ACLASS="xref"HREF="appa_01.htm"TITLE="DNS Message Format and Resource Records">Appendix A</A>.  It looks like this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">query identification number (2 octets)query response (1 bit)opcode (4 bits)authoritative answer (1 bit)truncation (1 bit)recursion desired (1 bit)recursion available (1 bit)reserved (3 bits)response code (4 bits)question count (2 octets)answer record count (2 octets)name server record count (2 octets)additional record count (2 octets)</PRE></BLOCKQUOTE><PCLASS="para">You'll also find opcode, response code, type, andclass values defined in <EMCLASS="emphasis">arpa/nameser.h</EM> as wellas routines to extract this information from a response.  We'lldiscuss these routines, the <EMCLASS="emphasis">name server library</EM>,shortly.</P><PCLASS="para">The<ACLASS="indexterm"NAME="AUTOID-15334"></A>question section is described on pages 28-29 of <SPANCLASS="acronym">RFC</SPAN> 1035. It looks like this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">domain name (variable length)query type (2 octets)query class (2 octets)</PRE></BLOCKQUOTE><PCLASS="para">The<ACLASS="indexterm"NAME="AUTOID-15339"></A><ACLASS="indexterm"NAME="AUTOID-15341"></A><ACLASS="indexterm"NAME="AUTOID-15343"></A>answer, authority, and additional sections are described on pages 29-30of <SPANCLASS="acronym">RFC</SPAN> 1035. These sections comprise some number of resource recordsthat look like this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">domain name (variable length)type (2 octets)class (2 octets)TTL (4 octets)resource data length (2 octets)resource data (variable length)</PRE></BLOCKQUOTE><PCLASS="para">The header section contains a count of how many of theseresource records are in each section.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-15348">14.2.2 Domain Name Storage</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15351"></A><ACLASS="indexterm"NAME="AUTOID-15354"></A>As you can see, the names storedin the <SPANCLASS="acronym">DNS</SPAN> packet are of variable length. Unlike C, <SPANCLASS="acronym">DNS</SPAN> does notstore the names as null-terminated strings. Domain names are storedas a series of length/value pairs ending with an octet of zero.Each label in a domain name is composed of a length octet and alabel. A name like <EMCLASS="emphasis">venera.isi.edu</EM> is storedas:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">6 venera  3  isi  3 edu 0</PRE></BLOCKQUOTE><PCLASS="para">You can imagine how much of a <SPANCLASS="acronym">DNS</SPAN> packet could bedevoted to storing names. The <SPANCLASS="acronym">DNS</SPAN> authors recognized this, and cameup with a simple way to compress domain names.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-15364">14.2.3 Domain Name Compression</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15367"></A><ACLASS="indexterm"NAME="AUTOID-15370"></A><ACLASS="indexterm"NAME="AUTOID-15372"></A>Oftenan entire domain name or, at least, the trailing labels of a domainname match a name already stored in the response. Domain name compression eliminatesthe repetition of domain names by storing a pointer to the earlieroccurrence of the name instead of inserting the name again. Hereis how it works. Suppose a response packet already contains thename <EMCLASS="emphasis">venera.isi.edu</EM>. If the name <EMCLASS="emphasis">vaxa.isi.edu</EM> isadded to the response, the label <EMCLASS="emphasis">vaxa</EM> is stored,and then a pointer to the earlier occurrence of <EMCLASS="emphasis">isi.edu</EM> is added.So how are pointers implemented?</P><PCLASS="para">The first two bitsof the length<ACLASS="indexterm"NAME="AUTOID-15379"></A>octetindicate whether a length/label pair or a pointer to alength/label pair follows. If the first two bits are zero, thenthe length and label follow. As you may have read elsewhere, a labelis limited to 63 characters. That's because the length field hasonly the remaining six bits for the length of the label&nbsp;- enoughto represent the lengths 0-63. If the first two bits of the lengthoctet are ones, then what follows is not a length, but a pointer.The pointer is the last six bits of the length octet <EMCLASS="emphasis">and</EM> thenext octet&nbsp;- 14 bits total. The pointer is an offset from the startof the <SPANCLASS="acronym">DNS</SPAN> packet. Now, when <EMCLASS="emphasis">vaxa.isi.edu</EM> iscompressed into a buffer containing only <EMCLASS="emphasis">venera.isi.edu</EM>,this is what results:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">  byte offset: 0 123456 7 890 1 234 5 6 7890 1    2               -------------+--------------+-------- pkt contents: 6 venera 3 isi 3 edu 0 4 vaxa 0xC0 7</PRE></BLOCKQUOTE><PCLASS="para">The 0xC0 is a byte with the high two bits ones andthe rest of the bits zeros. Since the high two bits are ones, thisis a pointer instead of a length. The pointer value is seven&nbsp;- thelast six bits of the first octet are zeros and the second octetis seven. At offset seven in this buffer, you find the rest of the <EMCLASS="emphasis">vaxa</EM> domain name: <EMCLASS="emphasis">isi.edu</EM>.</P><PCLASS="para">In this example, we only showed compressing two names in abuffer, not a whole <SPANCLASS="acronym">DNS</SPAN> packet. A <SPANCLASS="acronym">DNS</SPAN> packet would have had a headeras well as other fields. This example is intended to give you onlyan idea of how the domain name compression works. Now the good news:you don't have to care how names are compressed, as long as the libraryroutines do it properly. What you need to know is how parsing a<SPANCLASS="acronym">DNS</SPAN> response can get messed up if you are off by one byte. For example,try to expand the name starting with byte two instead of byte one.You'll discover that &quot;<KBDCLASS="command">v</KBD>&quot; doesn't make a verygood length octet or pointer.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-15395">14.2.4 The Resolver Library Routines</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="CH14.LIBRARY"></A>The resolver library contains theroutines that you need to write your application. You'll use theseroutines to generate queries.  You'll use the <EMCLASS="emphasis">name server library</EM>routines, explained next, to parse the response.  </P><PCLASS="para">Hereare the header files you must include:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/nameser.h&gt;#include &lt;resolv.h&gt;</PRE></BLOCKQUOTE><PCLASS="para">These are the resolver library routines:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int res_search(const char *dname,               int class,               int type,               u_char *answer,               int anslen)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15407"></A><EMCLASS="emphasis">res_search</EM> is the &quot;highest&quot; level resolverroutine. It is called by <EMCLASS="emphasis">gethostbyname</EM>. <EMCLASS="emphasis">res_search</EM> implementsthe search algorithm on the domain name passed to it. That is, ittakes the domain name it receives (<ACLASS="indexterm"NAME="AUTOID-15412"></A><EMCLASS="emphasis">dname</EM>), &quot;completes&quot;the name (if it's not fully qualified) by adding the various &quot;extensions&quot;from the resolver search list, and calls <EMCLASS="emphasis">res_query</EM> untilit receives a successful response, indicating that it found a valid,fully qualified name. In addition to implementing the search algorithm,<EMCLASS="emphasis">res_search</EM> looks in the file referenced byyour <CODECLASS="literal">HOSTALIASES</CODE> environment variable. (The <CODECLASS="literal">HOSTALIASES</CODE> variablewas described in <ACLASS="xref"HREF="ch06_01.htm"TITLE="Configuring Hosts">Chapter 6, <CITECLASS="chapter">Configuring Hosts</CITE></A>.)So it also takes care of any &quot;private&quot; host aliases you might have.<EMCLASS="emphasis">res_search</EM> returns the size of the response,or it fills in <EMCLASS="emphasis">h_errno</EM> and returns -1 if there wasan error or the answer count is zero. (<EMCLASS="emphasis">h_errno</EM> islike <EMCLASS="emphasis">errno</EM>, but for <SPANCLASS="acronym">DNS</SPAN> lookups.)</P><PCLASS="para">Therefore,the only parameter that's really of interest to <EMCLASS="emphasis">res_search</EM> is <EMCLASS="emphasis">dname</EM>;the others are just passed to <EMCLASS="emphasis">res_query</EM> andthe other resolver routines. The other arguments are:</P><DLCLASS="variablelist"><DTCLASS="term">class</DT><DDCLASS="listitem"><PCLASS="para">The &quot;address type&quot; of the data you're looking up.This is almost always the constant C_<SPANCLASS="acronym">IN</SPAN>, which requests an &quot;internetclass&quot; address. These constants are defined in <ICLASS="filename">arpa/nameser.h</I>.</P></DD><DTCLASS="term">type</DT><DDCLASS="listitem"><PCLASS="para">The type of request that you're making. Again, thisis a constant defined in <ICLASS="filename">arpa/nameser.h</I>. A typical value would beT_<SPANCLASS="acronym">NS</SPAN>, to retrieve a name server record; or T_<SPANCLASS="acronym">MX</SPAN>, to retrieve an <SPANCLASS="acronym">MX</SPAN>record.</P></DD><DTCLASS="term">answer</DT><DDCLASS="listitem"><PCLASS="para">A buffer in which <ICLASS="function">res_search</I> will place the responsepacket. Its size should be at least <SPANCLASS="acronym">PACKETSZ</SPAN> (from <ICLASS="filename">arpa/nameser.h</I>)bytes.</P></DD><DTCLASS="term">anslen</DT><DDCLASS="listitem"><PCLASS="para">The size of the <ICLASS="function">answer</I> buffer (e.g., <SPANCLASS="acronym">PACKETSZ</SPAN>).</P></DD></DL><PCLASS="para"><EMCLASS="emphasis">res_search</EM> returns the size of the response, or-1 if there was an error.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int res_query(const char *dname,              int class,              int type,              u_char *answer,              int anslen)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15461"></A><EMCLASS="emphasis">res_query</EM> is one of the &quot;midlevel&quot; resolverroutines. It does all the real work in looking up the domain name;it makes a query packet by calling <EMCLASS="emphasis">res_mkquery</EM>,sends the query by calling <EMCLASS="emphasis">res_send</EM>, and looksat enough of the response to determine if your question was answered.In many cases, <EMCLASS="emphasis">res_query</EM> is called by <EMCLASS="emphasis">res_search</EM>,which just feeds it the different domain names to look up. As you'dexpect, these two functions have the same arguments. <EMCLASS="emphasis">res_query</EM> returnsthe size of the response, or it fills in <EMCLASS="emphasis">h_errno</EM> andreturns -1 if there was an error or the answer count was zero.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int res_mkquery(int op,                const char *dname,                int class,                int type,                const u_char *data,                int datalen,                const u_char *newrr,                u_char *buf,                int buflen)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15472"></A><EMCLASS="emphasis">res_mkquery</EM> creates the query packet. It fillsin all the header fields, compresses the domain name into the questionsection, and fills in the other question fields.</P><PCLASS="para">The <EMCLASS="emphasis">dname</EM>, <EMCLASS="emphasis">class</EM>, and<EMCLASS="emphasis">type</EM> arguments are the same as for<EMCLASS="emphasis">res_search</EM> and <EMCLASS="emphasis">res_query</EM>.The remaining arguments are: </P><DLCLASS="variablelist"><DTCLASS="term">op</DT><DDCLASS="listitem"><PCLASS="para">The &quot;operation&quot; to be performed. This is normally<SPANCLASS="acronym">QUERY</SPAN>, but it can be <SPANCLASS="acronym">IQUERY</SPAN> (inverse query). However, as we've explainedbefore, <SPANCLASS="acronym">IQUERY</SPAN> is seldom used. <SPANCLASS="acronym">BIND</SPAN> versions 4.9.4 and later, bydefault, do not even support <SPANCLASS="acronym">IQUERY</SPAN> anymore.</P></DD><DTCLASS="term">data</DT><DDCLASS="listitem"><PCLASS="para">A buffer containing the data for inverse queries.It is <SPANCLASS="acronym">NULL</SPAN> when <ICLASS="parameter">op</I> is <SPANCLASS="acronym">QUERY</SPAN>.</P></DD><DTCLASS="term">datalen</DT><DDCLASS="listitem"><PCLASS="para">The size of the <ICLASS="function">data</I> buffer. If <ICLASS="function">data</I> is <SPANCLASS="acronym">NULL</SPAN>, then<ICLASS="parameter">datalen</I> is zero.</P></DD><DTCLASS="term">newrr</DT><DDCLASS="listitem"><PCLASS="para">A buffer used for the dynamic update code (coveredin <ACLASS="xref"HREF="ch10_01.htm"TITLE="Advanced Features and Security">Chapter 10, <CITECLASS="chapter">Advanced Features and Security</CITE></A>). Unless you are playingwith this feature, it is always <SPANCLASS="acronym">NULL</SPAN>.</P></DD><DTCLASS="term">buf</DT><DDCLASS="listitem"><PCLASS="para">A buffer in which <ICLASS="function">res_mkquery</I> makes the query packet.It should be <SPANCLASS="acronym">PACKETSZ</SPAN> or larger, just like the answer buffer in<ICLASS="function">res_search</I> and <ICLASS="function">res_query</I>.</P></DD><DTCLASS="term">buflen</DT><DDCLASS="listitem"><PCLASS="para">The size of the <ICLASS="parameter">buf</I> buffer (e.g., <SPANCLASS="acronym">PACKETSZ</SPAN>).</P></DD></DL><PCLASS="para"><EMCLASS="emphasis">res_mkquery</EM> returns the size of the querypacket, or -1 if there was an error.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int res_send(const u_char *msg,             int msglen,             u_char *answer,             int anslen)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15530"></A><EMCLASS="emphasis">res_send</EM> implements the retry algorithm. Itsends the query packet, <EMCLASS="emphasis">msg</EM>, in a <SPANCLASS="acronym">UDP</SPAN> packet,but it can also send it over a <SPANCLASS="acronym">TCP</SPAN> stream. The response packet isstored in <EMCLASS="emphasis">answer</EM>. This routine, of all theresolver routines, is the only one to use black magic (unless youknow all about connected datagram sockets). You've seen these argumentsbefore in the other resolver routines:</P><DLCLASS="variablelist"><DTCLASS="term">msg</DT><DDCLASS="listitem"><PCLASS="para">The buffer containing the <SPANCLASS="acronym">DNS</SPAN> query packet</P></DD><DTCLASS="term">msglen</DT><DDCLASS="listitem"><PCLASS="para">The size of the <ICLASS="parameter">msg</I></P></DD><DTCLASS="term">answer</DT><DDCLASS="listitem"><PCLASS="para">The buffer in which to store the <SPANCLASS="acronym">DNS</SPAN> response packet</P></DD><DTCLASS="term">anslen</DT><DDCLASS="listitem"><PCLASS="para">The size of the <ICLASS="parameter">answer</I> buffer</P></DD></DL><PCLASS="para"><EMCLASS="emphasis">res_send</EM> returns the size of the response,or -1 if there was an error. If this routine returns -1 and <EMCLASS="emphasis">errno</EM> is<SPANCLASS="acronym">ECONNREFUSED</SPAN>, then there is no name server running on the targetname server host. </P><PCLASS="para">You can look at <EMCLASS="emphasis">errno</EM> tosee if it is <SPANCLASS="acronym">ECONNREFUSED</SPAN> after calling <EMCLASS="emphasis">res_search</EM> or <EMCLASS="emphasis">res_query</EM>. (<EMCLASS="emphasis">res_search</EM> calls <EMCLASS="emphasis">res_query</EM>,which calls <EMCLASS="emphasis">res_send</EM>.) If you want to check <EMCLASS="emphasis">errno</EM> aftercalling <EMCLASS="emphasis">res_query</EM>, then clear <EMCLASS="emphasis">errno</EM> first.That way, you know the current call to <EMCLASS="emphasis">res_send</EM> wasthe one that set <EMCLASS="emphasis">errno</EM>. However, you don'thave to clear <EMCLASS="emphasis">errno</EM> before calling <EMCLASS="emphasis">res_search</EM>. <EMCLASS="emphasis">res_search</EM> clears <EMCLASS="emphasis">errno</EM> itselfbefore calling <EMCLASS="emphasis">res_query</EM>.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int res_init(void)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15582"></A><EMCLASS="emphasis">res_init</EM> reads <EMCLASS="emphasis">resolv.conf</EM> andinitializes a data structure called <EMCLASS="emphasis">_res</EM> (moreabout that later). All of the previously discussed routines willcall <EMCLASS="emphasis">res_init</EM> if they detect that it hasn't beencalled previously. Or you can call it on your own; this is usefulif you want to change some of the defaults before calling the firstresolver library routine. If there are any lines in <EMCLASS="emphasis">resolv.conf</EM> that<EMCLASS="emphasis">res_init</EM> doesn't understand, it ignores them.<EMCLASS="emphasis">res_init</EM> always returns zero, even if the manpagereserves the right to return -1.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">extern int h_errno;int herror(const char *s)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15593"></A><ACLASS="indexterm"NAME="AUTOID-15595"></A><ACLASS="indexterm"NAME="AUTOID-15598"></A><EMCLASS="emphasis">herror</EM> isa routine like <EMCLASS="emphasis">perror</EM>, except that it printsout a string based on the value of the external variable <EMCLASS="emphasis">h_errno</EM> insteadof <EMCLASS="emphasis">errno</EM>. The only argument is:</P><DLCLASS="variablelist"><DTCLASS="term">s</DT><DDCLASS="listitem"><PCLASS="para">A string used to identify the error message. Ifa string <ICLASS="parameter">s</I> is supplied, it is printed first, followed by &quot;: &quot; andthen a string based on the value of <ICLASS="parameter">h_errno</I>.</P></DD></DL><PCLASS="para">Here are the possible values of <EMCLASS="emphasis">h_errno</EM>:</P><DLCLASS="variablelist"><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15616"></A><KBDCLASS="command">HOST_NOT_FOUND</KBD></DT><DDCLASS="listitem"><PCLASS="para">The domain name does not exist. The return codein the name server response was <CODECLASS="literal">NXDOMAIN</CODE>.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15624"></A><KBDCLASS="command">TRY_AGAIN</KBD></DT><DDCLASS="listitem"><PCLASS="para">Either the name server is not running, or the nameserver returned <CODECLASS="literal">SERVFAIL</CODE>.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15632"></A><KBDCLASS="command">NO_RECOVERY</KBD></DT><DDCLASS="listitem"><PCLASS="para">Either the domain name could not be compressed becauseit was an invalid domain name (e.g., a name missing a label&nbsp;- <ICLASS="systemitem.sitename">movie.edu</I>)or the name server returned <CODECLASS="literal">FORMERR</CODE>, <CODECLASS="literal">NOTIMP</CODE>, or <CODECLASS="literal">REFUSED</CODE>.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15643"></A><KBDCLASS="command">NO_DATA</KBD></DT><DDCLASS="listitem"><PCLASS="para">The domain name exists, but there are no data ofthe requested type.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15650"></A><KBDCLASS="command">NETDB_INTERNAL</KBD></DT><DDCLASS="listitem"><PCLASS="para">There was a library error unrelated to the networkor name service. Instead, see <ICLASS="parameter">errno</I> for the problem description.</P></DD></DL><ACLASS="indexterm"NAME="AUTOID-15656"></A></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-15657">14.2.5 The _res Structure</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="CH14.RESSTRUCTURE"></A>Each of the resolverroutines (i.e., each routine whose name starts with <EMCLASS="emphasis">res_</EM>)makes use of a common data structure called<EMCLASS="emphasis">_res</EM>. You canchange the behavior of the resolver routines by changing <EMCLASS="emphasis">_res</EM>.If you want to change the number of times <EMCLASS="emphasis">res_send</EM> retries aquery, you can change the value of the <EMCLASS="emphasis">retry</EM> field.If you want to turn off the resolver search algorithm, you turnoff the <SPANCLASS="acronym">RES</SPAN>_<SPANCLASS="acronym">DNSRCH</SPAN> bit from the <EMCLASS="emphasis">options</EM> mask.You'll find the all-important <EMCLASS="emphasis">_res</EM> structurein <EMCLASS="emphasis">resolv.h</EM>:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">struct __res_state {    int      retrans;   /* retransmission time interval */    int      retry;     /* number of times to retransmit */    u_long   options;   /* option flags - see below. */    int      nscount;   /* number of name servers */    struct sockaddr_in             nsaddr_list[MAXNS];   /* address of name server */#define nsaddr nsaddr_list[0]      /* for backward compatibility */    u_short id;                    /* current packet id */    char     *dnsrch[MAXDNSRCH+1]; /* components of domain to search */    char     defdname[MAXDNAME];   /* default domain */    u_long   pfcode;               /* RES_PRF_ flags - see below. */    unsigned ndots:4;              /* threshold for initial abs. query */    unsigned nsort:4;              /* number of elements in sort_list[] */    char     unused[3];    struct {           struct in_addr  addr;   /* address to sort on */           u_int32_t       mask;    } sort_list[MAXRESOLVSORT];};</PRE></BLOCKQUOTE><PCLASS="para">The <EMCLASS="emphasis">options</EM> field is a simplebit mask of the enabled options. To turn on a feature, turn on thecorresponding bit in the options field. Bit masks for each of theoptions are defined in <EMCLASS="emphasis">resolv.h</EM>; the optionsare:</P><DLCLASS="variablelist"><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15679"></A><ACLASS="indexterm"NAME="AUTOID-15681"></A><KBDCLASS="command">RES_INIT</KBD></DT><DDCLASS="listitem"><PCLASS="para">If this bit is on, then <ICLASS="function">res_init</I> has been called.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15689"></A><ACLASS="indexterm"NAME="AUTOID-15691"></A><ACLASS="indexterm"NAME="AUTOID-15693"></A><KBDCLASS="command">RES_DEBUG</KBD></DT><DDCLASS="listitem"><PCLASS="para">This bit causes resolver debugging messages to beprinted, if the resolver routines were compiled with <SPANCLASS="acronym">DEBUG</SPAN>, thatis. Off is the default.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15702"></A><KBDCLASS="command">RES_AAONLY</KBD></DT><DDCLASS="listitem"><PCLASS="para">Requires the answer to be authoritative, not froma name server's cache. It's too bad this isn't implemented; it wouldbe a useful feature. With the <SPANCLASS="acronym">BIND</SPAN> resolver's design, this featurewould have to be implemented in the name server, and it's not.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15710"></A><KBDCLASS="command">RES_PRIMARY</KBD></DT><DDCLASS="listitem"><PCLASS="para">Query the primary server only&nbsp;- again, it's not implemented.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15717"></A><KBDCLASS="command">RES_USEVC</KBD></DT><DDCLASS="listitem"><PCLASS="para">Turn this bit on if you'd like the resolver to makeits queries over a<ACLASS="indexterm"NAME="AUTOID-15722"></A><ACLASS="indexterm"NAME="AUTOID-15724"></A>virtual circuit (<SPANCLASS="acronym">TCP</SPAN>) connectioninstead of with <SPANCLASS="acronym">UDP</SPAN> packets. As you might guess, there is a performancepenalty for setting up and tearing down a <SPANCLASS="acronym">TCP</SPAN> connection. Off isthe default.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15732"></A><KBDCLASS="command">RES_STAYOPEN</KBD></DT><DDCLASS="listitem"><PCLASS="para">If you are making your queries over a <SPANCLASS="acronym">TCP</SPAN> connection,turning this bit on causes the connection to be left open. Otherwise,the connection is torn down after the query has been answered. Offis the default.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15740"></A><KBDCLASS="command">RES_IGNTC</KBD></DT><DDCLASS="listitem"><PCLASS="para">If the name server response has the truncation bitset, then the default resolver behavior is to retry the query using<SPANCLASS="acronym">TCP</SPAN>. If this bit is turned on, then the truncation bit in the response packetis ignored and the query is not retried using <SPANCLASS="acronym">TCP</SPAN>. Off is the default.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15749"></A><KBDCLASS="command">RES_RECURSE</KBD></DT><DDCLASS="listitem"><PCLASS="para">The default behavior for the <SPANCLASS="acronym">BIND</SPAN> resolver is tomake recursive queries. Turning this bit off turns off the &quot;recursiondesired&quot; bit in the query packet. On is the default.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15757"></A><KBDCLASS="command">RES_DEFNAMES</KBD></DT><DDCLASS="listitem"><PCLASS="para">The default behavior for the <SPANCLASS="acronym">BIND</SPAN> resolver is toappend the default domain to names that do not have a dot in them.Turning this bit off turns off appending the default domain. On isthe default.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15765"></A><KBDCLASS="command">RES_DNSRCH</KBD></DT><DDCLASS="listitem"><PCLASS="para">The default behavior for the <SPANCLASS="acronym">BIND</SPAN> resolver is toappend each entry in the search list to a name that does not endin a dot. Turning this bit off turns off the search list function.On is the default.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15773"></A><KBDCLASS="command">RES_INSECURE1</KBD></DT><DDCLASS="listitem"><PCLASS="para">The default behavior for a 4.9.3 or later <SPANCLASS="acronym">BIND</SPAN> resolveris to ignore answers from servers that were not queried. Turningthis bit on disables this security check. Off (i.e., security checkon) is the default.</P></DD><DTCLASS="term"><KBDCLASS="command">RES_INSECURE2</KBD></DT><DDCLASS="listitem"><PCLASS="para">The default behavior for a 4.9.3 or later <SPANCLASS="acronym">BIND</SPAN> resolveris to ignore answers where the question section of the responsedoes not match the question section of the original query. Turningthis bit on disables this security check. Off (i.e., security checkon) is the default.</P></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-15787"></A><KBDCLASS="command">RES_NOALIASES</KBD></DT><DDCLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15792"></A>Thedefault behavior for the <SPANCLASS="acronym">BIND</SPAN> resolver is to use aliases definedin the file specified by the user's <CODECLASS="literal">HOSTALIASES</CODE> environment variable.Turning this bit on disables the <CODECLASS="literal">HOSTALIASES</CODE> feature for 4.9.3 andlater <SPANCLASS="acronym">BIND</SPAN> resolvers. Previous resolvers did not allow this featureto be disabled. Off is the default.</P></DD></DL><ACLASS="indexterm"NAME="AUTOID-15798"></A></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-15799">14.2.6 The Name Server Library Routines</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="CH14.LIBRARY2"></A>The name server library contains routines you need to parse responsepackets.  Here are the header files you must include:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/nameser.h&gt;#include &lt;resolv.h&gt;</PRE></BLOCKQUOTE><PCLASS="para">Here are the name server library routines:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int ns_init_parse(const u_char *msg,                  int msglen,                  ns_msg *handle)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15808"></A><ICLASS="function">ns_init_parse</I> is the first routine you must callbefore you use the other name server library routines.  <ICLASS="function">ns_init_parse</I>fills in the data structure pointed to by <ICLASS="parameter">handle</I>, which is a parameterpassed to other routines.  The arguments are:</P><DLCLASS="variablelist"><DTCLASS="term">msg</DT><DDCLASS="listitem"><PCLASS="para">A pointer to the beginning of the response buffer</P></DD><DTCLASS="term">msglen</DT><DDCLASS="listitem"><PCLASS="para">The size of the response buffer</P></DD><DTCLASS="term">handle</DT><DDCLASS="listitem"><PCLASS="para">A pointer to a data structure filled in by <ICLASS="function">ns_init_parse</I></P></DD></DL><PCLASS="para"><ICLASS="function">ns_init_parse</I> returns zero on success and -1 when it failsto parse the response buffer.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">const u_char *ns_msg_base(ns_msg handle)const u_char *ns_msg_end(ns_msg handle)int ns_msg_size(ns_msg handle)</PRE></BLOCKQUOTE><PCLASS="para">These routines return a pointer to the start of theresponse, a pointer to the end of the response, and the size ofthe response.  They are returning data you passed into <ICLASS="function">ns_init_parse</I>. The only argument is:</P><DLCLASS="variablelist"><DTCLASS="term">handle</DT><DDCLASS="listitem"><PCLASS="para">A data structure filled in by <ICLASS="function">ns_init_parse</I></P></DD></DL><BLOCKQUOTECLASS="screen"><PRECLASS="screen">u_int16_t ns_msg_id(ns_msg handle)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15840"></A><ICLASS="function">ns_msg_id</I> returns the identification from the header section(described earlier) of the response packet.  The only argument is:</P><DLCLASS="variablelist"><DTCLASS="term">handle</DT><DDCLASS="listitem"><PCLASS="para">A data structure filled in by <ICLASS="function">ns_init_parse</I>.</P></DD></DL><BLOCKQUOTECLASS="screen"><PRECLASS="screen">u_int16_t ns_msg_get_flag(ns_msg handle, ns_flag flag)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15851"></A><ICLASS="function">ns_msg_get_flag</I> returns the &quot;flag&quot; fields from theheader section of the response packet.  Its arguments are:</P><DLCLASS="variablelist"><DTCLASS="term">handle</DT><DDCLASS="listitem"><PCLASS="para">A data structure filled in by <ICLASS="function">ns_init_parse</I>.</P></DD><DTCLASS="term">flag</DT><DDCLASS="listitem"><PCLASS="para">An enumerated type that can have the followingvalues:</P></DD></DL><BLOCKQUOTECLASS="screen"><PRECLASS="screen">ns_f_qr     /* Question/Response */ns_f_opcode /* Operation Code */ns_f_aa     /* Authoritative Answer */ns_f_tc     /* Truncation Occurred */ns_f_rd     /* Recursion Desired */ns_f_ra     /* recursion Available */ns_f_rcode  /* Response Code */</PRE></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen">u_int16_t ns_msg_count(ns_msg handle, ns_sect section)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15867"></A><ICLASS="function">ns_msg_count</I> returns a counter from theheader section of the response packet.  Its arguments are:</P><DLCLASS="variablelist"><DTCLASS="term">handle</DT><DDCLASS="listitem"><PCLASS="para">A data structure filled in by <ICLASS="function">ns_init_parse</I>.</P></DD><DTCLASS="term">section</DT><DDCLASS="listitem"><PCLASS="para">An enumerated type that can have the following values:</P></DD></DL><BLOCKQUOTECLASS="screen"><PRECLASS="screen">ns_s_qd  /* Question section */ns_s_an  /* Answer section */ns_s_ns  /* Name Server section */ns_s_ar  /* Additional records sectiona */int ns_parserr(ns_msg *handle,               ns_sect section,               int rrnum,               ns_rr *rr)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15882"></A><ACLASS="indexterm"NAME="AUTOID-15884"></A><ICLASS="function">ns_parserr</I> extracts information about a responserecord and stores it in <ICLASS="parameter">rr</I>. <ICLASS="parameter">rr</I> is a parameter passed to other nameserver libarary routines.  The arguments are:</P><DLCLASS="variablelist"><DTCLASS="term">handle</DT><DDCLASS="listitem"><PCLASS="para">A pointer to a data structure filled in by <ICLASS="function">ns_init_parse</I>.</P></DD><DTCLASS="term">section</DT><DDCLASS="listitem"><PCLASS="para">The same parameter described in <ICLASS="function">ns_msg_count</I>.</P></DD><DTCLASS="term">rrnum</DT><DDCLASS="listitem"><PCLASS="para">A resource record number for the resourcerecords in this section.  Resource records start numbering at 0.<ICLASS="function">ns_msg_count</I> tells you how many resource records are in this section.</P></DD><DTCLASS="term">rr</DT><DDCLASS="listitem"><PCLASS="para">A pointer to a data structure to be initialized.</P></DD></DL><PCLASS="para"><ICLASS="function">ns_parserr</I> returns zero on success and -1 when it fails toparse the response buffer.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">char *ns_rr_name(ns_rr rr)u_int16_t ns_rr_type(ns_rr rr)u_int16_t ns_rr_class(ns_rr rr)u_int32_t ns_rr_ttl(ns_rr rr)u_int16_t ns_rr_rdlen(ns_rr rr)const u_char *ns_rr_rdata(ns_rr rr)</PRE></BLOCKQUOTE><PCLASS="para">These routines return individual fields from a response record. Their only argument is:</P><DLCLASS="variablelist"><DTCLASS="term">rr</DT><DDCLASS="listitem"><PCLASS="para">A data structure filled in by <ICLASS="function">ns_parserr</I>.</P></DD></DL><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int ns_name_compress(const char *exp_dn,                     u_char *comp_dn,                     size_t length,                     const u_char **dnptrs,                     const u_char **lastdnptr)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15922"></A><ACLASS="indexterm"NAME="AUTOID-15924"></A><ACLASS="indexterm"NAME="AUTOID-15927"></A><ICLASS="function">ns_name_compress</I>compresses a domain name. You won't normally call this routine yourself&nbsp;- you'lllet <EMCLASS="emphasis">res_mkquery</EM> do it for you. However, ifyou need to compress a name for some reason, this is the tool todo it. The arguments are:</P><DLCLASS="variablelist"><DTCLASS="term">exp_dn</DT><DDCLASS="listitem"><PCLASS="para">The &quot;expanded&quot; domain name that you supply; i.e.,a normal null-terminated string containing a fully qualified domainname.</P></DD><DTCLASS="term">comp_dn</DT><DDCLASS="listitem"><PCLASS="para">The place where <ICLASS="function">ns_name_compress</I> will store thecompressed domain name.</P></DD><DTCLASS="term">length</DT><DDCLASS="listitem"><PCLASS="para">The size of the <ICLASS="parameter">comp_dn</I> buffer.</P></DD><DTCLASS="term">dnptrs</DT><DDCLASS="listitem"><PCLASS="para">An array of pointers to previously compressed domainnames. <ICLASS="parameter">dnptrs[0]</I> points to the beginning of the message; the listends with a <SPANCLASS="acronym">NULL</SPAN> pointer. After you've initialized <ICLASS="parameter">dnptrs[0]</I> to thebeginning of the message and <ICLASS="parameter">dnptrs[1]</I> to <SPANCLASS="acronym">NULL</SPAN>, <ICLASS="function">dn_comp</I> updatesthe list each time you call it.</P></DD><DTCLASS="term">lastdnptr</DT><DDCLASS="listitem"><PCLASS="para">A pointer to the end of the <ICLASS="parameter">dnptrs</I> array. <ICLASS="function">ns_name_compress</I>needs to know where the end of the array is, so it doesn't overrunit.</P></DD></DL><PCLASS="para">If youwant to use this routine, look at how it is used in <EMCLASS="emphasis">res/res_mkquery.c</EM> fromthe <SPANCLASS="acronym">BIND</SPAN> source. It's often easier to see how to use a routine from anexample than from an explanation. <EMCLASS="emphasis">ns_name_compress</EM> returnsthe size of the compressed name, or -1 if there was an error.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int ns_name_uncompress(const u_char *msg,                       const u_char *eomorig,                       const u_char *comp_dn,                       char *exp_dn,                       size_t length)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15968"></A><ACLASS="indexterm"NAME="AUTOID-15970"></A><ACLASS="indexterm"NAME="AUTOID-15973"></A><ACLASS="indexterm"NAME="AUTOID-15975"></A><EMCLASS="emphasis">ns_name_uncompress</EM> expands a &quot;compressed&quot; domainname. You will use this routine if you parse a name server response,as we do in the example that follows. The arguments are:</P><DLCLASS="variablelist"><DTCLASS="term">msg</DT><DDCLASS="listitem"><PCLASS="para">A pointer to the beginning of your response packet(message).</P></DD><DTCLASS="term">eomorig</DT><DDCLASS="listitem"><PCLASS="para">A pointer to the first byte after the message. Itis used to make sure that <ICLASS="function">ns_name_uncompress</I> doesn't go past theend of the message.</P></DD><DTCLASS="term">comp_dn</DT><DDCLASS="listitem"><PCLASS="para">A pointer to the compressed domain name within themessage.</P></DD><DTCLASS="term">exp_dn</DT><DDCLASS="listitem"><PCLASS="para">The place where <ICLASS="function">ns_name_uncompress</I> will store theexpanded name. You should always allocate an array of <SPANCLASS="acronym">MAXDNAME</SPAN> charactersfor the expanded name.</P></DD><DTCLASS="term">length</DT><DDCLASS="listitem"><PCLASS="para">The size of the <ICLASS="parameter">exp_dn</I> buffer.</P></DD></DL><PCLASS="para"><EMCLASS="emphasis">ns_name_uncompress</EM> returns the size ofthe compressed name, or -1 if there was an error. You might wonderwhy <EMCLASS="emphasis">ns_name_uncompress</EM> returns the size ofthe <EMCLASS="emphasis">compressed</EM> name, not the size of the <EMCLASS="emphasis">expanded</EM> name.It does this because when you call <EMCLASS="emphasis">ns_name_uncompress</EM>,you are parsing a <SPANCLASS="acronym">DNS</SPAN> packet and need to know how much space thecompressed name took in the packet so that you can skip over it.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int ns_name_skip(const u_char **ptrptr, const u_char *eom)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16012"></A><ICLASS="function">ns_name_skip</I> is like <ICLASS="function">ns_name_uncompress</I>,  but insteadof uncompressing the name, it just skips over it. The arguments are: </P><DLCLASS="variablelist"><DTCLASS="term">ptrptr</DT><DDCLASS="listitem"><PCLASS="para">A pointer to a pointer to the name to skip over. The original pointer is advanced past the name.</P></DD><DTCLASS="term">eom</DT><DDCLASS="listitem"><PCLASS="para">A pointer to the first byte after the message. Itis used to make sure that <ICLASS="function">ns_name_skip</I> doesn't go past the end ofthe message.</P></DD></DL><PCLASS="para"><ICLASS="function">ns_name_skip</I>returns zero if successful.  It returns -1 when it fails to uncompressthe name.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">u_int ns_get16(const u_char *cp)void  ns_put16(u_int s, u_char *cp)</PRE></BLOCKQUOTE><PCLASS="para">The <SPANCLASS="acronym">DNS</SPAN> packets have fields that are unsigned short integer(type, class, and data length, to name a few). <EMCLASS="emphasis">ns_get16</EM> returnsa 16-bit integer pointed to by <EMCLASS="emphasis">cp</EM>. <EMCLASS="emphasis">ns_put16</EM> assigns the 16-bit value of <EMCLASS="emphasis">s</EM> tothe location pointed to by <EMCLASS="emphasis">cp</EM>.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">u_long ns_get32(const u_char *cp)void   ns_put32(u_long l, u_char *cp)</PRE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16038"></A><ACLASS="indexterm"NAME="AUTOID-16040"></A>These routines are like their 16-bit counterparts, except thatthey deal with a 32-bit integer instead of a 16-bit integer. The<SPANCLASS="acronym">TTL</SPAN> field (time to live) of a resource record is a 32-bit integer. </P><ACLASS="indexterm"NAME="AUTOID-16043"></A></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-16044">14.2.7 Parsing <SPANCLASS="acronym">DNS</SPAN> Responses</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16048"></A><ACLASS="indexterm"NAME="AUTOID-16051"></A>Theeasiest way to learn how to parse a <SPANCLASS="acronym">DNS</SPAN> packet is to look at codethat already does it. Assuming that you have the <SPANCLASS="acronym">DNS</SPAN> source code,the best file to look through is <EMCLASS="emphasis">res/res_debug.c</EM> (<SPANCLASS="acronym">BIND</SPAN>4) or <EMCLASS="emphasis">src/lib/resolv/res_debug.c</EM> (<SPANCLASS="acronym">BIND</SPAN> 8).This file has <EMCLASS="emphasis">fp_query</EM>, the routine that printsout the <SPANCLASS="acronym">DNS</SPAN> packets in the name server debugging output.   Our sampleprogram traces its parentage to code from this file.</P><PCLASS="para">Youwon't always want to parse the <SPANCLASS="acronym">DNS</SPAN> response manually. An &quot;intermediate&quot;way to parse the response is to call <EMCLASS="emphasis">p_query</EM>,which calls <EMCLASS="emphasis">fp_query</EM>, to print out the <SPANCLASS="acronym">DNS</SPAN>packet. Then use basic <SPANCLASS="acronym">UNIX</SPAN> tools, like <EMCLASS="emphasis">Perl</EM> or <EMCLASS="emphasis">awk</EM>,to grab what you need. Cricket has been known to wimp out this way.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-16069">14.2.8 A Sample Program: check_soa</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="CH14.EXAMPLE1"></A><ACLASS="indexterm"NAME="CH14.EXAMPLE2"></A>Here is a C program to solve the sameproblem that we wrote a shell script for earlier:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/**************************************************************** * check_soa -- Retrieve the SOA record from each name server   * *     for a given domain and print out the serial number.      * *                                                              * * usage: check_soa domain                                      * *                                                              * * The following errors are reported:                           * *     o There is no address for a server.                      * *     o There is no server running on this host.               * *     o There was no response from a server.                   * *     o The server is not authoritative for the domain.        * *     o The response had an error response code.               * *     o The response had more than one answer.                 * *     o The response answer did not contain an SOA record.     * *     o The expansion of a compressed domain name failed.      * ****************************************************************//* Various header files */#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;arpa/nameser.h&gt;#include &lt;resolv.h&gt;/* Error variables */extern int h_errno;  /* for resolver errors */extern int errno;    /* general system errors *//* Our own routines; code included later in this chapter */void nsError();            /* report resolver errors */void findNameServers();    /* find a domain's name servers */void addNameServers();     /* add name servers to our list */void queryNameServers();   /* grab SOA records from servers */void returnCodeError();    /* report response packet errors *//* Maximum number of name servers we will check */#define <SPANCLASS="acronym">MAX</SPAN>_<SPANCLASS="acronym">NS</SPAN> 20</PRE></BLOCKQUOTE><PCLASS="para">Here are the header files that are needed, the declarationsfor external variables, and the declarations of functions. Noticethat we use both <EMCLASS="emphasis">h_errno</EM> (for the resolver routines)and <EMCLASS="emphasis">errno</EM>. We've set a limit of 20 name serversthat this program will check. You will rarely see a zone with morethan ten name servers, so an upper limit of 20 should suffice:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">main(argc, argv)int argc;char *argv[];{    char *nsList[<SPANCLASS="acronym">MAX</SPAN>_<SPANCLASS="acronym">NS</SPAN>];  /* list of name servers */    int  nsNum = 0;        /* number of name servers in list */    /* sanity check: one (and only one) argument? */    if(argc != 2){        (void) fprintf(stderr, &quot;usage: %s domain\n&quot;, argv[0]);        exit(1);    }    (void) res_init();    /*     * Find the name servers for the domain.     * The name servers are written into nsList.     */    findNameServers(argv[1], nsList, &amp;nsNum);    /*     * Query each name server for the domain's <SPANCLASS="acronym">SOA</SPAN> record.     * The name servers are read from nsList.     */    queryNameServers(argv[1], nsList, nsNum);    exit(0);}</PRE></BLOCKQUOTE><PCLASS="para">The main body of the program is small. We have anarray of string pointers, <EMCLASS="emphasis">nsList</EM>, to store thenames of the name servers for the zone. We call the resolver function <EMCLASS="emphasis">res_init</EM> toinitialize the <EMCLASS="emphasis">_res</EM> structure. It wasn't necessaryfor this program to call <EMCLASS="emphasis">res_init</EM> explicitly,since it would have been called by the first resolver routine thatused the <EMCLASS="emphasis">_res</EM> structure. However, if we had wantedto modify the value of any of the <EMCLASS="emphasis">_res</EM> fieldsbefore calling the first resolver routine, we would have made themodifications right after calling <EMCLASS="emphasis">res_init</EM>.Next, the program calls <EMCLASS="emphasis">findNameServers</EM> tofind all the name servers for the zone referenced in <EMCLASS="emphasis">argv[1]</EM> andto store them in <EMCLASS="emphasis">nsList</EM>. Last, the programcalls <EMCLASS="emphasis">queryNameServers</EM> to query each of thename servers in <EMCLASS="emphasis">nsList</EM> for the <SPANCLASS="acronym">SOA</SPAN> record forthe zone.</P><PCLASS="para">The routine <EMCLASS="emphasis">findNameServers</EM> follows.This routine queries the local name server for the <SPANCLASS="acronym">NS</SPAN> records forthe zone. It then calls <EMCLASS="emphasis">addNameServers</EM> to parsethe response packet and store away all the name servers it finds.The header files, <EMCLASS="emphasis">arpa/nameser.h</EM> and <EMCLASS="emphasis">resolv.h</EM>,contain declarations we make extensive use of:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">&#13;/**************************************************************** * findNameServers -- find all of the name servers for the      * *     given domain and store their names in nsList.  nsNum is  * *     the number of servers in the nsList array.               * ****************************************************************/voidfindNameServers(domain, nsList, nsNum)char *domain;char *nsList[];int  *nsNum;{    union {        <SPANCLASS="acronym">HEADER</SPAN> hdr;              /* defined in resolv.h */        u_char buf[<SPANCLASS="acronym">NS</SPAN>_<SPANCLASS="acronym">PACKETSZ</SPAN>]; /* defined in arpa/nameser.h */    } response;                  /* response buffers */    int responseLen;             /* buffer length */    ns_msg handle;  /* handle for response packet */    /*     * Look up the <SPANCLASS="acronym">NS</SPAN> records for the given domain name.     * We expect the domain to be a fully qualified name, so     * we use res_query().  If we wanted the resolver search     * algorithm, we would have used res_search() instead.     */    if((responseLen =           res_query(domain,      /* the domain we care about   */                     ns_c_in,     /* Internet class records     */                     ns_t_ns,     /* Look up name server records*/                     (u_char *)&amp;response,      /*response buffer*/                     sizeof(response)))        /*buffer size    */                                        &lt; 0){  /*If negative    */        nsError(h_errno, domain); /* report the error           */        exit(1);                  /* and quit                   */    }    /*     * Initialize a handle to this response.  The handle will     * be used later to extract information from the response.     */    if (ns_initparse(response.buf, responseLen, &amp;handle) &lt; 0) {        fprintf(stderr, &quot;ns_initparse: %s\n&quot;, strerror(errno));        return;    }    /*     * Create a list of name servers from the response.     * <SPANCLASS="acronym">NS</SPAN> records may be in the answer section and/or in the     * authority section depending on the <SPANCLASS="acronym">DNS</SPAN> implementation.     * Walk through both.  The name server addresses may be in     * the additional records section, but we will ignore them     * since it is much easier to call gethostbyname() later     * than to parse and store the addresses here.     */    /*     * Add the name servers from the answer section.     */    addNameServers(nsList, nsNum, handle, ns_s_an);    /*     * Add the name servers from the authority section.     */    addNameServers(nsList, nsNum, handle, ns_s_ns);}/**************************************************************** * addNameServers -- Look at the resource records from a        * *     section.  Save the names of all name servers.            * ****************************************************************/voidaddNameServers(nsList, nsNum, handle, section)char *nsList[];int  *nsNum;ns_msg handle;ns_sect section;{    int rrnum;  /* resource record number */    ns_rr rr;   /* expanded resource record */    int i, dup; /* misc variables */    /*     * Look at all the resource records in this section.     */    for(rrnum = 0; rrnum &lt; ns_msg_count(handle, section); rrnum++)    {        /*         * Expand the resource record number rrnum into rr.         */        if (ns_parserr(&amp;handle, section, rrnum, &amp;rr)) {            fprintf(stderr, &quot;ns_parserr: %s\n&quot;, strerror(errno));        }        /*         * If the record type is <SPANCLASS="acronym">NS</SPAN>, save the name of the         * name server.         */        if (ns_rr_type(rr) == ns_t_ns) {            /*             * Allocate storage for the name.  Like any good             * programmer should, we test malloc's return value,             * and quit if it fails.             */            nsList[*nsNum] = (char *) malloc (<SPANCLASS="acronym">MAXDNAME</SPAN>);            if(nsList[*nsNum] == <SPANCLASS="acronym">NULL</SPAN>){                (void) fprintf(stderr, &quot;malloc failed\n&quot;);                exit(1);            }            /* Expand the name server's name */            if (ns_name_uncompress(                        ns_msg_base(handle),/* Start of the packet   */                        ns_msg_end(handle), /* End of the packet     */                        ns_rr_rdata(rr),    /* Position in the packet*/                        nsList[*nsNum],     /* Result                */                        <SPANCLASS="acronym">MAXDNAME</SPAN>)           /* Size of nsList buffer */                                  &lt; 0) {    /* Negative: error       */                (void) fprintf(stderr, &quot;ns_name_uncompress failed\n&quot;);                exit(1);            }            /*             * Check the name we've just unpacked and add it to             * the list of servers if it is not a duplicate.             * If it is a duplicate, just ignore it.             */            for(i = 0, dup=0; (i &lt; *nsNum) &amp;&amp; !dup; i++)                dup = !strcasecmp(nsList[i], nsList[*nsNum]);            if(dup)                free(nsList[*nsNum]);            else                (*nsNum)++;        }    }}</PRE></BLOCKQUOTE><PCLASS="para">Notice that we don't explicitly check for findingzero name server records. We don't need to check because<ACLASS="indexterm"NAME="AUTOID-16119"></A><ICLASS="function">res_query</I> flags that case as an error;it returns -1 and sets <ICLASS="parameter">herrno</I> to <KBDCLASS="command">NO_DATA</KBD>. If<ICLASS="function">res_query</I> returns -1, we call our own routine, <ICLASS="function">nsError</I>, to printout an error string from <ICLASS="parameter">h_errno</I> instead of using <ICLASS="parameter">herror</I>. The <ICLASS="parameter">herror</I>routine isn't a good fit for our program because its messages assumeyou are looking up address data (e.g., if <ICLASS="parameter">h_errno</I> is <KBDCLASS="command">NO_DATA</KBD>, theerror message is &quot;No address associated with name&quot;).</P><PCLASS="para">Thenext routine queries each name server that we've found for an <SPANCLASS="acronym">SOA</SPAN>record. In this routine, we change the value of several of the <EMCLASS="emphasis">_res</EM> structurefields. By changing the <EMCLASS="emphasis">nsaddr_list</EM> field,we change which server <EMCLASS="emphasis">res_send</EM> queries. Wedisable the search list by turning off bits in the <EMCLASS="emphasis">options</EM> field&nbsp;- allthe names that this program handles are fully qualified:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">&#13;/**************************************************************** * queryNameServers -- Query each of the name servers in nsList * *     for the <SPANCLASS="acronym">SOA</SPAN> record of the given domain.  Report any      * *     errors encountered.  (e.g., a name server not running or * *     the response not being an authoritative response.)  If   * *     there are no errors, print out the serial number for the * *     domain.                                                  * ****************************************************************/voidqueryNameServers(domain, nsList, nsNum)char *domain;char *nsList[];int nsNum;{    union {        <SPANCLASS="acronym">HEADER</SPAN> hdr;               /* defined in resolv.h */        u_char buf[<SPANCLASS="acronym">NS</SPAN>_<SPANCLASS="acronym">PACKETSZ</SPAN>];  /* defined in arpa/nameser.h */    } query, response;            /* query and response buffers */    int responseLen, queryLen;    /* buffer lengths */    u_char     *cp;       /* character pointer to parse <SPANCLASS="acronym">DNS</SPAN> packet */    struct in_addr saveNsAddr[<SPANCLASS="acronym">MAXNS</SPAN>];  /* addrs saved from _res */    int nsCount;          /* count of addresses saved from _res */    struct hostent *host; /* structure for looking up ns addr */    int i;                /* counter variable */    ns_msg handle;  /* handle for response packet */    ns_rr rr;       /* expanded resource record */    /*     * Save the _res name server list since     * we will need to restore it later.     */    nsCount = _res.nscount;    for(i = 0; i &lt; nsCount; i++)      saveNsAddr[i] = _res.nsaddr_list[i].sin_addr;    /*     * Turn off the search algorithm and turn off appending     * the default domain before we call gethostbyname(); the     * name server names will be fully qualified.     */    _res.options &amp;= ~(<SPANCLASS="acronym">RES</SPAN>_<SPANCLASS="acronym">DNSRCH</SPAN> | <SPANCLASS="acronym">RES</SPAN>_<SPANCLASS="acronym">DEFNAMES</SPAN>);    /*     * Query each name server for an <SPANCLASS="acronym">SOA</SPAN> record.     */    for(nsNum-- ; nsNum &gt;= 0; nsNum--){        /*         * First, we have to get the <SPANCLASS="acronym">IP</SPAN> address of every server.         * So far, all we have are names.  We use gethostbyname         * to get the addresses, rather than anything fancy.         * But first, we have to restore certain values in _res         * because _res affects gethostbyname().  (We altered         * _res in the previous iteration through the loop.)         *         * We can't just call res_init() again to restore         * these values since some of the _res fields are         * initialized when the variable is declared, not when         * res_init() is called.         */        _res.options |= <SPANCLASS="acronym">RES</SPAN>_<SPANCLASS="acronym">RECURSE</SPAN>;  /* recursion on (default) */        _res.retry = 4;               /* 4 retries (default)    */        _res.nscount = nsCount;       /* original name servers  */        for(i = 0; i &lt; nsCount; i++)            _res.nsaddr_list[i].sin_addr = saveNsAddr[i];        /* Look up the name server's address */        host = gethostbyname(nsList[nsNum]);        if (host == <SPANCLASS="acronym">NULL</SPAN>) {            (void) fprintf(stderr,&quot;There is no address for %s\n&quot;,                                              nsList[nsNum]);            continue; /* nsNum for-loop */        }        /*         * Now get ready for the real fun.  host contains <SPANCLASS="acronym">IP</SPAN>         * addresses for the name server we're testing.         * Store the first address for host in the _res         * structure.  Soon, we'll look up the <SPANCLASS="acronym">SOA</SPAN> record...         */        (void) memcpy((void *)&amp;_res.nsaddr_list[0].sin_addr,           (void *)host-&gt;h_addr_list[0], (size_t)host-&gt;h_length);        _res.nscount = 1;        /*         * Turn off recursion.  We don't want the name server         * querying another server for the <SPANCLASS="acronym">SOA</SPAN> record; this name         * server ought to be authoritative for this data.         */        _res.options &amp;= ~<SPANCLASS="acronym">RES</SPAN>_<SPANCLASS="acronym">RECURSE</SPAN>;        /*         * Reduce the number of retries.  We may be checking         * several name servers, so we don't want to wait too         * long for any one server.  With two retries and only         * one address to query, we'll wait at most 15 seconds.         */        _res.retry = 2;        /*         * We want to see the response code in the next         * response, so we must make the query packet and         * send it ourselves instead of having res_query()         * do it for us.  If res_query() returned -1, there         * might not be a response to look at.         *         * There is no need to check for res_mkquery()         * returning -1.  If the compression was going to         * fail, it would have failed when we called         * res_query() earlier with this domain name.         */        queryLen = res_mkquery(                     ns_o_query,      /* regular query         */                     domain,          /* the domain to look up */                     ns_c_in,         /* Internet type         */                     ns_t_soa,        /* Look up an <SPANCLASS="acronym">SOA</SPAN> record */                     (u_char *)<SPANCLASS="acronym">NULL</SPAN>,  /* always <SPANCLASS="acronym">NULL</SPAN>       */                     0,               /* length of <SPANCLASS="acronym">NULL</SPAN>        */                     (u_char *)<SPANCLASS="acronym">NULL</SPAN>,  /* always <SPANCLASS="acronym">NULL</SPAN>       */                     (u_char *)&amp;query,/* buffer for the query  */                     sizeof(query));  /* size of the buffer    */        /*         * Send the query packet.  If there is no name server         * running on the target host, res_send() returns -1         * and errno is <SPANCLASS="acronym">ECONNREFUSED</SPAN>.  First, clear out errno.         */        errno = 0;        if((responseLen = res_send((u_char *)&amp;query,/* the query  */                                   queryLen,        /* true length*/                                   (u_char *)&amp;response,/*buffer  */                                   sizeof(response)))  /*buf size*/                                        &lt; 0){          /* error  */            if(errno == <SPANCLASS="acronym">ECONNREFUSED</SPAN>) { /* no server on the host */                (void) fprintf(stderr,                    &quot;There is no name server running on %s\n&quot;,                    nsList[nsNum]);            } else {                   /* anything else: no response */                (void) fprintf(stderr,                    &quot;There was no response from %s\n&quot;,                    nsList[nsNum]);            }            continue; /* nsNum for-loop */        }        /*         * Initialize a handle to this response.  The handle will         * be used later to extract information from the response.         */        if (ns_initparse(response.buf, responseLen, &amp;handle) &lt; 0) {            fprintf(stderr, &quot;ns_initparse: %s\n&quot;, strerror(errno));            return;        }        /*         * If the response reports an error, issue a message         * and proceed to the next server in the list.         */        if(ns_msg_getflag(handle, ns_f_rcode) != ns_r_noerror){            returnCodeError(ns_msg_getflag(handle, ns_f_rcode),                                                  nsList[nsNum]);            continue; /* nsNum for-loop */        }        /*         * Did we receive an authoritative response?  Check the         * authoritative answer bit.  If the server isn't         * authoritative, report it, and go on to the next server.         */        if(!ns_msg_getflag(handle, ns_f_aa)){            (void) fprintf(stderr,                &quot;%s is not authoritative for %s\n&quot;,                nsList[nsNum], domain);            continue; /* nsNum for-loop */        }        /*         * The response should only contain one answer; if more,         * report the error, and proceed to the next server.         */        if(ns_msg_count(handle, ns_s_an) != 1){            (void) fprintf(stderr,                &quot;%s: expected 1 answer, got %d\n&quot;,                nsList[nsNum], ns_msg_count(handle, ns_s_an));            continue; /* nsNum for-loop */        }        /*         * Expand the answer section record number 0 into rr.         */        if (ns_parserr(&amp;handle, ns_s_an, 0, &amp;rr)) {                if (errno != <SPANCLASS="acronym">ENODEV</SPAN>){                        fprintf(stderr, &quot;ns_parserr: %s\n&quot;,                                strerror(errno));                }        }        /*         * We asked for an <SPANCLASS="acronym">SOA</SPAN> record; if we got something else,         * report the error and proceed to the next server.         */        if (ns_rr_type(rr) != ns_t_soa) {            (void) fprintf(stderr,                &quot;%s: expected answer type %d, got %d\n&quot;,                nsList[nsNum], ns_t_soa, ns_rr_type(rr));            continue; /* nsNum for-loop */        }        /*         * Set cp to point the the <SPANCLASS="acronym">SOA</SPAN> record.         */        cp = (u_char *)ns_rr_rdata(rr);        /*         * Skip the <SPANCLASS="acronym">SOA</SPAN> origin and mail address, which we don't         * care about.  Both are standard &quot;compressed names.&quot;         */        ns_name_skip(&amp;cp, ns_msg_end(handle));        ns_name_skip(&amp;cp, ns_msg_end(handle));        /* cp now points to the serial number; print it. */        (void) printf(&quot;%s has serial number %d\n&quot;,            nsList[nsNum], ns_get32(cp));    } /* end of nsNum for-loop */}</PRE></BLOCKQUOTE><PCLASS="para">Notice that we use recursive queries when we call <EMCLASS="emphasis">gethostbyname</EM>,but use nonrecursive queries when we look up the <SPANCLASS="acronym">SOA</SPAN> record. <EMCLASS="emphasis">gethostbyname</EM> mayneed to query other servers to find the host's address. But we don'twant the name server querying another server when we ask it forthe <SPANCLASS="acronym">SOA</SPAN> record&nbsp;- it's <EMCLASS="emphasis">supposed</EM> to be authoritativefor this zone, after all. Allowing the name server to ask anotherserver for the <SPANCLASS="acronym">SOA</SPAN> record would defeat the error check.</P><PCLASS="para">Thenext two routines print out error messages: </P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/**************************************************************** * nsError -- Print an error message from h_errno for a failure * *     looking up NS records.  res_query() converts the DNS     * *     packet return code to a smaller list of errors and       * *     places the error value in h_errno.  There is a routine   * *     called herror() for printing out strings from h_errno    * *     like perror() does for errno.  Unfortunately, the        * *     herror() messages assume you are looking up address      * *     records for hosts.  In this program, we are looking up   * *     NS records for domains, so we need our own list of error * *     strings.                                                 * ****************************************************************/voidnsError(error, domain)int error;char *domain;{    switch(error){        case HOST_NOT_FOUND:          (void) fprintf(stderr, &quot;Unknown domain: %s\n&quot;, domain);          break;        case NO_DATA:          (void) fprintf(stderr, &quot;No NS records for %s\n&quot;, domain);          break;        case TRY_AGAIN:          (void) fprintf(stderr, &quot;No response for NS query\n&quot;);          break;        default:          (void) fprintf(stderr, &quot;Unexpected error\n&quot;);          break;    }}/**************************************************************** * returnCodeError -- print out an error message from a DNS     * *     response return code.                                    * ****************************************************************/voidreturnCodeError(rcode, nameserver)ns_rcode rcode;char *nameserver;{    (void) fprintf(stderr, &quot;%s: &quot;, nameserver);    switch(rcode){        case ns_r_formerr:          (void) fprintf(stderr, &quot;FORMERR response\n&quot;);          break;        case ns_r_servfail:          (void) fprintf(stderr, &quot;SERVFAIL response\n&quot;);          break;        case ns_r_nxdomain:          (void) fprintf(stderr, &quot;NXDOMAIN response\n&quot;);          break;        case ns_r_notimpl:          (void) fprintf(stderr, &quot;NOTIMP response\n&quot;);          break;        case ns_r_refused:          (void) fprintf(stderr, &quot;REFUSED response\n&quot;);          break;        default:          (void) fprintf(stderr, &quot;unexpected return code\n&quot;);          break;    }}</PRE></BLOCKQUOTE><PCLASS="para">To compile this program using the resolver and nameserver routines in <EMCLASS="emphasis">libc</EM>:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cc -o check_soa check_soa.c</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">Or, if you've newly ported the BIND code as we describein <ACLASS="xref"HREF="appb_01.htm"TITLE="Compiling and Installing BIND on a Sun">Appendix B, <CITECLASS="appendix">Compiling and Installing <SPANCLASS="acronym">BIND</SPAN> on aSun</CITE></A>, and want touse the latest header files and resolver library:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cc -o check_soa \    -I/tmp/src/include \    -I/tmp/src/include/port/solaris/include \    check_soa.c \    /tmp/src/lib/libbind.a</B></CODE></PRE></BLOCKQUOTE><PCLASS="para">Here is what the output looks like:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>check_soa mit.edu</B></CODE>BITSY.MIT.EDU has serial number 378W20NS.MIT.EDU has serial number 378STRAWB.MIT.EDU has serial number 378</PRE></BLOCKQUOTE><PCLASS="para">If you look back at the shell script output, it looksthe same, except that the shell script's output is sorted by thename server's name. What you can't see is that the C program ranmuch faster.</P><ACLASS="indexterm"NAME="AUTOID-16191"></A><ACLASS="indexterm"NAME="AUTOID-16192"></A></DIV><ACLASS="indexterm"NAME="AUTOID-16193"></A><ACLASS="indexterm"NAME="AUTOID-16194"></A></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch14_01.htm"TITLE="14.1 Shell Script Programming with nslookup"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 14.1 Shell Script Programming with nslookup"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="DNS &amp; BIND"><IMGSRC="../gifs/txthome.gif"ALT="DNS &amp; BIND"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch14_03.htm"TITLE="14.3 Perl Programming with Net::DNS"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 14.3 Perl Programming with Net::DNS"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">14.1 Shell Script Programming with nslookup</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">14.3 Perl Programming with Net::DNS</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>