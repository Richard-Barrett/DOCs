<HTML><HEAD><TITLE>[Chapter 14] 14.3 Perl Programming with Net::DNS</TITLE><METANAME="DC.title"CONTENT="DNS &amp; BIND"><METANAME="DC.creator"CONTENT="Cricket Liu &amp; Paul Albitz"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-01-06T18:42:30Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-512-2"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch14_01.htm"TITLE="14. Programming with the Resolver and Name Server Library Routines"><LINKREL="prev"HREF="ch14_02.htm"TITLE="14.2 C Programming with the Resolver Library Routines"><LINKREL="next"HREF="ch15_01.htm"TITLE="15. Miscellaneous"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="DNS &amp; BIND"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="DNS &amp; BIND"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/dsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch14_02.htm"TITLE="14.2 C Programming with the Resolver Library Routines"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 14.2 C Programming with the Resolver Library Routines"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 14<BR>Programming with the Resolver and Name Server LibraryRoutines</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch15_01.htm"TITLE="15. Miscellaneous"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 15. Miscellaneous"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="AUTOID-16195">14.3 Perl Programming with Net::DNS</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="CH14.PERLPROGRAMMING1"></A><ACLASS="indexterm"NAME="CH14.PERLPROGRAMMING2"></A><ACLASS="indexterm"NAME="CH14.PERLPROGRAMMING3"></A>If usingthe shell to parse <KBDCLASS="command">nslookup</KBD>'s output seems too awkward and writinga C program seems too complicated, consider writing your programin Perl using the Net::DNS module written by Michael Fuhr.  You'llfind the package at <ACLASS="systemitem.url"HREF="http://www.perl.com/CPAN-local/modules/by-module/Net/">http://www.perl.com/CPAN-local/modules/by-module/Net/</A>.</P><PCLASS="para">Net::DNS treats resolvers, DNS packets, sections of DNS packets,and individual resource records as objects and provides methodsfor setting or querying each object's attributes.  We'll examineeach object type first, then give a Perl version of our <ICLASS="function">check_soa</I>program.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-16209">14.3.1 Resolver Objects</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16212"></A>Before making any queries,you must first create a resolver object:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$res = new Net::DNS::Resolver;</PRE></BLOCKQUOTE><PCLASS="para">Resolver objects are initialized from your <ICLASS="filename">resolv.conf</I>file, but you can change the default settings by making calls tothe object's methods.  Many of the methods described in the Net::DNS::Resolvermanual page correspond to fields and options of the <ICLASS="function">_res</I> structuredescribed earlier in the C programming section.  For example, ifyou want to set the number of times the resolver tries each querybefore timing out, you can call the <ICLASS="function">$res-&gt;retry</I> method:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$res-&gt;retry(2);</PRE></BLOCKQUOTE><PCLASS="para">To make a query, call one of the following methods:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$res-&gt;search$res-&gt;query$res-&gt;send</PRE></BLOCKQUOTE><PCLASS="para">These methods behave like the <ICLASS="function">res_search</I>, <ICLASS="function">res_query</I>,and <ICLASS="function">res_send</I> library functions described in the C programming section,though they take fewer arguments.  You must provide a name, andyou can optionally provide a DNS record type and class (the default behavioris to query for A records in the IN class).  These methods returnNet::DNS::Packet objects, which we'll describe shortly.  Here area few examples:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$packet = $res-&gt;search(&quot;terminator&quot;);$packet = $res-&gt;query(&quot;movie.edu&quot;, &quot;MX&quot;);$packet = $res-&gt;send(&quot;version.bind&quot;, &quot;TXT&quot;, &quot;CH&quot;);</PRE></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-16228">14.3.2 Packet Objects</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16231"></A>Resolver queries returnNet::DNS::Packet objects, whose methods you can use to access theheader, question, answer, authority, and additional sections ofa DNS packet:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$header     = $packet-&gt;header;@question   = $packet-&gt;question;@answer     = $packet-&gt;answer;@authority  = $packet-&gt;authority;@additional = $packet-&gt;additional;</PRE></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-16235">14.3.3 Header Objects</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16238"></A>DNS packet headers arereturned as Net::DNS::Header objects.  The methods described inthe Net::DNS::Header manual page correspond to the header fields describedin RFC 1035 and in the <ICLASS="function">HEADER</I> structure used in C programs.  Forexample, if you want to find out if this is an authoritative answer,you would call the <ICLASS="function">$header-&gt;aa</I> method:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if ($header-&gt;aa) {    print &quot;answer is authoritative\n&quot;;} else {    print &quot;answer is not authoritative\n&quot;;}</PRE></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-16244">14.3.4 Question Objects</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16247"></A>The question sectionof a DNS packet is returned as a list of Net::DNS::Question objects. You can find the name, type, and class of a question object withthe following methods:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$question-&gt;qname$question-&gt;qtype$question-&gt;qclass</PRE></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-16251">14.3.5 Resource Record Objects</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16254"></A>The answer, authority,and additional sections of a DNS packet are returned as lists ofNet::DNS::RR objects.  You can find the name, type, class, and TTLof an RR object with the following methods:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$rr-&gt;name$rr-&gt;type$rr-&gt;class$rr-&gt;ttl</PRE></BLOCKQUOTE><PCLASS="para">Each record type is a subclass of Net::DNS::RR andhas its own type-specific methods.  Here's an example that showshow to get the preference and mail exchange out of an MX record:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$preference = $rr-&gt;preference;$exchange   = $rr-&gt;exchange;</PRE></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="AUTOID-16260">14.3.6 A Perl Version of check_soa</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="CH14.EXAMPLE1A"></A><ACLASS="indexterm"NAME="CH14.EXAMPLE2A"></A>Now thatwe've described the objects Net::DNS uses, let's look at how touse them in a complete program.  We've rewritten <ICLASS="function">check_soa</I> in Perl:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#!/usr/local/bin/perl -wuse Net::DNS;#----------------------------------------------------------------------# Get the domain from the command line.#----------------------------------------------------------------------die &quot;Usage:  check_soa domain\n&quot; unless @ARGV == 1;$domain = $ARGV[0];#----------------------------------------------------------------------# Find all the nameservers for the domain.#----------------------------------------------------------------------$res = new Net::DNS::Resolver;$res-&gt;defnames(0);$res-&gt;retry(2);$ns_req = $res-&gt;query($domain, &quot;NS&quot;);die &quot;No nameservers found for $domain: &quot;, $res-&gt;errorstring, &quot;\n&quot;    unless defined($ns_req) and ($ns_req-&gt;header-&gt;ancount &gt; 0);@nameservers = grep { $_-&gt;type eq &quot;NS&quot; } $ns_req-&gt;answer;#----------------------------------------------------------------------# Check the SOA record on each nameserver.#----------------------------------------------------------------------$| = 1;$res-&gt;recurse(0);foreach $nsrr (@nameservers) {  #------------------------------------------------------------------  # Set the resolver to query this nameserver.  #------------------------------------------------------------------  $ns = $nsrr-&gt;nsdname;  print &quot;$ns &quot;;  unless ($res-&gt;nameservers($ns)) {      warn &quot;: can't find address: &quot;, $res-&gt;errorstring, &quot;\n&quot;;      next;  }  #------------------------------------------------------------------  # Get the SOA record.  #------------------------------------------------------------------  $soa_req = $res-&gt;send($domain, &quot;SOA&quot;);  unless (defined($soa_req)) {      warn &quot;: &quot;, $res-&gt;errorstring, &quot;\n&quot;;      next;  }  #------------------------------------------------------------------  # Is this nameserver authoritative for the domain?  #------------------------------------------------------------------  unless ($soa_req-&gt;header-&gt;aa) {      warn &quot;is not authoritative for $domain\n&quot;;      next;  }  #------------------------------------------------------------------  # We should have received exactly one answer.  #------------------------------------------------------------------  unless ($soa_req-&gt;header-&gt;ancount == 1) {      warn &quot;: expected 1 answer, got &quot;,            $soa_req-&gt;header-&gt;ancount, &quot;\n&quot;;      next;  }  #------------------------------------------------------------------  # Did we receive an SOA record?  #------------------------------------------------------------------   unless (($soa_req-&gt;answer)[0]-&gt;type eq &quot;SOA&quot;) {       warn &quot;: expected SOA, got &quot;,            ($soa_req-&gt;answer)[0]-&gt;type, &quot;\n&quot;;       next;  }  #------------------------------------------------------------------  # Print the serial number.  #------------------------------------------------------------------  print &quot;has serial number &quot;, ($soa_req-&gt;answer)[0]-&gt;serial, &quot;\n&quot;;}</PRE></BLOCKQUOTE><PCLASS="para">Now that you've seen how to write a DNS program usinga shell script, a Perl script, and C code, you should be able towrite one on your own using the language that best fits your situation.<ACLASS="indexterm"NAME="AUTOID-16271"></A><ACLASS="indexterm"NAME="AUTOID-16274"></A></P><ACLASS="indexterm"NAME="AUTOID-16276"></A><ACLASS="indexterm"NAME="AUTOID-16277"></A></DIV><ACLASS="indexterm"NAME="AUTOID-16278"></A><ACLASS="indexterm"NAME="AUTOID-16279"></A><ACLASS="indexterm"NAME="AUTOID-16280"></A><ACLASS="indexterm"NAME="AUTOID-16281"></A><ACLASS="indexterm"NAME="AUTOID-16282"></A></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch14_02.htm"TITLE="14.2 C Programming with the Resolver Library Routines"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 14.2 C Programming with the Resolver Library Routines"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="DNS &amp; BIND"><IMGSRC="../gifs/txthome.gif"ALT="DNS &amp; BIND"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch15_01.htm"TITLE="15. Miscellaneous"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 15. Miscellaneous"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">14.2 C Programming with the Resolver Library Routines</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">15. Miscellaneous</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>