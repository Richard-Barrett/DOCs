<HTML><HEAD><TITLE>[Chapter 6] 6.3 What Does a Packet Look Like?</TITLE><METANAME="DC.title"CONTENT="Building Internet Firewalls"><METANAME="DC.creator"CONTENT="D. Brent Chapman &amp; Elizabeth D. Zwicky"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:16:21Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-124-0"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch06_01.htm"TITLE="6. Packet Filtering"><LINKREL="prev"HREF="ch06_02.htm"TITLE="6.2 Configuring a Packet Filtering Router"><LINKREL="next"HREF="ch06_04.htm"TITLE="6.4 What Does the Router Do with Packets?"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Building Internet Firewalls"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Building Internet Firewalls"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/fsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Configuring a Packet Filtering Router"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.2 Configuring a Packet Filtering Router"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 6<BR>Packet Filtering</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_04.htm"TITLE="6.4 What Does the Router Do with Packets?"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.4 What Does the Router Do with Packets?"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="FIRE-06-S1-3">6.3 What Does a Packet Look Like?</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="CH06PACKSTRUCT"></A>To understand packet filtering, you first have to understand packetsand how they are handled at each layer of the<SPANCLASS="acronym">TCP/IP</SPAN> protocol stack:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Application layer (e.g., <SPANCLASS="acronym">FTP</SPAN>, Telnet,<SPANCLASS="acronym">HTTP</SPAN>)</P></LI><LICLASS="listitem"><PCLASS="para">Transport layer (<SPANCLASS="acronym">TCP</SPAN> or <SPANCLASS="acronym">UDP</SPAN>)</P></LI><LICLASS="listitem"><PCLASS="para">Internet layer (<SPANCLASS="acronym">IP</SPAN>)</P></LI><LICLASS="listitem"><PCLASS="para">Network access layer (e.g., Ethernet, <SPANCLASS="acronym">FDDI</SPAN>,<SPANCLASS="acronym">ATM</SPAN>)</P></LI></UL><PCLASS="para">Packets are constructed in such a way that layers for each protocolused for a particular connection are wrapped around the packets, likethe layers of skin on an onion.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4282"></A><ACLASS="indexterm"NAME="AUTOID-4284"></A>At each layer, a packet has two parts: the header and the body. Theheader contains protocol information relevant to that layer, while thebody contains the data for that layer which often consists of a wholepacket from the next layer in the stack. Each layer treats theinformation it gets from the layer above it as data, and applies itsown header to this data. At each layer, the packet contains all of theinformation passed from the higher layer; nothing is lost. Thisprocess of preserving the data while attaching a new header is knownas<EMCLASS="emphasis"> encapsulation</EM>.<ACLASS="indexterm"NAME="AUTOID-4288"></A></P><PCLASS="para">At the application layer, the packet consists simply of the data to betransferred (for example, part of a file being transferred during an<SPANCLASS="acronym">FTP</SPAN> session). As it moves to the transport layer,the Transmission Control Protocol (<SPANCLASS="acronym">TCP</SPAN>) or the UserDatagram Protocol (<SPANCLASS="acronym">UDP</SPAN>) preserves the data from theprevious layer and attaches a header to it. At the next layer,<SPANCLASS="acronym">IP</SPAN> considers the entire packet (consisting now ofthe <SPANCLASS="acronym">TCP</SPAN> or <SPANCLASS="acronym">UDP</SPAN> header and thedata) to be data, and now attaches its own <SPANCLASS="acronym">IP</SPAN>header. Finally, at the network access layer, Ethernet or anothernetwork protocol considers the entire <SPANCLASS="acronym">IP</SPAN> packetpassed to it to be data, and attaches its own header. <ACLASS="xref"HREF="ch06_03.htm#FIRE-06-FIG-2"TITLE="Data encapsulation">Figure 6.2</A> shows how this works.</P><H4CLASS="figure"><ACLASS="title"NAME="FIRE-06-FIG-2">Figure 6.2: Data encapsulation</A></H4><IMGCLASS="graphic"SRC="figs/fire0602.gif"ALT="Figure 6.2"><PCLASS="para">At the other side of the connection, this process is reversed. As thedata is passed up from one layer to the next higher layer, each header(each skin of the onion) is stripped off by its respective layer. Forexample, the Internet layer removes the <SPANCLASS="acronym">IP</SPAN> headerbefore passing the encapsulated data up to the transport layer(<SPANCLASS="acronym">TCP</SPAN> or <SPANCLASS="acronym">UDP</SPAN>).</P><PCLASS="para">In trying to understand packet filtering, the most importantinformation from our point of view is in the headers of the variouslayers. The sections below look at several examples of different typesof packets and show the contents of each of the headers that packetfiltering routers will be examining. We assume a certain knowledge of<SPANCLASS="acronym">TCP</SPAN>/<SPANCLASS="acronym">IP</SPAN> fundamentals, andconcentrate on discussing the particular issues related to packetfiltering. For a detailed introduction to <SPANCLASS="acronym">TCP/IP</SPAN>,see <ACLASS="xref"HREF="appc_01.htm"TITLE="TCP/IP Fundamentals">Appendix C</A>.</P><PCLASS="para">In the discussion below, we start with a simple example demonstrating<SPANCLASS="acronym">TCP/IP</SPAN> over Ethernet. From there, we go on todiscuss <SPANCLASS="acronym">IP</SPAN>'s packet filtering characteristics, thenprotocols above <SPANCLASS="acronym">IP</SPAN> (such as <SPANCLASS="acronym">TCP</SPAN>,<SPANCLASS="acronym">UDP</SPAN>, <SPANCLASS="acronym">ICMP</SPAN>, and<SPANCLASS="acronym">RPC</SPAN>), protocols below <SPANCLASS="acronym">IP</SPAN> (suchas Ethernet), and finally non-<SPANCLASS="acronym">IP</SPAN> protocols (such asAppleTalk or <SPANCLASS="acronym">IPX</SPAN>).</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="FIRE-06-S2-6">6.3.1 <SPANCLASS="acronym">TCP/IP</SPAN>/EthernetExample</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="CH06TCPIPPACKET"></A>Let's consider an example of a <SPANCLASS="acronym">TCP/IP</SPAN> packet (forexample, one that is part of a Telnet connection) on anEthernet. There are four layers that we're interested in here: theEthernet layer, the <SPANCLASS="acronym">IP</SPAN> layer, the<SPANCLASS="acronym">TCP</SPAN> layer, and the data layer. In this section,we'll consider them from bottom to top and look at the contents of theheaders that the packet filtering routers will be examining.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-1">6.3.1.1 Ethernet layer</A></H4><ACLASS="indexterm"NAME="AUTOID-4335"></A><PCLASS="para">At the Ethernet layer, the packet consists of two parts: the Ethernetheader and the Ethernet body. In general, you won't be able to dopacket filtering based on information in the Ethernet header. Basically, the header tells you:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">What kind of packet this is</EM>&nbsp;- we'll assume in thisexample that it is an <SPANCLASS="acronym">IP</SPAN> packet, as opposed to anAppleTalk packet, a Novell packet, a <SPANCLASS="acronym">DECNET</SPAN> packet,or some other kind of packet.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">The Ethernet address of the machine that put the packet ontothis particular Ethernet network segment</EM>&nbsp;- the originalsource machine, if it's attached to this segment; otherwise, the lastrouter in the path from the source machine to here.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">The Ethernet address of the packet's destination on thisparticular Ethernet network segment</EM>&nbsp;- perhaps thedestination machine, if it's attached to this segment; otherwise, thenext router in the path from here to the destination machine.</P></LI></UL><PCLASS="para">Because we are considering <SPANCLASS="acronym">IP</SPAN> packets in thisexample, we know that the Ethernet body contains an<SPANCLASS="acronym">IP</SPAN> packet.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-2">6.3.1.2 <SPANCLASS="acronym">IP</SPAN> layer</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4357"></A>At the <SPANCLASS="acronym">IP</SPAN> layer, the <SPANCLASS="acronym">IP</SPAN> packetis made up of two parts: the <SPANCLASS="acronym">IP</SPAN> header and the<SPANCLASS="acronym">IP</SPAN> body, as shown in <ACLASS="xref"HREF="ch06_03.htm#FIRE-06-FIG-3"TITLE="IP header and body">Figure 6.3</A>.From a packet filtering point of view, the<SPANCLASS="acronym">IP</SPAN> header contains four interesting pieces ofinformation:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">The <SPANCLASS="acronym">IP</SPAN> source address</EM>&nbsp;- fourbytes long, and typically written as something like172.16.244.34.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">The <SPANCLASS="acronym">IP</SPAN> destinationaddress</EM>&nbsp;- just like the <SPANCLASS="acronym">IP</SPAN> sourceaddress.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">The <SPANCLASS="acronym">IP</SPAN> protocoltype</EM>&nbsp;- identifies the <SPANCLASS="acronym">IP</SPAN> body as a<SPANCLASS="acronym">TCP</SPAN> packet, as opposed to a <SPANCLASS="acronym">UDP</SPAN>packet, an Internet Control Message Protocol (<SPANCLASS="acronym">ICMP</SPAN>)packet, or some other type of packet.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">The <SPANCLASS="acronym">IP</SPAN> options field</EM>&nbsp;- which isalmost always empty, but which is where options like the<SPANCLASS="acronym">IP</SPAN> source route and the <SPANCLASS="acronym">IP</SPAN>security options would be specified if they were used for a givenpacket. (See the discussion in &quot;<SPANCLASS="acronym">IP</SPAN>options&quot; below.)</P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4392"></A><ACLASS="indexterm"NAME="AUTOID-4395"></A><SPANCLASS="acronym">IP</SPAN> may divide up a packet that is too large tocross a given network into a series of smaller packets called<EMCLASS="emphasis">fragments</EM>. Fragmenting a packet doesn't changeits structure at the <SPANCLASS="acronym">IP</SPAN> layer (the<SPANCLASS="acronym">IP</SPAN> headers are duplicated into each fragment), butit may mean that the body contains only a part of a packet at the nextlayer. (See the discussion in &quot;<SPANCLASS="acronym">IP</SPAN>fragmentation&quot; below.)</P><H4CLASS="figure"><ACLASS="title"NAME="FIRE-06-FIG-3">Figure 6.3: <SPANCLASS="acronym">IP</SPAN> header and body</A></H4><IMGCLASS="graphic"SRC="figs/fire0603.gif"ALT="Figure 6.3"><PCLASS="para">The <SPANCLASS="acronym">IP</SPAN> body in this example contains anunfragmented <SPANCLASS="acronym">TCP</SPAN> packet, although it could just aswell contain the first fragment of a fragmented <SPANCLASS="acronym">TCP</SPAN>packet.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-3">6.3.1.3 <SPANCLASS="acronym">TCP</SPAN> layer</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4414"></A>At the <SPANCLASS="acronym">TCP</SPAN> layer, the packet again contains twoparts: the <SPANCLASS="acronym">TCP</SPAN> header and the<SPANCLASS="acronym">TCP</SPAN> body. (<ACLASS="xref"HREF="appc_06.htm#FIRE-C-FIG-8"TITLE="TCP segment format">Figure 13.12</A> in Appendix C showsthe format of the <SPANCLASS="acronym">TCP</SPAN> header and body.)From a packet filtering point of view, the <SPANCLASS="acronym">TCP</SPAN>header contains three interesting pieces of information:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">The <SPANCLASS="acronym">TCP</SPAN> source port</EM>&nbsp;- atwo-byte number, which specifies what client or server process thepacket is coming from on the source machine</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">The <SPANCLASS="acronym">TCP</SPAN> destination port</EM>&nbsp;- justlike the <SPANCLASS="acronym">TCP</SPAN> source port</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">The <SPANCLASS="acronym">TCP</SPAN> flags field</EM></P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4438"></A>The <SPANCLASS="acronym">TCP</SPAN> flags field contains one bit of interestfor packet filtering: the <SPANCLASS="acronym">ACK</SPAN> bit. By examining the<SPANCLASS="acronym">ACK</SPAN> bit, a packet filtering router can determinewhether a given packet is the first packet initiating a<SPANCLASS="acronym">TCP</SPAN> connection (if the <SPANCLASS="acronym">ACK</SPAN> bitis not set) or is a subsequent packet (if the <SPANCLASS="acronym">ACK</SPAN>bit is set). The <SPANCLASS="acronym">ACK</SPAN> bit is part of the<SPANCLASS="acronym">TCP</SPAN> mechanism that guarantees delivery of thedata. The <SPANCLASS="acronym">ACK</SPAN> bit is set whenever one side of aconnection has received data from the other side (it acknowledges thereceived data). Therefore, the <SPANCLASS="acronym">ACK</SPAN> bit is set onall packets going in either direction except the very first packetfrom the client to the server.</P><PCLASS="para">The <SPANCLASS="acronym">TCP</SPAN> body contains the actual &quot;data&quot;being transmitted&nbsp;- e.g., for Telnet the keystrokes or screendisplays that are part of a Telnet session, or for<SPANCLASS="acronym">FTP</SPAN> the data being transferred or commands beingissued as part of an <SPANCLASS="acronym">FTP</SPAN> session.<ACLASS="indexterm"NAME="AUTOID-4454"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="FIRE-06-S2-7">6.3.2 <SPANCLASS="acronym">IP</SPAN></A></H3><PCLASS="para"><ACLASS="indexterm"NAME="CH06IP"></A><SPANCLASS="acronym">IP</SPAN> serves as a common middle ground for theInternet. It can have many different layers below it, such asEthernet, token ring, <SPANCLASS="acronym">FDDI</SPAN>, <SPANCLASS="acronym">PPP</SPAN>,or carrier pigeon.[2] <SPANCLASS="acronym">IP</SPAN> can have many other protocolslayered on top of it, with <SPANCLASS="acronym">TCP</SPAN>,<SPANCLASS="acronym">UDP</SPAN>, and <SPANCLASS="acronym">ICMP</SPAN> being by far themost common, at least outside of research environments. In thissection, we discuss the special characteristics of<SPANCLASS="acronym">IP</SPAN> relevant to packet filtering.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] See RFC1149, dated 1 April 1990, which defines the Avian TransportProtocol; <SPANCLASS="acronym">RFC</SPAN>s dated 1 April are usually worthreading.</P></BLOCKQUOTE><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-4">6.3.2.1 <SPANCLASS="acronym">IP</SPAN> options</A></H4><PCLASS="para">As we saw in the discussion of the <SPANCLASS="acronym">IP</SPAN> layer above,<SPANCLASS="acronym">IP</SPAN> headers include an options field,which is usually empty. In its design, the <SPANCLASS="acronym">IP</SPAN>options field was intended as a place for special information orhandling instructions that didn't have a specific field of their ownin the header. However, <SPANCLASS="acronym">TCP/IP</SPAN>'s designers did sucha good job of providing fields for everything necessary that theoptions field is almost always empty. In practice,<SPANCLASS="acronym">IP</SPAN> options are very seldom used except for break-inattempts and (very rarely) for network debugging.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4482"></A><ACLASS="indexterm"NAME="AUTOID-4485"></A>The most common <SPANCLASS="acronym">IP</SPAN> option a firewall would beconfronted with is the <SPANCLASS="acronym">IP</SPAN> sourceroute option. Source routing lets the source of a packetspecify the route the packet is supposed to take to its destination,rather than letting each router along the way use its routing tablesto decide where to send the packet next. Source routing is supposedto override the instructions in the routing tables. In theory, thesource routing option is useful for working around routers with brokenor incorrect routing tables; if you know the route that the packetshould take, but the routing tables are broken, you can override thebad information in the routing tables by specifying appropriate<SPANCLASS="acronym">IP</SPAN> source route options on all your packets. Inpractice though, source routing is commonly used only by attackers whoare attempting to circumvent security measures by causing packets tofollow unexpected paths.</P><PCLASS="para">Many packet filtering systems take the approach of dropping any packetthat has any <SPANCLASS="acronym">IP</SPAN> option set, without even trying tofigure out what the option is or what it means; in general, this seemsto work well, without causing any special problems.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-5">6.3.2.2 <SPANCLASS="acronym">IP</SPAN> fragmentation</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4496"></A><ACLASS="indexterm"NAME="AUTOID-4499"></A><ACLASS="indexterm"NAME="AUTOID-4501"></A>Another <SPANCLASS="acronym">IP</SPAN>-level consideration for packet filteringis fragmentation. One of the features of <SPANCLASS="acronym">IP</SPAN> is itsability to divide a large packet that otherwise couldn't traverse somenetwork link (because of limitations on packet size along that link)into smaller packets, called <EMCLASS="emphasis">fragments</EM>, which cantraverse that link. The fragments are then reassembled into the fullpacket by the destination machine (not by the machine at the other endof the limited link; once a packet is fragmented, it stays fragmenteduntil it reaches its destination).</P><PCLASS="para"><SPANCLASS="acronym">IP</SPAN> fragmentation is illustrated in <ACLASS="xref"HREF="ch06_03.htm#FIRE-06-FIG-4"TITLE="Data fragmentation">Figure 6.4</A>.</P><H4CLASS="figure"><ACLASS="title"NAME="FIRE-06-FIG-4">Figure 6.4: Data fragmentation</A></H4><IMGCLASS="graphic"SRC="figs/fire0604.gif"ALT="Figure 6.4"><PCLASS="para">From a packet filtering point of view, the problem with fragmentationis that only the first fragment will contain the header informationfrom higher-level protocols, like <SPANCLASS="acronym">TCP</SPAN>, that the packetfiltering system needs in order to decide whether or not to allow thefull packet. The common packet filtering approach to dealing withfragmentation is to allow any nonfirst fragments through, and to dopacket filtering only on the first fragment of a packet. This is safebecause, if the packet filtering decides to drop the first fragment,the destination system will not be able to reassemble the rest of thefragments into the original packet, regardless of how many of the restof the fragments it receives. If it can't reconstruct the originalpacket, the partially reassembled packet will not be accepted.</P><PCLASS="para">The destination host will hold the fragments in memory for a while,waiting to see if it gets the missing piece; this makes it possiblefor attackers to use fragmented packets in a denial of serviceattack. When the destination host gives up on reassembling the packet,it will send an <SPANCLASS="acronym">ICMP</SPAN> &quot;packet reassembly timeexpired&quot; message back to the source host, which will tell anattacker that the host exists, and why the connection didn'tsucceed. There is nothing to be done about such denial ofservice attacks, but you can filter out the <SPANCLASS="acronym">ICMP</SPAN>messages.</P><PCLASS="para">Outbound fragments could conceivably contain data you don't want torelease to the world. For example, an outbound <SPANCLASS="acronym">NFS</SPAN>packet would almost certainly be fragmented, and if the file wasconfidential, that information would be released. If this happens byaccident, it's unlikely to be a problem; people do not generally hangaround looking at the data in random packets going by just in casethere's something interesting in them. You could wait a very long timefor somebody to accidentally send a fragment out with interesting datain it.</P><PCLASS="para">If somebody inside intentionally uses fragmentation to transmit data,you have hostile users within the firewall, and no firewall can dealsuccessfully with this problem. (They probably aren't very cleverhostile users, though, because there are easier ways to get data out.)</P><PCLASS="para">The only situation in which you need to worry about outbound fragmentsis the one in which you allow a request in but block the outboundreply. In this situation, nonfirst fragments of the reply will getout, and the attacker has reason to expect them and look for them. Youcan deal with this by being careful to filter out requests and by notrelying on filtering out the replies.<ACLASS="indexterm"NAME="AUTOID-4522"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="FIRE-06-S2-8">6.3.3 Protocols Above<SPANCLASS="acronym">IP</SPAN></A></H3><PCLASS="para"><ACLASS="indexterm"NAME="CH06PROTOIP"></A><SPANCLASS="acronym">IP</SPAN> serves as the base for a number of differentprotocols; by far the most common are <SPANCLASS="acronym">TCP</SPAN>,<SPANCLASS="acronym">UDP</SPAN>, and <SPANCLASS="acronym">ICMP</SPAN>. These are, infact, the only <SPANCLASS="acronym">IP</SPAN>-based protocols that you'relikely to see outside a research environment.</P><PCLASS="para">We discuss Remote Procedure Calls (<SPANCLASS="acronym">RPC</SPAN>s) as well inthis section, although <SPANCLASS="acronym">RPC</SPAN> is, strictly speaking,based on either <SPANCLASS="acronym">TCP</SPAN> or <SPANCLASS="acronym">UDP</SPAN>, noton <SPANCLASS="acronym">IP</SPAN> itself. It makes sense to discuss it here,however, because, like <SPANCLASS="acronym">TCP</SPAN> and<SPANCLASS="acronym">UDP</SPAN>, <SPANCLASS="acronym">RPC</SPAN> is intended to operateas a general-purpose session protocol on which application protocolscan be layered.</P><PCLASS="para">In addition, we briefly discuss <SPANCLASS="acronym">IP</SPAN> over<SPANCLASS="acronym">IP</SPAN> (i.e., an <SPANCLASS="acronym">IP</SPAN> packetencapsulated within another <SPANCLASS="acronym">IP</SPAN> packet), which isused primarily for tunneling multicast <SPANCLASS="acronym">IP</SPAN> packetsover nonmulticast <SPANCLASS="acronym">IP</SPAN> networks.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-6">6.3.3.1 <SPANCLASS="acronym">TCP</SPAN></A></H4><PCLASS="para"><ACLASS="indexterm"NAME="CH06TCP"></A><ACLASS="indexterm"NAME="CH06PACKTCP"></A><ACLASS="indexterm"NAME="CH06DATATRANSVIATCP"></A><SPANCLASS="acronym">TCP</SPAN> is the protocol most commonly used for serviceson the Internet. For example, Telnet, <SPANCLASS="acronym">FTP</SPAN>,<SPANCLASS="acronym">SMTP</SPAN>, <SPANCLASS="acronym">NNTP</SPAN>, and<SPANCLASS="acronym">HTTP</SPAN> are all <SPANCLASS="acronym">TCP</SPAN>-basedservices. <SPANCLASS="acronym">TCP</SPAN> provides a reliable, bidirectionalconnection between two endpoints. Opening a <SPANCLASS="acronym">TCP</SPAN>connection is like making a phone call: you dial the number, and aftera short setup period, a fairly reliable connection is establishedbetween you and whomever you're calling.</P><PCLASS="para"><SPANCLASS="acronym">TCP</SPAN> is <EMCLASS="emphasis">reliable</EM> in that itmakes three guarantees to the application layer:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">The destination will receive the application data in the order it wassent.</P></LI><LICLASS="listitem"><PCLASS="para">The destination will receive all the application data.</P></LI><LICLASS="listitem"><PCLASS="para">The destination will not receive duplicates of any of theapplication data.</P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4583"></A><SPANCLASS="acronym">TCP</SPAN> will kill a connection rather than violate oneof these guarantees. For example, if <SPANCLASS="acronym">TCP</SPAN> packetsfrom the middle of a session are lost in transit to the destination,the <SPANCLASS="acronym">TCP</SPAN> layer will arrange for those packets to beretransmitted before handing the data up to the application layer. Itwon't hand up the data following the missing data until it has themissing data. If some of the data cannot be recovered, despiterepeated attempts, the <SPANCLASS="acronym">TCP</SPAN> layer will kill theconnection and report this to the application layer, rather than handup the data to the application layer with a gap in it.</P><PCLASS="para">These guarantees incur certain costs in both setup time (the two sidesof a connection have to exchange startup information beforethey can actually begin moving data) and ongoing performance (the twosides of a connection have to keep track of the status of theconnection, to determine what data needs to be resent to the otherside to fill in gaps in the conversation).</P><PCLASS="para"><SPANCLASS="acronym">TCP</SPAN> is bidirectional in that once a connection isestablished, a server can reply to a client over the sameconnection. You don't have to establish one connection from a clientto a server for queries or commands and another from the server backto the client for answers.</P><PCLASS="para">If you're trying to block a <SPANCLASS="acronym">TCP</SPAN> connection, it issufficient to simply block the first packet of the connection. Withoutthat first packet (and, more importantly, the connection startupinformation it contains), any further packets in that connection won'tbe reassembled into a data stream by the receiver, and the connectionwill never be made. That first packet is recognizable because the<ACLASS="indexterm"NAME="AUTOID-4595"></A><SPANCLASS="acronym">ACK</SPAN> bit in its <SPANCLASS="acronym">TCP</SPAN> header is notset; every other packet in the connection, regardless of whichdirection it's going, will have the <SPANCLASS="acronym">ACK</SPAN> bit set.</P><PCLASS="para">Recognizing these &quot;start-of-connection&quot;<SPANCLASS="acronym">TCP</SPAN> packets allows you to enforce a policy thatallows internal clients to connect to external servers, but preventsexternal clients from connecting to internal servers. You do this byallowing start-of-connection <SPANCLASS="acronym">TCP</SPAN> packets (thosewithout the <SPANCLASS="acronym">ACK</SPAN> bit set) only outbound and notinbound. Start of connection packets would be allowed out frominternal clients to external servers, but would not be allowed in fromexternal clients to internal servers. Attackers cannot subvert thisapproach simply by turning on the <SPANCLASS="acronym">ACK</SPAN> bit in theirstart-of-connection packets, because the absence of the<SPANCLASS="acronym">ACK</SPAN> bit is what identifies these packets as startof connection packets.</P><PCLASS="para">Packet filtering implementations vary in how they treat and let youhandle the <SPANCLASS="acronym">ACK</SPAN> bit. Some packet filteringimplementations give direct access to the <SPANCLASS="acronym">ACK</SPAN>bit&nbsp;- for example, by letting you include &quot;ack&quot; as a keyword in apacket filtering rule. Some other implementations give indirect accessto the <SPANCLASS="acronym">ACK</SPAN> bit. For example, the Cisco&quot;established&quot; keyword works by examining this bit(established is &quot;true&quot; if the <SPANCLASS="acronym">ACK</SPAN> bitis set, and &quot;false&quot; if the <SPANCLASS="acronym">ACK</SPAN> bit isnot set). Finally, some implementations don't let you examine the<SPANCLASS="acronym">ACK</SPAN> bit at all.</P><PCLASS="para"><ACLASS="xref"HREF="ch06_03.htm#FIRE-06-FIG-5"TITLE="ACK bits on TCP packets">Figure 6.5</A> shows what<SPANCLASS="acronym">ACK</SPAN> is set to on packets that are part of a <SPANCLASS="acronym">TCP</SPAN> connection.</P><H4CLASS="figure"><ACLASS="title"NAME="FIRE-06-FIG-5">Figure 6.5: <SPANCLASS="acronym">ACK</SPAN> bits on <SPANCLASS="acronym">TCP</SPAN> packets</A></H4><IMGCLASS="graphic"SRC="figs/fire0605.gif"ALT="Figure 6.5"><ACLASS="indexterm"NAME="AUTOID-4623"></A><ACLASS="indexterm"NAME="AUTOID-4624"></A><ACLASS="indexterm"NAME="AUTOID-4625"></A></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-7">6.3.3.2 <SPANCLASS="acronym">UDP</SPAN></A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4630"></A><ACLASS="indexterm"NAME="AUTOID-4632"></A><ACLASS="indexterm"NAME="AUTOID-4635"></A>The body of an <SPANCLASS="acronym">IP</SPAN> packet might contain a<SPANCLASS="acronym">UDP</SPAN> packet instead of a <SPANCLASS="acronym">TCP</SPAN>packet. <SPANCLASS="acronym">UDP</SPAN> is a low-overhead alternative to<SPANCLASS="acronym">TCP</SPAN>.</P><PCLASS="para"><SPANCLASS="acronym">UDP</SPAN> is <EMCLASS="emphasis">low overhead</EM> in that itdoesn't make any of the reliability guarantees (delivery, ordering,and nonduplication) that <SPANCLASS="acronym">TCP</SPAN> does, and, therefore,it doesn't need the mechanism to make those guarantees. Every<SPANCLASS="acronym">UDP</SPAN> packet is independent; <SPANCLASS="acronym">UDP</SPAN>packets aren't part of a &quot;virtual circuit&quot; as<SPANCLASS="acronym">TCP</SPAN> packets are. Sending <SPANCLASS="acronym">UDP</SPAN>packets is like dropping postcards in the mail: if you drop 100postcards in the mail, even if they're all addressed to the sameplace, you can't be absolutely sure that they're all going to getthere, and those that do get there probably won't be in exactly thesame order they were in when you sent them.</P><PCLASS="para">Unlike postcards, <SPANCLASS="acronym">UDP</SPAN> packets can actually arrivemore than once (without being ripped to shreds, which is normally theonly way the same postcard gets delivered multiple times). Multiplecopies are possible because the packet might be duplicated by theunderlying network. For example, on an Ethernet, a packet would beduplicated if a router thought that it might have been the victim ofan Ethernet collision. If the router was wrong, and the originalpacket had not been the victim of a collision, both the original andthe duplicate would eventually arrive at the destination. (A confusedapplication may also decide to send the same data twice, perhapsbecause it didn't get an expected response to the first one.)</P><PCLASS="para">All of these things can happen to <SPANCLASS="acronym">TCP</SPAN> packets,too, but they will be corrected before the data is passed to theapplication. With <SPANCLASS="acronym">UDP</SPAN>, the application isresponsible for dealing with the packets, not corrected data.</P><PCLASS="para"><SPANCLASS="acronym">UDP</SPAN> packets are very similar to<SPANCLASS="acronym">TCP</SPAN> packets in structure. A <SPANCLASS="acronym">UDP</SPAN>header contains <SPANCLASS="acronym">UDP</SPAN> source and destination portnumbers, just like the <SPANCLASS="acronym">TCP</SPAN> source and destinationport numbers. However, a <SPANCLASS="acronym">UDP</SPAN> header does notcontain anything resembling an <SPANCLASS="acronym">ACK</SPAN> bit. The<SPANCLASS="acronym">ACK</SPAN> bit is part of <SPANCLASS="acronym">TCP</SPAN>'smechanism for guaranteeing reliable delivery of data. Because<SPANCLASS="acronym">UDP</SPAN> makes no such guarantees, it has no need for an<SPANCLASS="acronym">ACK</SPAN> bit. There is no way for a packet filteringrouter to determine, simply by examining the header of an incoming<SPANCLASS="acronym">UDP</SPAN> packet, whether that packet is a first packetfrom an external client to an internal server, or a response from anexternal server back to an internal client.</P><PCLASS="para">Some packet filtering implementations, such as CheckPoint's FireWall-1product, Janus; Morning Star's SecureConnect Router; and theKarlBridge/KarlBrouter, have the capability of&quot;remembering&quot; outgoing <SPANCLASS="acronym">UDP</SPAN> packets thatthey've seen. They can then allow only the corresponding responsepackets back in through the filtering mechanism. In order to becounted as a response, the incoming packet has to be from the host andport that the outbound packet was sent to, and has to be directed tothe host and port that sent the outbound packet. This capability is<ACLASS="indexterm"NAME="AUTOID-4671"></A><ACLASS="indexterm"NAME="AUTOID-4673"></A>often referred to as <EMCLASS="emphasis">dynamic packet filtering</EM>,because the router is essentially modifying the filtering rules on thefly to accommodate these returning packets. The rules created to allowthe responses are time-limited; they time out after a few seconds orminutes. Dynamic packet filtering may also be used for any situationin which the packet filtering rules change without somebody explictlychanging the configuration; different products support differentcapabilities.</P><PCLASS="para"><ACLASS="xref"HREF="ch06_03.htm#FIRE-06-FIG-6"TITLE="Dynamic packet filtering at the UDP layer">Figure 6.6</A> illustrates dynamic packet filtering atthe <SPANCLASS="acronym">UDP</SPAN> layer.</P><H4CLASS="figure"><ACLASS="title"NAME="FIRE-06-FIG-6">Figure 6.6: Dynamic packet filtering at the <SPANCLASS="acronym">UDP</SPAN> layer</A></H4><IMGCLASS="graphic"SRC="figs/fire0606.gif"ALT="Figure 6.6"></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-8">6.3.3.3 <SPANCLASS="acronym">ICMP</SPAN></A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4688"></A><ACLASS="indexterm"NAME="AUTOID-4690"></A><ACLASS="indexterm"NAME="AUTOID-4694"></A><ACLASS="indexterm"NAME="AUTOID-4697"></A><SPANCLASS="acronym">ICMP</SPAN> is used for <SPANCLASS="acronym">IP</SPAN> status andcontrol messages. <SPANCLASS="acronym">ICMP</SPAN> packets are carried in thebody of <SPANCLASS="acronym">IP</SPAN> packets, just as <SPANCLASS="acronym">TCP</SPAN>and <SPANCLASS="acronym">UDP</SPAN> packets are. Examples of<SPANCLASS="acronym">ICMP</SPAN> messages include:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Echo request</EM>&nbsp;- what a host sends when you run<EMCLASS="emphasis">ping</EM>.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Echo response</EM>&nbsp;- what a host responds to an&quot;echo request&quot; with.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Time exceeded</EM>&nbsp;- what a router returns when itdetermines that a packet appears to be looping; a more intuitive namemight be <EMCLASS="emphasis">maximum hopcount exceeded.</EM></P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Destination unreachable</EM>&nbsp;- what a router returnswhen the destination of a packet can't be reached for some reason(e.g., because a network link is down).</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Redirect</EM>&nbsp;- what a router sends a host in responseto a packet the host should have sent to a different router; the routerhandles the original packet anyway (forwarding it to the router itshould have gone to in the first place), and the redirect tells the hostabout the more efficient path for next time.</P></LI></UL><PCLASS="para">Unlike <SPANCLASS="acronym">TCP</SPAN> or <SPANCLASS="acronym">UDP</SPAN>,<SPANCLASS="acronym">ICMP</SPAN> has no source or destination ports, and noother protocols layered on top of it. Instead, there is a set ofdefined <SPANCLASS="acronym">ICMP</SPAN> message type codes; the particularcode used dictates the interpretation of the rest of the<SPANCLASS="acronym">ICMP</SPAN> packet.</P><PCLASS="para">Many packet filtering systems let you filter <SPANCLASS="acronym">ICMP</SPAN>packets based on the <SPANCLASS="acronym">ICMP</SPAN> message type field, muchas they allow you to filter <SPANCLASS="acronym">TCP</SPAN> or<SPANCLASS="acronym">UDP</SPAN> packets based on the <SPANCLASS="acronym">TCP</SPAN> or<SPANCLASS="acronym">UDP</SPAN> source and destination port fields.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-9">6.3.3.4 <SPANCLASS="acronym">RPC</SPAN></A></H4><PCLASS="para"><ACLASS="indexterm"NAME="CH06RPC"></A><ACLASS="indexterm"NAME="AUTOID-4745"></A><ACLASS="indexterm"NAME="AUTOID-4748"></A>There are multiple remote procedure callprotocols known as <SPANCLASS="acronym">RPC</SPAN>s. The most popular is sometimes called &quot;Sun<SPANCLASS="acronym">RPC</SPAN>&quot; because it was originally developed atSun Microsystems. This is the protocol we'll be discussing, and it isthe protocol most frequently referred to as simply&quot;<SPANCLASS="acronym">RPC</SPAN>&quot;. Other remote procedure callmechanisms are specific to particular <SPANCLASS="acronym">UNIX</SPAN>implementations or implementation families. (For example, <SPANCLASS="acronym">OSF DCE</SPAN> has its own remote procedure call protocol.) Thesemechanisms differ in detail from <SPANCLASS="acronym">RPC</SPAN>, but tend tohave similar problems.</P><PCLASS="para">Strictly speaking, the <SPANCLASS="acronym">RPC</SPAN> mechanism is not builton top of <SPANCLASS="acronym">IP</SPAN>, but rather on top of<SPANCLASS="acronym">UDP</SPAN> and <SPANCLASS="acronym">TCP</SPAN>. However, like<SPANCLASS="acronym">TCP</SPAN> and <SPANCLASS="acronym">UDP</SPAN>, RPC is used as ageneral-purpose transport protocol by a variety of applicationprotocols (such as <SPANCLASS="acronym">NFS</SPAN> and<SPANCLASS="acronym">NIS/YP</SPAN>, as we discuss in <ACLASS="xref"HREF="ch08_01.htm"TITLE="Configuring Internet Services">Chapter 8</A>), so it makes sense to describe it here.<SPANCLASS="acronym">NFS</SPAN> and <SPANCLASS="acronym">NIS/YP</SPAN> are vulnerableservices from a network security point of view. An attacker withaccess to your <SPANCLASS="acronym">NFS</SPAN> server can probably read anyfile on your system. An attacker with access to your<SPANCLASS="acronym">NIS/YP</SPAN> server can probably obtain your passwordfile, on which he can run a password-cracking attack against yoursystem.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4772"></A>In the <SPANCLASS="acronym">TCP</SPAN> and <SPANCLASS="acronym">UDP</SPAN> protocols,port numbers are two-byte fields. This means that there are only65,536 possible port numbers for <SPANCLASS="acronym">TCP</SPAN> and<SPANCLASS="acronym">UDP</SPAN> services. There aren't enough ports to be ableto assign a unique well-known port number to every possible serviceand application that might want one. Among other things,<SPANCLASS="acronym">RPC</SPAN> addresses this limitation. Each<SPANCLASS="acronym">RPC</SPAN>-based service is assigned a unique four-byte&quot;<SPANCLASS="acronym">RPC</SPAN> service number.&quot; This allows for4,294,967,296 different services, each with a unique number. That'smore than enough to assign a unique number to every possible serviceand application you'd need.</P><PCLASS="para"><SPANCLASS="acronym">RPC</SPAN> is built on top of <SPANCLASS="acronym">TCP</SPAN> and<SPANCLASS="acronym">UDP</SPAN> so there needs to be some way of mapping the<SPANCLASS="acronym">RPC</SPAN> service numbers of the<SPANCLASS="acronym">RPC</SPAN>-based servers in use on a machine to theparticular <SPANCLASS="acronym">TCP</SPAN> or <SPANCLASS="acronym">UDP</SPAN> portsthose servers are using. This is where the<EMCLASS="emphasis">portmapper</EM> server comes in.</P><PCLASS="para"><ACLASS="indexterm"NAME="CH06RPCPORT"></A><ACLASS="indexterm"NAME="CH06PORTMAP"></A>The <EMCLASS="emphasis">portmapper</EM> is the only<SPANCLASS="acronym">RPC</SPAN>-related server that is guaranteed to run on aparticular <SPANCLASS="acronym">TCP</SPAN> or <SPANCLASS="acronym">UDP</SPAN> portnumber (it is at port number 111 on both). When an<SPANCLASS="acronym">RPC</SPAN>-based server such as an <SPANCLASS="acronym">NFS</SPAN>or <SPANCLASS="acronym">NIS/YP</SPAN> server starts, it allocates a random<SPANCLASS="acronym">TCP</SPAN> and/or <SPANCLASS="acronym">UDP</SPAN> (some use one,some the other, some both) port for itself.[3]Then, it contacts the <EMCLASS="emphasis">portmapper</EM> server on thesame machine to &quot;register&quot; its unique<SPANCLASS="acronym">RPC</SPAN> service number and the particular port(s)it is using at the moment.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] Actually, most <SPANCLASS="acronym">NFS</SPAN> implementations that we've seenalways use port 2049; however, we're not willing to assume that<SPANCLASS="acronym">NFS</SPAN> always will use that port, in everyimplementation. In fact, <SPANCLASS="acronym">RFC</SPAN> 1094, the<SPANCLASS="acronym">NFS</SPAN> protocol specification, says &quot;The<SPANCLASS="acronym">NFS</SPAN> protocol currently uses the<SPANCLASS="acronym">UDP</SPAN> port number 2049. This is not an officiallyassigned port, so later versions of the protocol use the`Portmapping' facility of <SPANCLASS="acronym">RPC</SPAN>.&quot;</P></BLOCKQUOTE><PCLASS="para">An <SPANCLASS="acronym">RPC</SPAN>-based client program that wishes to contacta particular <SPANCLASS="acronym">RPC</SPAN>-based server on a machine firstcontacts the <EMCLASS="emphasis">portmapper</EM> server on that machine(which, remember, always runs on both <SPANCLASS="acronym">TCP</SPAN> and<SPANCLASS="acronym">UDP</SPAN> port 111). The client tells<EMCLASS="emphasis">portmapper</EM> the unique <SPANCLASS="acronym">RPC</SPAN>service number for the server it wishes to access, and<EMCLASS="emphasis">portmapper</EM> responds with a message saying, ineffect, either &quot;I'm sorry, but that service isn't available onthis machine at the moment,&quot; or &quot;That service is currentlyrunning on <SPANCLASS="acronym">TCP</SPAN> (or <SPANCLASS="acronym">UDP</SPAN>) port<EMCLASS="emphasis">N</EM> on this machine at the moment.&quot; At thatpoint, the client contacts the server on the port number it got fromthe <EMCLASS="emphasis">portmapper</EM>, and continues its conversationdirectly with the server, without further involvement from the<EMCLASS="emphasis">portmapper</EM>. (<ACLASS="xref"HREF="ch06_03.htm#FIRE-06-FIG-7"TITLE="RPC and the portmapper">Figure 6.7</A>shows this process.)</P><H4CLASS="figure"><ACLASS="title"NAME="FIRE-06-FIG-7">Figure 6.7: <SPANCLASS="acronym">RPC</SPAN> and the portmapper</A></H4><IMGCLASS="graphic"SRC="figs/fire0607.gif"ALT="Figure 6.7"><PCLASS="para">It's very difficult to use packet filtering to control<SPANCLASS="acronym">RPC</SPAN>-based services, because you don't know whatport the service will be using on a particular machine&nbsp;- and chancesare that the port used will change every time the machine isrebooted. Blocking access to the <EMCLASS="emphasis">portmapper</EM> isn'tsufficient. An attacker can bypass the step of talking to the<EMCLASS="emphasis">portmapper</EM>, and simply try all<SPANCLASS="acronym">TCP</SPAN> and/or <SPANCLASS="acronym">UDP</SPAN> ports (the 65,536possible ports can all be checked on a particular machine in a matterof minutes), looking for the response expected from a particular<SPANCLASS="acronym">RPC</SPAN>-based server like <SPANCLASS="acronym">NFS</SPAN> or<SPANCLASS="acronym">NIS/YP</SPAN>.</P><PCLASS="para">Some newer packet filtering products can talk to<EMCLASS="emphasis">portmapper</EM> to determine what services are whereand filter on that basis. Note that this has to be verified on aper-packet basis for <SPANCLASS="acronym">UDP</SPAN>-based services. The packetfilter will have to contact <EMCLASS="emphasis">portmapper</EM> every time it receives apacket, because if the machine has rebooted, the service may havemoved. Because <SPANCLASS="acronym">TCP</SPAN> is connection-oriented, the portnumber only has to be verified on a per-connection basis. Using thismechanism to allow <SPANCLASS="acronym">UDP</SPAN>-based services is going toresult in high overhead and is probably not wise for data-intenseapplications like <SPANCLASS="acronym">NFS</SPAN>.</P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> Even though it is not sufficient, you should still block access to the<EMCLASS="emphasis">portmapper</EM>, because some versions of<EMCLASS="emphasis">portmapper</EM> are capable of being used as proxiesfor an attacker's clients.<ACLASS="indexterm"NAME="AUTOID-4856"></A><ACLASS="indexterm"NAME="AUTOID-4857"></A></P></BLOCKQUOTE><PCLASS="para">So, what do you do to guard <SPANCLASS="acronym">RPC</SPAN>-based services? Acouple of observations: First, it turns out that most of the&quot;dangerous&quot; <SPANCLASS="acronym">RPC</SPAN>-based services(particularly <SPANCLASS="acronym">NIS/YP</SPAN> and <SPANCLASS="acronym">NFS</SPAN>)are offered only over <SPANCLASS="acronym">UDP</SPAN>. Second, most servicesyou'd want to access through a packet filter are<SPANCLASS="acronym">TCP</SPAN>-based, <EMCLASS="emphasis">not</EM><SPANCLASS="acronym">UDP</SPAN>-based; the notable exceptions are<SPANCLASS="acronym">DNS</SPAN>, <SPANCLASS="acronym">NTP</SPAN>,<EMCLASS="emphasis">syslog</EM>, and Archie. These twin observations leadto the common approach many sites take in dealing with<SPANCLASS="acronym">RPC</SPAN> using packet filtering: block<SPANCLASS="acronym">UDP</SPAN> altogether, except for specific and tightlycontrolled &quot;peepholes&quot; for <SPANCLASS="acronym">DNS</SPAN>,<SPANCLASS="acronym">NTP</SPAN>, syslog and Archie. (See the discussion ofthese services in <ACLASS="xref"HREF="ch08_01.htm"TITLE="Configuring Internet Services">Chapter 8</A>.)</P><PCLASS="para">With this approach, if you wish to allow any <SPANCLASS="acronym">TCP</SPAN>-based<SPANCLASS="acronym">RPC</SPAN> service, you'll need to allow themall. <SPANCLASS="acronym">TCP</SPAN>-based <SPANCLASS="acronym">NFS</SPAN> servers,while available, are not yet widely used; if you're using them,however, you'll need to modify this approach accordingly.<ACLASS="indexterm"NAME="AUTOID-4880"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="FIRE-06-S3-10">6.3.3.5 <SPANCLASS="acronym">IP</SPAN> over <SPANCLASS="acronym">IP</SPAN></A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4886"></A><ACLASS="indexterm"NAME="AUTOID-4889"></A><ACLASS="indexterm"NAME="AUTOID-4893"></A><ACLASS="indexterm"NAME="AUTOID-4895"></A>In some circumstances, <SPANCLASS="acronym">IP</SPAN> packets are encapsulatedwithin other <SPANCLASS="acronym">IP</SPAN> packets for transmission, yieldingso-called &quot;<SPANCLASS="acronym">IP</SPAN> over<SPANCLASS="acronym">IP.</SPAN>&quot; The most common use of<SPANCLASS="acronym">IP</SPAN> over <SPANCLASS="acronym">IP</SPAN> is to carry multicast<SPANCLASS="acronym">IP</SPAN> packets (that is, packets with multicastdestination addresses) between networks that do support multicasting<ACLASS="indexterm"NAME="AUTOID-4904"></A><ACLASS="indexterm"NAME="AUTOID-4907"></A>over intermediate networks that don't. To cross these intermediatenetworks, a special multicast router (or <EMCLASS="emphasis">mrouter</EM>) oneach multicast network encapsulates the multicast<SPANCLASS="acronym">IP</SPAN> packets that it wants to send into nonmulticast(i.e., normal) <SPANCLASS="acronym">IP</SPAN> packets addressed to other<EMCLASS="emphasis">mrouter</EM>s. The other <EMCLASS="emphasis">mrouter</EM>s, upon receiving these encapsulatedmulticast packets, strip off the outer (nonmulticast) packet and thenhandle the inner (multicast) packet.</P><PCLASS="para">Multicast <SPANCLASS="acronym">IP</SPAN> is becoming more and more popular onthe Internet, primarily because of the conferencing and other servicesoffered through the <SPANCLASS="acronym">MBONE</SPAN>. We discuss the <SPANCLASS="acronym">MBONE</SPAN>, and multicastservices in general, in more detail in <ACLASS="xref"HREF="ch02_01.htm"TITLE="Internet Services">Chapter 2, <CITECLASS="chapter">Internet Services</CITE></A>and <ACLASS="xref"HREF="ch08_01.htm"TITLE="Configuring Internet Services">Chapter 8</A>.<ACLASS="indexterm"NAME="AUTOID-4920"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="FIRE-06-S2-9">6.3.4 Protocols Below <SPANCLASS="acronym">IP</SPAN></A></H3><PCLASS="para">It's theoretically possible to filter on information from below the<SPANCLASS="acronym">IP</SPAN> level&nbsp;- for example, the Ethernet hardwareaddress. However, doing so is very rarely useful because in mostcases, all packets from the outside are coming from the same hardwareaddress (the address of the router that handles your Internetconnection). Furthermore, many routers have multiple connections withdifferent lower-level protocols. As a result, doing filtering atlower levels would require configuring different interfaces withdifferent kinds of rules for the different lower-level protocols. Youcouldn't write one rule to apply to all interfaces on a router thathad two Ethernet connections and an <SPANCLASS="acronym">FDDI</SPAN>connection, because the headers of Ethernet and<SPANCLASS="acronym">FDDI</SPAN> packets, while similar, are not identical. Inpractice, <SPANCLASS="acronym">IP</SPAN> is the lowest level protocol at whichpeople choose to do packet filtering.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="FIRE-06-S2-10">6.3.5 Application Layer Protocols</A></H3><PCLASS="para">In most cases, there is a further protocol on top of<SPANCLASS="acronym">TCP</SPAN> or <SPANCLASS="acronym">UDP</SPAN>, specific to theapplication. These protocols differ widely in their specificity, andthere are hundreds, if not thousands, of them (almost as many as thereare network-based applications). Some newer packet filteringapplications provide the ability to filter on application-layerprotocols for particular well-known applications. For example, theymay be able to recognize particular information in an<SPANCLASS="acronym">FTP</SPAN> transaction in order to set up dynamic filters,or they may be able to compare the information in a packet to theapplication that it's supposed to be going to, to be sure that packetsaddressed to a <SPANCLASS="acronym">DNS</SPAN> port are actually DNS packets.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="FIRE-06-S2-11">6.3.6 <SPANCLASS="acronym">IP</SPAN> Version 6</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="CH06IPV6"></A>The current version of<SPANCLASS="acronym">IP</SPAN> (at the time this book was written)is officially known as <SPANCLASS="acronym">IP</SPAN>Version 4; throughout this book, whenever we talk about<SPANCLASS="acronym">IP</SPAN> with no further qualification, that's what we'retalking about. There is, however, a new version of<SPANCLASS="acronym">IP</SPAN> in the works right now, known as<SPANCLASS="acronym">IP</SPAN> Version 6 (<SPANCLASS="acronym">IP</SPAN>v6 forshort). Why do we need a new version of <SPANCLASS="acronym">IP</SPAN>, and howwill <SPANCLASS="acronym">IP</SPAN>v6 affect you?</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4952"></A>As we mentioned in the section called &quot;What the FutureHolds&quot; in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Firewall Design">Chapter 4, <CITECLASS="chapter">Firewall Design</CITE></A>, the impetus to create<SPANCLASS="acronym">IP</SPAN>v6 was one simple problem: the Internet isrunning out of <SPANCLASS="acronym">IP</SPAN> addresses. The Internet hasbecome so popular that there just won't be enough<SPANCLASS="acronym">IP</SPAN> network numbers (particularly Class B networknumbers, which have proven to be what most sites need) to go around;by some estimates, if nothing had been done, the Internet would haverun out of addresses in 1995 or 1996. Fortunately, the problem wasrecognized, and something was done. Two things, actually&nbsp;- first, theimplementation of a set of temporary measures and guidelines to makebest possible use of the remaining unassigned addresses, and second,the design and implementation of a new version of<SPANCLASS="acronym">IP</SPAN> that would permanently deal with theaddress-exhaustion issue.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4961"></A>If you're going to create a new version of <SPANCLASS="acronym">IP</SPAN> inorder to deal with address-space exhaustion, you might as well takeadvantage of the opportunity to deal with a whole raft of otherproblems or limitations in <SPANCLASS="acronym">IP</SPAN> as well, such asencryption, authentication, source routing, and dynamicconfiguration. According to Steve Bellovin of<SPANCLASS="acronym">AT&T</SPAN> Bell Laboratories, a well-known firewallsexpert on the Internet and a participant in the<SPANCLASS="acronym">IP</SPAN>v6 design process:[4]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] Steve Bellovin, posting to the Firewalls mailing list, December 31, 1994.</P></BLOCKQUOTE><BLOCKQUOTECLASS="blockquote"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4972"></A><SPANCLASS="acronym">IP</SPAN>v6 is based on the concept of nestedheaders. That's how encryption and authentication are done; the&quot;next protocol&quot; field after the <SPANCLASS="acronym">IP</SPAN>v6header specifies an encryption or an authentication header. In turn,their next protocol fields would generally indicate either<SPANCLASS="acronym">IP</SPAN>v6 or one of the usual transport protocols, suchas <SPANCLASS="acronym">TCP</SPAN> or <SPANCLASS="acronym">UDP</SPAN>.</P><PCLASS="para">Nested <SPANCLASS="acronym">IP</SPAN> over <SPANCLASS="acronym">IP</SPAN> can be doneeven without encryption or authentication; that can be used as a formof source routing. A more efficient way is to use the source routingheader&nbsp;- which is more useful than the corresponding<SPANCLASS="acronym">IP</SPAN>v4 option, and is likely to be used much more,especially for mobile <SPANCLASS="acronym">IP</SPAN>.</P><PCLASS="para">Some of the implications for firewalls are already apparent. A packetfilter must follow down the full chain of headers, understanding andprocessing each one in turn. (And yes, this can make looking at portnumbers more expensive.) A suitably cautious stance dictates that apacket with an unknown header be bounced, whether inbound or outbound.Also, the ease and prevalence of source routing means that cryptographicauthentication is absolutely necessary. On the other hand, it isintended that such authentication be a standard, mandatory feature. Encrypted packets are opaque, and hence can't be examined; this is truetoday, of course, but there aren't very many encryptors in use now. That will change. Also note that encryption can be done host-to-host,host-to-gateway, or gateway-to-gateway, complicating the analysis stillmore. </P><PCLASS="para">Address-based filtering will also be affected, to some extent, by the newautoconfiguration mechanisms. It's vital that any host whose address ismentioned in a filter receive the same address each time. While this isthe intent of the standard mechanisms, one needs to be careful aboutproprietary schemes, dial-up servers, etc. Also, high-order addressbits can change, to accommodate the combination of provider-basedaddressing and easy switching among carriers. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4988"></A>Finally, <SPANCLASS="acronym">IP</SPAN>v6 incorporates&quot;flows.&quot; Flows are essentially virtual circuits at the<SPANCLASS="acronym">IP</SPAN> level; they're intended to be used for thingslike video, intermediate-hop <SPANCLASS="acronym">ATM</SPAN> circuit selection,etc. But they can also be used for firewalls, given appropriateauthentication: the <SPANCLASS="acronym">UDP</SPAN> reply problem might go awayif the query had a flow id that was referenced by the response. This,by the way, is a vague idea of mine; there are no standards for howthis should be done. The regular flow setup protocol won't work; it'stoo expensive. But a firewall traversal header might do the job.</P></BLOCKQUOTE><PCLASS="para">As you can see, <SPANCLASS="acronym">IP</SPAN>v6 could have a major impact onfirewalls, especially with respect to packet filtering. As this bookis being written, though, it's still too soon to tell just what thoseeffects will be, and when we'll start to feel them.</P><PCLASS="para">Keep in mind that <SPANCLASS="acronym">IP</SPAN>v6 won't be deployedovernight. <SPANCLASS="acronym">IP</SPAN>v4 will be around for a long time, andmany sites will continue to run it through the foreseeable future. The<SPANCLASS="acronym">IP</SPAN>v6 designers are very sensitive to the transitionissues, and a lot of attention is being paid to that area, and tovarious migration strategies sites might employ.<ACLASS="indexterm"NAME="AUTOID-5000"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="FIRE-06-S2-12">6.3.7 Non-<SPANCLASS="acronym">IP</SPAN> Protocols</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5005"></A>Other protocols at the same level as <SPANCLASS="acronym">IP</SPAN>, e.g.,AppleTalk and <SPANCLASS="acronym">IPX</SPAN>, provide similar kinds ofinformation as <SPANCLASS="acronym">IP</SPAN>, although the headers andoperations for these protocols, and, therefore their packet filteringcharacteristics, vary radically. Most packet filtering implementationssupport <SPANCLASS="acronym">IP</SPAN> filtering only, and simply dropnon-<SPANCLASS="acronym">IP</SPAN> packets. Some packages provide limitedpacket filtering support for non-<SPANCLASS="acronym">IP</SPAN> protocols, butthis support is usually far less flexible and capable than therouter's <SPANCLASS="acronym">IP</SPAN> filtering capability.</P><PCLASS="para">At this time, packet filtering as a tool isn't as popular and welldeveloped for non-<SPANCLASS="acronym">IP</SPAN> protocols, presumably becausethese protocols are rarely used to communicate outside a singleorganization over the Internet. (The Internet is, by definition, anetwork of <SPANCLASS="acronym">IP</SPAN> networks). Non-<SPANCLASS="acronym">IP</SPAN>protocols are more of an issue for firewalls that are internal to anorganization, and for this application, you would want to choose oneof the packages that supports non-<SPANCLASS="acronym">IP</SPAN> filtering.</P><PCLASS="para">Across the Internet, non-<SPANCLASS="acronym">IP</SPAN> protocols are handledby encapsulating them within <SPANCLASS="acronym">IP</SPAN> protocols. In mostcases, you will be limited to permitting or denying encapsulatedprotocols in their entirety; you can accept allAppletalk-in-<SPANCLASS="acronym">UDP</SPAN> connections, or reject them atall. A few packages that support non-<SPANCLASS="acronym">IP</SPAN> protocolscan recognize these connections when encapsulated and filter on fieldsin them.</P><DIVCLASS="sidebar"><H4CLASS="sidebar"><ACLASS="title"NAME="AUTOID-5025">Filtering by Interface</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5028"></A><ACLASS="indexterm"NAME="AUTOID-5031"></A>There is one key piece of information that would be useful when youare making a packet filtering decision, that can't be found in theheaders of the packet; this is the interface on which the packet cameinto the router or is going out of the router. This is importantinformation because it allows the router to detect forged packets.</P><PCLASS="para">If the sole router between your internal net and the external worldreceives a packet with an internal source address from the internalinterface, there is no problem; all packets coming from the insidewill have internal source addresses. If, however, the router receivesa packet with an internal source address from the external interface,it means either that someone is forging the packet (probably in anattempt to circumvent security), or that there is something seriouslywrong with your network configuration. </P><PCLASS="para">You can get these packets without forgery. For example, someone mighthave set up a second connection between your net and the outsideworld, such as a dial-up <SPANCLASS="acronym">PPP</SPAN> link from a user'sdesk, probably with little or no thought to security. As a result, thetraffic that should be staying internal to your net is&quot;leaking&quot; out through this second connection, going acrossthe Internet, and trying to come back in through your &quot;frontdoor&quot;). There's little you can do to detect such illicit&quot;back door&quot; connections except by detecting internalpackets arriving from the outside; about the best you can do is have astrong and well-publicized policy against them, and provide as many aspossible of the services your users desire through the front door (thefirewall), so that they don't feel a compelling need to create theirown back door.</P><PCLASS="para">These packets should be logged and treated as urgent issues. Ifsomeone is forging them, that person is attacking you with someseriousness. If the packets are leaked from a back door, you have asecurity problem because of the extra Internet connection. You mayalso have a routing problem: a host that claims to be internal andadvertises routes for itself is in danger of getting all of yourinternal network's traffic. This is bad if it's a<SPANCLASS="acronym">PPP</SPAN> link, which is probably not going to handle theload. It's much worse if it's not connected to your network at all,because some or all of your network's traffic is going to disappear.</P></DIV><ACLASS="indexterm"NAME="AUTOID-5038"></A></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Configuring a Packet Filtering Router"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.2 Configuring a Packet Filtering Router"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Building Internet Firewalls"><IMGSRC="../gifs/txthome.gif"ALT="Building Internet Firewalls"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_04.htm"TITLE="6.4 What Does the Router Do with Packets?"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.4 What Does the Router Do with Packets?"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">6.2 Configuring a Packet Filtering Router</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_a.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">6.4 What Does the Router Do with Packets?</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>