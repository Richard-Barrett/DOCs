<HTML><HEAD><TITLE>[Appendix C] C.4 The kill Command</TITLE><METANAME="DC.title"CONTENT="Practical UNIX &amp; Internet Security"><METANAME="DC.creator"CONTENT="Simson Garfinkel &amp; Gene Spafford"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:22:11Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-148-8"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="appc_01.htm"TITLE="C. UNIX Processes"><LINKREL="prev"HREF="appc_03.htm"TITLE="C.3 Signals"><LINKREL="next"HREF="appc_05.htm"TITLE="C.5 Starting Up UNIX and Logging In"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Practical UNIX &amp; Internet Security"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Practical UNIX &amp; Internet Security"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="appc_03.htm"TITLE="C.3 Signals"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: C.3 Signals"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Appendix C<BR>UNIX Processes</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="appc_05.htm"TITLE="C.5 Starting Up UNIX and Logging In"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: C.5 Starting Up UNIX and Logging In"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="PUIS-APP-C-SECT-4">C.4 The kill Command</A></H2><PCLASS="para">You can use the <ACLASS="indexterm"NAME="AUTOID-39806"></A><KBDCLASS="command">kill</KBD> commandto stop or merely pause the execution of a process. You might wantto <KBDCLASS="command">kill</KBD> a &quot;runaway&quot; process that is consuming<SPANCLASS="acronym">CPU</SPAN> and memory for no apparent reason; you mightalso want to kill the processes belonging to an intruder. kill worksby sending a <KBDCLASS="command">signal</KBD> to a process. Particularly useful signals aredescribed in detail below. The syntax of the <KBDCLASS="command">kill</KBD> command is:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><BCLASS="emphasis.bold">kill [-signal] process-IDs </B></PRE></BLOCKQUOTE><PCLASS="para">The <KBDCLASS="command">kill</KBD> command allows signals to be specified by their namesin most modern versions of <SPANCLASS="acronym">UNIX</SPAN>. To send a hangupto process #1, for example, type:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">kill -HUP 1</B></PRE></BLOCKQUOTE><PCLASS="para">With some older versions of <SPANCLASS="acronym">UNIX</SPAN>, you mustspecify the signal by number:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">kill -1 1</B></PRE></BLOCKQUOTE><PCLASS="para">The superuser can kill any process; other users can kill onlytheir own processes. You can kill many processes at a time by listingall of their <SPANCLASS="acronym">PIDS</SPAN> on the command line:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">kill -HUP 1023 3421 3221</B></PRE></BLOCKQUOTE><PCLASS="para">By default, <KBDCLASS="command">kill</KBD> sends signal 15 (<SPANCLASS="acronym">SIGTERM</SPAN>),the process-terminate signal. Berkeley-derived systems also havesome additional options to the <KBDCLASS="command">kill</KBD> command:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">If you specify 0 as the <SPANCLASS="acronym">PID</SPAN>,the signal is sent to all the processes in your process group.</P></LI><LICLASS="listitem"><PCLASS="para">If you specify -1 as a <SPANCLASS="acronym">PID</SPAN>and you are not the superuser, the signal is sent to all processeshaving the same <SPANCLASS="acronym">UID</SPAN> as you.</P></LI><LICLASS="listitem"><PCLASS="para">If you specify -1 as a <SPANCLASS="acronym">PID</SPAN>and you are the superuser, the signal is sent to all processes exceptsystem processes, process #1, and yourself.</P></LI><LICLASS="listitem"><PCLASS="para">If you specify any other negative value, the signalis sent to all processes in the process group numbered the sameas the absolute value of your argument.</P></LI></UL><PCLASS="para">To send any signal, you must have the same real or effective<SPANCLASS="acronym">UID</SPAN> as the target processes or you must be operatingas the superuser.</P><PCLASS="para">Many signals, including <SPANCLASS="acronym">SIGTERM</SPAN>, can be<KBDCLASS="command">caught</KBD> by programs. With a <KBDCLASS="command">caught</KBD> signal, a programmer has threechoices of action:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Ignore it.</P></LI><LICLASS="listitem"><PCLASS="para">Perform the default action.</P></LI><LICLASS="listitem"><PCLASS="para">Execute a program-specified function.</P></LI></UL><PCLASS="para">There are two signals that cannot be caught: signal 9 (<ACLASS="indexterm"NAME="AUTOID-39859"></A><SPANCLASS="acronym">SIGKILL</SPAN>) and signal 17 (<ACLASS="indexterm"NAME="AUTOID-39862"></A><SPANCLASS="acronym">SIGSTOP</SPAN>).</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-39866"></A><ACLASS="indexterm"NAME="AUTOID-39870"></A><ACLASS="indexterm"NAME="AUTOID-39873"></A>Onesignal that is very often sent is signal 1 (<ACLASS="indexterm"NAME="AUTOID-39877"></A><SPANCLASS="acronym">SIGHUP</SPAN>),which simulates a hangup on a modem. Standard practice when killinga process is to first send signal 1 (hangup); if the process doesnot terminate, then send it signal 15 (software terminate), andfinally signal 9 (sure kill).</P><PCLASS="para">Sometimes simply killing a rogue process is the wrong thingto do: you can learn more about a process by stopping it and examiningit with some of <SPANCLASS="acronym">UNIX</SPAN>'s debugging toolsthan by &quot;blowing it out of the water.&quot; Sendinga process a <SPANCLASS="acronym">SIGSTOP</SPAN> will stop the process butwill not destroy the process's memory image.</P><PCLASS="para">Under most modern versions of <SPANCLASS="acronym">UNIX</SPAN>, youcan use the <ACLASS="indexterm"NAME="AUTOID-39885"></A><ACLASS="indexterm"NAME="AUTOID-39887"></A><ACLASS="indexterm"NAME="AUTOID-39889"></A>gcoreprogram to generate a core file of a running process, which youcan then leisurely examine with <ACLASS="indexterm"NAME="AUTOID-39892"></A><ACLASS="indexterm"NAME="AUTOID-39894"></A><ACLASS="indexterm"NAME="AUTOID-39896"></A><KBDCLASS="command">adb</KBD> (a debugger), <KBDCLASS="command">dbx</KBD> (another debugger), or<KBDCLASS="command">gdb</KBD> (yet another debugger). If you simply want to get an idea ofwhat the process was doing, you can run strings (a programthat finds printable strings in a binary file) over the core imageto see what files it was referencing.</P><PCLASS="para">A core file is a specially formatted image of the memory beingused by the process at the time the signal was caught. By examiningthe core file, you can see what routines were being executed, registervalues, and more. You can also fill your disk with a core file&nbsp;- besure to look at the memory size of a process via the ps commandbefore you try to get its core image!</P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> Some versions of <SPANCLASS="acronym">UNIX</SPAN> name core files<ICLASS="filename">core.####</I>, where <ICLASS="filename">####</I>is the <SPANCLASS="acronym">PID</SPAN> of the process that generated thecore file, or <ICLASS="filename">name.core</I>, where <ICLASS="filename">name</I> is thename of the program's executable.</P></BLOCKQUOTE><PCLASS="para">Programs that you run may also dump core if they receive oneof the signals that causes a core dump. On systems without a <KBDCLASS="command">gcore</KBD>program, you can send a <SPANCLASS="acronym">SIGEMT</SPAN> or <SPANCLASS="acronym">SIGSYS</SPAN>signal to cause the program to dump core. That method will workonly if the process is currently in a directory where it can write,if it has not redefined the action to take on receiving the signal,and if the core will not be larger than the core file limits imposedfor the process's <SPANCLASS="acronym">UID</SPAN>. If you use thisapproach, you will also be faced with the problem of finding wherethe process left the core file!</P></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="appc_03.htm"TITLE="C.3 Signals"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: C.3 Signals"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Practical UNIX &amp; Internet Security"><IMGSRC="../gifs/txthome.gif"ALT="Practical UNIX &amp; Internet Security"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="appc_05.htm"TITLE="C.5 Starting Up UNIX and Logging In"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: C.5 Starting Up UNIX and Logging In"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">C.3 Signals</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">C.5 Starting Up UNIX and Logging In</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>