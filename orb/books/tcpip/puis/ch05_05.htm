<HTML><HEAD><TITLE>[Chapter 5] 5.5 SUID</TITLE><METANAME="DC.title"CONTENT="Practical UNIX &amp; Internet Security"><METANAME="DC.creator"CONTENT="Simson Garfinkel &amp; Gene Spafford"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:01:54Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-148-8"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch05_01.htm"TITLE="5. The UNIX Filesystem"><LINKREL="prev"HREF="ch05_04.htm"TITLE="5.4 Using Directory Permissions"><LINKREL="next"HREF="ch05_06.htm"TITLE="5.6 Device Files"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Practical UNIX &amp; Internet Security"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Practical UNIX &amp; Internet Security"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_04.htm"TITLE="5.4 Using Directory Permissions"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.4 Using Directory Permissions"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 5<BR>The UNIX Filesystem</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_06.htm"TITLE="5.6 Device Files"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.6 Device Files"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5">5.5 SUID</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5428"></A><ACLASS="indexterm"NAME="AUTOID-5430"></A><ACLASS="indexterm"NAME="AUTOID-5433"></A><ACLASS="indexterm"NAME="AUTOID-5436"></A>Sometimes, unprivilegedusers must be able to accomplish tasks that require privileges.An example is the <KBDCLASS="command">passwd</KBD> <ACLASS="indexterm"NAME="AUTOID-5440"></A>program, whichallows you to change your password. Changing a user's passwordrequires modifying the password field in the <ICLASS="filename">/etc/passwd</I>file. However, you should not give a user access to change thisfile directly&nbsp;- the user could change everybody else'spassword as well! Likewise, the <KBDCLASS="command">mail</KBD> program requires that you beable to insert a message into the mailbox of another user, yet youshould not to give one user unrestricted access to another'smailbox.</P><PCLASS="para">To get around these problems, <SPANCLASS="acronym">UNIX</SPAN> allowsprograms to be endowed with privilege. Processes executing theseprograms can assume another <SPANCLASS="acronym">UID</SPAN> or <SPANCLASS="acronym">GID</SPAN>when they're running. A program that changes its <SPANCLASS="acronym">UID</SPAN>is called a <SPANCLASS="acronym">SUID</SPAN> program (<EMCLASS="emphasis">set-UID</EM>);a program that changes its <SPANCLASS="acronym">GID</SPAN> is called a <SPANCLASS="acronym">SGID</SPAN>program (<EMCLASS="emphasis">set-GID)</EM>. A program can be both SUIDand SGID at the same time.</P><PCLASS="para">When a SUID program is run, its <ACLASS="indexterm"NAME="AUTOID-5456"></A>effectiveUID[22]becomes that of theowner of the file, rather than of the user who is running it. Thisconcept is so clever that <SPANCLASS="acronym">AT&T</SPAN> patented it.[23]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[22] We explained effective UID in &quot;Real and EffectiveUIDs&quot; in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Users, Groups, and the Superuser">Chapter 4, <CITECLASS="chapter">Users, Groups, and the Superuser</CITE></A>.</P><PCLASS="para">[23] However, the patent has since been released into the publicdomain, as should all software patents, if software patents shouldbe allowed at all.</P></BLOCKQUOTE><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.1">5.5.1 SUID, SGID, and Sticky Bits</A></H3><PCLASS="para">If a <ACLASS="indexterm"NAME="AUTOID-5467"></A><ACLASS="indexterm"NAME="AUTOID-5469"></A><ACLASS="indexterm"NAME="AUTOID-5472"></A>program is SUID or SGID, the output of the <KBDCLASS="command">ls -l</KBD> command will have the <EMCLASS="emphasis">x</EM> in the display changed to an <EMCLASS="emphasis">s</EM>.If the program is sticky, the last <EMCLASS="emphasis">x</EM> changes to a t as shownin <ACLASS="xref"HREF="ch05_05.htm#PUIS-CHP-5-TAB-13"TITLE="SUID, SGID, and Sticky Bits">Table 5.13</A> and <ACLASS="xref"HREF="ch05_05.htm#PUIS-CHP-5-FIG-3"TITLE="Additional file permissions">Figure 5.3</A>.</P><H4CLASS="figure"><ACLASS="title"NAME="PUIS-CHP-5-FIG-3">Figure 5.3: Additional file permissions</A></H4><IMGCLASS="graphic"SRC="figs/puis_0503.gif"ALT="Figure 5.3"><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="PUIS-CHP-5-TAB-13">Table 5.13: SUID, SGID, andSticky Bits</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Contents</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Permission</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Meaning</P></TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">---s------</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">SUID</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">A process that execs a SUID program hasits effective UID set to be the UID of the program's owner.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">------s---</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">SGID</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">A process that execs a SGID program hasits effective GID changed to the program's GID. Files createdby the process can have their primary group set to this GID as well,depending on the permissions of the directory in which the filesare created. Under Berkeley-derived UNIX, a process that execs anSGID program also has the program's GID temporarily addedto the process's list of GIDs.Solaris and other System V-derived versions of UNIX use the SGID bit on datafiles to enable mandatory file locking.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">---------t</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">sticky</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">This is obsolete with files, but is usedfor directories. See &quot;The Origin of `Sticky'&quot; sidebar later in this chapter.</P></TD></TR></TBODY></TABLE><DIVCLASS="sidebar"><H4CLASS="sidebar"><ACLASS="title"NAME="AUTOID-5519">The Origin of &quot;Sticky&quot;</A></H4><PCLASS="para">A very long time ago, <SPANCLASS="acronym">UNIX</SPAN> ran on machineswith much less memory than today: 64 kilobytes, for instance. Thisamount of memory was expected to contain a copy of the operatingsystem, I/O buffers, and running programs. This memoryoften wasn't sufficient when there were several large programsrunning at the same time.</P><PCLASS="para">To make the most of the limited memory, <SPANCLASS="acronym">UNIX</SPAN><ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-5526"></A><ACLASS="indexterm"NAME="AUTOID-5528"></A>swapped</I> processesto and from secondary storage as their turns at the CPU ended. Whena program was started, <SPANCLASS="acronym">UNIX</SPAN> would determine theamount of storage that might ultimately be needed for the program,its stack, and all its data. It then allocated a set of blocks onthe swap partition of the disk or drum attached to the system. (Manysystems still have a <ICLASS="filename">/dev/swap</I>, or a <KBDCLASS="command">swapper</KBD>process that is a holdover from these times.)</P><PCLASS="para">Each time the process got a turn from the scheduler, <SPANCLASS="acronym">UNIX</SPAN>would <ICLASS="firstterm">swap in</I> the program and data, if needed, execute for a while,and then <ICLASS="firstterm">swap out</I> the memory copy if the space was needed for thenext process. When the process exited or <ICLASS="filename">exec</I>'danother program, the swap space was reclaimed for use elsewhere.If there was not enough swap space to hold the process'smemory image, the user got a &quot;No memory error &quot;(still possible on many versions of <SPANCLASS="acronym">UNIX</SPAN> if alarge stack or heap is involved.)</P><PCLASS="para">Obviously, this is a great deal of I/O traffic thatcould slow computation. So, one of the eventual steps was developmentof compiler technology that constructed executable files with twoparts: <ICLASS="firstterm">pure</I> code that would not change, and everything else. Thesewere indicated with a special <ICLASS="firstterm">magic number</I> in the header insidethe file. When the program was first executed, the program and datawere copied to their swap space on disk first, then brought intomemory to execute. However, when the time comes to <EMCLASS="emphasis">swap</EM> out, thecode portions were not written to disk &nbsp;-  they would nothave changed from what was already on disk! This change was a bigsavings.</P><PCLASS="para">The next obvious step was to stop some of that extra disk-to-diskcopying at start-up time. Programs that were run frequently&nbsp;- suchas <KBDCLASS="command">cc</KBD>, <KBDCLASS="command">ed</KBD>, and <KBDCLASS="command">rogue</KBD>&nbsp;- could share the same program pages.Furthermore, even if no copy was currently running, we could expectanother one to be run soon. Therefore, keeping the pages in memoryand on the swap partition, even while we weren't usingthem, made sense. The &quot;sticky bit&quot; was added tomark those programs as worth saving.</P><PCLASS="para">Since those times, larger memories and better memory managementmethods have largely removed the original need for the sticky bit.<ACLASS="indexterm"NAME="AUTOID-5549"></A></P></DIV><PCLASS="para">In each of the cases above, the designator letter is capitalizedif the bit is set, and the corresponding execute bit is not set.Thus, a file that has its sticky and <SPANCLASS="acronym">SGID</SPAN> bitsset, and is otherwise mode 444, would appear in an ls listing as</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <BCLASS="emphasis.bold">ls -l /tmp/example</B> -r--r-Sr-T 1 root    user    12324 Mar 26 1995 /tmp/example </PRE></BLOCKQUOTE><PCLASS="para">An example of a <SPANCLASS="acronym">SUID</SPAN> program is the <KBDCLASS="command">su</KBD> command, introduced in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Users, Groups, and the Superuser">Chapter 4</A>:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <BCLASS="emphasis.bold">ls -l /bin/su </B>-rwsr-xr-x 1 root    user    16384 Sep 3 1989 /bin/su%</PRE></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.2">5.5.2 Problems with SUID</A></H3><PCLASS="para">Any program can be <SPANCLASS="acronym">SUID</SPAN>, <SPANCLASS="acronym">SGID</SPAN>,or both <SPANCLASS="acronym">SUID</SPAN> and <SPANCLASS="acronym">SGID</SPAN>. Becausethis feature is so general, <SPANCLASS="acronym">SUID/SGID</SPAN> can openup some interesting security problems.</P><PCLASS="para">For example, any user can become the superuser simply by runninga <SPANCLASS="acronym">SUID</SPAN> copy of <ACLASS="indexterm"NAME="AUTOID-5571"></A><ACLASS="indexterm"NAME="AUTOID-5573"></A><KBDCLASS="command">csh</KBD> that is owned by <ICLASS="systemitem.username">root</I>.Fortunately, you must be <ICLASS="systemitem.username">root</I>already to create a <SPANCLASS="acronym">SUID</SPAN> version of <KBDCLASS="command">csh</KBD> thatis owned by <ICLASS="systemitem.username">root</I>. Thus,an important objective in running a secure <SPANCLASS="acronym">UNIX</SPAN>computer is to ensure that somebody who has superuser privilegeswill not leave a <SPANCLASS="acronym">SUID</SPAN> <KBDCLASS="command">csh</KBD> on the system, directlyor indirectly.</P><PCLASS="para">If <ACLASS="indexterm"NAME="AUTOID-5585"></A>you leave your terminalunattended, an unscrupulous passerby can destroy the security ofyour account simply by typing the commands:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <BCLASS="emphasis.bold">cp /bin/sh /tmp/break-acct </B>%<BCLASS="emphasis.bold"> chmod 4755 /tmp/break-acct</B>%</PRE></BLOCKQUOTE><PCLASS="para">These commands create a <SPANCLASS="acronym">SUID</SPAN> version ofthe <ACLASS="indexterm"NAME="AUTOID-5592"></A><KBDCLASS="command">sh</KBD> program. Wheneverthe attacker runs this program, the attacker becomes you&nbsp;- withfull access to all of your files and privileges. The attacker mighteven copy this <SPANCLASS="acronym">SUID</SPAN> program into a hidden directoryso that it would only be found if the superuser scanned the entiredisk for <SPANCLASS="acronym">SUID</SPAN> programs. Not all system administratorsdo such scanning on any regular basis.</P><PCLASS="para">Note that the program copied need not be a shell. Someonewith malicious intent can cause you misery by creating a <SPANCLASS="acronym">SUID</SPAN>version of other programs. For instance, consider a <SPANCLASS="acronym">SUID</SPAN>version of the editor program. With it, not only can he read orchange any of your files, but he can also spawn a shell runningunder your <SPANCLASS="acronym">UID</SPAN>.</P><PCLASS="para">Most <SPANCLASS="acronym">SUID</SPAN> system programs are <SPANCLASS="acronym">SUID</SPAN><ICLASS="systemitem.username">root</I>; that is, theybecome the superuser when they're executing. In theory,this aspect is not a security hole, because a compiled program canperform only the function or functions that were compiled into it.(That is, you can change your password with the <KBDCLASS="command">passwd</KBD> program,but you cannot alter the program to change somebody else'spassword.) But many security holes have been discovered by peoplewho figured out ways of making a <SPANCLASS="acronym">SUID</SPAN> programdo something that it was not designed to do. In many circumstances,programs that are <SPANCLASS="acronym">SUID</SPAN> <ICLASS="systemitem.username">root</I>could easily have been designed to be <SPANCLASS="acronym">SUID</SPAN> somethingelse (such as <ICLASS="systemitem.username">daemon</I>, or some <SPANCLASS="acronym">UID</SPAN> created especiallyfor the purpose). Too often, <SPANCLASS="acronym">SUID</SPAN> <ICLASS="systemitem.username">root</I> is used when somethingwith less privilege would be sufficient.</P><PCLASS="para">In <ACLASS="xref"HREF="ch23_01.htm"TITLE="Writing Secure SUID and Network Programs">Chapter 23, <CITECLASS="chapter">Writing Secure SUID and Network Programs</CITE></A>, we provide some suggestions on howto write more secure programs in <SPANCLASS="acronym">UNIX</SPAN>. If youabsolutely must write a <SPANCLASS="acronym">SUID</SPAN> or <SPANCLASS="acronym">SGID</SPAN>program (and we advise you not to), then consult that chapter first.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.3">5.5.3 SUID Shell Scripts</A></H3><PCLASS="para">Under <ACLASS="indexterm"NAME="AUTOID-5623"></A><ACLASS="indexterm"NAME="AUTOID-5626"></A>most versions of <SPANCLASS="acronym">UNIX</SPAN>,you can create shell scripts[24] that are <SPANCLASS="acronym">SUID</SPAN> or <SPANCLASS="acronym">SGID</SPAN>.That is, you can create a shell script and, by setting the shellscript's owner to be <ICLASS="systemitem.username">root</I>and setting its <SPANCLASS="acronym">SUID</SPAN> bit, you can force the shellscript to execute with superuser privileges.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[24] Actually, any interpretedscripts.</P></BLOCKQUOTE><PCLASS="para">You should never write <SPANCLASS="acronym">SUID</SPAN> shell scripts.</P><PCLASS="para">Because of a fundamental flaw with the <SPANCLASS="acronym">UNIX</SPAN>implementation of shell scripts and <SPANCLASS="acronym">SUID</SPAN>, youcannot execute <SPANCLASS="acronym">SUID</SPAN> shell scripts in a completelysecure manner on systems that do not support the <ICLASS="filename">/dev/fd</I>device. This flaw arises because executing a shell script under<SPANCLASS="acronym">UNIX</SPAN> involves a two-step process: when the <ACLASS="indexterm"NAME="AUTOID-5643"></A>kerneldetermines that a shell script is about to be run, it first startsup a <SPANCLASS="acronym">SUID</SPAN> copy of the shell interpreter, thenthe shell interpreter begins executing the shell script. Becausethese two operations are performed in two discrete steps, you caninterrupt the kernel after the first step and switch the file thatthe shell interpreter is about to execute. In this fashion, an attackercould get the computer to execute any shell script of his or herchoosing, which essentially gives the attacker superuser privileges.Although this flaw is somewhat mitigated by the<ICLASS="filename"> /dev/fd</I>device, even on systems that do support a /dev/fddevice, <SPANCLASS="acronym">SUID</SPAN> shell scripts are very dangerousand should be avoided.</P><PCLASS="para">Some modern <SPANCLASS="acronym">UNIX</SPAN> systems ignore the <SPANCLASS="acronym">SUID</SPAN>and <SPANCLASS="acronym">SGID</SPAN> bits on shell scripts for this reason.Unfortunately, many do not. Instead of writing <SPANCLASS="acronym">SUID</SPAN>shell scripts, we suggest that you use the <ACLASS="indexterm"NAME="AUTOID-5653"></A><ACLASS="indexterm"NAME="AUTOID-5655"></A>Perl programming language for thesekinds of tasks. A version of Perl called<ICLASS="filename"> taintperl</I>[25]will force you to write <SPANCLASS="acronym">SUID</SPAN> scripts that checktheir <SPANCLASS="acronym">PATH</SPAN> environment variable and that do notuse values supplied by users for parameters such as filenames unlessthey have been explicitly &quot;untainted.&quot; Perl hasmany other advantages for system administration work as well. Wedescribe some of them in <ACLASS="xref"HREF="ch23_01.htm"TITLE="Writing Secure SUID and Network Programs">Chapter 23</A>.You can also learn more about Perl from the excellent O'Reillybook, <EMCLASS="emphasis">Programming Perl, </EM>by Larry Wall and RandalL. Schwartz.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[25] Inrelease 5 of Perl, this option is replaced by the -T option to Perl.</P></BLOCKQUOTE><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.3.1">5.5.3.1 write: Example of a possible SUID/SGID securityhole</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5667"></A><ACLASS="indexterm"NAME="AUTOID-5669"></A>Theauthors of <SPANCLASS="acronym">SUID</SPAN> and <SPANCLASS="acronym">SGID</SPAN> programstry to ensure that their software won't create securityholes. Sometimes, however, a <SPANCLASS="acronym">SUID</SPAN> or <SPANCLASS="acronym">SGID</SPAN>program can create a security hole if the program isn'tinstalled in the way the program author planned.</P><PCLASS="para">For example, the <KBDCLASS="command">write</KBD> program, which prints a message onanother user's terminal, is <SPANCLASS="acronym">SGID</SPAN> <ICLASS="systemitem.username">tty</I>.For security reasons, <SPANCLASS="acronym">UNIX</SPAN> doesn't normallylet users read or <KBDCLASS="command">write</KBD> information to another's terminal;if it did, you could <KBDCLASS="command">write</KBD> a program to read another user'skeystrokes, capturing any password that she might type. To let thewrite program function, every user's terminal is also setto be writable by the tty group. Because <KBDCLASS="command">write</KBD> is <SPANCLASS="acronym">SGID</SPAN><ICLASS="systemitem.username">tty</I>, the <KBDCLASS="command">write</KBD> program lets one user <KBDCLASS="command">write</KBD> onto another user'sterminal. It first prints a message that tells the recipient thename of the user who is writing onto her terminal.</P><PCLASS="para">But <KBDCLASS="command">write</KBD> has a potential security hole&nbsp;- its shellescape. By beginning a line with an exclamation mark, the personusing the <KBDCLASS="command">write</KBD> program can cause arbitrary programs to be run bythe shell. (The shell escape is left over from the days before <SPANCLASS="acronym">UNIX</SPAN>had job control. The shell escape made it possible to run anothercommand while you were engaged in a conversation with a person onthe computer using write.) Thus, <KBDCLASS="command">write</KBD> must give up its specialprivileges before it invokes a shell; otherwise, the shell (andany program the user might run) would inherit those privileges aswell.</P><PCLASS="para">The part of the <KBDCLASS="command">write</KBD> program that specifically takes awaythe <ICLASS="systemitem.username">tty</I> group permission before the program starts up the shelllooks like this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">setgid(getgid()); /* Give up effective group privs */ execl(getenv(&quot;SHELL&quot;),&quot;sh&quot;,&quot;-c&quot;,arg,0);</PRE></BLOCKQUOTE><PCLASS="para">Notice that <KBDCLASS="command">write</KBD> changes only its <SPANCLASS="acronym">GID</SPAN>,not its effective <SPANCLASS="acronym">UID</SPAN>. If <KBDCLASS="command">write</KBD> is installed<SPANCLASS="acronym">SUID</SPAN> <ICLASS="systemitem.username">root</I> instead of <SPANCLASS="acronym">SGID</SPAN><ICLASS="systemitem.username">tty</I>, the program will appear to run properly but any program thatthe user runs with the shell escape will actually be run as thesuperuser! An attacker who has broken the security on your systemonce might change the file permissions of the <KBDCLASS="command">write</KBD> program, leavinga hole that he or she could exploit in the future. The program,of course, will still function as before.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.3.2">5.5.3.2 Another SUID example: IFS and the /usr/lib/preservehole</A></H4><PCLASS="para">Sometimes, an interaction between a <SPANCLASS="acronym">SUID</SPAN>program and a system program or library creates a security holethat's unknown to the author of the program. For this reason,it can be extremely difficult to know if a <SPANCLASS="acronym">SUID</SPAN>program contains a security hole or not.</P><PCLASS="para">One <ACLASS="indexterm"NAME="AUTOID-5713"></A><ACLASS="indexterm"NAME="AUTOID-5716"></A><ACLASS="indexterm"NAME="AUTOID-5718"></A><ACLASS="indexterm"NAME="AUTOID-5721"></A><ACLASS="indexterm"NAME="AUTOID-5723"></A><ACLASS="indexterm"NAME="AUTOID-5725"></A><ACLASS="indexterm"NAME="AUTOID-5728"></A>of the most famous examplesof a security hole of this type existed for years in the programcalled <ICLASS="filename">/usr/lib/preserve</I> (which is nowgiven names similar to <ICLASS="filename">/usr/lib/ex3.5preserve</I>).This program, which is used by the <KBDCLASS="command">vi</KBD> and <KBDCLASS="command">ex</KBD> editors, automaticallymakes a backup of the file being edited if the user is unexpectedlydisconnected from the system before writing out changes to the file.The <KBDCLASS="command">preserve</KBD> program writes the changes to a temporary file in aspecial directory, then uses the /bin/mail programto send the user a notification that the file has been saved.</P><PCLASS="para">Because people might be editing a file that was private orconfidential, the directory used by the older version of the <KBDCLASS="command">preserve</KBD>program was not accessible by most users on the system. Therefore,to let the <KBDCLASS="command">preserve</KBD> program write into this directory, and let the<KBDCLASS="command">recover</KBD> program read from it, these programs were made <SPANCLASS="acronym">SUID</SPAN><ICLASS="systemitem.username">root</I>.</P><PCLASS="para">Three details of the <ICLASS="filename">/usr/lib/preserve</I>implementation worked together to allow knowledgeable system crackersto use the program to gain <ICLASS="systemitem.username">root</I> privileges:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para"><KBDCLASS="command">preserve</KBD> was installed <SPANCLASS="acronym">SUID</SPAN>root.</P></LI><LICLASS="listitem"><PCLASS="para"><KBDCLASS="command">preserve</KBD> ran <ICLASS="filename">/bin/mail</I> as the<ICLASS="filename">root</I> user to alert users that their files had been preserved.</P></LI><LICLASS="listitem"><PCLASS="para"><KBDCLASS="command">preserve</KBD> executed the <KBDCLASS="command">mail</KBD> program with the <ACLASS="indexterm"NAME="AUTOID-5759"></A><KBDCLASS="command">system()</KBD> function call.</P></LI></OL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5763"></A><ACLASS="indexterm"NAME="AUTOID-5765"></A>The problemwas that the <KBDCLASS="command">system</KBD> function uses <ICLASS="filename">sh</I> to parsethe string that it executes. There is a little-known shell variablecalled <SPANCLASS="acronym">IFS</SPAN>, the internal field separator, which<KBDCLASS="command">sh</KBD> uses to figure out where the breaks are between words on eachline that it parses. Normally, <SPANCLASS="acronym">IFS</SPAN> is set tothe white space characters: space, tab, and newline. But by setting<SPANCLASS="acronym">IFS</SPAN> to the slash character (/) thenrunning <KBDCLASS="command">vi</KBD>, and then issuing the <ICLASS="filename">preserve</I> command,it was possible to get <ICLASS="filename">/usr/lib/preserve</I>to execute a program in the current directory called <KBDCLASS="command">bin</KBD>. This programwas executed as root. (<KBDCLASS="command">/bin/mail</KBD> got parsed as<KBDCLASS="command">bin</KBD> with the argument <KBDCLASS="command">mail</KBD>.)</P><PCLASS="para">If a user can convince the operating system to run a commandas <ICLASS="filename">root</I>, that user can become <ICLASS="filename">root</I>. To see why this is so, imaginea simple shell script which might be called <KBDCLASS="command">bin</KBD>, and run throughthe hole described earlier:[26]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[26] There is actually a smallbug in this shell script; can you find it?</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># # Shell script to make an SUID-root shell # cd /homes/mydir/bin cp /bin/sh ./sh # Now do the damage! chown root sh chmod 4755 sh </PRE></BLOCKQUOTE><PCLASS="para">This shell script would get a copy of the Bourne shell programinto the user's <KBDCLASS="command">bin</KBD> directory, and then make it <SPANCLASS="acronym">SUID</SPAN><ICLASS="filename">root</I>. Indeed, this is the very way that the problem with <ICLASS="filename">/usr/lib/preserve</I>was exploited by system crackers.</P><PCLASS="para">The preserve program had more privilege than it needed&nbsp;- itviolated a basic security principle called <ACLASS="indexterm"NAME="AUTOID-5793"></A><ICLASS="firstterm">leastprivilege</I>. Least privilege states that a program should have onlythe privileges it needs to perform the particular function it'ssupposed to perform, and no others. In this case, instead of being<SPANCLASS="acronym">SUID</SPAN> <ICLASS="filename">root</I>, <ICLASS="filename">/usr/lib/preserve</I>should have been <SPANCLASS="acronym">SGID</SPAN> <KBDCLASS="command">preserve</KBD>, where <KBDCLASS="command">preserve</KBD>would have been a specially created group for this purpose. Althoughthis restriction would not have completely eliminated the securityhole, it would have made its presence considerably less dangerous.Breaking into the <ICLASS="filename">preserve </I>group would haveonly let the attacker view files that had been preserved.</P><PCLASS="para">Although the <KBDCLASS="command">preserve</KBD> security hole was a part of <SPANCLASS="acronym">UNIX</SPAN>since the addition of <KBDCLASS="command">preserve</KBD> to the <KBDCLASS="command">vi</KBD> editor, it wasn'twidely known until 1986. For a variety of reasons, it wasn'tfixed until a year after it was widely publicized.</P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> If you are using an older version of <SPANCLASS="acronym">UNIX</SPAN>that can't be upgraded, remove the <SPANCLASS="acronym">SUID</SPAN>permission from <ICLASS="filename">/usr/lib/preserve</I> to patchthis security hole.</P></BLOCKQUOTE><PCLASS="para">Newer editions of <SPANCLASS="acronym">UNIX</SPAN> <KBDCLASS="command">sh</KBD> ignore <SPANCLASS="acronym">IFS</SPAN>if the shell is running as <ICLASS="filename">root</I> or if the effective user ID differsfrom the real user ID. Many other shells have similarly been enhanced,but not all have. The idea that there are still programs being shippedby vendors in 1995 with this same <SPANCLASS="acronym">IFS</SPAN> vulnerabilityinside is interesting and very depressing. The general problem hasbeen known for over 10 years, and people are still making the same(dumb) <ACLASS="indexterm"NAME="AUTOID-5819"></A><ACLASS="indexterm"NAME="AUTOID-5822"></A>mistakes. <ACLASS="indexterm"NAME="AUTOID-5824"></A><ACLASS="indexterm"NAME="AUTOID-5827"></A><ACLASS="indexterm"NAME="AUTOID-5829"></A><ACLASS="indexterm"NAME="AUTOID-5832"></A><ACLASS="indexterm"NAME="AUTOID-5834"></A><ACLASS="indexterm"NAME="AUTOID-5836"></A><ACLASS="indexterm"NAME="AUTOID-5839"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.4">5.5.4 Finding All of the SUID and SGID Files</A></H3><PCLASS="para">You <ACLASS="indexterm"NAME="AUTOID-5845"></A><ACLASS="indexterm"NAME="AUTOID-5848"></A>should know the names of all<SPANCLASS="acronym">SUID</SPAN> and <SPANCLASS="acronym">SGID</SPAN> files on yoursystem. If you discover new <SPANCLASS="acronym">SUID</SPAN> or <SPANCLASS="acronym">SGID</SPAN>files, somebody might have created a trap door that they can useat some future time to gain superuser access. You can list all ofthe <SPANCLASS="acronym">SUID</SPAN> and <SPANCLASS="acronym">SGID</SPAN> files onyour system with the command:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">find / \(-perm -004000-o -perm -002000 \) -type f -print</B></PRE></BLOCKQUOTE><PCLASS="para">This <ACLASS="indexterm"NAME="AUTOID-5860"></A><ACLASS="indexterm"NAME="AUTOID-5862"></A><ACLASS="indexterm"NAME="AUTOID-5865"></A><KBDCLASS="command">find</KBD>command starts in the root directory (<ICLASS="filename">/</I>) andlooks for all files that match mode 002000 (<SPANCLASS="acronym">SGID</SPAN>)or mode 004000 (<SPANCLASS="acronym">SUID</SPAN>). The <KBDCLASS="command">-type f</KBD> optioncauses the search to be restricted to files. The <KBDCLASS="command">-print</KBD>option causes the name of every matching file to be printed.</P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> If you are using <ACLASS="indexterm"NAME="AUTOID-5876"></A><SPANCLASS="acronym">NFS</SPAN>, you should execute<ICLASS="filename">find</I> commands only on your file servers. Youshould further restrict the <KBDCLASS="command">find</KBD> command so that it does not tryto search networked disks. Otherwise, use of this command may causean excessive amount of <SPANCLASS="acronym">NFS</SPAN> traffic on your network.To restrict your <ICLASS="filename">find </I>command, use the following:</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><BCLASS="emphasis.bold"># find / \( -local -o -prune \) 		\( -perm -004000 -o -perm -002000 \)  		-type f -print</B> &#13;</PRE></BLOCKQUOTE><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> Alternatively, if your <ACLASS="indexterm"NAME="AUTOID-5888"></A><KBDCLASS="command">find</KBD> command has the<KBDCLASS="command">-xdev</KBD> option, you can use it to prevent <KBDCLASS="command">find</KBD> from crossingfilesystem boundaries. To search the entire filesystem using thisoption means running the command multiple times, once for each mountedpartition.</P></BLOCKQUOTE><PCLASS="para">Be sure that you are the superuser when you run <KBDCLASS="command">find</KBD>, or youmay miss <SPANCLASS="acronym">SUID</SPAN> files hidden in protected directories.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.4.1">5.5.4.1 The ncheck command</A></H4><PCLASS="para">The <ACLASS="indexterm"NAME="AUTOID-5900"></A><ACLASS="indexterm"NAME="AUTOID-5902"></A><KBDCLASS="command">ncheck</KBD>command is an old <SPANCLASS="acronym">UNIX</SPAN> command that prints alist of each file on your system and its corresponding inode number.When used with the <KBDCLASS="command">-s</KBD> option, <KBDCLASS="command">ncheck</KBD> restricts itself tolisting all of the &quot;special&quot; inodes on your system&nbsp;- suchas the devices and <SPANCLASS="acronym">SUID</SPAN> files.</P><PCLASS="para">The <KBDCLASS="command">ncheck</KBD> command runs on a filesystem-by-filesystem basis.For example:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># ncheck -s | cat -ve -/dev/dsk/c0t3d0s0:125     /dev/fd/0513     /dev/fd/1514     /dev/fd/2		...533     /dev/fd/21534     /dev/fd/22535     /dev/fd/233849    /sbin/su3850    /sbin/sulogin</PRE></BLOCKQUOTE><PCLASS="para">(The <ACLASS="indexterm"NAME="AUTOID-5914"></A><KBDCLASS="command">cat -ve</KBD>command is present in the above to print control characters so thatthey will be noticed, and to indicate the end of line for filenamesthat end in spaces.)</P><PCLASS="para">The <KBDCLASS="command">ncheck</KBD> command is very old, and has largely been supersededby other commands. It may not be present on all versions of <SPANCLASS="acronym">UNIX</SPAN>,although it is present in <SPANCLASS="acronym">SVR4</SPAN>. If you run it,you may discover that it is substantially faster than the <KBDCLASS="command">find</KBD> command, because <KBDCLASS="command">ncheck</KBD> reads the inodes directly, ratherthan searching through files in the filesystem. However, <KBDCLASS="command">ncheck</KBD>still needs to read some directory information to obtain pathnames,so it may not be that much faster.</P><PCLASS="para">Unlike <KBDCLASS="command">find</KBD>, <KBDCLASS="command">ncheck</KBD> will locate <SPANCLASS="acronym">SUID</SPAN> filesthat are hidden beneath directories that are used as mount-point.In this respect, <KBDCLASS="command">ncheck</KBD> is superior to <KBDCLASS="command">find</KBD>, because <KBDCLASS="command">find</KBD> can'tfind such files because they do not have complete pathnames as longas the mounts are mounted.</P><PCLASS="para">You must be superuser to run <KBDCLASS="command">ncheck</KBD>. <ACLASS="indexterm"NAME="AUTOID-5934"></A><ACLASS="indexterm"NAME="AUTOID-5937"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.5">5.5.5 Turning Off SUID and SGID in Mounted Filesystems</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5943"></A><ACLASS="indexterm"NAME="AUTOID-5946"></A><ACLASS="indexterm"NAME="AUTOID-5948"></A><ACLASS="indexterm"NAME="AUTOID-5951"></A><ACLASS="indexterm"NAME="AUTOID-5954"></A>If you mount remote network filesystems onyour computer, or if you allow users to mount their own floppy disksor<SPANCLASS="acronym"> CD-ROMS</SPAN>, you usually do not want programsthat are <SPANCLASS="acronym">SUID</SPAN> on these filesystems to be <SPANCLASS="acronym">SUID</SPAN>on your computer as well. In a network environment, honoring <SPANCLASS="acronym">SUID</SPAN>files means that if an attacker manages to take over the remotecomputer that houses the filesystem, he can also take over yourcomputer, simply by creating a <SPANCLASS="acronym">SUID</SPAN> program onthe remote filesystem and running the program on your machine. Likewise,if you allow users to mount floppy disks containing <SPANCLASS="acronym">SUID</SPAN>files on your computer, they can simply create a floppy disk witha <SPANCLASS="acronym">SUID</SPAN> <KBDCLASS="command">ksh</KBD> on another computer, mount the floppydisk on your computer, and run the program&nbsp;- making themselves<ICLASS="filename">root</I>.</P><PCLASS="para">You can turn off the <SPANCLASS="acronym">SUID</SPAN> and <SPANCLASS="acronym">SGID</SPAN>bits on mounted filesystems by specifying the <ACLASS="indexterm"NAME="AUTOID-5968"></A><KBDCLASS="command">nosuid</KBD> option with the <KBDCLASS="command">mount</KBD> command. You shouldalways specify this option when you mount a foreign filesystem unlessthere is an overriding reason to import <SPANCLASS="acronym">SUID</SPAN>or <SPANCLASS="acronym">SGID</SPAN> files from the filesystem you are mounting.Likewise, if you write a program to mount floppy disks for a user,that program should specify the <KBDCLASS="command">nosuid</KBD> option (because the usercan easily take his or her floppy disk to another computer and createa <SPANCLASS="acronym">SUID</SPAN> file).</P><PCLASS="para">For example, to mount the filesystem <ICLASS="filename">athena</I> in the <ICLASS="filename">/usr/athena</I>directory from the machine <ICLASS="filename">zeus</I> with the <KBDCLASS="command">nosuid</KBD> option, type thecommand:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># /etc/mount -o nosuid zeus:/athena /usr/athena</PRE></BLOCKQUOTE><PCLASS="para">Some systems also support a <ACLASS="indexterm"NAME="AUTOID-5984"></A><KBDCLASS="command">-nodev</KBD> option that causes the system to ignoredevice files that may be present on the mounted partition. If yoursystem supports this option, you should use it, too. If your usercreates a floppy with a mode 777 <ICLASS="filename">kmem</I>, forinstance, he can subvert the system with little difficulty if heis able to mount the floppy disk. This is because <SPANCLASS="acronym">UNIX</SPAN>treats the <ICLASS="filename">/dev/kmem </I>on the floppy disk thesame way that it treats the <ICLASS="filename">/dev/kmem </I>on yourmain system disk&nbsp;- it is a device that maps to your system'skernel memory.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.6">5.5.6 SGID and Sticky Bits on Directories</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5995"></A><ACLASS="indexterm"NAME="AUTOID-5998"></A><ACLASS="indexterm"NAME="AUTOID-6001"></A><ACLASS="indexterm"NAME="AUTOID-6004"></A>Althoughthe <SPANCLASS="acronym">SGID</SPAN> and sticky bits were originally intendedfor use only with programs, Berkeley <SPANCLASS="acronym">UNIX</SPAN>, SunOS,Solaris and other operating systems also use these bits to changethe behavior of directories, as shown in <ACLASS="xref"HREF="ch05_05.htm#PUIS-CHP-5-TAB-14"TITLE="Behavior of SGID and Sticky Bits with Directories">Table 5.14</A>.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="PUIS-CHP-5-TAB-14">Table 5.14: Behavior of SGID and Sticky Bits with Directories</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Bit</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Effect</P></TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">SGID bit</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">The SGID bit on a directory controlsthe way that groups are assigned for files created in the directory.If the SGID bit is set, files created in the directory have thesame group as the directory if the process creating the file alsois in that group. Otherwise, if the SGID bit is not set, or if theprocess is not in the same group, files created inside the directoryhave the same group as the user's effective group ID (usuallythe primary group ID).</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Sticky bit</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">If the sticky bit is set on a directory,files inside the directory may be renamed or removed only by theowner of the file, the owner of the directory, or the superuser(even if the modes of the directory would otherwise allow such anoperation); on some systems, any user who can write to a file canalso delete it. This feature was added to keep an ordinary userfrom deleting another's files in the <ICLASS="filename">/tmp</I> directory.</P></TD></TR></TBODY></TABLE><PCLASS="para">For example, to set the mode of the <ICLASS="filename">/tmp</I> directoryon a system so any user can create or delete her own files but can'tdelete another's files, type the command:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># chmod 1777 /tmp</PRE></BLOCKQUOTE><PCLASS="para">Many older versions of <SPANCLASS="acronym">UNIX</SPAN> (System V priorto Release 4, for instance) do not exhibit either of these behaviors.On those systems, the <SPANCLASS="acronym">SGID</SPAN> and sticky bits ondirectories are ignored by the system. However, on a few of theseolder systems (including <SPANCLASS="acronym">SVR3</SPAN>), setting the <SPANCLASS="acronym">SGID</SPAN>bit<EMCLASS="emphasis"> </EM>on the directory resulted in &quot;sticky&quot;behavior.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-5-SECT-5.7">5.5.7 SGID Bit on Files (System V UNIX Only): MandatoryRecord Locking</A></H3><PCLASS="para">If <ACLASS="indexterm"NAME="AUTOID-6045"></A><ACLASS="indexterm"NAME="AUTOID-6048"></A><ACLASS="indexterm"NAME="AUTOID-6051"></A><ACLASS="indexterm"NAME="AUTOID-6054"></A>the <SPANCLASS="acronym">SGID</SPAN>bit is set on a nonexecutable file, <SPANCLASS="acronym">AT&T</SPAN>System V <SPANCLASS="acronym">UNIX</SPAN> implements mandatory record lockingfor the file. Normal <SPANCLASS="acronym">UNIX</SPAN> record locking is discretionary;processes can modify a locked file simply by ignoring the record-lockstatus. On System V <SPANCLASS="acronym">UNIX</SPAN>, the kernel blocks aprocess which tries to access a file (or the portion of the file)that is protected with mandatory record locking until the processthat has locked the file unlocks it. Mandatory locking is enabledonly if <EMCLASS="emphasis">none </EM>of the execute permission bitsare turned on.</P><PCLASS="para">Mandatory record locking shows up in an <ICLASS="filename">ls</I>listing in the <SPANCLASS="acronym">SGID</SPAN> position as a capital &quot;S&quot;instead of a small &quot;s&quot;:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <BCLASS="emphasis.bold">ls -F data*</B> -rw-rwS--- 1 fred         2048 Dec 3 1994 database -r-x--s--x 2 bin         16384 Apr 2 1993 datamaint* <ACLASS="indexterm"NAME="AUTOID-6068"></A><ACLASS="indexterm"NAME="AUTOID-6070"></A> </PRE></BLOCKQUOTE></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_04.htm"TITLE="5.4 Using Directory Permissions"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.4 Using Directory Permissions"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Practical UNIX &amp; Internet Security"><IMGSRC="../gifs/txthome.gif"ALT="Practical UNIX &amp; Internet Security"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_06.htm"TITLE="5.6 Device Files"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.6 Device Files"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">5.4 Using Directory Permissions</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">5.6 Device Files</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>