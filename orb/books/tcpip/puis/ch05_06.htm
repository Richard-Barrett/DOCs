<HTML><HEAD><TITLE>[Chapter 5] 5.6 Device Files</TITLE><METANAME="DC.title"CONTENT="Practical UNIX &amp; Internet Security"><METANAME="DC.creator"CONTENT="Simson Garfinkel &amp; Gene Spafford"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:02:14Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-148-8"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch05_01.htm"TITLE="5. The UNIX Filesystem"><LINKREL="prev"HREF="ch05_05.htm"TITLE="5.5 SUID"><LINKREL="next"HREF="ch05_07.htm"TITLE="5.7 chown: Changing a File's Owner"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Practical UNIX &amp; Internet Security"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Practical UNIX &amp; Internet Security"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_05.htm"TITLE="5.5 SUID"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.5 SUID"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 5<BR>The UNIX Filesystem</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_07.htm"TITLE="5.7 chown: Changing a File's Owner"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.7 chown: Changing a File's Owner"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="PUIS-CHP-5-SECT-6">5.6 Device Files</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6076"></A><ACLASS="indexterm"NAME="AUTOID-6078"></A>Computersystems usually have peripheral devices attached to them. Thesedevices may be involved with <SPANCLASS="acronym">I/O</SPAN> (terminals,printers, modems); they may involve mass storage (disks, tapes);and they may have other specialized functions. The <SPANCLASS="acronym">UNIX</SPAN>paradigm for devices is to treat each one as a file, some with specialcharacteristics.</P><PCLASS="para"><SPANCLASS="acronym">UNIX</SPAN> devices are represented as inodes,identical to files. The <ACLASS="indexterm"NAME="AUTOID-6085"></A>inodes represent either a <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-6089"></A>character device</I> or a <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-6092"></A>block device (described in thesidebar)</I>. Each device is also designated by a majordevice number, indicating the type of device, and a minor devicenumber, indicating which one of many similar devices the inode represents.For instance, the partitions of a physical disk will all have thesame major device number, but different minor device numbers. Fora serial card, the minor device number may represent which portnumber is in use. When a program reads from or writes to a devicefile, the kernel turns the request into an <SPANCLASS="acronym">I/O</SPAN>operation with the appropriate device, using the major/minordevice numbers as parameters to indicate which device to access.</P><DIVCLASS="sidebar"><H4CLASS="sidebar"><ACLASS="title"NAME="AUTOID-6095">Block Vs. Character Devices</A></H4><PCLASS="para">Most devices in <SPANCLASS="acronym">UNIX</SPAN> are referenced as<ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-6100"></A>character devices</I>.These are also known as <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-6103"></A>rawdevices</I>. The reason for the name &quot;raw device&quot;is because that is what you get&nbsp;- raw access to the device.You must make your read and write calls to the device file in thenatural transfer units of the device. Thus, you probably read andwrite single characters at a time to a terminal device, but youneed to read and write sectors to a disk device. Attempts to readfewer (or more) bytes than the natural block size results in anerror, because the raw device doesn't work that way.</P><PCLASS="para">When accessing the filesystem, we often want to read or writeonly the next few bytes of a file at a time. If we used the rawdevice, it would mean that to write a few bytes to a file, we wouldneed to read in the whole sector off disk containing those bytes,modify the ones we want to write, and then write the whole sectorback out. Now consider every user doing that as they update eachfile. That would be a lot of disk traffic!</P><PCLASS="para">The solution is to make efficient use of <ACLASS="indexterm"NAME="AUTOID-6107"></A><ACLASS="indexterm"NAME="AUTOID-6109"></A>caching. <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-6112"></A>Blockdevices </I>are cached versions of character devices. Whenwe make reference to a few bytes of the block device, the kernelreads the corresponding sector into a buffer in memory, and thencopies the characters out of the buffer that we wanted. The nexttime we reference the same sector, to read from or write to, theaccess goes to the cached version in memory. If we have enough memory,most of the files we will access can all be kept in buffers, resultingin much better performance.</P><PCLASS="para">There is a drawback to block devices, however. If the systemcrashes before modified buffers get written back out to disk, thechanges our programs made won't be there when the systemreboots. Thus, we need to periodically flush the modified buffersout to disk. That is effectively what the <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-6116"></A>sync </I>() systemcall does: schedule the buffers to be flushed to disk. Most systemshave a <ICLASS="filename">syn</I> or <ICLASS="filename">fsflush</I>daemon that issues a <ICLASS="filename">sync()</I> call every 30 or60 seconds to make sure the disk is mostly up to date. If the systemgoes down between <ICLASS="filename">sync()</I> calls, we need to runa program such as <KBDCLASS="command">fsck</KBD> or <KBDCLASS="command">checkfsys</KBD>to make certain that no directories whose buffers werein memory were left in an inconsistent state.</P></DIV><PCLASS="para"><SPANCLASS="acronym">UNIX</SPAN> usually has some special device filesthat don't correspond to physical devices. The<ACLASS="indexterm"NAME="AUTOID-6126"></A><ACLASS="indexterm"NAME="AUTOID-6129"></A><ACLASS="indexterm"NAME="AUTOID-6132"></A><ACLASS="indexterm"NAME="AUTOID-6135"></A><ACLASS="indexterm"NAME="AUTOID-6137"></A><ACLASS="indexterm"NAME="AUTOID-6139"></A><ICLASS="filename">/dev/null</I> device simply discardsanything written to it, and nothing can ever be read from it&nbsp;- aprocess that attempts to do so gets an immediate end-of-file condition.Writing to the <ICLASS="filename">/dev/console</I> device results inoutput being printed on the system console terminal. And readingor writing to the <ICLASS="filename">/dev/kmem</I> device accesses thekernel's memory. Devices such as these are often referredto as <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-6145"></A>pseudo-devices</I>.</P><PCLASS="para">Device files are one of the reasons <SPANCLASS="acronym">UNIX</SPAN>is so flexible and popular&nbsp;- they allow programmers to writetheir programs in a general way without having to know the actualtype of device being used. Unfortunately, they also can presenta major security hazard when an attacker is able to access themin an unauthorized way.</P><PCLASS="para">For instance, if attackers can read or write to the <ICLASS="filename">/dev/kmem</I>device, they may be able to alter their priority, <SPANCLASS="acronym">UID</SPAN>,or other attributes of their process. They could also scribble garbagedata over important data structures and crash the system. Similarly,access to disk devices, tape devices, network devices, and terminalsbeing used by others all can lead to problems. Access to your screenbuffer might allow an attacker to read what is displayed on yourscreen. Access to your audio devices might allow an attacker toeavesdrop on your office without your knowing about it.</P><PCLASS="para">In standard configurations of <SPANCLASS="acronym">UNIX</SPAN>, allthe standard device files are located in the directory <ICLASS="filename">/dev.</I>There is usually a script (e.g., <SPANCLASS="acronym">MAKEDEV</SPAN>) inthat directory that can be run to create the appropriate devicefiles and set the correct permissions. A few devices, such as <ICLASS="filename">/dev/null</I>,<ICLASS="filename">/dev/tty</I>, and <ICLASS="filename">/dev/console</I>,should all be world-writable, but most of the rest should be unreadableand unwritable by regular users. Note that on some System V systems,many of the files in <ICLASS="filename">/dev</I> are symbolic linksto files in the <ICLASS="filename">/devices</I> directory: those arethe files whose permissions you need to check.</P><PCLASS="para">Check the permissions on these files when you install thesystem, and periodically thereafter. If any permission is changed,or any device is accessible to all users, you should investigate.This research should be included as part of your checklists.</P><PCLASS="para"><EMCLASS="emphasis">Unauthorized Device Files</EM></P><PCLASS="para">Although device files are normally located in the <ICLASS="filename">/dev</I>directory, they may, in fact, be anywhere on your system.A common method used by system crackers is to get on the systemas the superuser and then create a writable device file in a hiddendirectory, such as the <ICLASS="filename">/dev/kmem</I> device hiddenin<ICLASS="filename"> /usr/lib</I> and named to resemble one of thelibraries. Later, if they wish to become superuser again, they knowthe correct locations in <ICLASS="filename">/dev/kmem</I> to alter witha symbolic debugger or custom program to allow them that access.For instance, by changing the code for a certain routine to alwaysreturn true, they can execute <KBDCLASS="command">su</KBD> to become <ICLASS="filename">root</I> without needinga password. Then, they set the routine back to normal.</P><PCLASS="para">You should periodically scan your disks for unauthorized devicefiles. The <ACLASS="indexterm"NAME="AUTOID-6172"></A>ncheckcommand, mentioned earlier, will print the names of all device fileswhen run with the <KBDCLASS="command">-s</KBD> option. Alternatively, you can executethe following:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">find / \( -type c -o -type b \) -exec ls -l {} \;</B></PRE></BLOCKQUOTE><PCLASS="para">If you have <SPANCLASS="acronym">NFS</SPAN>-mounted directories, usethis version of the script:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">find / \( -local -o -prune \) \( -type c -o -type b \) -exec ls -l {} \;</B></PRE></BLOCKQUOTE><PCLASS="para">Note that some versions of <SPANCLASS="acronym">NFS</SPAN> allow userson remote machines running as root to create device files on exportedvolumes.[27]This is a major problem.Be <EMCLASS="emphasis">very </EM>careful about exporting writable directoriesusing <SPANCLASS="acronym">NFSDEVICE FILESFILESDEVICE</SPAN>(see <ACLASS="xref"HREF="ch20_01.htm"TITLE="NFS">Chapter 20</A>, for more information).</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[27] Of course, these modifications cannot be made if thefilesystem is exported read only.</P></BLOCKQUOTE><DIVCLASS="sidebar"><H4CLASS="sidebar"><ACLASS="title"NAME="AUTOID-6194">Not Everything Is a File or a Device!</A></H4><PCLASS="para">The two commands:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">find / \! -type f -a \! -type d -exec ls -l {} \;</PRE></BLOCKQUOTE><PCLASS="para">and:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">find / \( -type c -o -type b \) -exec ls -l {} \;</PRE></BLOCKQUOTE><PCLASS="para">arenot equivalent!</P><PCLASS="para">The first command prints all of the entries in the filesystemthat are not files or directories. The second prints all of theentries in the filesystem that are either character or block devices.</P><PCLASS="para">Why aren't these commands the same? Because thereare other things that can be in a filesystem that are neither filesnor directories. These include:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Symbolic Links</P></LI><LICLASS="listitem"><PCLASS="para">Sockets</P></LI><LICLASS="listitem"><PCLASS="para">Named pipes (<SPANCLASS="acronym">FIFOS</SPAN>)</P></LI></UL></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_05.htm"TITLE="5.5 SUID"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.5 SUID"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Practical UNIX &amp; Internet Security"><IMGSRC="../gifs/txthome.gif"ALT="Practical UNIX &amp; Internet Security"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_07.htm"TITLE="5.7 chown: Changing a File's Owner"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.7 chown: Changing a File's Owner"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">5.5 SUID</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">5.7 chown: Changing a File's Owner</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>