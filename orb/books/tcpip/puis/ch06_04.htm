<HTML><HEAD><TITLE>[Chapter 6] 6.4 Common Cryptographic Algorithms</TITLE><METANAME="DC.title"CONTENT="Practical UNIX &amp; Internet Security"><METANAME="DC.creator"CONTENT="Simson Garfinkel &amp; Gene Spafford"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:02:34Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-148-8"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch06_01.htm"TITLE="6. Cryptography"><LINKREL="prev"HREF="ch06_03.htm"TITLE="6.3 The Enigma Encryption System"><LINKREL="next"HREF="ch06_05.htm"TITLE="6.5 Message Digests and Digital Signatures"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Practical UNIX &amp; Internet Security"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Practical UNIX &amp; Internet Security"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_03.htm"TITLE="6.3 The Enigma Encryption System"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.3 The Enigma Encryption System"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 6<BR>Cryptography</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_05.htm"TITLE="6.5 Message Digests and Digital Signatures"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.5 Message Digests and Digital Signatures"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4">6.4 Common Cryptographic Algorithms</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6762"></A><ACLASS="indexterm"NAME="AUTOID-6764"></A><ACLASS="indexterm"NAME="AUTOID-6767"></A><ACLASS="indexterm"NAME="AUTOID-6769"></A><ACLASS="indexterm"NAME="AUTOID-6772"></A>There are two basic kinds ofencryption algorithms in use today:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Private key cryptography, which usesthe same key to encrypt and decrypt the message. This type is alsoknown as <ICLASS="firstterm">symmetric</I> <ICLASS="firstterm">key</I>cryptography.</P></LI><LICLASS="listitem"><PCLASS="para">Public key cryptography, which uses a <ICLASS="firstterm">publickey </I>to encrypt the message and a <ICLASS="firstterm">privatekey </I>to decrypt it. The name public key comes from thefact that you can make the encryption key public without compromisingthe secrecy of the message or the decryption key. Public key systemsare also known as <ACLASS="indexterm"NAME="AUTOID-6784"></A>asymmetrickey cryptography.</P></LI></UL><PCLASS="para">Private key cryptography is most often used for protectinginformation stored on a computer's hard disk, or for encryptinginformation carried by a communications link between two differentmachines. Public key cryptography is most often used for creating<ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-6788"></A>digital signatures</I>on data, such as electronic mail, to certify the data'sorigin and integrity.</P><PCLASS="para">This analysis gives rise to a third kind of system:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Hybrid public/private cryptosystems.In these systems, slower public key cryptography is used to exchangea random <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-6795"></A>session key</I>,which is then used as the basis of a private key algorithm. (A sessionkey is used only for a single encryption session and is then discarded.)Nearly all practical public key cryptography implementations areactually hybrid systems.</P></LI></UL><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.1">6.4.1 Summary of Private Key Systems</A></H3><PCLASS="para">The following list summarizes the private key systems in commonuse today.</P><DLCLASS="variablelist"><DTCLASS="term">ROT13 </DT><DDCLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6806"></A>A simple cryptographyalgorithm which is used, among other things, to obscure the contentof risqu&eacute; jokes on various Usenet groups. The <SPANCLASS="acronym">ROT13</SPAN>encryption algorithm has no key, and it is not secure.</P></DD><DTCLASS="term">crypt </DT><DDCLASS="listitem"><PCLASS="para">The original <SPANCLASS="acronym">UNIX</SPAN><ACLASS="indexterm"NAME="AUTOID-6814"></A>encryption program which is modeled on the German Enigma encryptionmachine. <KBDCLASS="command">crypt</KBD> uses a variable-length key. Someprograms can automatically decrypt <ICLASS="filename">crypt</I>-encrypted files withoutprior knowledge of the key or the plaintext. <KBDCLASS="command">crypt</KBD> is not secure.(This program should not be confused with the secure one-way <ICLASS="filename">crypt</I>program that <SPANCLASS="acronym">UNIX </SPAN>uses for encrypting passwords.)</P></DD><DTCLASS="term">DES </DT><DDCLASS="listitem"><PCLASS="para">The <ACLASS="indexterm"NAME="AUTOID-6825"></A><ACLASS="indexterm"NAME="AUTOID-6827"></A><ACLASS="indexterm"NAME="AUTOID-6830"></A>Data Encryption Standard (<SPANCLASS="acronym">DES</SPAN>),an encryption algorithm developed in the 1970s by the National Bureauof Standards and Technology (since renamed the National Instituteof Standards and Technology, or <SPANCLASS="acronym">NIST</SPAN>) and <SPANCLASS="acronym">IBM</SPAN>.<SPANCLASS="acronym">DES</SPAN> uses a 56-bit key.[8]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] Technically,we should refer to it as the DEA: Data Encryption Algorithm. Standard-conformingimplementations are certified by NIST, and usually require a hardwareimplementation. However, nearly everyone refers to it as the DES,so we will too.</P></BLOCKQUOTE></DD><DTCLASS="term">RC2 </DT><DDCLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6843"></A><ACLASS="indexterm"NAME="AUTOID-6845"></A><ACLASS="indexterm"NAME="AUTOID-6847"></A>A blockcipher originally developed by Ronald Rivest and kept as a tradesecret by <SPANCLASS="acronym">RSA</SPAN> Data Security. This algorithm wasrevealed by an anonymous Usenet posting in 1996 and appears to bereasonably strong (although there are some particular keys thatare weak). RC2 is sold with an implementation that allows keys between1 and 2048 bits. The RC2mail key length is often limited to 40 bitsin software that is sold for export.[9]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] Unfortunately,a 40-bit key is vulnerable to a brute force attack.</P></BLOCKQUOTE></DD><DTCLASS="term">RC4</DT><DDCLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6858"></A><ACLASS="indexterm"NAME="AUTOID-6860"></A><ACLASS="indexterm"NAME="AUTOID-6862"></A>A stream cipheroriginally developed by Ronald Rivest and kept as a trade secretby <SPANCLASS="acronym">RSA</SPAN> Data Security. This algorithm was revealedby an anonymous Usenet posting in 1994 and appears to be reasonablystrong (although there are some particular keys that are weak).RC4 is sold with an implementation that allows keys between 1 and2048 bits. The RC4 key length is often limited to 40 bits in softwarethat is sold for export.[10]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[10] Unfortunately, a 40-bitkey is vulnerable to a brute force attack.</P></BLOCKQUOTE></DD><DTCLASS="term">RC5</DT><DDCLASS="listitem"><PCLASS="para">A block cipher developed by Ronald Rivest and publishedin 1994. RC5 allows a user-defined key length, data block size,and number of encryption rounds.</P></DD><DTCLASS="term">IDEA</DT><DDCLASS="listitem"><PCLASS="para">The <ACLASS="indexterm"NAME="AUTOID-6876"></A><ACLASS="indexterm"NAME="AUTOID-6878"></A><ACLASS="indexterm"NAME="AUTOID-6880"></A>InternationalData Encryption Algorithm (<SPANCLASS="acronym">IDEA</SPAN>), developed inZurich, Switzerland by James L. Massey and Xuejia <ACLASS="indexterm"NAME="AUTOID-6885"></A><ACLASS="indexterm"NAME="AUTOID-6887"></A>Lai and published in 1990. <SPANCLASS="acronym">IDEA</SPAN>uses a 128-bit key, and is believed to be quite strong. <SPANCLASS="acronym">IDEA</SPAN>is used by the popular program <SPANCLASS="acronym">PGP</SPAN> (describedlater in this chapter) to encrypt files and electronic mail. Unfortunately,[11] wider useof <SPANCLASS="acronym">IDEA</SPAN> may be hampered by a series of softwarepatents on the algorithm which is currently held by Ascom-Tech AG,in Solothurn, Switzerland. Ascom-Tech supposedly will allow <SPANCLASS="acronym">IDEA</SPAN>to be used royalty free in implementations of <SPANCLASS="acronym">PGP</SPAN>outside the U.S., but concerned users should verify the terms withAscom-Tech or their licensees directly.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[11] Although we are generally in favor of intellectual propertyprotection, we are opposed to the concept of software patents, inpart because they hinder the development and use of innovative softwareby individuals and small companies.</P></BLOCKQUOTE></DD><DTCLASS="term"><ACLASS="indexterm"NAME="AUTOID-6899"></A><ACLASS="indexterm"NAME="AUTOID-6901"></A><ACLASS="indexterm"NAME="AUTOID-6904"></A>Skipjack </DT><DDCLASS="listitem"><PCLASS="para">A classified (<SPANCLASS="acronym">SECRET</SPAN>) algorithmdeveloped by the National Security Agency (<SPANCLASS="acronym">NSA</SPAN>).Reportedly, a Top Secret security clearance is required to see thealgorithm's source code and design specifications. Skipjackis the algorithm used by the Clipper encryption chip. It uses an80-bit key.<ACLASS="indexterm"NAME="AUTOID-6911"></A><ACLASS="indexterm"NAME="AUTOID-6914"></A></P></DD></DL></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.2">6.4.2 Summary of Public Key Systems</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6919"></A><ACLASS="indexterm"NAME="AUTOID-6921"></A><ACLASS="indexterm"NAME="AUTOID-6925"></A><ACLASS="indexterm"NAME="AUTOID-6927"></A>The following listsummarizes the public key systems in common use today:</P><DLCLASS="variablelist"><DTCLASS="term">Diffie-Hellman</DT><DDCLASS="listitem"><PCLASS="para">A system for exchanging cryptographic keys betweenactive parties. Diffie-Hellman is not actually a method of encryptionand decryption, but a method of developing and exchanging a sharedprivate key over a public communications channel. In effect, thetwo parties agree to some common numerical values, and then eachparty creates a key. Mathematical transformations of the keys areexchanged. Each party can then calculate a third session key thatcannot easily be derived by an attacker who knows both exchangedvalues.</P><PCLASS="para">Several versions of this protocol exist, involvinga differing number of parties and different transformations. Particularcare must be exercised in the choice of some of the numbers andcalculations used or the exchange can be easily compromised. Ifyou are interested, consult the references for all the gory details.</P><PCLASS="para">The Diffie-Hellman algorithm is frequently usedas the basis for exchanging cryptographic keys for encrypting acommunications link. The key may be any length, depending on theparticular implementation used. Longer keys are generally more secure.</P></DD><DTCLASS="term">RSA</DT><DDCLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6941"></A><ACLASS="indexterm"NAME="AUTOID-6943"></A><ACLASS="indexterm"NAME="AUTOID-6945"></A>Thewell-known public key cryptography system developed by (then) <SPANCLASS="acronym">MIT</SPAN>professors Ronald Rivest and Adi Shamir, and by <SPANCLASS="acronym">USC</SPAN>professor Leonard <ACLASS="indexterm"NAME="AUTOID-6951"></A><ACLASS="indexterm"NAME="AUTOID-6953"></A><ACLASS="indexterm"NAME="AUTOID-6955"></A>Adleman. <SPANCLASS="acronym">RSA</SPAN> can be used bothfor encrypting information and as the basis of a digital signaturesystem. Digital signatures can be used to prove the authorship andauthenticity of digital information. The key may be any length,depending on the particular implementation used. Longer keys aregenerally considered to be more secure.</P></DD><DTCLASS="term">ElGamal </DT><DDCLASS="listitem"><PCLASS="para">Another algorithm based on exponentiation and modulararithmetic. <ACLASS="indexterm"NAME="AUTOID-6962"></A><ACLASS="indexterm"NAME="AUTOID-6964"></A>ElGamalmay be used for encryption and digital signatures in a manner similarto the <SPANCLASS="acronym">RSA</SPAN> algorithm. Longer keys are generallyconsidered to be more secure.</P></DD><DTCLASS="term">DSA</DT><DDCLASS="listitem"><PCLASS="para">The <ACLASS="indexterm"NAME="AUTOID-6973"></A><ACLASS="indexterm"NAME="AUTOID-6975"></A><ACLASS="indexterm"NAME="AUTOID-6979"></A>DigitalSignature Algorithm, developed by <SPANCLASS="acronym">NSA</SPAN> and adoptedas a <ACLASS="indexterm"NAME="AUTOID-6983"></A><ACLASS="indexterm"NAME="AUTOID-6985"></A>Federal InformationProcessing Standard (<SPANCLASS="acronym">FIPS</SPAN>) by <SPANCLASS="acronym">NIST</SPAN>.Although the <SPANCLASS="acronym">DSA</SPAN> key may be any length, onlykeys between 512 and 1024 bits are permitted under the <SPANCLASS="acronym">FIPS</SPAN>.As specified, <SPANCLASS="acronym">DSA</SPAN> can only be used for digitalsignatures, although it is possible to use <SPANCLASS="acronym">DSA</SPAN>implementations for encryption as well. The <SPANCLASS="acronym">DSA</SPAN>is sometimes referred to as the <SPANCLASS="acronym">DSS</SPAN>, in the samemanner as the <SPANCLASS="acronym">DEA</SPAN> is usually referred to as the<SPANCLASS="acronym">DES</SPAN>.</P></DD></DL><PCLASS="para"><ACLASS="xref"HREF="ch06_04.htm#PUIS-CHP-6-TAB-1"TITLE="Commonly Used Private and Public Key Cryptography Algorithms">Table 6.1</A> lists all of the private andpublic key algorithms we've discussed</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="PUIS-CHP-6-TAB-1">Table 6.1: Commonly UsedPrivate and Public Key Cryptography Algorithms</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Algorithm</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Description</P></TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="2"><PCLASS="para">Private Key Algorithms:</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><SPANCLASS="acronym">ROT13</SPAN></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Keyless text scrambler; very weak.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><ICLASS="filename">crypt</I></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Variable key length stream cipher; veryweak.[12]</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><SPANCLASS="acronym">DES</SPAN></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">56-bit block cipher; patented, but freelyusable (but not exportable).</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">RC2</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Variable key length block cipher; proprietary.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">RC4</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Variable key length stream cipher; proprietary.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">RC5</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Variable key length block cipher; proprietary.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><SPANCLASS="acronym">IDEA</SPAN></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">128-bit block cipher; patented.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Skipjack</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">80-bit stream cipher; classified.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="2"><PCLASS="para">Public Key Algorithms:</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Diffie-Hellman</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Key exchange protocol; patented.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><SPANCLASS="acronym">RSA</SPAN></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Public key encryption and digital signatures;patented</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">ElGamal</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Public key encryption and digital signatures;patented.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><SPANCLASS="acronym">DSA</SPAN></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Digital signatures only; patented.</P></TD></TR></TBODY></TABLE><BLOCKQUOTECLASS="footnote"><PCLASS="para">[12] Actually, crypt is a fair cipher for filesof length less than 1024 bytes. Its recurrence properties only surfacewhen used on longer inputs, thus providing more information fordecrypting.</P></BLOCKQUOTE><PCLASS="para">.</P><PCLASS="para">The following sections provide some technical informationabout a few of the algorithms mentioned above. If you are only interestedin using encryption, you can skip ahead to the section called &quot;EncryptionPrograms Available for UNIX&quot; later in this chapter.<ACLASS="indexterm"NAME="AUTOID-7088"></A><ACLASS="indexterm"NAME="AUTOID-7090"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.3">6.4.3 ROT13: Great for Encoding Offensive Jokes</A></H3><PCLASS="para"><SPANCLASS="acronym">ROT13</SPAN><ACLASS="indexterm"NAME="AUTOID-7097"></A><ACLASS="indexterm"NAME="AUTOID-7099"></A><ACLASS="indexterm"NAME="AUTOID-7103"></A><ACLASS="indexterm"NAME="AUTOID-7106"></A>is a simple substitutioncipher[13]that is traditionally used for distributing potentially objectionablematerial on the Usenet, a worldwide bulletin board system. It isa variation on the <ACLASS="indexterm"NAME="AUTOID-7112"></A>Caesar Cipher&nbsp;- anencryption method used by Caesar's troops thousands ofyears ago. In the <SPANCLASS="acronym">ROT13</SPAN> cipher, each letter ofthe alphabet is replaced with a letter that is 13 letters furtheralong in the alphabet (with A following Z). Letters encrypt as follows:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[13] Technically, it is an encoding scheme&nbsp;- the &quot;rotation&quot;is fixed, and it does a constant encoding from a fixed alphabet.</P></BLOCKQUOTE><TABLECLASS="informaltable"><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Plaintext</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Ciphertext</P></TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">A</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">N</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">B</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">O</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">. . .</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">M</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Z</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">N</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">A</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">. . .</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Z</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">M</P></TD></TR></TBODY></TABLE><PCLASS="para"><SPANCLASS="acronym">ROT13</SPAN> used to be the most widely used encryptionsystem in the <SPANCLASS="acronym">UNIX</SPAN> world. However, it is notsecure at all. Many news and mail-reading programs automaticallydecrypt <SPANCLASS="acronym">ROT13</SPAN>-encoded text with a single keystroke.Some people are known to be able to read <SPANCLASS="acronym">ROT13</SPAN>text without any machine assistance whatsoever.</P><PCLASS="para">For example, here is a <SPANCLASS="acronym">ROT13</SPAN> message:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Jung tbrf nebhaq, pbzrf nebhaq.</PRE></BLOCKQUOTE><PCLASS="para">And here is how the message decrypts:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">What goes around, comes around.</PRE></BLOCKQUOTE><PCLASS="para">If you are not blessed with the ability to read <SPANCLASS="acronym">ROT13</SPAN>files without computer assistance, you can use the following commandto either encrypt or decrypt files with the <SPANCLASS="acronym">ROT13</SPAN>algorithm:[14]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[14] On some versions of UNIX, you will needto remove the &quot;[ ]&quot; symbols.</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% tr &quot;[a-z][A-Z]&quot; &quot;[n-z][a-m][N-Z][A-M]&quot; &lt; <ICLASS="filename">filename</I></PRE></BLOCKQUOTE><PCLASS="para">Needless to say, do not use <SPANCLASS="acronym">ROT13</SPAN> as ameans of protecting your files! The only real use for this &quot;encryption&quot;method is the one to which it is put on the Usenet: to keep someonewho does not want to be exposed to material (such as the answerto a riddle, a movie spoiler in a review, or an offensive joke)from reading it inadvertently.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.4">6.4.4 DES</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7179"></A><ACLASS="indexterm"NAME="AUTOID-7181"></A><ACLASS="indexterm"NAME="AUTOID-7183"></A>Oneof the most widely used encryption systems today is the Data EncryptionStandard (<SPANCLASS="acronym">DES</SPAN>), developed in the 1970s and patentedby researchers at <SPANCLASS="acronym">IBM</SPAN>. The <SPANCLASS="acronym">DES</SPAN>was an outgrowth of another <SPANCLASS="acronym">IBM</SPAN> cipher knownas <ACLASS="indexterm"NAME="AUTOID-7190"></A>Lucifer. <SPANCLASS="acronym">IBM</SPAN>made the <SPANCLASS="acronym">DES</SPAN> available for public use, and thefederal government issued Federal Information Processing StandardPublication (<SPANCLASS="acronym">FIPS</SPAN> <SPANCLASS="acronym">PUB</SPAN>) Number46 in 1977 describing the system. Since that time, the <SPANCLASS="acronym">DES</SPAN>has been periodically reviewed and reaffirmed (most recently inDecember 30, 1993), until 1998 as <SPANCLASS="acronym">FIPS</SPAN> <SPANCLASS="acronym">PUB</SPAN>46-2. It has also been adopted as an American National Standard(X3.92-1981/R1987).</P><PCLASS="para">The <SPANCLASS="acronym">DES</SPAN> performs a series of bit permutation,substitution, and recombination operations on blocks containing64 bits of data and 56 bits of key (eight 7-bit characters). The64 bits of input are permuted initially, and are then input to afunction using static tables of permutations and substitutions (calledS-boxes). The bits are permuted in combination with 48 bits of thekey in each round. This process is iterated 16 times (rounds), eachtime with a different set of tables and different bits from thekey. The algorithm then performs a final permutation, and 64 bitsof output are provided. The algorithm is structured in such a waythat changing any bit in the input has a major effect on almostall of the output bits. Indeed, the output of the <SPANCLASS="acronym">DES</SPAN>function appears so unrelated to its input that the function issometimes used as a random number generator.</P><PCLASS="para">Although there is no standard <SPANCLASS="acronym">UNIX</SPAN> programthat performs encryption using the <SPANCLASS="acronym">DES</SPAN>, somevendors' versions of <SPANCLASS="acronym">UNIX</SPAN> include aprogram called <KBDCLASS="command"><ACLASS="indexterm"NAME="AUTOID-7207"></A>des</KBD>which performs <SPANCLASS="acronym">DES</SPAN> encryption. (This commandmay not be present in international versions of the operating system,as described in the next section.)</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.4.1">6.4.4.1 Use and export of DES</A></H4><PCLASS="para">The <SPANCLASS="acronym">DES</SPAN> <ACLASS="indexterm"NAME="AUTOID-7214"></A><ACLASS="indexterm"NAME="AUTOID-7217"></A><ACLASS="indexterm"NAME="AUTOID-7219"></A>was mandated as the encryptionmethod to be used by all federal agencies in protecting sensitivebut not classified information.[15]The <SPANCLASS="acronym">DES</SPAN> is heavily used in many financial andcommunication exchanges. Many vendors make <SPANCLASS="acronym">DES</SPAN>chips that can encode or decode information fast enough to be usedin data-encrypting modems or network interfaces. Note that the <SPANCLASS="acronym">DES</SPAN>is not (and has never been) certified as an encryption method thatcan be used with U.S. Department of Defense classified material.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[15] Other algorithmsdeveloped by the NSA are designed for use with classified information.</P></BLOCKQUOTE><PCLASS="para">Export control rules restrict the export of hardware or softwareimplementations of the <SPANCLASS="acronym">DES</SPAN>, even though the algorithmhas been widely published and implemented many times outside theUnited States. If you have the international version of <SPANCLASS="acronym">UNIX</SPAN>,you may find that your system lacks a <KBDCLASS="command">des</KBD> command.If you find yourself in this position, don't worry; goodimplementations of the <SPANCLASS="acronym">DES</SPAN> can be obtained viaanonymous <SPANCLASS="acronym">FTP</SPAN> from almost any archive service,including the Usenet <ICLASS="filename">comp.sources</I> archives.</P><PCLASS="para">For more information about export of cryptography, see &quot;Encryptionand U.S. Law,&quot; later in this chapter.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.4.2">6.4.4.2 DES modes</A></H4><PCLASS="para"><SPANCLASS="acronym">FIPS</SPAN> <SPANCLASS="acronym">PUB</SPAN> 81 explainshow the <SPANCLASS="acronym">DES</SPAN> algorithm can be used in four modes:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Electronic Code Book (<SPANCLASS="acronym">ECB</SPAN>)</P></LI><LICLASS="listitem"><PCLASS="para">Cipher Block Chaining (<SPANCLASS="acronym">CBC</SPAN>)</P></LI><LICLASS="listitem"><PCLASS="para">Cipher Feedback (<SPANCLASS="acronym">CFB</SPAN>)</P></LI><LICLASS="listitem"><PCLASS="para">Output Feedback (<SPANCLASS="acronym">OFB</SPAN>)</P></LI></UL><PCLASS="para">Each mode has particular advantages in some circumstances,such as when transmitting text over a noisy channel, or when itis necessary to decrypt only a portion of a file. The followingprovides a brief discussion of these four methods; consult <SPANCLASS="acronym">FIPS</SPAN><SPANCLASS="acronym">PUB</SPAN> 81 or a good textbook on cryptography fordetails.</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">ECB</SPAN><ACLASS="indexterm"NAME="AUTOID-7261"></A><ACLASS="indexterm"NAME="AUTOID-7263"></A>Mode.In electronic code book (<SPANCLASS="acronym">ECB</SPAN>) mode, each blockof the input is encrypted using the same key, and the output iswritten as a block. This method performs simple encryption of amessage, a block at a time. This method may not indicate when portionsof a message have been inserted or removed. It works well with noisytransmission channels&nbsp;- alteration of a few bits will corruptonly a single 64-bit block.</P></LI><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">CBC</SPAN> Mode. In <ACLASS="indexterm"NAME="AUTOID-7270"></A><ACLASS="indexterm"NAME="AUTOID-7273"></A>cipher blockchaining (<SPANCLASS="acronym">CBC</SPAN>) mode, the plaintext is first <SPANCLASS="acronym">XOR</SPAN>'edwith the encrypted value of the previous block. Some known value(usually referred to as the <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-7278"></A>initialization vector</I>, or IV)is used for the first block. The result is then encrypted usingthe key. Unlike <SPANCLASS="acronym">ECB</SPAN> mode, long runs of repeatedcharacters in the plaintext will be masked in the output. <SPANCLASS="acronym">CBC</SPAN>mode is the default mode for Sun Microsystems' des program.</P></LI><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">CFB</SPAN> Mode. In <ACLASS="indexterm"NAME="AUTOID-7285"></A><ACLASS="indexterm"NAME="AUTOID-7288"></A>cipher feedback (<SPANCLASS="acronym">CFB</SPAN>)mode, the output is fed back into the mechanism. After each blockis encrypted, part of it is shifted into a shift register. The contentsof this shift register are encrypted with the user's keyvalue using (effectively) <SPANCLASS="acronym">ECB</SPAN> mode, and thisoutput is <SPANCLASS="acronym">XOR</SPAN>'d with the data streamto produce the encrypted result. This method is self synchronizing,and enables the user to decrypt only a portion of a large databaseby starting a fixed distance before the start of the desired data.</P></LI><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">OFB</SPAN> Mode. In <ACLASS="indexterm"NAME="AUTOID-7296"></A><ACLASS="indexterm"NAME="AUTOID-7298"></A>output feedback(<SPANCLASS="acronym">OFB</SPAN>) mode, the output is also fed back intothe mechanism. A register is initialized with some known value (again,the IV). This register is then encrypted with (effectively) <SPANCLASS="acronym">ECB</SPAN>mode using the user's key. The result of this is used asthe key to encrypt the data block (using an <SPANCLASS="acronym">XOR</SPAN>operation), and it is also stored back into the register for useon the next block. The algorithm effectively generates a long streamof key bits that can be used to encrypt/decrypt communicationstreams, with good tolerance for small bit errors in the transmission.This mode is almost never used in <SPANCLASS="acronym">UNIX</SPAN>-basedsystems.</P></LI></UL><PCLASS="para">All of these modes require that byte and block boundariesremain synchronized between the sender and recipient. If informationis inserted or removed from the encrypted data stream, it is likelythat all of the following data from the point of modification canbe rendered unintelligible.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.4.3">6.4.4.3 DES strength</A></H4><PCLASS="para">Ever <ACLASS="indexterm"NAME="AUTOID-7308"></A>since <SPANCLASS="acronym">DES</SPAN> was first proposedas a national standard, some people have been suspicious of thealgorithm. <SPANCLASS="acronym">DES</SPAN> was based on a proprietary encryptionalgorithm developed by <SPANCLASS="acronym">IBM</SPAN> called <ACLASS="indexterm"NAME="AUTOID-7314"></A>Lucifer, which <SPANCLASS="acronym">IBM</SPAN> had submittedto the National Bureau of Standards (<SPANCLASS="acronym">NBS</SPAN>)[16]for consideration as a national cryptographic standard. But whereasLucifer had a key that was 112 bits long, the <SPANCLASS="acronym">DES</SPAN>key was shortened to 56 bits at the request of the National SecurityAgency. The <SPANCLASS="acronym">NSA</SPAN> also requested that certain changesbe made in the algorithm's S-boxes. Many people suspectedthat <SPANCLASS="acronym">NSA</SPAN> had intentionally weakened the Luciferalgorithm, so the final standard adopted by <SPANCLASS="acronym">NBS</SPAN>would not pose a threat to the <SPANCLASS="acronym">NSA</SPAN>'songoing intelligence collection activities. But nobody had any proof.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[16] NBS later became the National Institute of Standards and Technology.</P></BLOCKQUOTE><PCLASS="para">Today the <SPANCLASS="acronym">DES</SPAN> is more than 20 years old,and the algorithm is definitely showing its age. Recently <ACLASS="indexterm"NAME="AUTOID-7327"></A>Michael Weiner, a researcher at Bell NorthernResearch, published a paper detailing how to build a machine capableof decrypting messages encrypted with the <SPANCLASS="acronym">DES</SPAN>by conducting an exhaustive key search. Such a machine could bebuilt for a few million dollars, and could break any <SPANCLASS="acronym">DES</SPAN>-encryptedmessage in about a day. We can reasonably assume that such machineshave been built by both governments and private industry.</P><PCLASS="para">In June 1994, <SPANCLASS="acronym">IBM</SPAN> published a paper describingthe design criteria of the <SPANCLASS="acronym">DES</SPAN>. The paper claimsthat the choices of the <SPANCLASS="acronym">DES</SPAN> key size, S-boxes,and number of rounds were a direct result of the conflicting goalsof making the <SPANCLASS="acronym">DES</SPAN> simple enough to fit onto asingle chip with 1972 chip-making technology, and the desire tomake it resistant to differential cryptanalysis.</P><PCLASS="para">These two papers, coupled with many previously published analyses,appear to have finally settled a long-running controversy as towhether or not <SPANCLASS="acronym">NSA</SPAN> had intentionally built inweaknesses to the <SPANCLASS="acronym">DES</SPAN>. The <SPANCLASS="acronym">NSA</SPAN>didn't build a back door into <SPANCLASS="acronym">DES</SPAN> thatwould have allowed it to forcibly decrypt any <SPANCLASS="acronym">DES</SPAN>-encryptedtransmission: it didn't need to. Messages encrypted with<SPANCLASS="acronym">DES</SPAN> can be forcibly decrypted simply by tryingevery possible key, given the appropriate hardware.</P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.5">6.4.5 Improving the Security of DES</A></H3><PCLASS="para">You <ACLASS="indexterm"NAME="AUTOID-7346"></A><ACLASS="indexterm"NAME="AUTOID-7348"></A><ACLASS="indexterm"NAME="AUTOID-7350"></A><ACLASS="indexterm"NAME="AUTOID-7353"></A><ACLASS="indexterm"NAME="AUTOID-7355"></A><ACLASS="indexterm"NAME="AUTOID-7358"></A>can improve the security of <SPANCLASS="acronym">DES</SPAN>by performing multiple encryptions, known as <ICLASS="firstterm">superencryption</I>.The two most common ways of doing this are with double encryption(<ICLASS="firstterm">Double </I><SPANCLASS="acronym">DES</SPAN><ICLASS="firstterm">)</I>and with triple encryption (<ICLASS="firstterm">Triple </I><SPANCLASS="acronym">DES</SPAN>).</P><PCLASS="para">While double <SPANCLASS="acronym">DES</SPAN> appears to add significantsecurity, research has found some points of attack, and thereforeexperts recommend Triple <SPANCLASS="acronym">DES</SPAN> for applicationswhere single <SPANCLASS="acronym">DES</SPAN> is not adequate.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.5.1">6.4.5.1 Double DES</A></H4><PCLASS="para">In Double <SPANCLASS="acronym">DES</SPAN>, each 64-bit block of datais encrypted twice with the <SPANCLASS="acronym">DES</SPAN> algorithm, firstwith one key, then with another, as follows:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Encrypt with (key 1).</P></LI><LICLASS="listitem"><PCLASS="para">Encrypt with (key 2).</P></LI></OL><PCLASS="para">Plaintext <IMGSRC="../chars/rarr.gif"ALT="-&gt;"> (key1) <IMGSRC="../chars/rarr.gif"ALT="-&gt;"> (key2) <IMGSRC="../chars/rarr.gif"ALT="-&gt;"> ciphertext</P><PCLASS="para">Double <SPANCLASS="acronym">DES</SPAN> is not significantly more securethan single <SPANCLASS="acronym">DES</SPAN>. In 1981, Ralph Merkle and MartinHellman published an article[17] in which they outlineda so-called &quot;meet-in-the-middle attack.&quot;</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[17] R. C. Merkle and M.Hellman, &quot;On the Security of Multiple Encryption,&quot;<EMCLASS="emphasis">Communications of the ACM</EM>, Volume 24, Number7, July 1981, pp. 465-467.</P></BLOCKQUOTE><PCLASS="para">The <ACLASS="indexterm"NAME="AUTOID-7390"></A><ACLASS="indexterm"NAME="AUTOID-7392"></A><ACLASS="indexterm"NAME="AUTOID-7395"></A><ACLASS="indexterm"NAME="AUTOID-7397"></A>meet-in-the-middleattack is a <ICLASS="firstterm">known plaintext attack</I> whichrequires that an attacker have both a known piece of plaintext anda block of that same text that has been encrypted. (These piecesare surprisingly easily to get.) The attack requires storing 2<SUPCLASS="superscript">56</SUP>intermediate results when trying to crack a message that has beenencrypted with <SPANCLASS="acronym">DES</SPAN> (a total of 2<SUPCLASS="superscript">59</SUP> bytes), butit reduces the number of different keys you need to check from 2<SUPCLASS="superscript">112</SUP>to 2<SUPCLASS="superscript">57</SUP>. &quot;This is still considerably more memory storagethan one could comfortably comprehend, but it's enoughto convince the most paranoid of cryptographers that double encryptionis not worth anything,&quot; writes Bruce Schneier in his landmarkvolume, <EMCLASS="emphasis">Applied Cryptography.</EM></P><PCLASS="para">In other words, because a message encrypted with <SPANCLASS="acronym">DES</SPAN>can be forcibly decrypted by an attacker performing an exhaustivekey search today, an attacker might also be able to forcibly decrypta message encrypted with Double <SPANCLASS="acronym">DES</SPAN> using a meet-in-the-middleattack at some point in the future.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.5.2">6.4.5.2 Triple DES</A></H4><PCLASS="para">The dangers of the Merkle-Hellman meet-in-the-middle attackcan be circumvented by performing three block encryption operations.This method is called Triple <SPANCLASS="acronym">DES</SPAN>.</P><PCLASS="para">In practice, the most common way to perform Triple <SPANCLASS="acronym">DES</SPAN>is:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Encrypt with (key1).</P></LI><LICLASS="listitem"><PCLASS="para">Decrypt with (key2).</P></LI><LICLASS="listitem"><PCLASS="para">Encrypt with (key3).</P></LI></OL><PCLASS="para">The advantage of this technique is that it can be backwardcompatible with single <SPANCLASS="acronym">DES</SPAN>, simply by settingall three keys to be the same value.</P><PCLASS="para">To decrypt, reverse the steps:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Decrypt with (key3).</P></LI><LICLASS="listitem"><PCLASS="para">Encrypt with (key2).</P></LI><LICLASS="listitem"><PCLASS="para">Decrypt with (key1).</P></LI></OL><PCLASS="para">For many applications, you can use the same key for both key1and key3 without creating a significant vulnerability.</P><PCLASS="para">Triple <SPANCLASS="acronym">DES</SPAN> appears to be roughly as secureas single <SPANCLASS="acronym">DES</SPAN> would be if it had a 112-bit key.How secure is this really? Suppose you had an integrated circuitwhich could perform one million Triple <SPANCLASS="acronym">DES</SPAN> encryptionsper second, and you built a massive computer containing one millionof these chips to forcibly try all Triple <SPANCLASS="acronym">DES</SPAN>keys. This computer, capable of testing 10<SUPCLASS="superscript">12</SUP> encryptions per second,would require:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">2<SUPCLASS="superscript">112</SUP> = 5.19 x 10<SUPCLASS="superscript">33</SUP> encryption operations 5.19 x 10<SUPCLASS="superscript">33</SUP> encryption operations / 10<SUPCLASS="superscript">12</SUP> operations/sec = 5.19 x 10<SUPCLASS="superscript">21</SUP> sec= 1.65 x 10<SUPCLASS="superscript">14</SUP> years.</PRE></BLOCKQUOTE><PCLASS="para">This is more than 16,453 times older than the currently estimatedage of the universe (approximately 10<SUPCLASS="superscript">10</SUP> years).</P><PCLASS="para">Apparently, barring new discoveries uncovering fundamentalflaws or weaknesses with the <SPANCLASS="acronym">DES</SPAN> algorithm, ornew breakthroughs in the field of cryptanalysis, Triple <SPANCLASS="acronym">DES</SPAN>is the most secure private key encryption algorithm that humanitywill ever need (although niche opportunities may exist for fasteralgorithms).<ACLASS="indexterm"NAME="AUTOID-7451"></A><ACLASS="indexterm"NAME="AUTOID-7453"></A><ACLASS="indexterm"NAME="AUTOID-7456"></A><ACLASS="indexterm"NAME="AUTOID-7459"></A><ACLASS="indexterm"NAME="AUTOID-7461"></A><ACLASS="indexterm"NAME="AUTOID-7464"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.6">6.4.6 RSA and Public Key Cryptography</A></H3><PCLASS="para"><SPANCLASS="acronym">RSA</SPAN><ACLASS="indexterm"NAME="AUTOID-7471"></A><ACLASS="indexterm"NAME="AUTOID-7473"></A><ACLASS="indexterm"NAME="AUTOID-7475"></A><ACLASS="indexterm"NAME="AUTOID-7479"></A><ACLASS="indexterm"NAME="AUTOID-7481"></A>isthe most widely known algorithm for performing public key cryptography.The algorithm is named after its inventors, Ronald Rivest, Adi Shamir,and Leonard <ACLASS="indexterm"NAME="AUTOID-7484"></A><ACLASS="indexterm"NAME="AUTOID-7486"></A><ACLASS="indexterm"NAME="AUTOID-7488"></A>Adleman,who made their discovery in the spring of 1977.</P><PCLASS="para">Unlike <SPANCLASS="acronym">DES</SPAN>, which uses a single key, <SPANCLASS="acronym">RSA</SPAN>uses two cryptographic keys: a public key and a <ACLASS="indexterm"NAME="AUTOID-7493"></A>secret key. The public key is used to encrypt amessage and the secret key is used to decrypt it. (The system canalso be run in reverse, using the secret key to encrypt data thatcan be decrypted with the public key.)</P><PCLASS="para">The <SPANCLASS="acronym">RSA</SPAN> <ACLASS="indexterm"NAME="AUTOID-7497"></A>algorithmis covered by U.S. Patent 4,405,829 (&quot;Cryptographic CommunicationsSystem and Method&quot;), which was filed for on December 14,1977; issued on September 20, 1983; and expires on September 20,2000. Because a description of the algorithm was published beforethe patent application was filed, <SPANCLASS="acronym">RSA</SPAN> can beused without royalty everywhere in the world except the United States(international patent laws have different coverage of prior disclosureand patent applicability).[18] Not surprisingly, <SPANCLASS="acronym">RSA</SPAN>is significantly more popular in Europe and Japan than in the UnitedStates, although its popularity in the U.S. is increasing.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[18] Ongoing controversy existsover whether this, or any other patent granted on what amounts toa series of mathematical transformations, can properly be patented.Some difference of opinion also exists about the scope of the patentprotection. We anticipate that the courts will need a lot of timeto sort out these issues.</P></BLOCKQUOTE><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.6.1">6.4.6.1 How RSA works</A></H4><PCLASS="para">The strength of <SPANCLASS="acronym">RSA</SPAN> is based on the difficultyof factoring a very large number. The following brief treatmentdoes not fully explain the mathematical subtleties of the algorithm.If you are interested in more detail, you can consult the originalpaper[19] or a text such as those listedin <ACLASS="xref"HREF="appd_01.htm"TITLE="Paper Sources">Appendix D</A>.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[19] Rivest, R., Shamir, A., Adleman, L., &quot;AMethod for Obtaining Digital Signatures and Public Key Cryptosystems,&quot;<EMCLASS="emphasis">Communications of the ACM</EM>, Volume 21, Number2, February 1978.</P></BLOCKQUOTE><PCLASS="para"><SPANCLASS="acronym">RSA</SPAN> is based on well-known, number-theoreticproperties of modular arithmetic and integers. One property makesuse of the <ACLASS="indexterm"NAME="AUTOID-7514"></A><ACLASS="indexterm"NAME="AUTOID-7516"></A>EulerTotient Function, <ICLASS="filename"><IMGSRC="../chars/phi.gif"ALT="[phi]">(n)</I>. The Totient function of a number is definedas the count of integers less than that number that are relativelyprime to that number. (Two numbers are relatively prime if theyhave no common factors; for example, 9 and 8 are relatively prime.)The Totient function for a prime number is one less than the primenumber itself: every positive integer less than the number is relativelyprime to it.</P><PCLASS="para">The property used by <SPANCLASS="acronym">RSA</SPAN> was discoveredby Euler and is this: any integer <ICLASS="filename">i</I> relatively prime to <ICLASS="filename">n</I> raisedto the power of <ICLASS="filename"><IMGSRC="../chars/phi.gif"ALT="[phi]">(n)</I> and taken <ICLASS="filename">mod n </I>is equalto&nbsp;1. That is:</P><PCLASS="para">equation goes here</P><PCLASS="para">Suppose <EMCLASS="emphasis">e</EM> and <EMCLASS="emphasis">d</EM> are random integers that are inverses modulo<IMGSRC="../chars/phi.gif"ALT="[phi]"><EMCLASS="emphasis">(n)</EM>, that is:</P><PCLASS="para">equation goes here</P><PCLASS="para">A related property used in <SPANCLASS="acronym">RSA</SPAN> was alsodiscovered by Euler. His theorem says that if <EMCLASS="emphasis">M </EM>is any number relativelyprime to <EMCLASS="emphasis">n</EM>, then:</P><PCLASS="para">and equation goes here</P><PCLASS="para">Cryptographically speaking, if <EMCLASS="emphasis">M</EM> is part of a message, wehave a simple means for encoding it with one function:</P><PCLASS="para">equation goes here</P><PCLASS="para">and decoding it with another function:</P><PCLASS="para">equation goes here</P><PCLASS="para">So how do we get appropriate values for <ICLASS="filename">n</I>, <ICLASS="filename">e</I>, and <ICLASS="filename">d</I>?First, two large prime numbers <ICLASS="filename">p</I> and <KBDCLASS="command">q</KBD>, of approximately the samesize, are chosen, using some appropriate method. These numbers shouldbe large&nbsp;- on the order of several hundred digits&nbsp;- andthey should be kept secret.</P><PCLASS="para">Next, the Euler Totient function <IMGSRC="../chars/phi.gif"ALT="[phi]">(<ICLASS="filename">pq</I>) is calculated. In thecase of <KBDCLASS="command">n</KBD> being the product of two primes, <IMGSRC="../chars/phi.gif"ALT="[phi]">( <ICLASS="filename">p q</I> ) = (<ICLASS="filename">p - 1</I> ) ( <ICLASS="filename">q - 1</I> ) = <IMGSRC="../chars/phi.gif"ALT="[phi]">(<ICLASS="filename">n</I>).</P><PCLASS="para">Next, we pick a value e that is relatively prime to <IMGSRC="../chars/phi.gif"ALT="[phi]">(<ICLASS="filename">n</I>).A good choice would be to pick something in the interval max ( <ICLASS="filename">p+ 1, q + 1</I> ) &lt; <ICLASS="filename">e</I> &lt;; <IMGSRC="../chars/phi.gif"ALT="[phi]"> (<ICLASS="filename">n</I>). Thenwe calculate a corresponding <ICLASS="filename">d</I>, such that <ICLASS="filename">e d mod <IMGSRC="../chars/phi.gif"ALT="[phi]">(n)  1</I>. Thatis, we find the modular inverse of <ICLASS="filename">e mod <IMGSRC="../chars/phi.gif"ALT="[phi]">(n)</I>. If <ICLASS="filename">d</I> should happento be too small (i.e., less than about <ICLASS="filename">log2(n))</I>, we pick another<ICLASS="filename">e</I> and <ICLASS="filename">d</I>.</P><PCLASS="para">Now we have our keys. To encrypt a message m, we split m intofixed-size integers M less than n. Then we find the value (M<SUPCLASS="superscript">e</SUP>) modn = s for each portion of the message. This calculationcan be done quickly with hardware, or with software using specialalgorithms. These values are concatenated to form the encryptedmessage. To decrypt the message, it is split into the blocks, andeach block is decrypted as <EMCLASS="emphasis">(s<SUPCLASS="superscript">d</SUP></EM>) mod&nbsp;<EMCLASS="emphasis">n</EM> =<EMCLASS="emphasis">M</EM>.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.6.2">6.4.6.2 An RSA example</A></H4><PCLASS="para">For this example, assume we pick two prime numbers <EMCLASS="emphasis">p</EM> and <EMCLASS="emphasis">q</EM>:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">p = 251 q = 269 </PRE></BLOCKQUOTE><PCLASS="para">The number <EMCLASS="emphasis">n</EM> is therefore:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">n = 251 * 269 = 67519</PRE></BLOCKQUOTE><PCLASS="para">The Euler Totient function for this value is:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><IMGSRC="../chars/phi.gif"ALT="[phi]"><EMCLASS="emphasis">(n)</EM> = (251-1) (269-1) = 67000</PRE></BLOCKQUOTE><PCLASS="para">Let's arbitrarily pick <EMCLASS="emphasis">e</EM> as 50253. <EMCLASS="emphasis">d</EM> is then:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">d = e<SUPCLASS="superscript">-1</SUP> mod 67000 = 27917</PRE></BLOCKQUOTE><PCLASS="para">because:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">50253 * 27917 = 1402913001 = 20939 * 67000 + 1 = 1 ( mod 67000 )</PRE></BLOCKQUOTE><PCLASS="para">Using <EMCLASS="emphasis">n</EM> = 67519 allows us to encode any message <EMCLASS="emphasis">M</EM>that is between 0 and 67518. We can therefore use this system toencode a text message two characters at a time. (Two charactershave 16 bits, or 65536 possibilities.)</P><PCLASS="para">Using <EMCLASS="emphasis">e</EM> as our key, let's encode the message &quot;<SPANCLASS="acronym">RSA</SPAN>works!&quot; The sequence of <SPANCLASS="acronym">ASCII</SPAN> charactersencoding &quot;<SPANCLASS="acronym">RSA</SPAN> works!&quot; is shownin the following table</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="PUIS-CHP-6-TAB-2">Table 6.2: RSA Encoding Example</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><SPANCLASS="acronym">ASCII</SPAN></P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Decimal Value</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Encoded Value</P></TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">&quot;RS&quot;</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">21075</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">48467</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">&quot;A&quot;</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">16672</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">14579</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">&quot;wo&quot;</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">30575</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">26195</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">&quot;rk&quot;</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">29291</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">58004</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">&quot;s!&quot;</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">29473</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">30141</P></TD></TR></TBODY></TABLE><PCLASS="para">.</P><PCLASS="para">As you can see, the encoded values do not resemble the originalmessage.</P><PCLASS="para">To decrypt, we raise each of these numbers to the power ofd and take the remainder mod n. After translating to <SPANCLASS="acronym">ASCII</SPAN>,we get back the original message.</P><PCLASS="para">When <SPANCLASS="acronym">RSA</SPAN> is used for practical applications,it is used with numbers that are hundreds of digits long. Becausedoing math with hundred-digit-long strings is time consuming, modernpublic key applications are designed to minimize the number of <SPANCLASS="acronym">RSA</SPAN>calculations that need to be performed. Instead of using <SPANCLASS="acronym">RSA</SPAN>to encrypt the entire message, <SPANCLASS="acronym">RSA</SPAN> is used toencrypt a session key, which itself is used to encrypt the messageusing a high-speed, private key algorithm such as <SPANCLASS="acronym">DES</SPAN>or <SPANCLASS="acronym">IDEA</SPAN>.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.6.3">6.4.6.3 Strength of RSA</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7664"></A>Thenumbers <EMCLASS="emphasis">n</EM> and either <EMCLASS="emphasis">e</EM> or <EMCLASS="emphasis">d</EM> can be disclosed without seriously compromisingthe strength of an <SPANCLASS="acronym">RSA</SPAN> cipher. For an attackerto be able to break the encryption, he or she would have to find<IMGSRC="../chars/phi.gif"ALT="[phi]">(<EMCLASS="emphasis">n</EM>), which, to the best of anyone's knowledge, requiresfactoring <EMCLASS="emphasis">n</EM>.</P><PCLASS="para">Factoring large numbers is very difficult&nbsp;- no knownmethod exists to do it efficiently. The time required to factora number can be several hundred years or several billion years withthe fastest computers, depending on how large the number <EMCLASS="emphasis">n</EM> is. If<EMCLASS="emphasis">n</EM> is large enough, it is, for all intents and purposes, unfactorable.The <SPANCLASS="acronym">RSA</SPAN> encryption system is therefore quitestrong, provided that appropriate values of <EMCLASS="emphasis">n</EM>, <EMCLASS="emphasis">e</EM>, and <EMCLASS="emphasis">d</EM> are chosen,and that they are kept secret.</P><PCLASS="para">To see how difficult factoring a large number is, let'sdo a little rough calculation of how long factoring a 200 decimal-digitnumber would take; this number is more than 70 digits longer thanthe largest number ever factored, as of the time this book wentto press.</P><PCLASS="para">All 200-digit values can be represented in at most 665 binarybits.</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">has  digits.equation goes here</P></LI></OL><PCLASS="para">(In general, to factor a 665-bit number using one of the fastest-knownfactoring algorithms would require approximately 1.2 x 10<SUPCLASS="superscript">23</SUP> operations.)</P><PCLASS="para">Let's assume you have a machine that will do 10 billion(10<SUPCLASS="superscript">10</SUP>) operations per second. (Somewhat faster than today'sfastest parallel computers.) To perform 1.2 x 10<SUPCLASS="superscript">23</SUP> operations wouldrequire 1.2 x 10<SUPCLASS="superscript">13</SUP> seconds, or 380,267 years worth of computer time.If you feel uneasy about having your number factored in 380,267years, simply double the size of your prime number: a 400-digitnumber would require a mere 8.6 x 10<SUPCLASS="superscript">15</SUP> years to factor. This isprobably long enough; according to Stephen Hawking's <EMCLASS="emphasis">A Brief History of Time</EM>, the universe itself is only about 2 x 10<SUPCLASS="superscript">10</SUP>years old.</P><PCLASS="para">To give you another perspective on the size of these numbers,assume that you (somehow) could precalculate the factors of all200 decimal digit numbers. Simply to store the unfactored numbersthemselves would require approximately (9 x 10<SUPCLASS="superscript">200</SUP>) x 665 bits ofstorage (not including any overhead or indexing). Assume that youcan store these on special media that hold 100GB (100 x 1024<SUPCLASS="superscript">4</SUP> orapproximately 1.1 x 10<SUPCLASS="superscript">14</SUP>) of storage. You would need about 6.12x 10 <SUPCLASS="superscript">189</SUP> of these disks.</P><PCLASS="para">Now assume that each of those disks is only one millionth<EMCLASS="emphasis">A Brief History of Time</EM>, the universe itself is only about 2 x 1010of a gram in weight (1 pound is 453.59 grams). The weight of allyour storage would come to over 6.75 x 10<SUPCLASS="superscript">177</SUP> tons of disk. The planetEarth weighs only 6.588 x 10<SUPCLASS="superscript">21</SUP> tons. The Chandrasekhar limit, theamount of mass at which a star will collapse into a black hole,is about 1.5 times the mass of our Sun, or approximately 3.29 x10<SUPCLASS="superscript">27</SUP> tons. Thus, your storage, left to itself, would collapse intoa black hole from which your factoring could not escape! We arenot sure how much mass is in our local galaxy, but we suspect itmight be less than the amount you'd need for this project.</P><PCLASS="para">Again, it looks fairly certain that without a major breakthroughin number theory, the <SPANCLASS="acronym">RSA</SPAN> mechanism (and similarmethods) are almost assuredly safe from brute-force attacks, providedthat you are careful in selecting appropriately prime numbers tocreate<ACLASS="indexterm"NAME="AUTOID-7706"></A><ACLASS="indexterm"NAME="AUTOID-7708"></A><ACLASS="indexterm"NAME="AUTOID-7712"></A><ACLASS="indexterm"NAME="AUTOID-7714"></A> your key.</P><DIVCLASS="sidebar"><H4CLASS="sidebar"><ACLASS="title"NAME="AUTOID-7717">Factor This!</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7720"></A>Not a year goes bywithout someone claiming to have made a revolutionary breakthroughin the field of factoring &nbsp;-  some new discovery which &quot;breaks&quot;<SPANCLASS="acronym">RSA</SPAN> and leaves any program based upon it vulnerableto decoding.</P><PCLASS="para">To help weed out the frauds from the real findings, <SPANCLASS="acronym">RSA</SPAN>Data Security has created a challenge list of numbers. Each numberon the list is the product of two large prime numbers. When thefolks at <SPANCLASS="acronym">RSA</SPAN> are contacted by somebody who claimsa factoring breakthrough (and usually promises to keep the breakthrougha secret in exchange for some cash), they give the person a copyof the <SPANCLASS="acronym">RSA</SPAN> challenge numbers.</P><PCLASS="para">The first <SPANCLASS="acronym">RSA</SPAN> challenge number was publishedin the August 1977 issue of Scientific American. The number was129 digits long, and $100 was offered for finding its factors.The <SPANCLASS="acronym">RSA</SPAN>-129 number was solved in the fall of1994 by an international team of more than 600 volunteers.</P><PCLASS="para">A month later, a researcher at the <SPANCLASS="acronym">MIT</SPAN>AI Laboratory contacted one of the authors of this chapter, claiminga new factoring breakthrough. But there was a catch: to prove thathe had solved the factoring problem, the researcher had factoredthat same <SPANCLASS="acronym">RSA</SPAN>-129 number.</P><PCLASS="para">Nice try. That one has already been solved. If you are interestedin the fame and fortune that comes from finding new factoring functions,try factoring this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">RSA-140 =21290246318258757547497882016271517497806703963277216278233383215381949984056495911366573853021918316783107387995317230889569230873441936471 </PRE></BLOCKQUOTE><PCLASS="para">If you factor this number, you'llget more than fame: you'll get cash. <SPANCLASS="acronym">RSA</SPAN>Data Security keeps a &quot;jackpot&quot; for factoringwinners. The pot grows by $1750 every quarter. The firstquarter of 1995, it was approximately $15,000.</P><PCLASS="para">Youcan get a complete list of all the <SPANCLASS="acronym">RSA</SPAN> challengenumbers by sending an electronic mail message to <EMCLASS="emphasis">challenge-rsa-list@rsa.com</EM>.</P></DIV></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.7">6.4.7 An Unbreakable Encryption Algorithm</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7743"></A><ACLASS="indexterm"NAME="AUTOID-7745"></A>One type of encryption system is trulyunbreakable: the so-called <EMCLASS="emphasis">one-time pad mechanism</EM>. A one-time padis illustrated in <ACLASS="xref"HREF="ch06_04.htm#PUIS-CHP-6-FIG-4"TITLE="A one-time pad">Figure 6.4</A>.</P><PCLASS="para">The one-time pad often makes use of the mathematical functionknown as <ACLASS="indexterm"NAME="AUTOID-7751"></A><ACLASS="indexterm"NAME="AUTOID-7753"></A>exclusiveOR (<SPANCLASS="acronym">XOR</SPAN>,<IMGSRC="../chars/oplus.gif"ALT="(+)">). If you <SPANCLASS="acronym">XOR</SPAN> a numberwith any value <EMCLASS="emphasis">V</EM>, then you get a second, encryptednumber. <SPANCLASS="acronym">XOR</SPAN> the encrypted number with value Va second time, and you'll get your starting number back.That is:</P><PCLASS="para">message = M</P><PCLASS="para">ciphertext = M<IMGSRC="../chars/oplus.gif"ALT="(+)">V</P><PCLASS="para">plaintext = ciphertext<IMGSRC="../chars/oplus.gif"ALT="(+)">V = ((M<IMGSRC="../chars/oplus.gif"ALT="(+)">V)<IMGSRC="../chars/oplus.gif"ALT="(+)">V)</P><PCLASS="para">A system based on one-time pads is mathematically unbreakable(provided that the key itself is truly random) because you can'tdo a key search: if you try every possible key, you will get everypossible message of the same length back. How do you tell whichone is correct?</P><PCLASS="para">Unfortunately, there is a catch: to use this system, you needto have a stream of values&nbsp;- a key, if you will&nbsp;- thatis at least as long as the message you wish to encrypt. Each characterof your message is <SPANCLASS="acronym">XOR</SPAN>'ed, bit by bit,with each successive character of the stream.</P><H4CLASS="figure"><ACLASS="title"NAME="PUIS-CHP-6-FIG-4">Figure 6.4: A one-time pad</A></H4><IMGCLASS="graphic"SRC="figs/puis_0604.gif"ALT="Figure 6.4"><PCLASS="para">One-time pads have two important vulnerabilities:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">The stream of random values must betruly random. If there is any regularity or order, that order canbe measured and exploited to decode the message.</P></LI><LICLASS="listitem"><PCLASS="para">The stream must never be repeated. If it is, a sophisticatedcryptanalyst can find the repeats and use them to decode all messagesthat have been encoded with the no-longer one-time pad.</P></LI></OL><PCLASS="para">Most one-time pads are generated with machines based on nuclearradioactive decay, a process that is believed to be unpredictable,if not truly random. Almost every &quot;random number generator&quot;you will find on any standard computer system will not generatetruly random numbers: the sequence will eventually repeat.</P><PCLASS="para">To see how this encryption mechanism works in practice, imaginethe following one-time pad:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">23 43 11 45 23 43 98 43 52 86 43 87 43 92 34</PRE></BLOCKQUOTE><PCLASS="para">With this sequence, the message:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><SPANCLASS="acronym">UNIX</SPAN> is secure.</PRE></BLOCKQUOTE><PCLASS="para">Might encrypt as follows:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:\:\:s*:3:\rEs[drNERwe.</PRE></BLOCKQUOTE><PCLASS="para">Which is really a printed representation of the followingstring of values:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">69 98 85 55 66 17 11 71 51 72 34 89 57 12</PRE></BLOCKQUOTE><PCLASS="para">To use a one-time pad system, you need two copies of the pad:one to encrypt the message, and the other to decrypt the message.Each copy must be destroyed after use; after all, if an attackershould ever obtain a copy of the pad, then any messages sent withit would be compromised.</P><PCLASS="para">One of the main uses of one-time pads has been for sensitivediplomatic communications that are subject to heavy monitoring andintensive code breaking attempts&nbsp;- such as the communicationlines between the U.S. Embassy in Moscow and the State Departmentin Washington, D.C. However, the general use of one-time pads islimited because generating the sequence of random bits is difficult,and distributing it securely to both the sender and the recipientof the message is expensive.</P><PCLASS="para">Because of the problems associated with one-time pads, otherkinds of algorithms are normally employed for computer encryption.These tend to be compact, mathematically based functions. The mathematicalfunctions are frequently used to generate a pseudorandom sequenceof numbers that are <SPANCLASS="acronym">XOR</SPAN>'ed with theoriginal message&nbsp;- which is similar to the way the one-timepad works. (For example, Jim Bidzos, president of <SPANCLASS="acronym">RSA</SPAN>Data Security, likes to call its RC4 stream cipher a &quot;one-timepad generator,&quot; although the cipher is clearly not sucha thing.) The difference between the two techniques is that, withmathematical functions, you can always&nbsp;- in principle, atleast&nbsp;- translate any message encrypted with these methodsback into the original message without knowing the key. <ACLASS="indexterm"NAME="AUTOID-7789"></A><ACLASS="indexterm"NAME="AUTOID-7791"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-6-SECT-4.8">6.4.8 Proprietary Encryption Systems</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7797"></A><ACLASS="indexterm"NAME="AUTOID-7799"></A><ACLASS="indexterm"NAME="AUTOID-7802"></A>TheRC4 algorithm mentioned in the previous section is an example ofa so-called proprietary encryption algorithm: an encryption algorithmdeveloped by an individual or company which is not made publiclyavailable.</P><PCLASS="para">There are many proprietary algorithms in use today. Usually,the algorithms are private key algorithms that are used in placeof algorithms such as <SPANCLASS="acronym">DES</SPAN> or <SPANCLASS="acronym">IDEA</SPAN>.[20] Althoughsome proprietary systems are relatively secure, the vast majorityare not. To make matters worse, you can rarely tell which are safeand which are not&nbsp;- especially if the company selling theencryption program refuses to publish the details of the algorithm.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[20] While creating a public key encryption system is difficult,creating a private key system is comparatively easy. Making a privatekey system that is <EMCLASS="emphasis">secure</EM>, on the other hand,is a considerably more difficult endeavor.</P></BLOCKQUOTE><PCLASS="para">A standard tenet in data encryption is that the security ofthe system should depend completely on the security of the encryptionkey. When choosing an encryption system, rely on formal mathematicalproofs of security, rather than on secret proprietary systems. Ifthe vendor of an encryption algorithm or technology will not disclosethe algorithm and show how it has been analyzed to show its strength,you are probably better off avoiding it.</P><PCLASS="para">The RC4 algorithm is no exception to this tenet. In 1994,an unknown person or persons published source code that claimedto be RC4 on the Internet. By early 1996, a number of groups aroundthe world had started to find minor flaws in the algorithm, mostof them having to do with weak keys. Although RC4 appears to besecure for most applications at this time, the clock may be ticking.</P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_03.htm"TITLE="6.3 The Enigma Encryption System"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.3 The Enigma Encryption System"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Practical UNIX &amp; Internet Security"><IMGSRC="../gifs/txthome.gif"ALT="Practical UNIX &amp; Internet Security"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_05.htm"TITLE="6.5 Message Digests and Digital Signatures"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.5 Message Digests and Digital Signatures"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">6.3 The Enigma Encryption System</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">6.5 Message Digests and Digital Signatures</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>