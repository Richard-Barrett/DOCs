<HTML><HEAD><TITLE>[Chapter 20] NFS</TITLE><METANAME="DC.title"CONTENT="Practical UNIX &amp; Internet Security"><METANAME="DC.creator"CONTENT="Simson Garfinkel &amp; Gene Spafford"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:15:49Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-148-8"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="part04.htm"TITLE="IV. Network and Internet Security"><LINKREL="prev"HREF="ch19_07.htm"TITLE="19.7 Other Network Authentication Systems"><LINKREL="next"HREF="ch20_02.htm"TITLE="20.2 Server-Side NFS Security"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Practical UNIX &amp; Internet Security"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Practical UNIX &amp; Internet Security"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch19_07.htm"TITLE="19.7 Other Network Authentication Systems"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 19.7 Other Network Authentication Systems"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 20</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch20_02.htm"TITLE="20.2 Server-Side NFS Security"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 20.2 Server-Side NFS Security"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="CHAPTER"><H1CLASS="chapter"><ACLASS="title"NAME="PUIS-CHP-20">20. NFS</A></H1><DIVCLASS="htmltoc"><P><B>Contents:</B><BR><ACLASS="SECT1"HREF="#PUIS-CHP-20-SECT-1"TITLE="20.1 Understanding NFS">Understanding NFS</A><BR><ACLASS="SECT1"HREF="ch20_02.htm"TITLE="20.2 Server-Side NFS Security">Server-Side NFS Security</A><BR><ACLASS="SECT1"HREF="ch20_03.htm"TITLE="20.3 Client-Side NFS Security">Client-Side NFS Security</A><BR><ACLASS="SECT1"HREF="ch20_04.htm"TITLE="20.4 Improving NFS Security">Improving NFS Security</A><BR><ACLASS="SECT1"HREF="ch20_05.htm"TITLE="20.5 Some Last Comments">Some Last Comments</A></P><P></P></DIV><PCLASS="para">In many environments, we want to share files and programsamong many workstations in a local area network. Doing so requiresprograms that let us share the files, create new files, do filelocking, and manage ownership correctly. Over the last dozen yearsthere have been a number of network-capable filesystems developedby commercial firms and research groups. These have included ApolloDomain, the Andrew Filesystem (<SPANCLASS="acronym">AFS</SPAN>), the AT&amp;TRemote Filesystem (<SPANCLASS="acronym">RFS</SPAN>), and Sun Microsystems'Network Filesystem (<SPANCLASS="acronym">NFS</SPAN>). Each of these has hadbeneficial features and limiting drawbacks.</P><PCLASS="para">Of all the network filesystems, <SPANCLASS="acronym">NFS</SPAN> isprobably the most widely used. <SPANCLASS="acronym">NFS</SPAN> is availableon almost all versions of <SPANCLASS="acronym">UNIX</SPAN>, as well as onApple Macintosh systems, MS-<SPANCLASS="acronym">DOS</SPAN>, Windows, <SPANCLASS="acronym">OS/2</SPAN>,and <SPANCLASS="acronym">VMS</SPAN>. <SPANCLASS="acronym">NFS</SPAN> has continuedto mature, and we expect that Version 3 of <SPANCLASS="acronym">NFS</SPAN>will help to perpetuate and expand its reach. For this reason, wewill focus in this book on the security implications of running<SPANCLASS="acronym">NFS</SPAN> on your <SPANCLASS="acronym">UNIX</SPAN> systems.If you use one of the other forms of network filesystems, thereare associated security considerations, many of which are similarto the ones we present here: be sure to consult your vendor documentation.</P><DIVCLASS="sect1"><H2CLASS="sect1"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1">20.1 Understanding NFS</A></H2><PCLASS="para">Using <SPANCLASS="acronym">NFS</SPAN>, clients can mount partitionsof a server as if they were physically connected to the client.In addition to simply allowing remote access to files over the network,<SPANCLASS="acronym">NFS</SPAN> allows many (relatively) low-cost computersystems to share the same high-capacity disk drive at the same time.<SPANCLASS="acronym">NFS</SPAN> server programs have been written for manydifferent operating systems, which let users on <SPANCLASS="acronym">UNIX</SPAN>workstations have remote access to files stored on a variety ofdifferent platforms. <SPANCLASS="acronym">NFS</SPAN> clients have been writtenfor microcomputers such as the <SPANCLASS="acronym">IBM/PC</SPAN> and AppleMacintosh, giving PC users much of the same flexibility enjoyedby their <SPANCLASS="acronym">UNIX</SPAN> coworkers, as well as a relativelyeasy method of data interchange.</P><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> is nearly transparent. In practice,a workstation user simply logs into the workstation and begins working,accessing it as if the files were locally stored. In many environments,workstations are set up to mount the disks on the server automaticallyat boot time or when files on the disk are first referenced. <SPANCLASS="acronym">NFS</SPAN>also has a network mounting program that can be configured to mountthe <SPANCLASS="acronym">NFS</SPAN> disk automatically when an attempt ismade to access files stored on remote disks.</P><PCLASS="para">There are several basic security problems with <SPANCLASS="acronym">NFS</SPAN>:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> is built ontop of Sun's <SPANCLASS="acronym">RPC</SPAN> (Remote Procedure Call),and in most cases uses <SPANCLASS="acronym">RPC</SPAN> for user authentication.Unless a secure form of <SPANCLASS="acronym">RPC</SPAN> is used, <SPANCLASS="acronym">NFS</SPAN>can be easily spoofed.</P></LI><LICLASS="listitem"><PCLASS="para">Even when Secure <SPANCLASS="acronym">RPC</SPAN> is used,information sent by <SPANCLASS="acronym">NFS</SPAN> over the network is notencrypted, and is thus subject to monitoring and eavesdropping.As we mention elsewhere, the data can be intercepted and replaced(thereby corrupting or Trojaning files being imported via <SPANCLASS="acronym">NFS</SPAN>).</P></LI><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> uses the standard <SPANCLASS="acronym">UNIX</SPAN>filesystem for access control, opening the networked filesystemto many of the same problems as a local filesystem.</P></LI></UL><PCLASS="para">One of the key design features behind <SPANCLASS="acronym">NFS</SPAN>is the concept of <ICLASS="firstterm">server</I> <ICLASS="filename">statelessness</I>.Unlike several other systems, there is no &quot;state&quot;kept on a server to indicate that a client is performing a remotefile operation. Thus, if the client crashes and is rebooted, thereis no state in the server that needs to be recovered. Alternatively,if the server crashes and is rebooted, the client can continue operatingon the remote file as if nothing really happened&nbsp;- thereis no server-side state to recreate.[1] We'll discuss this concept furtherin later sections.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] Actual implementationsare not completely stateless, however, as we will see later in thischapter.</P></BLOCKQUOTE><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1.1">20.1.1 NFS History</A></H3><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> was developed inside Sun Microsystemsin the early 1980s. Since that time, <SPANCLASS="acronym">NFS</SPAN> hasundergone three major revisions:</P><DLCLASS="variablelist"><DTCLASS="term">NFS Version 1</DT><DDCLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> Version 1 was Sun'sprototype network filesystem. This version was never released tothe outside world.</P></DD><DTCLASS="term">NFS Version 2</DT><DDCLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> Version 2 was first distributedwith Sun's SunOS 2 operating system in 1985. Version 2was widely licensed to numerous <SPANCLASS="acronym">UNIX</SPAN> workstationvendors. A freely distributable, compatible version was developedin the late 1980s at the University of California at Berkeley.</P><PCLASS="para">During its 10-year life, many subtle, undocumentedchanges were made to the <SPANCLASS="acronym">NFS</SPAN> version 2 specification.Some vendors allowed <SPANCLASS="acronym">NFS</SPAN> version 2 to read orwrite more than 4K bytes at a time; others increased the numberof groups provided as part of the <SPANCLASS="acronym">RPC</SPAN> authenticationfrom 8 to 16. Although these minor changes created occasional incompatibilitiesbetween different <SPANCLASS="acronym">NFS</SPAN> implementations, <SPANCLASS="acronym">NFS</SPAN>version 2 provided a remarkable degree of compatibility betweensystems made by different vendors.</P></DD><DTCLASS="term">NFS Version 3</DT><DDCLASS="listitem"><PCLASS="para">The <SPANCLASS="acronym">NFS</SPAN> Version 3 specificationwas developed during a series of meetings in Boston in July, 1992.[2]Working code for <SPANCLASS="acronym">NFS</SPAN> Version 3 was introducedby some vendors in 1995, and is expected to be widely availablein 1996. Version 3 incorporates many performance improvements overVersion 2, but does not significantly change the way that <SPANCLASS="acronym">NFS</SPAN>works or the security model used by the network filesystem.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] Pawlowski, Juszczak, Staubach, Smith, Lebel and Hitz, &quot;NFSVersion 3 Design and Implementation,&quot; USENIX Summer 1994conference. The standard was later codified as RFC 1813. A copyof the NFS Version 3 paper can be obtained from <ACLASS="systemitem.url"HREF="http://www.netapp.com/Docs/TechnicalDocs/nfs_version_3.html">http://www.netapp.com/Docs/TechnicalDocs/nfs_version_3.html</A>.The RFC can be downloaded from <ACLASS="systemitem.url"HREF="http://ds.internic.net/rfc/rfc1813.txt">http://ds.internic.net/rfc/rfc1813.txt</A>.</P></BLOCKQUOTE></DD></DL><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN><ACLASS="indexterm"NAME="AUTOID-28045"></A>is based on two similar but distinctprotocols: <SPANCLASS="acronym">MOUNT</SPAN> <ACLASS="indexterm"NAME="AUTOID-28049"></A>and<SPANCLASS="acronym">NFS</SPAN>. Both make use of a data object known asa <ICLASS="firstterm">file handle</I>. There is also a distributedprotocol for file locking, which is not technically part of <SPANCLASS="acronym">NFS</SPAN>,and which does not have any obvious security ramifications (otherthan those related to potential denial of service attacks for itsusers), so we won't describe the file locking protocolhere.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1.2">20.1.2 <ACLASS="indexterm"NAME="AUTOID-28057"></A>File Handles</A></H3><PCLASS="para">Each object on the <SPANCLASS="acronym">NFS</SPAN>-mounted filesystemis referenced by a unique object called a<ICLASS="firstterm"> file handle</I>.A file handle is viewed by the client as being <ICLASS="firstterm">opaque</I>&nbsp;- theclient cannot interpret the contents. However, to the server, thecontents have considerable meaning. The file handles uniquely identifyevery file and directory on the server computer.</P><PCLASS="para">Under <SPANCLASS="acronym">UNIX</SPAN>, a file handle consists of atleast three important elements: the <EMCLASS="emphasis">filesystem identifier</EM>,the <EMCLASS="emphasis">file identifier</EM>, and a <ICLASS="firstterm">generationcount</I>. The file identifier can be something as simpleas an inode number to refer to a particular item on a partition.The filesystem identifier refers to the partition containing thefile (inode numbers are unique per partition, but not per system).The file handle doesn't include a pathname; a pathnameis not necessary and is in fact subject to change while a file isbeing accessed.</P><PCLASS="para">The generation count is a number that is incremented eachtime a file is unlinked and recreated. The generation count ensuresthat when a client references a file on the server, that file isin fact the same file that the server thinks it is. Without a generationcount, two clients accessing the same file on the server could produceerroneous results if one client deleted the file and created a newfile with the same inode number. The generation count prevents suchsituations from occurring: when the file is recreated, the generationnumber is incremented, and the second client gets an error messagewhen it attempts to access the older, now nonexistent, file.</P><DIVCLASS="sidebar"><H4CLASS="sidebar"><ACLASS="title"NAME="AUTOID-28069">Which Is Better: Stale Handles or Stale Love?</A></H4><PCLASS="para">To better understand the role of the generationcount, imagine a situation in which you are writing a steamy loveletter to a colleague with whom you are having a clandestine affair.You start by opening a new editor file on your workstation. Unbeknownstto you, your editor puts the file in the <ICLASS="filename">/tmp</I>directory, which happens to be on the <SPANCLASS="acronym">NFS</SPAN> server.The server allocates an inode from the free list on that partition,constructs a file handle for the new file, and sends the file handleto your workstation (the client). You begin editing the file. &quot;Mydarling chickadee, I remember last Thursday in your office,&quot;you start to write, only to be interrupted by a long phone call.</P><PCLASS="para">Youaren't aware of it, but as you are talking on the phone,there is a power flicker in the main computer room, and the servercrashes and reboots. As part of the reboot, the temporary file foryour mailer is deleted along with everything else in the <ICLASS="filename">/tmp</I>directory, and its inode is added back to the free list on the server.While you are still talking on the phone, your manager starts tocompose a letter to the president of the company, recommending araise and promotion for you. He also opens a file in the <ICLASS="filename">/tmp</I>directory, and his diskless workstation is allocated a file handlefor the same inode that you were using (it is free now, after all)!</P><PCLASS="para">You finally finish your call and return to your letter.Of course, you notice nothing out of the ordinary because of thestateless nature of <SPANCLASS="acronym">NFS</SPAN>. You put the finishingtouches on your letter, &quot;... and I can'twait until this weekend; my wife suspects nothing!&quot; andsave it. Your manager finishes his letter at the same moment: &quot;...as a reward for his hard work and serious attitude, I recommenda 50% raise.&quot; Your manager and you hit the &quot;send&quot;key simultaneously.</P><PCLASS="para">Without a generation count, theresults might be less than amusing. The object of your affectioncould get a letter about you deserving a raise. Or, your manager'sboss could get a letter concerning a midday dalliance on the desktop.Or, both recipients might get a mixture of the two versions, witheach version containing one file record from one file and one fromanother. The problem is that the system can't distinguishthe two files because the file handles are the same.</P><PCLASS="para">Thissort of thing occasionally happened before Sun got the generation-countcode working properly and consistently. With the generation-countsoftware working as it should, you would instead get an error messagestating &quot;Stale <SPANCLASS="acronym">NFS</SPAN> File Handle&quot;when you try to access the (now deleted) file. That's becausethe server increments the generation count value in the inode whenthe inode is returned to the free list. Later, whenever the serverreceives a request from a client that has a valid file handle <EMCLASS="emphasis">exceptfor the generation count</EM>, the server rejects the operationand returns an error.</P></DIV><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> Some <SPANCLASS="acronym">NFS</SPAN> servers ignore the generationcount in the file handle. These versions of <SPANCLASS="acronym">NFS</SPAN>are considerably less secure, as they enable an attacker to easilycreate valid file handles for directories on the server.</P></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1.3">20.1.3 MOUNT Protocol</A></H3><PCLASS="para">The <SPANCLASS="acronym">MOUNT</SPAN> protocol is used for the initialnegotiation between the <SPANCLASS="acronym">NFS</SPAN> client and the <SPANCLASS="acronym">NFS</SPAN>server. Using <SPANCLASS="acronym">MOUNT</SPAN>, a client can determine whichfilesystems are available for mounting and can obtain a token (thefile handle) which is used to access the root directory of a particularfilesystem. After that file handle is returned, it can thereafterbe used to retrieve file handles for other directories and fileson the server.</P><PCLASS="para">Another benefit of the <SPANCLASS="acronym">MOUNT</SPAN> protocol isthat you can export only a portion of a local partition to a remoteclient. By specifying that the root is a directory on the partition,the <SPANCLASS="acronym">MOUNT</SPAN> service will return its file handleto the client. To the client, this file handle behaves exactly asone for the root of a partition: reads, writes, and directory lookupsall behave the same way.</P><PCLASS="para"><SPANCLASS="acronym">MOUNT</SPAN> is an <SPANCLASS="acronym">RPC</SPAN> service.The service is provided by the <KBDCLASS="command">mountd</KBD> or <KBDCLASS="command">rpc.mountd</KBD>daemon, which is started automatically at boot. (On Solaris 2.xsystems, for example, <KBDCLASS="command">mountd</KBD> is located in <ICLASS="firstterm">/usr/lib/nfs/</I><ICLASS="filename">mountd,</I>and is started by the startup script <ICLASS="filename">/etc/rc3.d/S15nfs.server</I>.)<SPANCLASS="acronym">MOUNT</SPAN> is often given the <SPANCLASS="acronym">RPC</SPAN>program number 100,005. The standard mountd can respond to sevendifferent requests:</P><TABLECLASS="informaltable"><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">NULL</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Does nothing.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">MNT</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Returns a file handle for a filesystem.Advises the <KBDCLASS="command">mount</KBD> daemon that a client has mounted the filesystem.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">DUMP</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Returns the list of mounted filesystems.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">UMNT</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Removes the <KBDCLASS="command">mount</KBD> entry for this clientfor a particular filesystem.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">UMNTALL</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Removes all <KBDCLASS="command">mount</KBD> entries for this client.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">EXPORT</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Returns the server's exportlist to the client.</P></TD></TR></TBODY></TABLE><PCLASS="para">Although the <SPANCLASS="acronym">MOUNT</SPAN> protocol provides usefulinformation within an organization, the information that it providescould be used by those outside an organization to launch an attack.For this reason, you should prevent people outside your organizationfrom accessing your computer's <KBDCLASS="command">mount</KBD> daemon. Two ways ofproviding this protection are via the <KBDCLASS="command">portmapper</KBD> wrapper, and viaan organizational firewall. See Chapter 22, <EMCLASS="emphasis">Wrappers and Proxies,</EM>and <ACLASS="xref"HREF="ch21_01.htm"TITLE="Firewalls">Chapter 21, <CITECLASS="chapter">Firewalls</CITE></A>, forfurther information.</P><PCLASS="para">The <SPANCLASS="acronym">MOUNT</SPAN> protocol is based on Sun Microsystem'sRemote Procedure Call (<SPANCLASS="acronym">RPC</SPAN>) and External DataRepresentation (<SPANCLASS="acronym">XDR</SPAN>) protocols. For a completedescription of the <SPANCLASS="acronym">MOUNT</SPAN> protocol see <SPANCLASS="acronym">RFC</SPAN>1094.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1.4">20.1.4 NFS Protocol</A></H3><PCLASS="para">The <SPANCLASS="acronym">NFS</SPAN> protocol takes over where the <SPANCLASS="acronym">MOUNT</SPAN>protocol leaves off. With the <SPANCLASS="acronym">NFS</SPAN> protocol, aclient can list the contents of an exported filesystem'sdirectories; obtain file handles for other directories and files;and even create, read, or modify files (as permitted by <SPANCLASS="acronym">UNIX</SPAN>permissions.)</P><PCLASS="para">Here is a list of the <SPANCLASS="acronym">RPC</SPAN> functions thatperform operations on directories:</P><TABLECLASS="informaltable"><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">CREATE</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Creates (or truncates) a file in thedirectory</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">LINK</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Creates a hard link</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">LOOKUP</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Looks up a file in the directory</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">MKDIR</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Makes a directory</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">READADDR</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Reads the contents of a directory</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">REMOVE</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Removes a file in the directory</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">RENAME</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Renames a file in the directory</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">RMDIR</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Removes a directory</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">SYMLINK</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Creates a symbolic link</P></TD></TR></TBODY></TABLE><PCLASS="para">These <SPANCLASS="acronym">RPC</SPAN> functions can be used with files:</P><TABLECLASS="informaltable"><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">GETATTR</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Gets a file's attributes (owner,length, etc.)</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">SETATTR</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Sets some of a file's attributes</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">READLINK</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Reads a symbolic link's path</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">READ</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Reads from a file.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">WRITE</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Writes to a file.</P></TD></TR></TBODY></TABLE><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> version 3 adds a number of additional<SPANCLASS="acronym">RPC</SPAN> functions. With the exception of <SPANCLASS="acronym">MKNOD3</SPAN>,these new functions simply allow improved performance:</P><TABLECLASS="informaltable"><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">ACCESS</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Determines if a user has the permissionto access a particular file or directory.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">FSINFO</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Returns static information about a filesystem.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">FSSTAT</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Returns dynamic information about a filesystem.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><ICLASS="function">MKNOD</I></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Creates a device or special file on theremote filesystem.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><ICLASS="function">READDIRPLUS</I></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Reads a directory and returns the fileattributes for each entry in the directory.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><ICLASS="function">PATHCONF</I></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Returns the attributes of a file specifiedby pathname.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><ICLASS="function">COMMIT</I></P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Commits the NFS write cache to disk.</P></TD></TR></TBODY></TABLE><PCLASS="para">All communication between the <SPANCLASS="acronym">NFS</SPAN> clientand the <SPANCLASS="acronym">NFS</SPAN> server is based upon Sun's<SPANCLASS="acronym">RPC</SPAN> system, which lets programs running on onecomputer call subroutines that are executed on another. <SPANCLASS="acronym">RPC</SPAN>uses Sun's <SPANCLASS="acronym">XDR</SPAN> system to allow the exchangeof information between different kinds of computers. For speed andsimplicity, Sun built <SPANCLASS="acronym">NFS</SPAN> upon the Internet UserDatagram Protocol (<SPANCLASS="acronym">UDP</SPAN>); however, <SPANCLASS="acronym">NFS</SPAN>version 3 allows the use of <SPANCLASS="acronym">TCP</SPAN>, which actuallyimproves performance over low-bandwidth, high-latency links suchas modem-based <SPANCLASS="acronym">PPP</SPAN> connections.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1.4.1">20.1.4.1 How NFS creates a reliable filesystem from a best-effortprotocol</A></H4><PCLASS="para"><SPANCLASS="acronym">UDP</SPAN> is fast but only best-effort: &quot;Besteffort&quot; means that the protocol does not guarantee that<SPANCLASS="acronym">UDP</SPAN> packets transmitted will ever be delivered,or that they will be delivered in order. <SPANCLASS="acronym">NFS</SPAN>works around this problem by requiring the <SPANCLASS="acronym">NFS</SPAN>server to acknowledge every <SPANCLASS="acronym">RPC</SPAN> command witha result code that indicates whether the command was successfullycompleted or not. If the <SPANCLASS="acronym">NFS</SPAN> client does notget an acknowledgment within a certain amount of time, it retransmitsthe original command.</P><PCLASS="para">If the <SPANCLASS="acronym">NFS</SPAN> client does not receive an acknowledgment,then <SPANCLASS="acronym">UDP</SPAN> lost either the original <SPANCLASS="acronym">RPC</SPAN>command or the <SPANCLASS="acronym">RPC</SPAN> acknowledgment. If the original<SPANCLASS="acronym">RPC</SPAN> command was lost, there is no problem&nbsp;- theserver sees it for the first time when it is retransmitted. Butif the acknowledgment was lost, the server will actually get thesame <SPANCLASS="acronym">NFS</SPAN> command twice.</P><PCLASS="para">For most <SPANCLASS="acronym">NFS</SPAN> commands, this duplicationof requests presents no problem. With <SPANCLASS="acronym">READ</SPAN>, forexample, the same block of data can be read once or a dozen times,without consequence. Even with the <SPANCLASS="acronym">WRITE</SPAN> command,the same block of data can be written twice to the same point inthe file, without consequence.[3]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] This is preciselythe reason that NFS does not have an atomic command for appendinginformation to the end of a file.</P></BLOCKQUOTE><PCLASS="para">Other commands, however, cannot be executed twice in a row.<SPANCLASS="acronym">MKDIR</SPAN>, for example, will fail the second timethat it is executed because the requested directory will alreadyexist. For commands that cannot be repeated, some <SPANCLASS="acronym">NFS</SPAN>servers maintain a cache of the last few commands that were executed.When the server receives a <SPANCLASS="acronym">MKDIR</SPAN> request, itfirst checks the cache to see if it has already received the <SPANCLASS="acronym">MKDIR</SPAN>request. If so, the server merely retransmits the acknowledgment(which must have been lost).</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1.4.2">20.1.4.2 Hard, soft, and spongy mounts</A></H4><PCLASS="para">If the <SPANCLASS="acronym">NFS</SPAN> client still receives no acknowledgment,it will retransmit the request again and again, each time doublingthe time that it waits between retries. If the network filesystemwas mounted with the <KBDCLASS="command">soft</KBD> option, the request will eventually timeout. If the network filesystem is mounted with the <KBDCLASS="command">hard</KBD> option,the client continues sending the request until the client is rebootedor gets an acknowledgment. <SPANCLASS="acronym">BSDI</SPAN> and <SPANCLASS="acronym">OSF</SPAN>/1also have a spongy option that is similar to <KBDCLASS="command">hard</KBD>, except that the<KBDCLASS="command">stat, lookup, fsstat, readlink,</KBD> and <KBDCLASS="command">readdir</KBD> operations behave likea <KBDCLASS="command">soft</KBD> <SPANCLASS="acronym">MOUNT</SPAN>.</P><H4CLASS="figure"><ACLASS="title"NAME="PUIS-CHP-20-FIG-1">Figure 20.1: NFS protocol stack</A></H4><IMGCLASS="graphic"SRC="figs/puis_2001.gif"ALT="Figure 20.1"><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> uses the <KBDCLASS="command">mount</KBD> commandto specify if a filesystem is mounted with the <KBDCLASS="command">hard</KBD> or <KBDCLASS="command">soft</KBD> option.To mount a filesystem soft, specify the soft option. For example:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/etc/mount -o soft zeus:/big /zbig</PRE></BLOCKQUOTE><PCLASS="para">This command mounts the directory <ICLASS="filename">/big</I> stored onthe server called zeus locally in the directory <ICLASS="filename">/zbig.</I>The option <KBDCLASS="command">-o</KBD> soft tells the <KBDCLASS="command">mount</KBD> program that you wishthe filesystem mounted soft.</P><PCLASS="para">To mount a filesystem hard, do not specify the <KBDCLASS="command">soft</KBD> option:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/etc/mount zeus:/big /zbig</PRE></BLOCKQUOTE><PCLASS="para">Deciding whether to mount a filesystem hard or soft can bedifficult, because there are advantages and disadvantages to eachoption. Diskless workstations often hard-mount the directories thatthey use to keep system programs; if a server crashes, the workstationswait until the server is rebooted, then continue file access withno problem. Filesystems containing home directories are usuallyhard mounted, so that all disk writes to those filesystems willbe correctly performed.</P><PCLASS="para">On the other hand, if you mount many filesystems with thehard option, you will discover that your workstation may stop workingevery time any server crashes until it reboots. If there are manylibraries and archives that you keep mounted on your system, butwhich are not critical, you may wish to mount them soft. You mayalso wish to specify the <KBDCLASS="command">intr</KBD> option, which is like the <KBDCLASS="command">hard</KBD> optionexcept that the user can interrupt it by typing the kill character(usually control-C).</P><PCLASS="para">As a general rule of thumb, read-only filesystems can be mountedsoft without any chance of accidental loss of data. But you willhave problems if you try to run programs off partitions that aresoft-mounted, because when you get errors, the program that youare running will crash.</P><PCLASS="para">An alternative to using soft mounts is to mount everythinghard (or <KBDCLASS="command">spongy</KBD>, when available), but to avoid mounting your nonessential<SPANCLASS="acronym">NFS</SPAN> partitions directly in the <ICLASS="filename">root</I> directory.This practice will prevent the <SPANCLASS="acronym">UNIX</SPAN> <KBDCLASS="command">getpwd()</KBD>function from hanging when a server is down.[4]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] HalStern, in Managing NFS and NIS, says that any filesystem that isread-write or on which you are mounting executables should be mountedhard to avoid corruption. His analogy with a dodgy NFS server isthat hard mount behaves like a slow drive, while soft mount behaveslike a broken drive!</P></BLOCKQUOTE></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1.4.3">20.1.4.3 Connectionless and stateless</A></H4><PCLASS="para">As we've mentioned, <SPANCLASS="acronym">NFS</SPAN> serversare <ICLASS="firstterm">stateless</I> by design. <ACLASS="indexterm"NAME="AUTOID-28375"></A>Statelessmeans that all of the information that the client needs to mounta remote filesystem is kept on the client, instead of having additionalinformation with the mount stored on the server. After a file handleis issued for a file, that file handle will remain good even ifthe server is shut down and rebooted, as long as the file continuesto exist and as long as no major changes are made to the configurationof the server that would change the values (e.g., a file systemrebuild or restore from tape).</P><PCLASS="para">Early <SPANCLASS="acronym">NFS</SPAN> servers were also <ICLASS="firstterm">connectionless</I>.Connectionless means that the server program does not keep trackof every client that has remotely mounted the filesystem.[5]When offering <SPANCLASS="acronym">NFS</SPAN> over a <SPANCLASS="acronym">TCP</SPAN>connection, however, <SPANCLASS="acronym">NFS</SPAN> is not connectionless:there is one <SPANCLASS="acronym">TCP</SPAN> connection for each mountedfilesystem.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] An NFS server computer does keep track of clients that mounttheir filesystems remotely. The <ICLASS="filename">/usr/etc/rpc.</I>mountdprogram maintains this database; however, a computer that is notin this database can still access the server's filesystemeven if it is not registered in the rpc.mountd database.</P></BLOCKQUOTE><PCLASS="para">The advantage of a stateless, connectionless system is thatsuch systems are easier to write and debug. The programmer doesnot need to write any code for reestablishing connections afterthe network server crashes and restarts, because there is no connectionthat must be reestablished. If a client should crash (or if thenetwork should become disconnected), valuable resources are nottied up on the server maintaining a connection and state for thatclient.</P><PCLASS="para">A second advantage of this approach is that it scales. Thatis, a connectionless, stateless <SPANCLASS="acronym">NFS</SPAN> server worksequally well if ten clients are using a filesystem or if ten thousandare using it. Although system performance suffers under extremelyheavy use, every file request made by a client using <SPANCLASS="acronym">NFS</SPAN>will eventually be satisfied, and there is absolutely no performancepenalty if a client mounts a filesystem but never uses it.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1.4.4">20.1.4.4 NFS and root</A></H4><PCLASS="para">Because the superuser can do so much damage on the typical<SPANCLASS="acronym">UNIX</SPAN> system, <SPANCLASS="acronym">NFS</SPAN> takes specialprecautions in the way that it handles the superuser running onclient computers.</P><PCLASS="para">Instead of giving the client superuser unlimited privilegeson the <SPANCLASS="acronym">NFS</SPAN> server, <SPANCLASS="acronym">NFS</SPAN> givesthe superuser on the clients virtually no privileges: the superusergets mapped to the <SPANCLASS="acronym">UID</SPAN> of the <ICLASS="filename">nobody</I> user&nbsp;- usuallya <SPANCLASS="acronym">UID</SPAN> of 32767 or 60001 (although occasionally-1 or -2 on pre-<SPANCLASS="acronym">POSIX</SPAN> systems).[6] Some versions of <SPANCLASS="acronym">NFS</SPAN>allow you to specify the <SPANCLASS="acronym">UID</SPAN> to which to map<ICLASS="filename">root</I>'s accesses, with the <SPANCLASS="acronym">UID</SPAN> of thenobody user as the default.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] TheUNIX kernel maps accesses from client superusers to the kernel variable<ICLASS="filename">nobody</I>, which is set to different values on different systems. Historically,the value of <ICLASS="filename">nobody</I> was -1, although Solaris defines <ICLASS="filename">nobody</I> to be60001. You can change this value to 0 through the use of <KBDCLASS="command">adb</KBD>,making all superuser requests automatically be treated as superuseron the NFS server. In the immortal words of Ian D. Horswill, &quot;TheSun kernel has a user-patchable cosmology. It contains a polytheismbit called `nobody.'...The default correspondsto a basically Greek pantheon in which there are many Gods and they'reall trying to screw each other (both literally and figurativelyin the Greek case). However, by using <KBDCLASS="command">adb</KBD> toset the kernel variable <ICLASS="filename">nobody</I> to 0 in the divine boot image, youcan move to a Ba'hai cosmology in which all Gods are reallymanifestations of the One Root God, Zero, thus inventing monotheism.&quot;(<EMCLASS="emphasis">The UNIX-Haters Handbook</EM>, Garfinkel et al.IDG Books, 1994. p. 291)</P></BLOCKQUOTE><PCLASS="para">Thus, superusers on <SPANCLASS="acronym">NFS</SPAN> client machinesactually have fewer privileges (with respect to the <SPANCLASS="acronym">NFS</SPAN>server) than ordinary users. However, this lack of privilege isn'tusually much of a problem for would-be attackers who have <ICLASS="filename">root</I> access,because the superuser can simply <KBDCLASS="command">su</KBD> to a different <SPANCLASS="acronym">UID</SPAN>such as <ICLASS="filename">bin</I> or <ICLASS="filename">sys</I>. On the other hand, treating the superuser inthis way can protect other files on the <SPANCLASS="acronym">NFS</SPAN> server.</P><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> does no remapping of any other <SPANCLASS="acronym">UID</SPAN>,nor does it do any remapping of any <SPANCLASS="acronym">GID</SPAN> values.Thus, if a server exports any file or directory with access permissionsfor some user or group, the superuser on a client machine can takeon an identity to access that information. This rule implies thatthe exported file can be read or copied by someone remote, or worse,modified without authorization.</P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-20-SECT-1.5">20.1.5 NFS Version 3</A></H3><PCLASS="para">During the ten years of the life of <SPANCLASS="acronym">NFS</SPAN>Version 2, a number of problems were discovered with it. These problemsincluded:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> was originallybased on <SPANCLASS="acronym">AUTH_UNIX</SPAN> <SPANCLASS="acronym">RPC</SPAN> security.As such, it provided almost no protection against spoofing. <SPANCLASS="acronym">AUTH_UNIX</SPAN>simply used the stated <SPANCLASS="acronym">UID</SPAN> and <SPANCLASS="acronym">GID</SPAN>of the client user to determine access.</P></LI><LICLASS="listitem"><PCLASS="para">The packets transmitted by <SPANCLASS="acronym">NFS</SPAN>were not encrypted, and were thus open to eavesdropping, alteration,or forging on a network.</P></LI><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> had no provisions for fileslarger than 4GB. This was not a problem in 1985, but many <SPANCLASS="acronym">UNIX</SPAN>users now have bigger disks and bigger files.</P></LI><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> suffered serious performanceproblems on high-speed networks because of the maximum 8K data-sizelimitation on <SPANCLASS="acronym">READ</SPAN> and <SPANCLASS="acronym">WRITE</SPAN>procedures, and because of the need to separately request the fileattributes on each file when a directory was read.</P></LI></UL><PCLASS="para"><SPANCLASS="acronym">NFS</SPAN> 3 is the first major revision to <SPANCLASS="acronym">NFS</SPAN>since the protocol was commercially released. As such, <SPANCLASS="acronym">NFS</SPAN>3 was designed to correct many of the problems that had been experiencedwith <SPANCLASS="acronym">NFS</SPAN>. But <SPANCLASS="acronym">NFS</SPAN> 3 is nota total rewrite. According to Pawlowski et al., there were threeguiding principles in designing <SPANCLASS="acronym">NFS</SPAN> 3:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Keep it simple.</P></LI><LICLASS="listitem"><PCLASS="para">Get it done in a year.</P></LI><LICLASS="listitem"><PCLASS="para">Avoid anything controversial.</P></LI></OL><PCLASS="para">Thus, while <SPANCLASS="acronym">NFS</SPAN> 3 allows for improved performanceand access to files larger than 4GB, it does not make any fundamentalchanges to the overall <SPANCLASS="acronym">NFS</SPAN> architecture.</P><PCLASS="para">As a result of the design criteria, there are relatively fewchanges between the <SPANCLASS="acronym">NFS</SPAN> 2 and 3 protocols:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">File-handle size has been increasedfrom a fixed-length 32-byte block of data to a variable-length arraywith a maximum length of 64 bytes.</P></LI><LICLASS="listitem"><PCLASS="para">The maximum size of data that can be transferredusing <SPANCLASS="acronym">READ</SPAN> and <SPANCLASS="acronym">WRITE</SPAN> proceduresis now determined dynamically by the values returned by the <SPANCLASS="acronym">FSINFO</SPAN>function. The maximum lengths for filenames and pathnames are nowsimilarly specified.</P></LI><LICLASS="listitem"><PCLASS="para">File lengths and offsets have been extended fromfour bytes to eight bytes.[7]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] Future versions of NFS&nbsp;- orany other filesystem&nbsp;- will not likely need to use more thaneight bytes to represent the size of a file: eight bytes can representmore than 1.7 x 1013MB of storage.</P></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para"><SPANCLASS="acronym">RPC</SPAN> errors can now return data(such as file attributes) in addition to return codes.</P></LI><LICLASS="listitem"><PCLASS="para">Additional file types are now supported for character-and block-device files, sockets, and <SPANCLASS="acronym">FIFOS</SPAN>.</P></LI><LICLASS="listitem"><PCLASS="para">An <SPANCLASS="acronym">ACCESS</SPAN> procedure has beenadded to allow an <SPANCLASS="acronym">NFS</SPAN> client to explicitly checkto see if a particular user can or cannot access a file.</P></LI></UL><PCLASS="para">Because <SPANCLASS="acronym">RPC</SPAN> allows a server to respondto more than one version of a protocol at the same time, <SPANCLASS="acronym">NFS</SPAN>3 servers will be able to support the <SPANCLASS="acronym">NFS</SPAN> 2 and3 protocols simultaneously, so that they can serve older <SPANCLASS="acronym">NFS</SPAN>2 clients while allowing easy upgradability to <SPANCLASS="acronym">NFS</SPAN>3. Likewise, most <SPANCLASS="acronym">NFS</SPAN> 3 clients will continueto support the <SPANCLASS="acronym">NFS</SPAN> 2 protocol as well, so thatthey can speak with old servers and new ones.</P><PCLASS="para">This need for backward compatibility effectively preventedthe <SPANCLASS="acronym">NFS</SPAN> 3 designers from adding new securityfeatures to the protocols. If <SPANCLASS="acronym">NFS</SPAN> 3 had moresecurity features, an attacker could avoid them by resorting to<SPANCLASS="acronym">NFS</SPAN> 2. On the other hand, by changing a sitefrom unsecure <SPANCLASS="acronym">RPC</SPAN> to secure <SPANCLASS="acronym">RPC</SPAN>,a site can achieve secure <SPANCLASS="acronym">NFS</SPAN> for all of its<SPANCLASS="acronym">NFS</SPAN> clients and servers, whether they are running<SPANCLASS="acronym">NFS</SPAN> 2 or <SPANCLASS="acronym">NFS</SPAN> 3.</P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> If and when your system supports <SPANCLASS="acronym">NFS</SPAN>over <SPANCLASS="acronym">TCP</SPAN> links, you should configure it to use<SPANCLASS="acronym">TCP</SPAN> and not <SPANCLASS="acronym">UDP</SPAN> unless thereare significant performance reasons for not doing so. <SPANCLASS="acronym">TCP</SPAN>-basedservice is more immune to denial of service problems, spoofed requests,and several other potential problems inherent in the current useof <SPANCLASS="acronym">UDP</SPAN> packets.</P></BLOCKQUOTE></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch19_07.htm"TITLE="19.7 Other Network Authentication Systems"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 19.7 Other Network Authentication Systems"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Practical UNIX &amp; Internet Security"><IMGSRC="../gifs/txthome.gif"ALT="Practical UNIX &amp; Internet Security"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch20_02.htm"TITLE="20.2 Server-Side NFS Security"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 20.2 Server-Side NFS Security"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">19.7 Other Network Authentication Systems</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">20.2 Server-Side NFS Security</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>