<HTML><HEAD><TITLE>[Chapter 23] 23.2 Tips on Avoiding Security-related Bugs</TITLE><METANAME="DC.title"CONTENT="Practical UNIX &amp; Internet Security"><METANAME="DC.creator"CONTENT="Simson Garfinkel &amp; Gene Spafford"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:17:33Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-148-8"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch23_01.htm"TITLE="23. Writing Secure SUID and Network Programs"><LINKREL="prev"HREF="ch23_01.htm"TITLE="23.1 One Bug Can Ruin Your Whole Day..."><LINKREL="next"HREF="ch23_03.htm"TITLE="23.3 Tips on Writing Network Programs"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Practical UNIX &amp; Internet Security"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Practical UNIX &amp; Internet Security"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch23_01.htm"TITLE="23.1 One Bug Can Ruin Your Whole Day..."><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 23.1 One Bug Can Ruin Your Whole Day..."BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 23<BR>Writing Secure SUID and Network Programs</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch23_03.htm"TITLE="23.3 Tips on Writing Network Programs"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 23.3 Tips on Writing Network Programs"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="PUIS-CHP-23-SECT-2">23.2 Tips on Avoiding Security-related Bugs</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="IDX-BUGS-TIPS-ON-AVOIDING"></A><ACLASS="indexterm"NAME="AUTOID-32108"></A>Software engineers define <ICLASS="firstterm">errors</I>as mistakes made by humans when designing and coding software. <ICLASS="firstterm">Faults</I>are manifestations of errors in programs that may result in <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-32114"></A>failures</I>. Failuresare deviations from program <ICLASS="firstterm">specifications</I>.In common usage, faults are called <ICLASS="firstterm">bugs</I>.</P><PCLASS="para">Why do we bother to explain these formal terms? For threereasons:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">To remind you that although bugs (faults)may be present in the code, they aren't necessarily a problemuntil they trigger a failure. Testing is designed to trigger sucha failure before the program becomes operational...and resultsin damage.</P></LI><LICLASS="listitem"><PCLASS="para">Bugs don't suddenly appear in code. Theyare there because some person made a mistake&nbsp;- from ignorance,from haste, from carelessness, or for some other reason. Ultimately,unintentional flaws that allow someone to compromise your systemare caused by people who made errors.</P></LI><LICLASS="listitem"><PCLASS="para">Almost every piece of <SPANCLASS="acronym">UNIX</SPAN> softwarehas been developed without comprehensive specifications. As a result,you cannot easily tell when a program has actually failed. Indeed,what appears to be a bug to users of the program might be a featurethat was intentionally planned by the program's authors.[5]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] &quot;It's not a bug, it's a feature!&quot;</P></BLOCKQUOTE></LI></OL><PCLASS="para">When you write a program that will run as superuser or insome other critical context, you must try to make the program asbug free as possible because a bug in a program that runs as superusercan leave your entire computer system wide open.</P><PCLASS="para">Ofcourse, no program can be guaranteed perfect. A library routinecan be faulty, or a stray gamma ray may flip a bit in memory tocause your program to misbehave. Nevertheless, there are a varietyof techniques that you can employ when writing programs that willtend to minimize the security implications of any bugs that maybe present. You can also program defensively to try to counter anyproblems that you can't anticipate now.</P><PCLASS="para">Hereare some general rules to code by:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Carefully design the program before youstart. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32136"></A><ACLASS="indexterm"NAME="AUTOID-32138"></A>Be certain that youunderstand what you are trying to build. Carefully consider theenvironment in which it will run, the input and output behavior, filesused, arguments recognized, signals caught, and other aspects ofbehavior. Try to list all of the errors that might occur, and how youwill deal with them. Consider writing a specification document for thecode. If you can't or won't do that, at least considerwriting documentation including a <EMCLASS="emphasis">complete</EM> manualpage before you write any code. That can serve as a valuable exerciseto focus your thoughts on the code and its intended behavior.</P></LI><LICLASS="listitem"><PCLASS="para">Check all of your arguments. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32144"></A><ACLASS="indexterm"NAME="AUTOID-32146"></A>An astonishing number ofsecurity-related bugs arise because an attacker sends an unexpectedargument or an argument with unanticipated format to a program or afunction within a program. A simple way to avoid these kinds ofproblems is by having your program <EMCLASS="emphasis">always check all of itsarguments</EM>. Argument checking will not noticeably slow downmost programs, but it will make them less susceptible to hostileusers. As an added benefit, argument checking and error reporting willmake the process of catching non-security-related bugs easier.</P><PCLASS="para">When you are checking arguments in your program, pay extraattention to the following:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Check arguments passed to your programon the command line. Check to make sure that each command-lineargument is properly formed and bounded. </P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32156"></A>Check arguments that you pass to<SPANCLASS="acronym">UNIX</SPAN> system functions. Even though your program iscalling the system function, you should check the arguments to be surethat they are what you expect them to be. For example, if you thinkthat your program is opening a file in the current directory, youmight want to use the <EMCLASS="emphasis">index( )</EM> function to see ifthe filename contains a slash character (/). If the file doescontain the slash, and it shouldn't, the program should not openthe file.</P></LI><LICLASS="listitem"><PCLASS="para">Check arguments passed in environment variablesto your program, including general environment variables and suchvariables as the <SPANCLASS="acronym">LESS</SPAN> argument.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32165"></A>Do bounds checking on every variable. Ifyou only define an option as valid from 1 to 5, be sure that no onetries to set it to 0, 6, -1, 32767, or 32768. If string arguments aresupposed to be 16 bytes or less, check the length<EMCLASS="emphasis">before</EM> you copy them into a local buffer (anddon't forget the room required for the terminating nullbyte). If you are supposed to have three arguments, be sure you gotthree.</P></LI></UL></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32171"></A><ACLASS="indexterm"NAME="AUTOID-32174"></A> Don't use routines that fail tocheck buffer boundaries when manipulating strings of arbitrarylength.</P><PCLASS="para">In the C programming language particularly, note thefollowing:</P><TABLECLASS="informaltable"><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Avoid</P></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Use Instead</P></TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><KBDCLASS="command">gets</KBD>()</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><KBDCLASS="command">fget</KBD>()</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><KBDCLASS="command">strcpy</KBD>()</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><KBDCLASS="command">strncpy</KBD>()</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><KBDCLASS="command">strcat</KBD>()</P></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><KBDCLASS="command">strncat</KBD>()</P></TD></TR></TBODY></TABLE><PCLASS="para">Use the following library calls with greatcare&nbsp;- they can overflow either a destination buffer or aninternal, static buffer on some systems if the input is &quot;cooked&quot;to do so:[6]<ACLASS="indexterm"NAME="AUTOID-32210"></A><ACLASS="indexterm"NAME="AUTOID-32212"></A><ACLASS="indexterm"NAME="AUTOID-32214"></A><ACLASS="indexterm"NAME="AUTOID-32216"></A><ACLASS="indexterm"NAME="AUTOID-32218"></A><ACLASS="indexterm"NAME="AUTOID-32220"></A><ACLASS="indexterm"NAME="AUTOID-32222"></A><ACLASS="indexterm"NAME="AUTOID-32224"></A><ACLASS="indexterm"NAME="AUTOID-32226"></A><ACLASS="indexterm"NAME="AUTOID-32228"></A><ACLASS="indexterm"NAME="AUTOID-32230"></A><KBDCLASS="command">sprintf( ),fscanf( ), scanf( ), sscanf( ), vsprintf( ), realpath( ), getopt(), getpass( ), streadd( ), strecpy( ), </KBD> and<KBDCLASS="command"> strtrns( )</KBD>. Check to make sure that you have the version of thesyslog() library which checks the length of its arguments.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] Not all of these will be available underevery version of UNIX.</P></BLOCKQUOTE><PCLASS="para">There may be other routines in libraries on your system ofwhich you should be somewhat cautious. Note carefully if a copyor transformation is performed into a string argument without benefitof a length parameter to delimit it. Also note if the documentationfor a function says that the routine returns a pointer to a resultin static storage. If an attacker can provide the necessary inputto overflow these buffers, you may have a major problem.</P></LI><LICLASS="listitem"><PCLASS="para">&#13;Check all return codes from systemcalls.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32238"></A><ACLASS="indexterm"NAME="AUTOID-32240"></A><ACLASS="indexterm"NAME="AUTOID-32242"></A><ACLASS="indexterm"NAME="AUTOID-32244"></A><ACLASS="indexterm"NAME="AUTOID-32246"></A>The<SPANCLASS="acronym">UNIX</SPAN> operating system has almost every singlesystem call provide a return code.  Even system calls that you thinkcannot fail, such as <KBDCLASS="command">write()</KBD>,<KBDCLASS="command">chdir()</KBD>, or<KBDCLASS="command">chown()</KBD>, can fail under exceptionalcircumstances and return appropriate return codes.</P><DIVCLASS="sidebar"><H4CLASS="sidebar"><ACLASS="title"NAME="AUTOID-32252">When Good Calls Fail</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32255"></A>You may not believe that system calls canfail for a program that is running as root. For instance, you mightnot believe that a<KBDCLASS="command">chdir</KBD>()<KBDCLASS="command"></KBD> call could fail, as <ICLASS="filename">root</I> has permission to change into anydirectory. However, if the directory in question is mounted via<SPANCLASS="acronym">NFS</SPAN>, <ICLASS="filename">root</I> has no special privileges. The directorymight not exist, again causing thechdir() call to fail. If the targetprogram is started in the wrong directory and you fail to check thereturn codes, the results will not be what you expected when you wrotethe code.</P><PCLASS="para">Or consider the<KBDCLASS="command"><ACLASS="indexterm"NAME="AUTOID-32264"></A>open</KBD>()call. It can fail for <ICLASS="filename">root</I>, too. For example, you can't open afile on a<SPANCLASS="acronym"> CD-ROM</SPAN> for writing, because<SPANCLASS="acronym">CD-ROM</SPAN> is a read-only media. Or consider someonecreating several thousand zero-length files to use up all the inodeson the disk. Even <ICLASS="filename">root</I> can't create a file if all the fre inodesare gone.</P><PCLASS="para">The <ACLASS="indexterm"NAME="AUTOID-32271"></A><KBDCLASS="command">fork($a)</KBD> system call may fail if the process table is full,<ACLASS="indexterm"NAME="AUTOID-32274"></A><KBDCLASS="command">exec()</KBD>may fail if the swap space is exhausted, and<ACLASS="indexterm"NAME="AUTOID-32277"></A><KBDCLASS="command">sbrk()</KBD> (the call which allocates memory for <KBDCLASS="command">malloc( )</KBD>) may fail if a process has already allocated the maximumamount of memory allowed by process limits. An attacker can easilyarrange for these cases to occur. The difference between a safe and anunsafe program may be how that program deals with thesesituations.</P><PCLASS="para">If you don't like to type explicitchecks for each call, then consider writing a set of macros to&quot;wrap&quot; the calls and do it for you. You will need onemacro for calls that return -1 on failure, and another for calls thatreturn 0 on failure.</P><PCLASS="para">Here are some macros that you mayfind helpful:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#include &lt;assert.h&gt;#define Call0(s) assert((s) != 0)#define Call1(s) assert((s) &gt;= 0)</PRE></BLOCKQUOTE><PCLASS="para">Here is howto use them:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Call0(fd =open(&quot;foo&quot;, O_RDWR, 0666));</PRE></BLOCKQUOTE><PCLASS="para">Note,however, that these simply cause the program to terminate withoutany cleanup. You may prefer to change the macros to call some commonroutine first to do cleanup and logging.</P></DIV><PCLASS="para"> When the calls fail, check the <ICLASS="filename">errno</I> variableto determine <EMCLASS="emphasis">why</EM> they failed. Have your programlog the unexpected value and then cleanly terminate if the systemcall fails for any unexpected reason. This approach will be a greathelp in tracking down problems later on.</P><PCLASS="para">If you thinkthat a system call should not fail and it does, do something appropriate.If you can't think of anything appropriate to do, thenhave your program delete all of its temporary files and exit. </P></LI><LICLASS="listitem"><PCLASS="para">Don't design your programto depend on <SPANCLASS="acronym">UNIX</SPAN> <ACLASS="indexterm"NAME="AUTOID-32294"></A>environmentvariables. </P><PCLASS="para">The simplest way to write a secure programis to make absolutely no assumptions about your environment andto <EMCLASS="emphasis">set everything explicitly </EM>(e.g. signals,umask, current directory, environment variables). A common way ofattacking programs is to make changes in the runtime environmentthat the programmer did not anticipate.</P><PCLASS="para">Thus, you want to make certain that your program environmentis in a known state. Here are some of the things you want to do:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">If you absolutely must pass informationto the program in its environment, then have your program test forthe necessary environment variables and then erase the environmentcompletely. </P></LI><LICLASS="listitem"><PCLASS="para">Otherwise, wipe the environment clean of all butthe most essential variables. On most systems, this is the <ACLASS="indexterm"NAME="AUTOID-32304"></A>TZ variable that specifies the local time zone,and possibly some variables to indicate locale. Cleaning the environmentavoids any possible interactions between it and the <SPANCLASS="acronym">UNIX</SPAN>system libraries.</P></LI><LICLASS="listitem"><PCLASS="para">You might also consider constructing a new <ICLASS="filename">envp</I>and passing that to <KBDCLASS="command">exec()</KBD>, rather than using even a scrubbedoriginal <ICLASS="filename">envp</I>. Doing so is safer because you explicitly create theenvironment rather than trying to clean it.</P></LI><LICLASS="listitem"><PCLASS="para">Make sure that the <ACLASS="indexterm"NAME="AUTOID-32314"></A>filedescriptors that you expect to be open are open, and that the filedescriptors you expect to be closed are closed.</P></LI><LICLASS="listitem"><PCLASS="para">Ensure that your signals are set to a sensible state.</P></LI><LICLASS="listitem"><PCLASS="para">Set your umask appropriately.</P></LI><LICLASS="listitem"><PCLASS="para">Explicitly <KBDCLASS="command">chdir</KBD>() to an appropriate directory when the program starts.</P></LI><LICLASS="listitem"><PCLASS="para">Set whatever limit values are necessary so thatyour program will not leave a <ACLASS="indexterm"NAME="AUTOID-32326"></A>corefile if it fails. Consider setting your other limits on number offiles and stack size to appropriate values if they might not beappropriate at program start.</P></LI></UL></LI><LICLASS="listitem"><PCLASS="para">Have internal consistency-checkingcode. </P><PCLASS="para">Use the <EMCLASS="emphasis"><ACLASS="indexterm"NAME="AUTOID-32332"></A>assert</EM>macro if you are programming in C. If you have a variable that youknow should either be a 1 or a 2, then your program should not berunning if the variable is anything else.</P></LI><LICLASS="listitem"><PCLASS="para">Include lots of <ACLASS="indexterm"NAME="AUTOID-32336"></A>logging.</P><PCLASS="para">You are almost always better having too much loggingrather than too little. Report your log information into a dedicatedlog file. Or, consider using the <KBDCLASS="command">syslog</KBD> facility, so that logs canbe redirected to users or files, piped to programs, and/orsent to other machines. And remember to do bounds checking on argumentspassed to <KBDCLASS="command">syslog()</KBD> to avoid buffer overflows.</P><PCLASS="para">Here is specific information that you might wish to log:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">The time that the program was run.</P></LI><LICLASS="listitem"><PCLASS="para">The <SPANCLASS="acronym">UID</SPAN> and effective <SPANCLASS="acronym">UID</SPAN>of the process.</P></LI><LICLASS="listitem"><PCLASS="para">The <SPANCLASS="acronym">GID</SPAN> and effective <SPANCLASS="acronym">GID</SPAN>of the process.</P></LI><LICLASS="listitem"><PCLASS="para">The terminal from which it was run.</P></LI><LICLASS="listitem"><PCLASS="para">The process number (<SPANCLASS="acronym">PID</SPAN>).</P></LI><LICLASS="listitem"><PCLASS="para">Command-line arguments.</P></LI><LICLASS="listitem"><PCLASS="para">Invalid arguments, or failures in consistencychecking.</P></LI><LICLASS="listitem"><PCLASS="para">The host from which the request came (in the caseof network servers).</P></LI></UL></LI><LICLASS="listitem"><PCLASS="para">Make the critical portion of your programas small and as simple as possible. </P></LI><LICLASS="listitem"><PCLASS="para">Read through your code. </P><PCLASS="para">Think of howyou might attack it yourself. What happens if the program gets unexpectedinput? What happens if you are able to delay the program betweentwo system calls?</P></LI><LICLASS="listitem"><PCLASS="para">Always use full <ACLASS="indexterm"NAME="AUTOID-32371"></A>pathnamesfor any filename argument, for both commands and datafiles.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32375"></A><ACLASS="indexterm"NAME="AUTOID-32377"></A>Check anything supplied by the userfor shell meta characters if the user-supplied input is passed onto another program, written into a file, or used as a filename.In general, checking for good characters is safer than checkingfor a set of &quot;bad characters&quot; and is not thatrestrictive in most situations.</P></LI><LICLASS="listitem"><PCLASS="para">Examine your code and test it carefully for assumptionsabout the operating environments. For example:</P><PCLASS="para"></P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">If you assume that the program isalways run by somebody who is not <ICLASS="filename">root</I>, what happens if the programis run by <ICLASS="systemitem">root?</I> (Manyprograms designed to be run as <ICLASS="systemitem">daemon</I>or <ICLASS="systemitem">bin</I> can cause securityproblems when run as <ICLASS="filename">root</I>, for instance.)</P></LI><LICLASS="listitem"><PCLASS="para">If you assume that it will be run by <ICLASS="filename">root</I>, whathappens if it is not run as root? </P></LI><LICLASS="listitem"><PCLASS="para">If you assume that a program always runs in the<ICLASS="filename">/tmp</I> or <ICLASS="filename">/tmp/root</I>[7]directory, what happens if it is runsomewhere else?</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] We use <ICLASS="filename">/tmp/root</I>, with the understanding thatyouhave a directory <ICLASS="filename">/tmp/root</I> automatically created by yourstart-up scripts, and that this directory has a mode of 0700. Your<ICLASS="filename">/tmp</I> directory should have mode 1777, which prevents ordinaryusers from deleting the <ICLASS="filename">/tmp/root</I> directory.</P></BLOCKQUOTE></LI></UL></LI><LICLASS="listitem"><PCLASS="para">Make good use of available tools. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32407"></A><ACLASS="indexterm"NAME="AUTOID-32409"></A><ACLASS="indexterm"NAME="AUTOID-32411"></A>Ifyou are using C and have an <SPANCLASS="acronym">ANSI</SPAN> C compiler available,use it, and use prototypes for calls. If you don't havean <SPANCLASS="acronym">ANSI</SPAN> C compiler, then be sure to use the <KBDCLASS="command">-Wall</KBD>option to your C compiler (if supported) or the <KBDCLASS="command">lint</KBD>program to check for common mistakes.</P></LI><LICLASS="listitem"><PCLASS="para">Test your program thoroughly. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32421"></A><ACLASS="indexterm"NAME="AUTOID-32424"></A><ACLASS="indexterm"NAME="AUTOID-32426"></A><ACLASS="indexterm"NAME="AUTOID-32428"></A><ACLASS="indexterm"NAME="AUTOID-32430"></A>If you have a systembased on <SPANCLASS="acronym">SVR4</SPAN>, consider using (at the least)<KBDCLASS="command">tcov</KBD>, a statement-coverage tester. Consider using commercial products,such as CodeCenter and Purify (from personal experience, we cantell you that these programs are very useful). Look into <SPANCLASS="acronym">GCT</SPAN>,a test tool developed by Brian Marick at the University of Illinois.[8]Remember that finding a bug in testing is better than letting someanonymous system cracker find it for you!</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] Available for FTP from <ACLASS="systemitem.ftpserver"HREF="ftp://ftp.cs.uiuc.edu.">ftp.cs.uiuc.edu.</A></P></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para">Be aware of <ACLASS="indexterm"NAME="AUTOID-32440"></A><ACLASS="indexterm"NAME="AUTOID-32442"></A><ACLASS="indexterm"NAME="AUTOID-32444"></A><ACLASS="indexterm"NAME="AUTOID-32447"></A><ACLASS="indexterm"NAME="AUTOID-32449"></A><ACLASS="indexterm"NAME="AUTOID-32452"></A><ACLASS="indexterm"NAME="AUTOID-32455"></A>race conditions.These can be manifest as a deadlock, or as failure of two callsto execute in close sequence. </P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Deadlock conditions.</EM>Remember: more than one copy of your program may be running at thesame time. Consider using file locking for any files that you modify.Provide a way to recover the locks in the event that the programcrashes while a lock is held. Avoid deadlocks or &quot;deadlyembraces,&quot; which can occur when one program attempts tolock file A then file B, while another program already holds a lockfor file B and then attempts to lock file A.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Sequenceconditions</EM><ACLASS="indexterm"NAME="AUTOID-32466"></A><ACLASS="indexterm"NAME="AUTOID-32468"></A>. Be aware that your programdoes not execute atomically. That is, the program can be interruptedbetween any two operations to let another program run for awhile&nbsp;- including one that is trying to abuse yours. Thus, checkyour code carefully for any pair of operations that might fail ifarbitrary code is executed between them.</P><PCLASS="para">In particular,when you are performing a series of operations on a file, such aschanging its owner, <ICLASS="filename">stat'</I>ing the file, orchanging its mode, first open the file and then use the<KBDCLASS="command">fchown()</KBD>, <KBDCLASS="command">fstat()</KBD>, or <KBDCLASS="command">fchmod()</KBD> systemcalls. Doing so will prevent the file from being replaced while yourprogram is running (a possible race condition). Also avoid the use ofthe <ACLASS="indexterm"NAME="AUTOID-32475"></A><ICLASS="filename">access()</I> function to determineyour ability to access a file: Using the <ICLASS="filename">access()</I> functionfollowed by an <KBDCLASS="command">open()</KBD> is a race condition, and almost always abug.</P></LI></UL></LI><LICLASS="listitem"><PCLASS="para">Don't have your program dump core except duringyour testing. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-32483"></A><ACLASS="indexterm"NAME="AUTOID-32485"></A>Core files can fill up a filesystem. Corefiles can contain confidential information. In some cases, anattacker can actually use the fact that a program dumps core to breakinto a system. Instead of dumping core, have your program log theappropriate problem and exit. Use the<EMCLASS="emphasis"><ACLASS="indexterm"NAME="AUTOID-32489"></A>setrlimit</EM>() functionto limit the size of the core file to 0.</P></LI><LICLASS="listitem"><PCLASS="para">Do not provide shell escapes (with job control,they are no longer needed).</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Never</EM> use <ACLASS="indexterm"NAME="AUTOID-32496"></A><ACLASS="indexterm"NAME="AUTOID-32498"></A><KBDCLASS="command">system()</KBD> or <KBDCLASS="command">popen()</KBD>calls. </P><PCLASS="para">Both invoke the shell, and can have unexpectedresults when they are passed arguments with funny characters, orin cases in which environment variables have peculiar definitions.</P></LI><LICLASS="listitem"><PCLASS="para">If you are expecting to create a new file with theopen call, then use the O_EXCL | <ACLASS="indexterm"NAME="AUTOID-32505"></A>O_CREAT flagsto cause the routine to fail if the file exists. </P><PCLASS="para">If you expect the file to be there, be sure to omit theO_CREAT flag so that the routine will fail if the file is notthere.[9]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] Note that on some systems, if the pathname inthe open call refers to a symbolic link that names a file that doesnot exist, the call may not behave as you expect. This scenario shouldbe tested on your system so you know what to expect.</P></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para">If you think that a file should be a file, use<ACLASS="indexterm"NAME="AUTOID-32513"></A><KBDCLASS="command">lstat()</KBD> to make sure that it isnot a link. </P><PCLASS="para">However, remember that what you check may change before you canget around to opening it if it is in a public directory.  (See item)</P></LI><LICLASS="listitem"><PCLASS="para">If you need to create a temporary file, considerusing the <ACLASS="indexterm"NAME="AUTOID-32519"></A><ACLASS="indexterm"NAME="AUTOID-32521"></A><KBDCLASS="command">tmpfile( )</KBD> or <KBDCLASS="command">mktemp( )</KBD> function. </P><PCLASS="para">This step willcreate a temporary file, open the file, delete the file, and returna file handle. The open file can be passed to a subprocess createdwith <KBDCLASS="command">fork( )</KBD> and <KBDCLASS="command">exec( )</KBD>,but the contents of the file cannot be read by any other programon the system. The space associated with the file will automaticallybe returned to the operating system when your program exits. Ifpossible, create the temporary file in a closed directory, suchas <ICLASS="filename">/tmp/root/</I>.</P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> The <ACLASS="indexterm"NAME="AUTOID-32531"></A><KBDCLASS="command">mktemp()</KBD>library call is not safe to use in a program that is running withextra privilege. The code as provided on most versions of<SPANCLASS="acronym">UNIX</SPAN> has a race condition between a file test and afile open. This condition is a well-known problem, and relatively easyto exploit. Avoid the standard<KBDCLASS="command">mktemp()</KBD> call.</P></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para">Do not create files in world-writable directories.</P></LI><LICLASS="listitem"><PCLASS="para">Have your code reviewed by another competent programmer(or two, or more). </P><PCLASS="para">After they have reviewed it, &quot;walkthrough&quot; the code with them and explain what each partdoes. We have found that such reviews are a surefire way to discoverlogic errors. Trying to explain why something is done a certainway often results in an exclamation of &quot;Wait a moment ...whydid I do <EMCLASS="emphasis">that?&quot;</EM></P></LI><LICLASS="listitem"><PCLASS="para">If you need to use a shell as part of your program,don't use the <ACLASS="indexterm"NAME="AUTOID-32544"></A>C shell.</P><PCLASS="para">Many versions have known flaws that can be exploited, andnearly every version performs an implicit <ICLASS="filename">eval $TERM</I> onstart-up, enabling all sorts of attacks. Furthermore, the C shellmakes it difficult to do things that you may want to do, such ascapture error output to another file or pipe.</P><PCLASS="para">We recommend the use of <ACLASS="indexterm"NAME="AUTOID-32549"></A><KBDCLASS="command">ksh93</KBD> (used for most of the shell scriptsin this book). It is well designed, fast, powerful, and welldocumented (see <ACLASS="xref"HREF="appd_01.htm"TITLE="Paper Sources">Appendix D</A>).</P></LI></OL><PCLASS="para">Remember, many security bugs are actually programming bugs,which is good news for programmers. When you make your program moresecure, you'll simultaneously be making it morereliable.<ACLASS="indexterm"NAME="AUTOID-32554"></A></P></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch23_01.htm"TITLE="23.1 One Bug Can Ruin Your Whole Day..."><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 23.1 One Bug Can Ruin Your Whole Day..."BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Practical UNIX &amp; Internet Security"><IMGSRC="../gifs/txthome.gif"ALT="Practical UNIX &amp; Internet Security"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch23_03.htm"TITLE="23.3 Tips on Writing Network Programs"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 23.3 Tips on Writing Network Programs"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">23.1 One Bug Can Ruin Your Whole Day...</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">23.3 Tips on Writing Network Programs</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>