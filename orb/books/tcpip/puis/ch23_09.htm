<HTML><HEAD><TITLE>[Chapter 23] 23.9 A Good Random Seed Generator</TITLE><METANAME="DC.title"CONTENT="Practical UNIX &amp; Internet Security"><METANAME="DC.creator"CONTENT="Simson Garfinkel &amp; Gene Spafford"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:18:01Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-148-8"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch23_01.htm"TITLE="23. Writing Secure SUID and Network Programs"><LINKREL="prev"HREF="ch23_08.htm"TITLE="23.8 Picking a Random Seed"><LINKREL="next"HREF="part06.htm"TITLE="VI. Handling Security Incidents"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Practical UNIX &amp; Internet Security"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Practical UNIX &amp; Internet Security"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch23_08.htm"TITLE="23.8 Picking a Random Seed"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 23.8 Picking a Random Seed"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 23<BR>Writing Secure SUID and Network Programs</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="PART"HREF="part06.htm"TITLE="VI. Handling Security Incidents"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: VI. Handling Security Incidents"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="PUIS-CHP-23-SECT-8">23.9 A Good Random SeedGenerator</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="IDX-643418"></A><ACLASS="indexterm"NAME="AUTOID-33101"></A>As we've mentioned, one way of generating a random seed is to use a source message digest algorithm such as MD5 or HAVAL. As input, give it as much data as you can based on temporary state. This data might include the output of ps -efl, the environment variables for the current process, its PID and PPID, the current time and date, the output of the random number generator given your seed, the seed itself, the state of network connections, and perhaps a directory listing of the current directory. The output of the function will be a string of bits that an attacker cannot likely duplicate, but which is likely to meet all the other conditions of randomness youmight desire.</P><PCLASS="para">The <ACLASS="indexterm"NAME="IDX-643419"></A>Perl program in <ACLASS="xref"HREF="ch23_09.htm#PUIS-CHP-23-EX-1"TITLE="Generating a Random Seed String">Example 23.1</A> is an example of such a program. It uses several aspects of system state, network status, virtual memory statistics, and process state as input to MD5. These numbers change very quickly on most computers, and cannot be anticipated, even by programs running as supe-ruser on the same computer. The entropy (randomness) of these values is spread throughout the result by the hashing function of MD5, resulting in an output that should be sufficiently random for most uses.</P><PCLASS="para">Note that this script is an excellent method for generating Xauthority keys (see &quot;X security&quot; in <ACLASS="xref"HREF="ch17_01.htm"TITLE="TCP/IP Services">Chapter 17</A>), if you need them. Simply execute it with an argument of 14 (you need 28 hex characters of key) and use the result as your key.</P><DIVCLASS="example"><H4CLASS="example"><ACLASS="title"NAME="PUIS-CHP-23-EX-1">Example 23.1: Generating a Random Seed String</A></H4><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#!/usr/bin/perl## randbits -- Gene Spafford &lt;spaf@cs.purdue.edu&gt;# generate a random seed string based on state of system## Inspired by a program from Bennett Todd (bet@std.sbi.com), derived# from original by Larry Wall.## Uses state of various kernel structures as random &quot;seed&quot;# Mashes them together and uses MD5 to spread around## Usage:  randbits [-n] [-h | -H ] [keylen]#      Where#         -n means to emit no trailing linefeed#         -h means to give output in hex (default)#         -H means hex output, but use uppercase letters#         keylen is the number of bytes to the random key (default is 8)# If you run this on a different kind of system, you will want to adjust the# setting in the &quot;noise&quot; string to system-specific strings.  Do it as another# case in the &quot;if...else&quot; and e-mail me the modification so I can keep a # merged copy.  (Hint: check in your manual for any programs with &quot;stat&quot; in # the name or description.)## You will need to install a version of MD5.  You can find one in the COAST # achive at <ACLASS="systemitem.url"HREF="ftp://coast.cs.purdue.edu/pub/tools/unix">ftp://coast.cs.purdue.edu/pub/tools/unix</A># Be sure to include its location in the PATH below if it isn't in one of the# directories already listed.$ENV{'PATH'} = &quot;/bin:/usr/bin:/usr/etc:/usr/ucb:/etc:&quot; . $ENV{'PATH'};# We start with the observation that most machines have either a BSD# core command set, or a System V-ish command set.  We'll build from those.$BSD = &quot;ps -agxlww ; netstat -s ; vmstat -s ;&quot;;$SYSV = &quot;ps -eflj ; netstat -s ; nfsstat -nr ;&quot;;if ( -e &quot;/sdmach&quot; ) {    $_ = &quot;NeXT&quot;;} elsif ( -x &quot;/usr/bin/uname&quot; || -x &quot;/bin/uname&quot;) {    $_ = `uname -sr`;} elsif ( -x &quot;/etc/version&quot; ) {    $_ = `/etc/version`;} else {    die &quot;How do I tell what OS this is?&quot;;}/^AIX 1/	&amp;&amp;	(                   $noise = $BSD . 'pstat -afipSsT')||/^CLIX 3/	&amp;&amp;	(                  $noise = &quot;ps -efl ; nfsstat -nr&quot;)||/^DYNIX/	&amp;&amp;	(                   $noise = $BSD . 'pstat -ai')||/^FreeBSD 2/	&amp;&amp;	(               $noise = $BSD . 'vmstat -i')||/^HP-UX 7/	&amp;&amp;	(                 $noise = $SYSV)||/^HP-UX A.09/	&amp;&amp;	(              $noise = $SYSV . &quot;vmstat -s&quot;)||/^IRIX(64)? [56]/   &amp;&amp;	(       $noise = $SYSV)||/^Linux 1/	&amp;&amp;	(                 $noise = &quot;ps -agxlww ; netstat -i ; vmstat&quot;)||/^NeXT/		&amp;&amp; (                  $noise = 'ps agxlww;netstat -s;vm_stat')||/^OSF1/		&amp;&amp; (                  $noise = $SYSV . 'vmstat -i')||/^SunOS 4/	&amp;&amp;	(                 $noise = $BSD . 'pstat -afipSsT;vmstat -i')||/^SunOS 5/	&amp;&amp;	(                 $noise = $SYSV . 'vmstat -i;vmstat -s')||/^ULTRIX 4/	&amp;&amp;	(                $noise = $BSD . 'vmstat -s')|||    die &quot;No 'noise' commands defined for this OS.  Edit and retry!&quot;;  ####  End of things you may need to modifyrequire 'getopts.pl';require 'open2.pl';($prog = $0) =~ s|.*/||;$usage = &quot;usage: $prog [-n] [-h | -H] [keylength]\n&quot;;&amp;Getopts('nhH') || die $usage;defined($keylen = shift) || ($keylen = 8);die $usage if ($keylen =~ /\D/);die $usage if ($opt_H &amp;&amp; $opt_h);die &quot;Maximum keylength is 16 bytes (32 hex digits)\n&quot; if ($keylen &gt; 16);# Run the noise command and include whatever other state we# can conveniently (portably) find.@junk = times();$buf = `$noise` . $$ . getppid() . time . join(`', %ENV) . &quot;@junk&quot; . `ls -lai`;# Now, run it through the md5 program to mix bits and entropy&amp;open2('m_out', 'm_in', &quot;md5&quot;) || die &quot;Cannot run md5 command: $!&quot;;print m_in $buf;close m_in;$buf = &lt;m_out&gt;;($buf =~ y/a-f/A-F/) if $opt_H;print substr($buf, 0, 2*$keylen);print &quot;\n&quot; unless $opt_n;</PRE></BLOCKQUOTE></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch23_08.htm"TITLE="23.8 Picking a Random Seed"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 23.8 Picking a Random Seed"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Practical UNIX &amp; Internet Security"><IMGSRC="../gifs/txthome.gif"ALT="Practical UNIX &amp; Internet Security"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="PART"HREF="part06.htm"TITLE="VI. Handling Security Incidents"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: VI. Handling Security Incidents"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">23.8 Picking a Random Seed</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">VI. Handling Security Incidents</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>