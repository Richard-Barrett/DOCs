<HTML><HEAD><TITLE>[Chapter 25] 25.2 Overload Attacks</TITLE><METANAME="DC.title"CONTENT="Practical UNIX &amp; Internet Security"><METANAME="DC.creator"CONTENT="Simson Garfinkel &amp; Gene Spafford"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T00:19:34Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-148-8"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch25_01.htm"TITLE="25. Denial of Service Attacks and Solutions"><LINKREL="prev"HREF="ch25_01.htm"TITLE="25.1 Destructive Attacks"><LINKREL="next"HREF="ch25_03.htm"TITLE="25.3 Network Denial of Service Attacks"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Practical UNIX &amp; Internet Security"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Practical UNIX &amp; Internet Security"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch25_01.htm"TITLE="25.1 Destructive Attacks"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 25.1 Destructive Attacks"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 25<BR>Denial of Service Attacks and Solutions</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch25_03.htm"TITLE="25.3 Network Denial of Service Attacks"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 25.3 Network Denial of Service Attacks"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2">25.2 Overload Attacks</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34238"></A><ACLASS="indexterm"NAME="AUTOID-34240"></A>In an overload attack, a sharedresource or service is overloaded with requests to such a pointthat it's unable to satisfy requests from other users.For example, if one user spawns enough processes, other users won'tbe able to run processes of their own. If one user fills up thedisks, other users won't be able to create new files. Youcan partially protect against overload attacks by partitioning yourcomputer's resources, and limiting each user to one partition.Alternatively, you can establish quotas to limit each user. Finally,you can set up systems for automatically detecting overloads andrestarting your computer.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.1">25.2.1 Process-Overload Problems</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34247"></A><ACLASS="indexterm"NAME="AUTOID-34250"></A>Oneof the simplest denial of service attacks is a process attack. Ina process attack, one user makes a computer unusable for otherswho happen to be using the computer at the same time. Process attacksare generally of concern only with shared computers: the fact thata user incapacitates his or her own workstation is of no interestif nobody else is using the machine.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.1.1">25.2.1.1 Too many processes</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34256"></A>The following program willparalyze or crash many older versions of <SPANCLASS="acronym">UNIX</SPAN>:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">main() { 		while (1) 			fork(); 	}</PRE></BLOCKQUOTE><PCLASS="para">When this program is run, the process executes the <KBDCLASS="command">fork()</KBD>instruction, creating a second process identical to the first. Bothprocesses then execute the <KBDCLASS="command">fork()</KBD>instruction, creating four processes. The growth continues untilthe system can no longer support any new processes. This is a totalattack, because all of the child processes are waiting for new processesto be established. Even if you were somehow able to kill one process,another would come along to take its place.</P><PCLASS="para">This attack will not disable most current versions of <SPANCLASS="acronym">UNIX</SPAN>,because of limits on the number of processes that can be run underany <SPANCLASS="acronym">UID</SPAN> (except for <ICLASS="filename">root</I>). This limit, called<SPANCLASS="acronym">MAXUPROC</SPAN>, is usually configured into the kernelwhen the system is built. Some <SPANCLASS="acronym">UNIX</SPAN> systems allowthis value to be set at boot time; for instance, <ACLASS="indexterm"NAME="AUTOID-34269"></A>Solaris allows you to put the following in your<ICLASS="filename">/etc/system</I> file:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">set maxuproc=100</PRE></BLOCKQUOTE><PCLASS="para">A user employing this attack will use up his quota of processes,but no more. As superuser, you will then be able to use the <ACLASS="indexterm"NAME="AUTOID-34275"></A><ACLASS="indexterm"NAME="AUTOID-34278"></A><KBDCLASS="command">ps</KBD>command to determine the process numbers of the offending processesand use the <KBDCLASS="command">kill</KBD> command to kill them. You cannot kill the processesone by one, because the remaining processes will simply create more.A better approach is to use the <KBDCLASS="command">kill</KBD> command to first stop eachprocess, then kill them all at once:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">kill -STOP 1009 1110 1921 </B># <BCLASS="emphasis.bold">kill -STOP 3219 3220 </B><BCLASS="emphasis.bold">. . . </B># <BCLASS="emphasis.bold">kill -KILL 1009 1110 1921 3219 3220... </B></PRE></BLOCKQUOTE><PCLASS="para">Because the stopped processes still come out of the user's<SPANCLASS="acronym">NPROC</SPAN><ACLASS="indexterm"NAME="AUTOID-34291"></A>quota,the forking program will be able to spawn no more. You can thendeal with the author.</P><PCLASS="para">Alternatively, you can kill all the processes in a processgroup at the same time; in many cases of a user spawning too manyprocesses, the processes will all be in the same process group.To discover the process group, run the <KBDCLASS="command">ps</KBD> command with the <KBDCLASS="command">-j</KBD>option. Identify the process group, and then kill all processeswith one fell swoop:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">kill -9 -1009</B></PRE></BLOCKQUOTE><PCLASS="para">Note that many older, AT&amp;T-derived systems do notsupport either process groups or the enhanced version of the <ICLASS="filename">kill</I> command, but it is present in <SPANCLASS="acronym">SVR4</SPAN>.This enhanced version of<ICLASS="filename"> kill </I>interprets thesecond argument as indicating a process group if it is precededby a &quot;-&quot;, and the absolute value of theargument is used as the process group; the indicated signal is sentto every process in the group.</P><PCLASS="para">Under modern versions of <SPANCLASS="acronym">UNIX</SPAN>, the <ICLASS="filename">root</I>user can still halt the system with a process attack because thereis no limit to the number of processes that the superuser can spawn.However, the superuser can also shut down the machine or performalmost any other act, so this is not a major concern&nbsp;- <EMCLASS="emphasis">except</EM>when <ICLASS="filename">root</I> is running a program that is buggy (or booby-trapped).In these cases, it's possible to encounter a situationin which the machine is overwhelmed to the point where no one elsecan get a free process even to do a login.</P><PCLASS="para">There is also a possibility that your system may reach thetotal number of allowable processes because so many users are loggedon, even though none of them has reached her individual limit.</P><PCLASS="para">One other possibility is that your system has been configuredincorrectly. Your per-user process limit may be equal to or greaterthan the limit for all processes on the system. In this case, asingle user can swamp the machine.</P><PCLASS="para">If you are ever presented with an error message from the shellthat says &quot;No more processes,&quot; then either you'vecreated too many child processes or there are simply too many processesrunning on the system; the system won't allow you to createany more processes.</P><PCLASS="para">For example:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <BCLASS="emphasis.bold">ps -efj </B>No more processes %</PRE></BLOCKQUOTE><PCLASS="para">If you run out of processes, wait a moment and try again.The situation may have been temporary. If the process problem doesnot correct itself, you have an interesting situation on your hands.</P><PCLASS="para">Having too many processes that are running can be very difficultto correct without rebooting the computer; there are two reasonswhy:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">You cannot run the <KBDCLASS="command">ps</KBD> command to determinethe process numbers of the processes to kill.</P></LI><LICLASS="listitem"><PCLASS="para">If you are not currently the superuser, you cannotuse the <KBDCLASS="command">su</KBD> or <ICLASS="filename">login </I>command, because both ofthese functions require the creation of a new process.</P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34324"></A>One way around thesecond problem is to use the shell's <KBDCLASS="command">exec</KBD>[1] built-in commandto run the <KBDCLASS="command">su</KBD> command without creating a new process:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] Theshell's <EMCLASS="emphasis">exec</EM> function causes a programto be run (with the <KBDCLASS="command">exec()</KBD> system call) without a <KBDCLASS="command">fork()</KBD> systemcall being executed first; the user-visible result is that the shellruns the program and then exits.</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% exec /bin/su password: <ICLASS="systemitem.password">foobar</I>#</PRE></BLOCKQUOTE><PCLASS="para">Be careful, however, that you do not mistype your passwordor <KBDCLASS="command">exec</KBD> the <KBDCLASS="command">ps</KBD> program: the program will execute, but you will thenbe automatically logged out of your computer!</P><PCLASS="para">If you have a problem with too many processes saturating thesystem, you may be forced to reboot the system. The simplest waymight seem to be to power-cycle the machine. However, this may damageblocks on disk, because it will probably not flush active buffersto disk &nbsp;-  few systems are designed to undergo an orderlyshutdown when powered off suddenly. It's better to usethe <KBDCLASS="command">kill</KBD> command to kill the errant processes or to bring the systemto single-user mode. (See <ACLASS="xref"HREF="appc_01.htm"TITLE="UNIX Processes">Appendix C, <CITECLASS="appendix">UNIX Processes</CITE></A> for information about <KBDCLASS="command">kill</KBD>, <KBDCLASS="command">ps</KBD>, <SPANCLASS="acronym">UNIX</SPAN>processes, and signals.)</P><PCLASS="para">On most modern versions of <SPANCLASS="acronym">UNIX</SPAN>, the superusercan send a <SPANCLASS="acronym">SIGTERM</SPAN><ACLASS="indexterm"NAME="AUTOID-34347"></A>signal to all processes except system processes and your own processby typing:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">kill -TERM -1</B> #</PRE></BLOCKQUOTE><PCLASS="para">If your <SPANCLASS="acronym">UNIX</SPAN> system does not have thisfeature, you can execute the command:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">kill -TERM 1</B>#</PRE></BLOCKQUOTE><PCLASS="para">to send a <SPANCLASS="acronym">SIGTERM </SPAN>to the <KBDCLASS="command">init</KBD> process.<SPANCLASS="acronym">UNIX</SPAN> automatically kills all processes and goesto single-user mode when <KBDCLASS="command">init</KBD> dies. You can then execute the <KBDCLASS="command">sync</KBD>command from the console and reboot the operating system.</P><PCLASS="para">If you get the error &quot;No more processes&quot;when you attempt to execute the <KBDCLASS="command">kill</KBD> command, exec a version ofthe <KBDCLASS="command">ksh</KBD> or <KBDCLASS="command">csh</KBD>&nbsp;- they have the <KBDCLASS="command">kill</KBD> command built into themand therefore don't need to spawn an extra process to runthe command.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.1.2">25.2.1.2 System overload attacks</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34369"></A><ACLASS="indexterm"NAME="AUTOID-34372"></A>Another common process-based denialof service occurs when a user spawns many processes that consumelarge amounts of <SPANCLASS="acronym">CPU</SPAN>. As most <SPANCLASS="acronym">UNIX</SPAN>systems use a form of simple round-robin scheduling, these overloadsreduce the total amount of <SPANCLASS="acronym">CPU</SPAN> processing timeavailable for all other users. For example, someone who dispatchesten <KBDCLASS="command">find</KBD> commands with <KBDCLASS="command">grep</KBD> components throughout your Usenet directories,or spawns a dozen large <KBDCLASS="command">troff</KBD> jobs can slow the system to a crawl.[2]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] We resist using the phrase commonly found on the net of &quot;bringingthe system to its knees.&quot; UNIX systems have many interestingfeatures, but knees are not among them. How the systems manage tocrawl, then, is left as an exercise to the reader.</P></BLOCKQUOTE><PCLASS="para">The best way to deal with these problems is to educate yourusers about how to share the system fairly. Encourage them to usethe <ACLASS="indexterm"NAME="AUTOID-34385"></A><KBDCLASS="command">nice</KBD> command to reduce thepriority of their background tasks, and to do them a few at a time.They can also use the <KBDCLASS="command">at</KBD> or <ICLASS="filename"><ACLASS="indexterm"NAME="AUTOID-34390"></A><ACLASS="indexterm"NAME="AUTOID-34392"></A>batch</I> command to defer execution oflengthy tasks to a time when the system is less crowded. You'llneed to be more forceful with users who intentionally or repeatedlyabuse the system.</P><PCLASS="para">If your system is exceptionally loaded, log in as <ICLASS="filename">root</I> andset your own priority as high as you can right away with the <ACLASS="indexterm"NAME="AUTOID-34396"></A><KBDCLASS="command">renice</KBD> command, if it is available on your system:[3]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] In this case, your login may require a lot of time; reniceis described in more detail in <ACLASS="xref"HREF="appc_01.htm"TITLE="UNIX Processes">Appendix C</A>.</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">renice -19 $$$</B>#</PRE></BLOCKQUOTE><PCLASS="para">Then, use the <ICLASS="filename">ps </I>command to see what'srunning, followed by the <KBDCLASS="command">kill</KBD> command to remove the processes monopolizingthe system, or the <KBDCLASS="command">renice</KBD> command to slow down these <ACLASS="indexterm"NAME="AUTOID-34408"></A><ACLASS="indexterm"NAME="AUTOID-34411"></A>processes.<ACLASS="indexterm"NAME="AUTOID-34414"></A><ACLASS="indexterm"NAME="AUTOID-34417"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.2">25.2.2 Disk Attacks</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34423"></A><ACLASS="indexterm"NAME="AUTOID-34425"></A><ACLASS="indexterm"NAME="AUTOID-34429"></A>Another way of overwhelming a system isto fill a disk partition. If one user fills up the disk, other userswon't be able to create files or do other useful work.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.2.1">25.2.2.1 Disk-full attacks</A></H4><PCLASS="para">A disk can store only a certain amount of information. Ifyour disk is full, you must delete some information before morecan be stored.</P><PCLASS="para">Sometimes disks fill up suddenly when an application programor a user erroneously creates too many files (or a few files thatare too large). Other times, disks fill up because many users areslowly increasing their disk usage.</P><PCLASS="para">The <ACLASS="indexterm"NAME="AUTOID-34436"></A><KBDCLASS="command">du</KBD> command lets you findthe directories on your system that contain the most data. <KBDCLASS="command">du</KBD> searchesrecursively through a tree of directories and lists how many blocksare used by each one. For example, to check the entire <ICLASS="filename">/usr</I>partition, you could type:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">du /usr </B>29		/usr/dict/papers 3875		/usr/dict 8		/usr/pub 4032		/usr ... #</PRE></BLOCKQUOTE><PCLASS="para">By finding the larger directories, you can decide where tofocus your cleanup efforts.</P><PCLASS="para">You can also search for and list only the names of the largerfiles by using the <KBDCLASS="command">find</KBD> command. You can also use the <ACLASS="indexterm"NAME="AUTOID-34446"></A><ACLASS="indexterm"NAME="AUTOID-34449"></A><ACLASS="indexterm"NAME="AUTOID-34452"></A><KBDCLASS="command">find</KBD> command with the <KBDCLASS="command">-size</KBD> optionto list only the files larger than a certain size. Additionally,you can use the options called <KBDCLASS="command">-xdev</KBD> or <KBDCLASS="command">-local</KBD> to avoid searching<SPANCLASS="acronym">NFS</SPAN>-mounted directories (although you will wantto run find on each <SPANCLASS="acronym">NFS</SPAN> server.) This methodis about as fast as doing a <KBDCLASS="command">du</KBD> and can be even more useful whentrying to find a few large files that are taking up space. For example:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">find /usr -size +1000 -exec ls -l {} \;</B>-rw-r--r-- 1 root 1819832 Jan  9 10:45 /usr/lib/libtext.a-rw-r--r-- 1 root 2486813 Aug 10  1985 /usr/dict/web2-rw-r--r-- 1 root 1012730 Aug 10  1985 /usr/dict/web2a-rwxr-xr-x 1 root  589824 Oct 22 21:27 /usr/bin/emacs-rw-r--r-- 1 root 7323231 Oct 31  1990 /usr/tex/TeXdist.tar.Z-rw-rw-rw- 1 root  772092 Mar 10 22:12 /var/spool/mqueue/syslog-rw-r--r-- 1 uucp 1084519 Mar 10 22:12 /var/spool/uucp/LOGFILE-r--r--r-- 1 root  703420 Nov 21 15:49 /usr/tftpboot/mach... #</PRE></BLOCKQUOTE><PCLASS="para">In this example, the file <ICLASS="filename">/usr/tex/TeXdist.tar.Z</I>is probably a candidate for deletion&nbsp;- especially if youhave already unpacked the TeX distribution. The files <ICLASS="filename">/var/spool/mqueue/syslog</I>and <ICLASS="filename">/var/spool/uucp/LOGFILE</I>are also good candidates to delete, after saving them to tape oranother disk.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.2.2">25.2.2.2 quot command</A></H4><PCLASS="para">The <ACLASS="indexterm"NAME="AUTOID-34471"></A><ACLASS="indexterm"NAME="AUTOID-34473"></A><ACLASS="indexterm"NAME="AUTOID-34476"></A><KBDCLASS="command">quot</KBD> command letsyou summarize filesystem usage by user; this program is availableon some System V and on most Berkeley-derived systems. With the<ICLASS="filename">-f </I>option, <KBDCLASS="command">quot</KBD> prints the number of filesand the number of blocks used by each user:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">quot -f /dev/sd0a</B>/dev/sd0a (/):53698  4434 root 4487   294 bin  681   155 hilda  319   121 daemon  123    25 uucp   24     1 audit   16     1 mailcmd   16     1 news    6     7 operator#</PRE></BLOCKQUOTE><PCLASS="para">You do not need to have disk quotas enabled to run the <KBDCLASS="command">quot</KBD><KBDCLASS="command">-f</KBD> command.</P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> The <ICLASS="filename">quot -f</I> command may lock the device while it isrunning. All other programs that need to access the device willbe blocked until the <ICLASS="filename">quot -f</I> command completes.</P></BLOCKQUOTE></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.2.3">25.2.2.3 Inode problems</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34494"></A><ACLASS="indexterm"NAME="AUTOID-34497"></A>The<SPANCLASS="acronym">UNIX</SPAN> filesystem uses inodes to store informationabout files. One way to make the disk unusable is to consume allof the free inodes on a disk, so no new files can be created. Aperson might inadvertently do this by creating thousands of emptyfiles. This can be a perplexing problem to diagnose if you'renot aware of the potential because the <KBDCLASS="command">df</KBD> commandmight show lots of available space, but attempts to create a filewill result in a &quot;no space&quot; error. In general,each new file, directory, pipe, <SPANCLASS="acronym">FIFO</SPAN>, or socketrequires an inode on disk to describe it. If the supply of availableinodes is exhausted, the system can't allocate a new fileeven if disk space is available.</P><PCLASS="para">You can tell how many inodes are free on a disk by issuingthe <ACLASS="indexterm"NAME="AUTOID-34504"></A><KBDCLASS="command">df</KBD> command with the <ICLASS="filename">-i</I>option:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <BCLASS="emphasis.bold">df -o i /usr</B>           <EMCLASS="emphasis">&gt;may be <ICLASS="filename">df -i</I> on some systems</EM>Filesystem             iused   ifree  %iused  Mounted on/dev/dsk/c0t3d0s5      20100   89404    18%   /usr%</PRE></BLOCKQUOTE><PCLASS="para">The output shows that this disk has lots of inodes availablefor new files.</P><PCLASS="para">The number of inodes in a filesystem is usually fixed at thetime you initially format the disk for use. The default createdfor the partition is usually appropriate for normal use, but youcan override it to provide more or fewer inodes, as you wish. Youmay wish to increase this number for partitions in which you havemany small files&nbsp;- for example, a partition to hold Usenetfiles (e.g., <ICLASS="filename">/var/spool/news</I>). If you run outof inodes on a filesystem, about the only recourse is to save thedisk to tape, reformat with more inodes, and then restore the contents.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.2.4">25.2.2.4 Using partitions to protect your users</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34518"></A>You can protect your systemfrom disk attacks by dividing your hard disk into several smallerpartitions. Place different users' home directories ondifferent partitions. In this manner, if one user fills up one partition,users on other partitions won't be affected. (Drawbacksof this approach include needing to move directories to differentpartitions if they require more space, and an inability to hard-linkfiles between some user directories.)</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.2.5">25.2.2.5 Using quotas</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34523"></A><ACLASS="indexterm"NAME="AUTOID-34525"></A><ACLASS="indexterm"NAME="AUTOID-34528"></A>Amore effective way to protect your system from disk attacks is touse the quota system that is available on most modern versions of<SPANCLASS="acronym">UNIX</SPAN>. (Quotas are usually available as a build-timeor run-time option on <SPANCLASS="acronym">POSIX</SPAN> systems.)</P><PCLASS="para">With disk quotas, each user can be assigned a limit for howmany inodes and how many disk blocks that user can use. There aretwo basic kinds of quotas:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34536"></A><ACLASS="indexterm"NAME="AUTOID-34539"></A><ICLASS="firstterm">Hard quotas</I> are absolute limits on how manyinodes and how much space the user may consume.</P></LI><LICLASS="listitem"><PCLASS="para"><ICLASS="firstterm">Soft quotas</I> are advisory. Users are allowed to exceedsoft quotas for a grace period of several days. During this time,the user is issued a warning whenever he or she logs into the system.After the final day, the user is not allowed to create any morefiles (or use any more space) without first reducing current usage.</P></LI></UL><PCLASS="para">A few systems also support a <ICLASS="firstterm"><ACLASS="indexterm"NAME="AUTOID-34547"></A>group quota</I>, which allows you to set a limit onthe total space used by a whole group of users. This can resultin cases where one user can deny another the ability to store afile if they are in the same group, so it is an option you may notwish to use.</P><PCLASS="para">To enable quotas on your system, you first need to createthe quota summary file. This is usually named <ICLASS="filename">quotas</I>,and is located in the top-level directory of the disk. Thus, toset quotas on the <ICLASS="filename">/home</I> partition, you wouldissue the following commands:[4]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] If your system supportsgroup quotas, the file will be named something else, such as <ICLASS="filename">quotas.user</I>or <ICLASS="filename">quotas.group.</I></P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">cp /dev/null /home/quotas</B># <BCLASS="emphasis.bold">chmod 600 /home/quotas</B># <BCLASS="emphasis.bold">chown root /home/quotas</B></PRE></BLOCKQUOTE><PCLASS="para">You also need to mark the partition as having quotas enabled.You do this by changing the filesystem file in your <ICLASS="filename">/etc</I>directory: depending on the system, this may be <ICLASS="filename">/etc/fstab,</I><ICLASS="filename">/etc/vfstab, /etc/checklist,</I>or <ICLASS="filename">/etc/filesystems</I>. If the option field is currently<KBDCLASS="command">rw</KBD> you will change it to <KBDCLASS="command">rq</KBD>; otherwise, you probably add the optionsparameter.[5] Then,you need to build the options tables on every disk. This processis done with the <ACLASS="indexterm"NAME="AUTOID-34569"></A><KBDCLASS="command">quotacheck</KBD><KBDCLASS="command">-a</KBD> command. (If your version of <ICLASS="filename">quotacheck</I>takes the <KBDCLASS="command">-p</KBD> option, you may wish to use it to make the checks faster.)Note that if there are any active users on the system, this checkmay result in improper values. Thus, we advise that you reboot;the quotacheck command should run as part of the standard boot sequenceand will check all the filesystems you enabled.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] This is yet another example of how non-standardUNIX has become, and why we have not given more examples of howto set up each and every system for each option we have explained.It is also a good illustration of why you should consult your vendordocumentation to see how to interpret our suggestions appropriatelyfor your release of the operating system.</P></BLOCKQUOTE><PCLASS="para">Last of all, you can edit an individual user's quotaswith the <ACLASS="indexterm"NAME="AUTOID-34576"></A><KBDCLASS="command">edquota</KBD> command:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">edquota spaf</B></PRE></BLOCKQUOTE><PCLASS="para">If you want to &quot;clone&quot; the same set of quotasto multiple users and your version of the command supports the -poption, you may do so by using one user's quotas as a &quot;prototype&quot;:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">edquota -p spaf simsong beth kathy</B></PRE></BLOCKQUOTE><PCLASS="para">You and your users can view quotas with the quota command;see your documentation for particular details.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.2.6">25.2.2.6 Reserved space</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34588"></A><ACLASS="indexterm"NAME="AUTOID-34591"></A>Versionsof <SPANCLASS="acronym">UNIX</SPAN> that use a filesystem derived from the<ACLASS="indexterm"NAME="AUTOID-34594"></A><ACLASS="indexterm"NAME="AUTOID-34596"></A><ACLASS="indexterm"NAME="AUTOID-34598"></A><ACLASS="indexterm"NAME="AUTOID-34601"></A><ACLASS="indexterm"NAME="AUTOID-34605"></A><SPANCLASS="acronym">BSD</SPAN> Fast Filesystem (<SPANCLASS="acronym">FFS</SPAN>)have an additional protection against filling up the disk: the filesystemreserves approximately 10% of the disk and makes it unusableby regular users. The reason for reserving this space is performance:the <SPANCLASS="acronym">BSD</SPAN> Fast Filesystem does not perform as wellif less than 10% of the disk is free. However, this restrictionalso prevents ordinary users from overwhelming the disk. The restrictiondoes not apply to processes running with superuser privileges.</P><PCLASS="para">This &quot;minfree&quot; value (10%) canbe set to other values when the partition is created. It can alsobe changed afterwards using the <ACLASS="indexterm"NAME="AUTOID-34612"></A><KBDCLASS="command">tunefs</KBD>command, but setting it to less than 10% is probably nota good idea.</P><PCLASS="para">The <ACLASS="indexterm"NAME="AUTOID-34616"></A><ACLASS="indexterm"NAME="AUTOID-34619"></A>Linux ext2 filesystem also allowsyou to reserve space on your filesystem. The amount of space thatis reserved, 10% by default, can be changed with the <ICLASS="filename">tune2fs</I>command.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.2.7">25.2.2.7 Hidden space</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34625"></A><ACLASS="indexterm"NAME="AUTOID-34628"></A><ACLASS="indexterm"NAME="AUTOID-34631"></A><ACLASS="indexterm"NAME="AUTOID-34634"></A><ACLASS="indexterm"NAME="AUTOID-34637"></A>Open files thatare unlinked continue to take up space until they are closed. Thespace that these files take up will not appear with the du or findcommands, because they are not in the directory tree; however, theywill nevertheless take up space, because they are in the filesystem.</P><PCLASS="para">For example:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">main(){		int ifd;		char buf[8192];		ifd = open(&quot;./attack&quot;, O_WRITE|O_CREAT, 0777);		unlink(&quot;./attack&quot;);		while (1)			write (ifd, buf, sizeof(buf));}</PRE></BLOCKQUOTE><PCLASS="para">Files created in this way can't be found with the<KBDCLASS="command">ls</KBD> or <KBDCLASS="command">du</KBD> commands because the files have no directory entries.</P><PCLASS="para">To recover from this situation and reclaim the space, youmust kill the process that is holding the file open. You may haveto take the system into single-user mode and kill <EMCLASS="emphasis">all</EM> processes if you cannot determine which process is toblame. After you've done this, run the filesystem consistencychecker (e.g., fsck) to verify that the free list was not damagedduring the shutdown operation.</P><PCLASS="para">You can more easily identify the program at fault by downloadinga copy of the freeware <ACLASS="indexterm"NAME="AUTOID-34647"></A><KBDCLASS="command">lsof</KBD> programfrom the net. This program will identify the processes that haveopen files, and the file position of each open file.[6]By identifying a process with an open file that has a huge currentoffset, you can terminate that single process to regain the diskspace. After the process dies and the file is closed, all the storageit occupied is reclaimed.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] Actually,you should consider getting a copy of <KBDCLASS="command">lsof</KBD> for other reasons, too.It has an incredible number of other uses, such as determining whichprocesses have open network connections and which processes havetheir current directories on a particular disk.</P></BLOCKQUOTE></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.2.8">25.2.2.8 Tree-structure attacks</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34656"></A><ACLASS="indexterm"NAME="AUTOID-34658"></A><ACLASS="indexterm"NAME="AUTOID-34661"></A><ACLASS="indexterm"NAME="AUTOID-34664"></A><ACLASS="indexterm"NAME="AUTOID-34667"></A><ACLASS="indexterm"NAME="AUTOID-34669"></A>It is alsopossible to attack a system by building a tree structure that ismade too deep to be deleted with the <ACLASS="indexterm"NAME="AUTOID-34672"></A><ACLASS="indexterm"NAME="AUTOID-34675"></A><ACLASS="indexterm"NAME="AUTOID-34677"></A><KBDCLASS="command">rm</KBD> command.Such an attack could be caused by something like the following shellfile:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$!/bin/ksh $ $ Don't try this at home!while mkdir anotherdirdo		cd ./anotherdir		cp /bin/cc fillitupdone</PRE></BLOCKQUOTE><PCLASS="para">On some systems, <KBDCLASS="command">rm -r</KBD> cannot delete this tree structurebecause the directory tree overflows either the buffer limits usedinside the <KBDCLASS="command">rm</KBD> program to represent filenames or the number of opendirectories allowed at one time.</P><PCLASS="para">You can almost always delete a very deep set of directoriesby manually using the <ACLASS="indexterm"NAME="AUTOID-34686"></A><KBDCLASS="command">chdir</KBD>command from the shell and going to the bottom of the tree, thendeleting the files and directories one at a time. This process canbe very tedious. Unfortunately, some <SPANCLASS="acronym">UNIX</SPAN> systemsdo not let you <KBDCLASS="command">chdir</KBD> to a directory described by a path that containsmore than a certain number of characters.</P><PCLASS="para">Another approach is to use a script similar to the one inExample 25-1:</P><DIVCLASS="example"><H4CLASS="example"><ACLASS="title"NAME="AUTOID-34692">Example 25.1: Removing Nested Directories</A></H4><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#!/bin/ksh if (( $# != 1 ))then    print -u2 &quot;usage: $0 &lt;dir&gt;&quot;    exit 1fitypeset -i index=1 dindex=0typeset t_prefix=&quot;unlikely_fname_prefix&quot; fname=$(basename $1)cd $(dirname &quot;$1&quot;)         # go to the directory containing the problemwhile (( dindex &lt; index ))do    for entry in $(ls -1a &quot;$fname&quot;)    do      [[ &quot;$entry&quot; == @(.|..) ]] &amp;&amp; continue      if [[ -d &quot;$fname/$entry&quot; ]]      then          rmdir - &quot;$fname/$entry&quot; 2&gt;/dev/null &amp;&amp; continue          mv &quot;$fname/$entry&quot; ./$t_prefix.$index          let index+=1      else          rm -f - &quot;$fname/$entry&quot;      fi    done    rmdir &quot;$fname&quot;    let dindex+=1    fname=&quot;$t_prefix.$dindex&quot;done</PRE></BLOCKQUOTE></DIV><PCLASS="para">What this method does is delete the nested directories startingat the top. It deletes any files at the top level, and moves anynested directories up one level to a temporary name. It then deletesthe (now empty) top-level directory and begins anew with one ofthe former descendent directories. This process is slow, but itwill work on almost any version of <SPANCLASS="acronym">UNIX</SPAN>.</P><PCLASS="para">The only other way to delete such a directory on one of thesesystems is to remove the inode for the top-level directory manually,and then use the <ACLASS="indexterm"NAME="AUTOID-34698"></A>fsck commandto erase the remaining directories. To delete these kinds of troublingdirectory structures this way, follow these steps:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Take the system to single-user mode.</P></LI><LICLASS="listitem"><PCLASS="para">Find the inode number of the <ICLASS="filename">root</I> of the offendingdirectory.</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">ls -i anotherdir </B>1491 anotherdir # </PRE></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para">Use the <KBDCLASS="command">df</KBD> command to determine the device of theoffending directory:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">/usr/bin/df anotherdir </B>/g17            (/dev/dsk/c0t2d0s2 ):  377822 blocks   722559 files # </PRE></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para">Clear the inode associated with that directory usingthe <KBDCLASS="command">clri</KBD> program:[7]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] The <KBDCLASS="command">clri</KBD> command can be found in<ICLASS="filename">/usr/sbin/clri</I> on Solaris systems. Ifyou are using SunOS, use the unlink command instead.</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">clri /dev/dsk/c0t2d0s2 1491 </B>#</PRE></BLOCKQUOTE><PCLASS="para">(Remember to replace <ICLASS="filename">/dev/dsk/c0t2d0s2</I>with the name of the actual device reported by the <KBDCLASS="command">df</KBD> command.)</P></LI><LICLASS="listitem"><PCLASS="para">Run your filesystem consistency checker (for example,<KBDCLASS="command">fsck</KBD> <ICLASS="filename">/dev/dsk/cot2dos2)</I> until it reportsno errors. When the program tells you that there is an unconnecteddirectory with inode number 1491 and asks you if you want to reconnectit, answer &quot;no.&quot; The <KBDCLASS="command">fsck</KBD> program will reclaimall the disk blocks and inodes used by the directory tree.</P></LI></OL><PCLASS="para">If you are using the Linux ext2 filesystem, you can deletean inode using the <ACLASS="indexterm"NAME="AUTOID-34731"></A>debugfscommand. It is important that the filesystem be unmounted beforeusing the debugfs <ACLASS="indexterm"NAME="AUTOID-34733"></A><ACLASS="indexterm"NAME="AUTOID-34735"></A><ACLASS="indexterm"NAME="AUTOID-34738"></A><ACLASS="indexterm"NAME="AUTOID-34741"></A><ACLASS="indexterm"NAME="AUTOID-34744"></A><ACLASS="indexterm"NAME="AUTOID-34746"></A>command.<ACLASS="indexterm"NAME="AUTOID-34749"></A><ACLASS="indexterm"NAME="AUTOID-34751"></A><ACLASS="indexterm"NAME="AUTOID-34755"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.3">25.2.3 Swap Space Problems</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34760"></A><ACLASS="indexterm"NAME="AUTOID-34762"></A>Most <SPANCLASS="acronym">UNIX</SPAN>systems are configured with some disk space for holding processmemory images when they are paged or swapped out of main memory.[8] If your systemis not configured with enough swap space, then new processes, especiallylarge ones, will not be run because there is no swap space for them.This failure often results in the error message &quot;No space&quot;when you attempt to execute a command.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] Swapping and paging are technically two different activities.Older systems swapped entire process memory images out to secondarystorage; paging removes only portions of programs at a time. Theuse of the word &quot;swap&quot; has become so commonplacethat most UNIX users use the word &quot;swap&quot; for bothswapping and paging, so we will too.</P></BLOCKQUOTE><PCLASS="para">If you run out of swap space because processes have accidentallyfilled up the available space, you can increase the space you'veallocated to backing store. On <SPANCLASS="acronym">SVR4</SPAN> or the SunOSsystem, this increase is relatively simple to do, although you mustgive up some of your user filesystem. First, find a partition withsome spare storage:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">/bin/df -ltk</B>Filesystem            kbytes      used   avail capacity  Mounted on/dev/dsk/c0t3d0s0        95359     82089    8505     91%     /                  /proc                      0         0       0      0%     /proc              /dev/dsk/c0t1d0s2     963249    280376  634713    31%    /user2      /dev/dsk/c0t2d0s0    1964982   1048379  720113    59%    /user3      /dev/dsk/c0t2d0s6    1446222    162515 1139087    12%    /user4      #</PRE></BLOCKQUOTE><PCLASS="para">In this case, partition <ICLASS="filename">/user4</I> appears to have lotsof spare room. You can create an additional 50 Mb of swap spaceon this partition with this command sequence on Solaris systems:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">mkfile 50m /user4/junkfile</B># <BCLASS="emphasis.bold">swap -a /user4/junkfile</B></PRE></BLOCKQUOTE><PCLASS="para">On SunOS systems, type:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">mkfile 50m /user4/junkfile</B># <BCLASS="emphasis.bold">swapon /user4/junkfile</B></PRE></BLOCKQUOTE><PCLASS="para">You can add this to the <KBDCLASS="command">vfstab</KBD> if you want the swap spaceto be available across reboots. Otherwise, remove the sequence asa swap device (<KBDCLASS="command">swap -d /user4/junkfile)</KBD> and thendelete the file.</P><PCLASS="para">Correcting a shortage of swap space on systems that do notsupport swapping to files (such as most older versions of <SPANCLASS="acronym">UNIX</SPAN>)usually involves shutting down your computer and repartitioningyour hard disk.</P><PCLASS="para">If a malicious user has filled up your swap space, a short-termapproach is to identify the offending process or processes and killthem. The ps command shows you the size of every executing processand helps you determine the cause of the problem. The <KBDCLASS="command">vmstat</KBD> command,if you have it, can also provide valuable process state information.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.4">25.2.4 /tmp Problems</A></H3><PCLASS="para">Most <SPANCLASS="acronym">UNIX</SPAN> systems are configured so thatany user can create files of any size in the <ICLASS="filename"><ACLASS="indexterm"NAME="AUTOID-34793"></A><ACLASS="indexterm"NAME="AUTOID-34795"></A><ACLASS="indexterm"NAME="AUTOID-34798"></A>/tmp</I>directory. Normally, there is no quota checking enabled in the <ICLASS="filename">/tmp</I>directory. Consequently, a single user can fill up the partitionon which the <ICLASS="filename">/tmp</I> directory is mounted, so that it willbe impossible for other users (and possibly the superuser) to createnew files.</P><PCLASS="para">Unfortunately, many programs require the ability to storefiles in the <ICLASS="filename">/tmp</I> directory to function properly.For example, the <KBDCLASS="command">vi</KBD> and <KBDCLASS="command">mail</KBD> programs both store temporary filesin <ICLASS="filename">/tmp</I>. These programs will unexpectedly failif they cannot create their temporary files. Many locally writtensystem administration scripts rely on the ability to create filesin the <ICLASS="filename">/tmp</I> directory, and do not check to make sure thatsufficient space is available.</P><PCLASS="para">Problems with the <ICLASS="filename">/tmp</I> directory are almost alwaysaccidental. A user will copy a number of large files there, andthen forget them. Perhaps many users will do this.</P><PCLASS="para">In the early days of <SPANCLASS="acronym">UNIX</SPAN>, filling up the<ICLASS="filename">/tmp</I> directory was not a problem. The <ICLASS="filename">/tmp</I>directory is automatically cleared when the system boots, and early<SPANCLASS="acronym">UNIX</SPAN> computers crashed a lot. These days, <SPANCLASS="acronym">UNIX</SPAN>systems stay up much longer, and the /tmp directory oftendoes not get cleaned out for days, weeks, or months.</P><PCLASS="para">There are a number of ways to minimize the danger of <ICLASS="filename">/tmp</I>attacks:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Enable <ACLASS="indexterm"NAME="AUTOID-34822"></A>quota checking on <ICLASS="filename">/tmp</I>, so that nosingle user can fill it up. A good quota is to allow each user totake up 40% of the space in <ICLASS="filename">/tmp</I>. Thus, fillingup <ICLASS="filename">/tmp</I> will, under the best circumstances, require collusionbetween more than two users.</P></LI><LICLASS="listitem"><PCLASS="para">Have a process that monitors the <ICLASS="filename">/tmp</I> directoryon a regular basis and alerts the system administrator if it isnearly filled.</P></LI></UL><PCLASS="para">As the superuser, you might also want to sweep through the<ICLASS="filename">/tmp</I> directory on a periodic basis and deleteany files that are more than three or five days old:[9]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] Bewarethat this command may be vulnerable to the filename attacks describedin <ACLASS="xref"HREF="ch11_01.htm"TITLE="Protecting Against Programmed Threats">Chapter 11</A>.</P></BLOCKQUOTE><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <BCLASS="emphasis.bold">find /tmp -mtime +5 -print | xargs rm -rf</B></PRE></BLOCKQUOTE><PCLASS="para">This line is a simple addition to your <ACLASS="indexterm"NAME="AUTOID-34839"></A><ACLASS="indexterm"NAME="AUTOID-34842"></A><KBDCLASS="command">crontab</KBD>for nightly execution.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="PUIS-CHP-25-SECT-2.5">25.2.5 Soft Process Limits: Preventing Accidental  Denialof Service</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-34849"></A><ACLASS="indexterm"NAME="AUTOID-34852"></A>Most modern versions of <SPANCLASS="acronym">UNIX</SPAN>allow you to set limits on the maximum amount of memory or <SPANCLASS="acronym">CPU</SPAN>time a process can consume, as well as the maximum file size itcan create. These limits are handy if you are developing a new programand do not want to accidentally make the machine very slow or unusablefor other people with whom you're sharing.</P><PCLASS="para">The Korn shell <KBDCLASS="command">ulimit</KBD> and C shell <ACLASS="indexterm"NAME="AUTOID-34860"></A><ACLASS="indexterm"NAME="AUTOID-34862"></A><KBDCLASS="command">limit</KBD> commands display the current process limits:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">ulimit -Sa</B>           -H for hard limits, -S for soft limitstime(seconds) 							unlimitedfile(blocks) 						unlimiteddata(kbytes) 						2097148 kbytesstack(kbytes) 						8192 kbytescoredump(blocks) 						unlimitednofiles(descriptors) 	64vmemory(kbytes) 						unlimited$ </PRE></BLOCKQUOTE><PCLASS="para">These limits have the following meanings:</P><DLCLASS="variablelist"><DTCLASS="term"><ICLASS="firstterm">time</I></DT><DDCLASS="listitem"><PCLASS="para">Maximum number of <SPANCLASS="acronym">CPU</SPAN> secondsyour process can consume.</P></DD><DTCLASS="term"><ICLASS="firstterm">file</I></DT><DDCLASS="listitem"><PCLASS="para">Maximum file size that your process can create,reported in 512-byte blocks.</P></DD><DTCLASS="term"><ICLASS="firstterm">data</I></DT><DDCLASS="listitem"><PCLASS="para">Maximum amount of memory for data space that yourprocess can reference.</P></DD><DTCLASS="term"><ICLASS="firstterm">stack</I></DT><DDCLASS="listitem"><PCLASS="para">Maximum stack your process can consume.</P></DD><DTCLASS="term"><ICLASS="firstterm">coredump</I></DT><DDCLASS="listitem"><PCLASS="para">Maximum size of a core file that your process willwrite; setting this value to 0 prevents you from writing core files.</P></DD><DTCLASS="term"><ICLASS="firstterm">nofiles</I></DT><DDCLASS="listitem"><PCLASS="para">Number of file descriptors (open files) that yourprocess can have.</P></DD><DTCLASS="term"><ICLASS="firstterm">vmemory</I></DT><DDCLASS="listitem"><PCLASS="para">Total amount of virtual memory your process canconsume.</P></DD></DL><PCLASS="para">You can also use the <KBDCLASS="command">ulimit</KBD> command to change a limit. Forexample, to prevent any future process you create from writing adata file longer than 5000 Kilobytes, execute the following command:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">ulimit -Sf 10000 </B>$ <BCLASS="emphasis.bold">ulimit -Sa </B>time(seconds) 				unlimitedfile(blocks) 			10000data(kbytes) 			2097148 kbytesstack(kbytes) 			8192 kbytescoredump(blocks) 			unlimitednofiles(descriptors) 	64vmemory(kbytes) 			unlimited$ </PRE></BLOCKQUOTE><PCLASS="para">To reset the limit, execute this command:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">ulimit -Sf unlimited</B>$ <BCLASS="emphasis.bold">ulimit -Sa </B>ctime(seconds) 				unlimitedfile(blocks) 			unlimiteddata(kbytes) 			2097148 kbytesstack(kbytes) 			8192 kbytescoredump(blocks) 			unlimitednofiles(descriptors) 	64vmemory(kbytes) 			unlimited$</PRE></BLOCKQUOTE><PCLASS="para">Note that if you set the hard limit, you cannot increase itagain unless you are currently the superuser. This limit may behandy to use in a system-wide profile to limit all your users.<ACLASS="indexterm"NAME="AUTOID-34915"></A><ACLASS="indexterm"NAME="AUTOID-34917"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch25_01.htm"TITLE="25.1 Destructive Attacks"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 25.1 Destructive Attacks"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Practical UNIX &amp; Internet Security"><IMGSRC="../gifs/txthome.gif"ALT="Practical UNIX &amp; Internet Security"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch25_03.htm"TITLE="25.3 Network Denial of Service Attacks"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 25.3 Network Denial of Service Attacks"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">25.1 Destructive Attacks</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">25.3 Network Denial of Service Attacks</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>