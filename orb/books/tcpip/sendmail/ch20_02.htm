<HTML><HEAD><TITLE>[Chapter 20] 20.2 The Cookbook</TITLE><METANAME="DC.title"CONTENT="sendmail"><METANAME="DC.creator"CONTENT="Bryan Costales &amp; Eric Allman"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-01-06T19:24:37Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-222-0"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch20_01.htm"TITLE="20. The checkcompat() Cookbook"><LINKREL="prev"HREF="ch20_01.htm"TITLE="20.1 How checkcompat() Works"><LINKREL="next"HREF="ch20_03.htm"TITLE="20.3 Alphabetized V8.8 Subroutines"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="sendmail"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="sendmail"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ssrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch20_01.htm"TITLE="20.1 How checkcompat() Works"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 20.1 How checkcompat() Works"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 20<BR>The checkcompat() Cookbook</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch20_03.htm"TITLE="20.3 Alphabetized V8.8 Subroutines"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 20.3 Alphabetized V8.8 Subroutines"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="SML2-CH-20-SECT-2">20.2 The Cookbook</A></H2><PCLASS="para">In this section we show several examples of possible uses for the<EMCLASS="emphasis">checkcompat</EM>() routine. Among those we illustrate are the following:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Accept mail only from our domain. (see <ACLASS="xref"HREF="ch20_02.htm#SML2-CH-20-SECT-2-1"TITLE="Accept Mail Only From Our Domain">Section 20.2.1, "Accept Mail Only From Our Domain"</A>).</P></LI><LICLASS="listitem"><PCLASS="para">Cause your workstation to refuse to work as a mail gateway (see <ACLASS="xref"HREF="ch20_02.htm#SML2-CH-20-SECT-2-2"TITLE="Workstation Refuses to Act as a Mail Gateway">Section 20.2.2, "Workstation Refuses to Act as a Mail Gateway"</A>).</P></LI><LICLASS="listitem"><PCLASS="para">Limit the size of guest account messages (see <ACLASS="xref"HREF="ch20_02.htm#SML2-CH-20-SECT-2-3"TITLE="Limit the Size of Guest Messages">Section 20.2.3, "Limit the Size of Guest Messages"</A>).</P></LI><LICLASS="listitem"><PCLASS="para">Verify that <EMCLASS="emphasis">identd</EM> information is correct (see <ACLASS="xref"HREF="ch20_02.htm#SML2-CH-20-SECT-2-4"TITLE="Verify identd Information">Section 20.2.4, "Verify identd Information"</A>).</P></LI><LICLASS="listitem"><PCLASS="para">Prune <CODECLASS="literal">Received:</CODE> headers at a firewall (see <ACLASS="xref"HREF="ch20_02.htm#SML2-CH-20-SECT-2-5"TITLE="Prune Received: Headers at Firewall">Section 20.2.5, "Prune Received: Headers at Firewall"</A>).</P></LI><LICLASS="listitem"><PCLASS="para">Reject mail from spamming or mail-bombing sites (see <ACLASS="xref"HREF="ch20_02.htm#SML2-CH-20-SECT-2-6"TITLE="Reject Mail from Spamming or Mail-bombing Sites">Section 20.2.6, "Reject Mail from Spamming or Mail-bombing Sites"</A>).</P></LI></UL><PCLASS="para">Note that in all of the following examples the numbers to theleft indicate line numbers for discussion and are not a part of the code.&#13;</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="SML2-CH-20-SECT-2-1">20.2.1 Accept Mail Only From Our Domain</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16342"></A><ACLASS="indexterm"NAME="AUTOID-16345"></A><ACLASS="indexterm"NAME="AUTOID-16348"></A><ACLASS="indexterm"NAME="AUTOID-16351"></A><ACLASS="indexterm"NAME="AUTOID-16354"></A>If your site lives behind a <EMCLASS="emphasis">firewall</EM>,[2]you might want to use <EMCLASS="emphasis">checkcompat</EM>() to configure the internal <EMCLASS="emphasis">sendmail</EM> sothat it accepts only mail that is generated locally. The external <EMCLASS="emphasis">sendmail</EM> (outside the firewall or part of it)acts as a proxy. That is, it accepts external mail that is destinedfor internal delivery from the outsideand forwards it to the internal <EMCLASS="emphasis">sendmail</EM>.Because the external <EMCLASS="emphasis">sendmail</EM> is part of the local domain,its envelope always appears to be local. Any external mail that somehow bypasses thefirewall needs to be bounced.The way to do this in <EMCLASS="emphasis">checkcompat</EM>() looks like this:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] A firewall is a machine that lies between the local network and theoutside world. It intercepts and filters all network trafficand rejects any that are considered inappropriate.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># define OUR_NET_IN_HEX 0x7b2d4300 /* 123.45.67.0 in hex */# define OUR_NETMASK 0xffffff00checkcompat(to, e)      register ADDRESS *to;      register ENVELOPE *e;{      if (tTd(49, 1))              printf(&quot;checkcompat(to=%s, from=%s)\n&quot;,                      to-&gt;q_paddr, e-&gt;e_from.q_paddr);      if (RealHostAddr.sa.sa_family == 0)      {              /* this is a locally submitted message */              return EX_OK;      }      if (RealHostAddr.sa.sa_family != AF_INET ||      (RealHostAddr.sin.sin_addr.s_addr &amp; OUR_NETMASK)!= OUR_NET_IN_HEX)      {<CODECLASS="userinput"><B>              usrerr(&quot;553 End run mail not allowed&quot;);</B></CODE><CODECLASS="userinput"><B>              e-&gt;e_flags |= EF_NO_BODY_RETN;</B></CODE><CODECLASS="userinput"><B>              to-&gt;q_status = &quot;5.7.1&quot;;</B></CODE><CODECLASS="userinput"><B>              return (EX_UNAVAILABLE);</B></CODE>      }      return (EX_OK);}</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16374"></A>The <CODECLASS="literal">usrerr</CODE>() routine (line <EMCLASS="emphasis">21</EM>)causes a warning to be printedat the sending site, and returning EX_UNAVAILABLE(line <EMCLASS="emphasis">24</EM>)causes the mail message to be bounced.Bounced mail is sent back to the originatingsender. A copy may also be sent to the local postmasterdepending on the setting of <CODECLASS="literal">PostmasterCopy</CODE> (<CODECLASS="literal">P</CODE>) option(see <ACLASS="xref"HREF="ch34_08.htm#SML2-CH-34-SECT-8-46"TITLE="">Section 34.8.46, PostmasterCopy (P)</A>).</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16383"></A>The EF_NO_BODY_RETN (line <EMCLASS="emphasis">22</EM>) causes only the headers from the messageto be returned in bounced mail, not the original message body.Other envelope flags of interest can be found in <ACLASS="xref"HREF="ch37_05.htm#SML2-CH-37-TAB-2"TITLE="Hexadecimal Envelope Flags">Table 37.3</A> of <ACLASS="xref"HREF="ch37_05.htm#SML2-CH-37-SECT-5-12"TITLE="">Section 37.5.12</A>.</P><PCLASS="para">The <CODECLASS="literal">to-&gt;q_status</CODE> (line <EMCLASS="emphasis">23</EM>)conveys the DSN error status inthe bounced mail message (see RFC1893).  Here, <CODECLASS="literal">5.7.1</CODE> indicatesa permanent failure (<CODECLASS="literal">5</CODE>) of policy status (<CODECLASS="literal">7</CODE>),where delivery is not authorized and the message is refused (<CODECLASS="literal">1</CODE>).</P><PCLASS="para">Also note that this code sample is only a suggestion. It doesn't take into accountthat <CODECLASS="literal">RealHostAddr</CODE> may contain <CODECLASS="literal">0x7f000001</CODE> (<EMCLASS="emphasis">127.0.0.1</EM> for <EMCLASS="emphasis">localhost</EM>).&#13;</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="SML2-CH-20-SECT-2-2">20.2.2 Workstation Refuses to Act as a Mail Gateway</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16403"></A><ACLASS="indexterm"NAME="AUTOID-16406"></A>If you've spent many months getting your workstation set upand running perfectly, you might not want outsiders usingit as a knowledgeable mail relay. One way to prevent suchunwanted use is to set up <EMCLASS="emphasis">checkcompat</EM>() in <EMCLASS="emphasis">conf.c</EM>so that it rejects any mail from outsideyour machine that is destined to another site outside your machine. <ACLASS="indexterm"NAME="AUTOID-16411"></A><ACLASS="indexterm"NAME="AUTOID-16413"></A>A desirable side effect is thatthis will also prevent outsiders from directly posting into yourinternal mailing lists.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">checkcompat(to, e)        register ADDRESS *to;        register ENVELOPE *e;{        if (tTd(49, 1))                printf(&quot;checkcompat(to=%s, from=%s)\n&quot;,                        to-&gt;q_paddr, e-&gt;e_from.q_paddr);        if (RealHostAddr.sa.sa_family == 0)        {                /* this is a locally submitted message */                return (EX_OK);        }        /* only accept local delivery from outside */<CODECLASS="userinput"><B>        if (!bitnset(M_LOCALMAILER, to-&gt;q_mailer-&gt;m_flags))</B></CODE>        {                usrerr(&quot;553 External gateway use prohibited&quot;);                e-&gt;e_flags |= EF_NO_BODY_RETN;                to-&gt;q_status = &quot;5.7.1&quot;;                return (EX_UNAVAILABLE);        }        return (EX_OK);}</PRE></BLOCKQUOTE></P><PCLASS="para">Although <CODECLASS="literal">to</CODE> (line <EMCLASS="emphasis">16</EM>) is really a linked listof recipients, we check only the current recipient to prevent spurious warnings.This is done because <EMCLASS="emphasis">checkcompat</EM>() is called once for <EMCLASS="emphasis">every</EM>recipient.The check in line <EMCLASS="emphasis">16</EM> is to see whether<CODECLASS="literal">F=l</CODE> delivery agent flag is not set (see <ACLASS="xref"HREF="ch30_08.htm#SML2-CH-30-SECT-8-28"TITLE="">Section 30.8.28, F=l (lowercase L)</A>)thus implying that the recipient is not local.</P><PCLASS="para">Note that this form of rejecting messages will <EMCLASS="emphasis">not</EM> work on a mail hub.In that case more sophisticated checks need to be made. Among them are the following:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Check all the IP domains for your site. If you have only one,the check in <ACLASS="xref"HREF="ch20_02.htm#SML2-CH-20-SECT-2-1"TITLE="Accept Mail Only From Our Domain">Section 20.2.1</A> will work. If you have several(as in an assortment of class <CODECLASS="literal">C</CODE> domains), the check will be morecomplex. If the connecting host is in your domain or one of your domains,you should accept the message.</P></LI><LICLASS="listitem"><PCLASS="para">The envelope sender's host (<CODECLASS="literal">e-&gt;e_from-&gt;q_host</CODE>) should be checked tosee whether it is in the class <CODECLASS="literal">$=w</CODE> (see <ACLASS="xref"HREF="ch32_05.htm#SML2-CH-32-SECT-5-8"TITLE="">Section 32.5.8, $=w</A>). Youcan use the <EMCLASS="emphasis">wordinclass</EM>() routine (see <ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-8"TITLE="">Section 20.3.8, wordinclass()</A>)to look it up. If it is in <CODECLASS="literal">$=w</CODE>, you should accept the message.This prevents a message from being forwarded through a workstation.</P></LI><LICLASS="listitem"><PCLASS="para">If the delivery agent for a recipient is <CODECLASS="literal">*include*</CODE>, the messageis destined for a mailing list. You might wish to screen further at thispoint.</P></LI></UL><PCLASS="para"></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="SML2-CH-20-SECT-2-3">20.2.3 Limit the Size of Guest Messages</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16449"></A><ACLASS="indexterm"NAME="AUTOID-16452"></A><ACLASS="indexterm"NAME="AUTOID-16455"></A>Suppose your site has reserved <EMCLASS="emphasis">uid</EM>s numbered from900 to 999 for guest users.Because guests are sometimes inconsiderate, youmight want to limit the size of their messages andthe number of simultaneous recipients they may specify.One way to do this is with the <EMCLASS="emphasis">checkcompat</EM>() routine:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#define MAXGUESTSIZE 8000#define MAXGUESTNRCP 4checkcompat(to, e)        register ADDRESS *to;        register ENVELOPE *e;{        if (tTd(49, 1))                printf(&quot;checkcompat(to=%s, from=%s)\n&quot;,                        to-&gt;q_paddr, e-&gt;e_from.q_paddr);        /* does q_uid contain a valid uid? - no external */<CODECLASS="userinput"><B>        if (! bitset(QGOODUID, e-&gt;e_from.q_flags))</B></CODE>                return (EX_OK);<CODECLASS="userinput"><B>        if (e-&gt;e_from.q_uid &lt; 900 || e-&gt;e_from.q_uid &gt; 999)</B></CODE>                return (EX_OK);        if (e-&gt;e_msgsize &gt; MAXGUESTSIZE)        {                syslog(LOG_NOTICE,                        &quot;Guest %s attempted to send %d size&quot;,                        e-&gt;e_from.q_user, e-&gt;e_msgsize);                usrerr(&quot;553 Message too large, %d max&quot;, MAXGUESTSIZE);<CODECLASS="userinput"><B>                e-&gt;e_flags |= EF_NO_BODY_RETN;</B></CODE>                to-&gt;q_status = &quot;5.7.1&quot;;                return (EX_UNAVAILABLE);        }        if (e-&gt;e_nrcpts &gt; MAXGUESTNRCP)        {                syslog(LOG_NOTICE,                        &quot;Guest %s attempted to send %d recipients&quot;,                        e-&gt;e_from.q_user, e-&gt;e_nrcpts);                usrerr(&quot;553 Too many recipients for guest, %d max&quot;,                        MAXGUESTNRCP);<CODECLASS="userinput"><B>                e-&gt;e_flags &amp;= ~EF_NO_BODY_RETN;</B></CODE>                to-&gt;q_status = &quot;5.7.1&quot;;                return (EX_UNAVAILABLE);        }        return (EX_OK);}</PRE></BLOCKQUOTE></P><PCLASS="para">Note that <CODECLASS="literal">q_uid</CODE> will have a valid <EMCLASS="emphasis">uid</EM> (QGOODUID will be set)only if the senderis local (line <EMCLASS="emphasis">14</EM>). For external mail coming in, QGOODUID will be clear.</P><PCLASS="para">Also note that we specifically do not return the message body (EF_NO_BODY_RETN)if the message was returned because it was too large (line <EMCLASS="emphasis">24</EM>).But we do return the message bodyif the message was rejected for too many recipients (line <EMCLASS="emphasis">35</EM>).Other envelope flags of interest can be found in<ACLASS="xref"HREF="ch37_05.htm#SML2-CH-37-TAB-2"TITLE="Hexadecimal Envelope Flags">Table 37.3</A> of <ACLASS="xref"HREF="ch37_05.htm#SML2-CH-37-SECT-5-12"TITLE="">Section 37.5.12</A>.&#13;</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="SML2-CH-20-SECT-2-4">20.2.4 Verify identd Information</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16477"></A><ACLASS="indexterm"NAME="AUTOID-16479"></A><ACLASS="indexterm"NAME="AUTOID-16482"></A>When an outside host connects to the local <EMCLASS="emphasis">sendmail</EM> via SMTP,its hostname is saved in the <CODECLASS="literal">$s</CODE> macro (see <ACLASS="xref"HREF="ch31_10.htm#SML2-CH-31-SECT-10-33"TITLE="">Section 31.10.33, $s</A>).If the <CODECLASS="literal">Timeout.ident</CODE> option (see <ACLASS="xref"HREF="ch34_08.htm#SML2-CH-34-SECT-8-70"TITLE="">Section 34.8.70, Timeout (r)</A>) is nonzero,<EMCLASS="emphasis">sendmail</EM> uses the RFC1413 identification protocol to record the identity of the host at the other end, that is, the identityof the host that made the connection.That identity is recorded in the <CODECLASS="literal">$_</CODE> macro (see <ACLASS="xref"HREF="ch31_10.htm#SML2-CH-31-SECT-10-1"TITLE="">Section 31.10.1, $-</A>).<ACLASS="indexterm"NAME="AUTOID-16493"></A><ACLASS="indexterm"NAME="AUTOID-16495"></A></P><PCLASS="para">If you are unusually picky about the identity of other hosts,you may wish to confirm that the host in <CODECLASS="literal">$s</CODE> isthe same as the host in <CODECLASS="literal">$_</CODE>. One way to performsuch a check is with the <EMCLASS="emphasis">checkcompat</EM>() routine:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">checkcompat(to, e)        register ADDRESS *to;        register ENVELOPE *e;{        char *s, *u, *v;        int len;        static char old_s[MAXHOSTNAMELEN];        if (tTd(49, 1))                printf(&quot;checkcompat(to=%s, from=%s)\n&quot;,                        to-&gt;q_paddr, e-&gt;e_from.q_paddr);        /* if $s is localhost or in $=w, accept it */        if ((s = macvalue('s', e)) == NULL)                return (EX_OK);<CODECLASS="userinput"><B>        if (strncasecmp(s, old_s, MAXHOSTNAMELEN-1) == 0)</B></CODE>                return (EX_OK);        else                (void)sprintf(old_s, &quot;%.*s&quot;, MAXHOSTNAMELEN-1, s);<CODECLASS="userinput"><B>        if (strcasecmp(s, &quot;localhost&quot;) == 0)</B></CODE>                return (EX_OK);<CODECLASS="userinput"><B>        if (wordinclass(s, 'w') == TRUE)</B></CODE>                return (EX_OK);        if ((u = macvalue('_', e)) == NULL)                return (EX_OK);        if ((u = strchr(u, '@')) == NULL)                return (EX_OK);        if ((v = strchr(u, ' ')) != NULL)                *v = ' ';        len = strlen(u);        if (v != NULL)                *v = ' ';<CODECLASS="userinput"><B>        if (strncasecmp(s, u, len) != 0)</B></CODE>        {<CODECLASS="userinput"><B>             auth_warning(e, &quot;$s=%s doesn't match $_=%.*s&quot;, s, len, u);</B></CODE>        }        return (EX_OK);}</PRE></BLOCKQUOTE></P><PCLASS="para">First (line <EMCLASS="emphasis">16</EM>) we check to see whether we have already checkedthis value of <CODECLASS="literal">$s</CODE>. If so, we don't check again because<EMCLASS="emphasis">checkcompat</EM>() is called once for each recipient. If <CODECLASS="literal">$s</CODE> isnew, we save a copy of its value for next time.</P><PCLASS="para">Then we make sure that the local host (nomatter what its name) is acceptable (lines <EMCLASS="emphasis">20</EM> and <EMCLASS="emphasis">22</EM>).If this is an offsite host,we compare the values of <CODECLASS="literal">$s</CODE> and the host part of <CODECLASS="literal">$_</CODE> (line <EMCLASS="emphasis">35</EM>).If they don't match, we insert an <CODECLASS="literal">X-Authentication-Warning:</CODE>header (line <EMCLASS="emphasis">37</EM>). This keeps such warnings under the control of the <CODECLASS="literal">PrivacyOptions.authwarnings</CODE> (<CODECLASS="literal">p</CODE>)option (see <ACLASS="xref"HREF="ch34_08.htm#SML2-CH-34-SECT-8-47"TITLE="">Section 34.8.47, PrivacyOptions (p)</A>).&#13;</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="SML2-CH-20-SECT-2-5">20.2.5 Prune Received: Headers at Firewall</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16529"></A><ACLASS="indexterm"NAME="AUTOID-16532"></A><ACLASS="indexterm"NAME="AUTOID-16535"></A>In routing mail outward from a firewall (see <ACLASS="xref"HREF="ch20_02.htm#SML2-CH-20-SECT-2-1"TITLE="Accept Mail Only From Our Domain">Section 20.2.1</A>),it may be advantageous toreplace all the internal <CODECLASS="literal">Received:</CODE> headers with one master header.<ACLASS="indexterm"NAME="AUTOID-16541"></A>A way to do this with <EMCLASS="emphasis">checkcompat</EM>() looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># define OUR_NET_IN_HEX 0x7b2d4300 /* 123.45.67.0 in hex */# define OUR_NETMASK 0xffffff00# define LOOP_CHECK &quot;X-Loop-Check&quot;checkcompat(to, e)        register ADDRESS *to;        register ENVELOPE *e;{        HDR *h;        int cnt;<CODECLASS="userinput"><B>        if (RealHostAddr.sa.sa_family == 0)</B></CODE>        {                /* this is a locally submitted message */                return EX_OK;        }<CODECLASS="userinput"><B>        if (RealHostAddr.sa.sa_family != AF_INET ||</B></CODE><CODECLASS="userinput"><B>        (RealHostAddr.sin.sin_addr.s_addr &amp; OUR_NETMASK) != OUR_NET_IN_HEX)</B></CODE>        {                /* not received from the internal network */                return EX_OK;        }<CODECLASS="userinput"><B>        if (hvalue(LOOP_CHECK, e-&gt;e_header) != NULL)</B></CODE>        {                /* We've stripped them once already */                return EX_OK;        }<CODECLASS="userinput"><B>        addheader(LOOP_CHECK, &quot;&quot;, &amp;e-&gt;e_header);</B></CODE><CODECLASS="userinput"><B>        for (cnt = 0, h = e-&gt;e_header; h != NULL; h = h-&gt;h_link)</B></CODE>        {<CODECLASS="userinput"><B>               if (strcasecmp(h-&gt;h_field, &quot;received&quot;) != 0)</B></CODE>                       continue;<CODECLASS="userinput"><B>               if (cnt++ == 0)</B></CODE>                       continue;<CODECLASS="userinput"><B>               clrbitmap(h-&gt;h_mflags);</B></CODE><CODECLASS="userinput"><B>               h-&gt;h_flags |= H_ACHECK;</B></CODE>        }        return (EX_OK);}</PRE></BLOCKQUOTE></P><PCLASS="para">Because we are stripping the message of <CODECLASS="literal">Received:</CODE> headers, we need to be careful.We shouldn't do it if the message originated on the firewall machine (line <EMCLASS="emphasis">12</EM>).We also shouldn't do it if the message originated from outside the internal (firewalled)network (lines <EMCLASS="emphasis">17</EM> and <EMCLASS="emphasis">18</EM>). To prevent possibly disastrous mail loops,we check for a special header (line <EMCLASS="emphasis">23</EM>) and skip stripping again if thatheader is found. We then add that special header (line <EMCLASS="emphasis">120</EM>), just in casethe mail flows though this firewall again.</P><PCLASS="para">If it is okay to do so, we scan all the headers (line <EMCLASS="emphasis">30</EM>) looking for all <CODECLASS="literal">Received:</CODE> headers (line <EMCLASS="emphasis">32</EM>).We skip deleting the first one because it was placed there by the firewall(line <EMCLASS="emphasis">34</EM>). We delete all the others by clearing their <CODECLASS="literal">?</CODE><CODECLASS="replaceable"><I>flags</I></CODE><CODECLASS="literal">?</CODE>bits (line <EMCLASS="emphasis">36</EM>) and setting the H_ACHECK flag (line <EMCLASS="emphasis">37</EM>).See <ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-3"TITLE="">Section 20.3.3, </A> for a general discussion of this technique.</P><PCLASS="para">Be aware that this is only one possible approach and that, depending onwhat other hosts on the Internet do to the message, this loop detection maybreak. A safer but more difficult approach is to rewrite the <CODECLASS="literal">Received:</CODE>headers themselves and to mask out sensitive information in them.&#13;</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="SML2-CH-20-SECT-2-6">20.2.6 Reject Mail from Spamming or Mail-bombing Sites</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16579"></A><ACLASS="indexterm"NAME="AUTOID-16581"></A><ACLASS="indexterm"NAME="AUTOID-16584"></A><ACLASS="indexterm"NAME="AUTOID-16587"></A><ACLASS="indexterm"NAME="AUTOID-16589"></A>As the Internet grows, your site may become more and more subject toadvertising and vengeful attacks from the outside. Advertising attacksare called &quot;spams&quot; and are symptomized by advertisers sending multiplecopies of advertisements through your internal mail lists or toseveral of your users. Vengeful attacks are called &quot;mail bombs&quot; and usually are detected by your mail spool directory filling witha huge number of messages from a single sender.[3]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] Often in response to one of your users sending an offensive spam.</P></BLOCKQUOTE><PCLASS="para">To limit your vulnerability to such events (and to others of a similarnature that may be invented in the future), you may screen mailfrom outside hosts using a combination of a database and <EMCLASS="emphasis">checkcompat</EM>().First we show you how to set up such a database, then we show you a <EMCLASS="emphasis">checkcompat</EM>()routine for using it.[4]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] You may also screen sender addresses at the SMTP MAIL commandwith the new V8.8 <CODECLASS="literal">check_mail</CODE> rule set (see <ACLASS="xref"HREF="ch29_10.htm#SML2-CH-29-SECT-10-1"TITLE="The check_mail Rule Set">Section 29.10.1, "The check_mail Rule Set"</A>).<ACLASS="indexterm"NAME="AUTOID-16601"></A><ACLASS="indexterm"NAME="AUTOID-16603"></A>Although it can be easier to design <CODECLASS="literal">check_mail</CODE> rules, the <EMCLASS="emphasis">checkcompat</EM>() routinecan be more powerful.</P></BLOCKQUOTE><PCLASS="para">The source file for the database will look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">user@spam.host      spamuser@bomb.host      bomb</PRE></BLOCKQUOTE></P><PCLASS="para">Here, each left-hand side entry is an email address with a user part,an <CODECLASS="literal">@</CODE>, and a host part. We will be screening on the basis of individualsender addresses rather than screening at a sitewide level. The right-hand side is eitherthe word <CODECLASS="literal">spam</CODE> to represent a spamming sender or <CODECLASS="literal">bomb</CODE>to represent a mail-bombing sender.</P><PCLASS="para">If the source file is called <EMCLASS="emphasis">/etc/mail/blockusers</EM>, the databasewill be created like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>makemap hash /etc/mail/blockusers.db &lt; /etc/mail/blockusers</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">Here, we create a <CODECLASS="literal">hash</CODE> <EMCLASS="emphasis">db</EM> style database. For other availablestyles, see <ACLASS="xref"HREF="ch33_02.htm"TITLE="Create Files with makemap">Section 33.2, "Create Files with makemap"</A>. </P><PCLASS="para">Once the database is in place, your configuration file needs to betold of its existence. To do that, we use the <CODECLASS="literal">K</CODE> configurationcommand (see <ACLASS="xref"HREF="ch33_03.htm"TITLE="The K Configuration Command">Section 33.3, "The K Configuration Command"</A>):</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Kbadusers hash -o /etc/mail/blockusers.db</PRE></BLOCKQUOTE></P><PCLASS="para">For the <EMCLASS="emphasis">m4</EM> configuration technique you would place thisdeclaration under the LOCAL_CONFIG line in your <EMCLASS="emphasis">mc</EM> file(see <ACLASS="xref"HREF="ch19_06.htm#SML2-CH-19-SECT-6-30"TITLE="">Section 19.6.30, LOCAL-CONFIG</A>).</P><PCLASS="para">&#13;One possible <EMCLASS="emphasis">checkcompat</EM>() routine to handle all this willlook like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">checkcompat(to, e)        register ADDRESS *to;        register ENVELOPE *e;{        STAB *map;        char *p;        int  ret = 0;<CODECLASS="userinput"><B>        map = stab(&quot;badusers&quot;, ST_MAP, ST_FIND);</B></CODE>        if (map == (STAB *)NULL)<CODECLASS="userinput"><B>                return (EX_OK);</B></CODE><CODECLASS="userinput"><B>        p = (*map-&gt;s_map.map_class-&gt;map_lookup)</B></CODE>                 (&amp;map-&gt;s_map, e-&gt;e_from.q_paddr, NULL, &amp;ret);        if (p == NULL)<CODECLASS="userinput"><B>                return (EX_OK);</B></CODE><CODECLASS="userinput"><B>        if (strcasecmp(p, &quot;spam&quot;) == 0)</B></CODE>        {<CODECLASS="userinput"><B>                usrerr(&quot;553 Spamming mail rejected from %s&quot;,</B></CODE>                        e-&gt;e_from.q_paddr);                to-&gt;q_status = &quot;5.7.1&quot;;                return (EX_UNAVAILABLE);        }<CODECLASS="userinput"><B>        if (strcasecmp(p, &quot;bomb&quot;) == 0)</B></CODE>        {                usrerr(&quot;553 Message rejected from mail-bomber %s&quot;,                        e-&gt;e_from.q_paddr);                e-&gt;e_flags &amp;= ~EF_NO_BODY_RETN;                to-&gt;q_status = &quot;5.7.1&quot;;                return (EX_UNAVAILABLE);        }        return (EX_OK);}</PRE></BLOCKQUOTE></P><PCLASS="para">Here we first look up the database named <CODECLASS="literal">badusers</CODE> in the symbol table(line <EMCLASS="emphasis">9</EM>). It is okay for the database not to exist (line <EMCLASS="emphasis">11</EM>).If the database exists, we look up the sender's address in it (line <EMCLASS="emphasis">12</EM>).If the address is not found, all is okay (line <EMCLASS="emphasis">15</EM>).</P><PCLASS="para">If the address was found in the database, we have a potential bad person. So we firstcheck to see whether the address was marked as a <CODECLASS="literal">spam</CODE> (line <EMCLASS="emphasis">17</EM>).If it was, we bounce it with an appropriate error message (line <EMCLASS="emphasis">19</EM>).</P><PCLASS="para">We also bounce the message if it is a mail bomb (line <EMCLASS="emphasis">24</EM>).This is fraught with risk however. The bounced mail can fill up the outgoingqueue, thereby accomplishing the bomber's ends in a different way.A better approach might be to drop the mail on the floor (see <EMCLASS="emphasis">dropenvelope</EM>()in <EMCLASS="emphasis">envelope.c</EM>), but we leave this as an exercise for the reader.&#13;</P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch20_01.htm"TITLE="20.1 How checkcompat() Works"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 20.1 How checkcompat() Works"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="sendmail"><IMGSRC="../gifs/txthome.gif"ALT="sendmail"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch20_03.htm"TITLE="20.3 Alphabetized V8.8 Subroutines"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 20.3 Alphabetized V8.8 Subroutines"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">20.1 How checkcompat() Works</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">20.3 Alphabetized V8.8 Subroutines</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>