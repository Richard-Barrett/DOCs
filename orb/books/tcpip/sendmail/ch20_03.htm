<HTML><HEAD><TITLE>[Chapter 20] 20.3 Alphabetized V8.8 Subroutines</TITLE><METANAME="DC.title"CONTENT="sendmail"><METANAME="DC.creator"CONTENT="Bryan Costales &amp; Eric Allman"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-01-06T19:25:21Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-222-0"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch20_01.htm"TITLE="20. The checkcompat() Cookbook"><LINKREL="prev"HREF="ch20_02.htm"TITLE="20.2 The Cookbook"><LINKREL="next"HREF="part03.htm"TITLE="III. Administration"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="sendmail"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="sendmail"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ssrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch20_02.htm"TITLE="20.2 The Cookbook"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 20.2 The Cookbook"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 20<BR>The checkcompat() Cookbook</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="PART"HREF="part03.htm"TITLE="III. Administration"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: III. Administration"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="SML2-CH-20-SECT-3">20.3 Alphabetized V8.8 Subroutines</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="SML2-CH-20-IX-CHECKCOMPAT-ROUTINE-SUBROUTINES-FOR"></A>Many subroutines inside <EMCLASS="emphasis">sendmail</EM> can be very useful inwriting your own <EMCLASS="emphasis">checkcompat</EM>() routine. Always try to use<EMCLASS="emphasis">sendmail</EM>'s internal routines rather than redesigning your own.Those supplied with <EMCLASS="emphasis">sendmail</EM> have already been screened and tested bya large body of skilled programmers.</P><PCLASS="para">In this section we list the ones that we consider most useful and describehow best to use them (see<ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-TAB-2"TITLE="Handy Subroutines for Use with checkcompat()">Table 20.3</A>).</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="SML2-CH-20-TAB-2">Table 20.3: Handy Subroutines for Use with checkcompat()</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Subroutine</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1"></TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Description</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">addheader</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-1"TITLE="">Section 20.3.1, addheader()</A></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Add a new header to the list of headers</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">define</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-2"TITLE="">Section 20.3.2, define()</A></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Define a macro</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-3"TITLE="">Section 20.3.3</A></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">How to remove a header</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">hvalue</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-4"TITLE="">Section 20.3.4, hvalue()</A></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Look up a header's field by name</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">macid</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-5"TITLE="">Section 20.3.5, macid()</A></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Convert a text string macro name into an integer</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">macvalue</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-6"TITLE="">Section 20.3.6, macvalue()</A></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Fetch a macro's value</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-&gt;map_lookup</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-7"TITLE="">Section 20.3.7, -&gt;map-lookup()</A></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Look up a key in an external database</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">wordinclass</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><ACLASS="xref"HREF="ch20_03.htm#SML2-CH-20-SECT-3-8"TITLE="">Section 20.3.8</A></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Look up a word in a class</TD></TR></TBODY></TABLE><PCLASS="para">Be aware that these subroutines are documented for V8.8 <EMCLASS="emphasis">sendmail</EM>.If you are using a different version of <EMCLASS="emphasis">sendmail</EM>, you must familiarizeyourself with the source before attempting to use them.Mismatched parameters can cause errors that are difficult to diagnose.</P><DIVCLASS="refentry"><DIVCLASS="refnamediv"><H3CLASS="refname"><ACLASS="refname"NAME="SML2-CH-20-SECT-3-1">20.3.1 addheader()</A></H3><PCLASS="refpurpose">Add a new header to the list of headers</P></DIV><BLOCKQUOTE><DIVCLASS="refsect1"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16730"></A><ACLASS="indexterm"NAME="AUTOID-16732"></A><ACLASS="indexterm"NAME="AUTOID-16735"></A>The <EMCLASS="emphasis">addheader</EM>() routine is used to add a new header tothe existing list of headers. Note that since it does not check for duplicates,you should screen for the existence of a header beforeadding it (unless it is okay for multiple headers to exist):</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">char value[MAXLINE];(void)sprintf(value, &quot;Screened by checkcompat() for %s&quot;, q_user);(void)addheader(<CODECLASS="userinput"><B>&quot;x-screened&quot;</B></CODE>, value, e-&gt;e_header);</PRE></BLOCKQUOTE></P><PCLASS="para">Memory for the name of the new header and its value are allocatedinternally by <EMCLASS="emphasis">addheader</EM>(), so automatic variables canbe safely passed. Note that the first argument to <EMCLASS="emphasis">addheader</EM>() (line <EMCLASS="emphasis">4</EM>)is the name of the header.If you accidentally include a colon in that argument,the name will be stored with that colon included, andlater the header name will be incorrectly emitted with two colons.</P><PCLASS="para">Note that <EMCLASS="emphasis">addheader</EM> does not check for the validity of itsarguments. If you pass it NULL or an illegal address, youmay cause <EMCLASS="emphasis">sendmail</EM> to core-dump and fail. You are dealingwith <EMCLASS="emphasis">sendmail</EM> internals here, so be very careful.</P></DIV></BLOCKQUOTE></DIV><DIVCLASS="refentry"><DIVCLASS="refnamediv"><H3CLASS="refname"><ACLASS="refname"NAME="SML2-CH-20-SECT-3-2">20.3.2 define()</A></H3><PCLASS="refpurpose">Define a macro</P></DIV><BLOCKQUOTE><DIVCLASS="refsect1"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16758"></A><ACLASS="indexterm"NAME="AUTOID-16760"></A><ACLASS="indexterm"NAME="AUTOID-16763"></A>Macros can be defined and redefined inside <EMCLASS="emphasis">checkcompat</EM>()using the <EMCLASS="emphasis">define</EM>() routine. It is called like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">define( <CODECLASS="replaceable"><I>macid</I></CODE>, <CODECLASS="replaceable"><I>value</I></CODE>, <CODECLASS="replaceable"><I>envel</I></CODE>);</PRE></BLOCKQUOTE></P><PCLASS="para">Here, <CODECLASS="replaceable"><I>macid</I></CODE> is the literal character in the caseof a single-character macro name (such as <CODECLASS="literal">'A'</CODE>) or theidentifying value for a multicharacter name (this latterbeing derived from a call to <EMCLASS="emphasis">macid</EM>().The <CODECLASS="replaceable"><I>value</I></CODE> is the value to be assigned to the macro. (Note that ifthe macro already has a value, that prior value is overwritten.)The <CODECLASS="replaceable"><I>envel</I></CODE> is a pointer to the envelope (in the caseof <EMCLASS="emphasis">checkcompat</EM>() it is <CODECLASS="literal">e</CODE>).</P><PCLASS="para">To illustrate, consider the following code fragment that assignsa new value to the macros <CODECLASS="literal">$A</CODE> and <CODECLASS="literal">${foo}</CODE>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int mid;/** A single-character name is given a value that is the address* of a character constant.*/define( 'A', &quot;some text as a value&quot;, e);/** A multi-character name is given a value that is in malloc()d* memory space.*/mid = macid(<CODECLASS="userinput"><B>&quot;{foo}&quot;</B></CODE>, NULL);define(mid, <CODECLASS="userinput"><B>newstr</B></CODE>(to-&gt;qpaddr), e);</PRE></BLOCKQUOTE></P><PCLASS="para">In both cases the <CODECLASS="replaceable"><I>value</I></CODE> stored is in permanent memory. Youmust not pass a pointer to automatic or volatile memory, because<EMCLASS="emphasis">define</EM>() just stores the pointer, it does not copy the value.[5]In the second example (line <EMCLASS="emphasis">18</EM>), memory is allocated for the string with<EMCLASS="emphasis">newstr</EM>(), another internal routine that allocates roomfor the string and the string's terminating zero, copies the stringinto that allocated space, and returns a pointer to the newlyallocated string. But be careful to keep track of what you aredoing. You can easily create a serious memory leak if you arecareless with <EMCLASS="emphasis">newstr</EM>().</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] Technically, you should not use a string constant becausestring constants are stored in read-only program space andoften may not be changed at runtime, for example, when a macro's value needs tobe later modified in place.</P></BLOCKQUOTE><PCLASS="para">The first argument to <EMCLASS="emphasis">wordinclass</EM>() (line <EMCLASS="emphasis">17</EM>) is a string that containsthe macro's literal name without a <CODECLASS="literal">$</CODE> prefix. For multicharacternames, the enclosing curly braces are mandatory(see <ACLASS="xref"HREF="ch31_04.htm#SML2-CH-31-SECT-4-2"TITLE="Multicharacter Names">Section 31.4.2, "Multicharacter Names"</A>).</P><PCLASS="para">See the <CODECLASS="literal">-d35</CODE> debugging switch (<ACLASS="xref"HREF="ch37_05.htm#SML2-CH-37-SECT-5-120"TITLE="">Section 37.5.120, -d35.9</A>)for a way to watch macros being defined and redefined. Also see<EMCLASS="emphasis">munchstring</EM>() in <EMCLASS="emphasis">readcf.c</EM> if you need to parse a macro'sliteral name from among other text.</P></DIV></BLOCKQUOTE></DIV><DIVCLASS="refentry"><DIVCLASS="refnamediv"><H3CLASS="refname"><ACLASS="refname"NAME="SML2-CH-20-SECT-3-3">20.3.3 </A></H3><PCLASS="refpurpose">How to remove a header</P></DIV><BLOCKQUOTE><DIVCLASS="refsect1"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16814"></A><ACLASS="indexterm"NAME="AUTOID-16817"></A><ACLASS="indexterm"NAME="AUTOID-16819"></A>The <EMCLASS="emphasis">sendmail</EM> program's internal routines cannot be used toremove a header from the linked list of headers,but you can preventone from being emitted into the delivered message by massagingits flags.</P><PCLASS="para">Consider the need to suppress custom <CODECLASS="literal">X-Accounting:</CODE> headers:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">HDR *h;<CODECLASS="userinput"><B>for (h = e-&gt;e_header; h != NULL; h = h-&gt;h_link)</B></CODE>{<CODECLASS="userinput"><B>       if (strcasecmp(h-&gt;h_field, &quot;x-accounting&quot;) != 0)</B></CODE>               continue;<CODECLASS="userinput"><B>       clrbitmap(h-&gt;h_mflags);</B></CODE><CODECLASS="userinput"><B>       h-&gt;h_flags |= H_ACHECK;</B></CODE>}</PRE></BLOCKQUOTE></P><PCLASS="para">Here, we have to manually scan the linked list of headers (line <EMCLASS="emphasis">3</EM>).When the one that is being sought is found(note that the check is not case sensitive, line <EMCLASS="emphasis">5</EM>)we delete it. This is doneby first zeroing all the <CODECLASS="literal">?</CODE><CODECLASS="replaceable"><I>flags</I></CODE><CODECLASS="literal">?</CODE> for theheader (line <EMCLASS="emphasis">7</EM>). Then we add the H_ACHECKflag (line <EMCLASS="emphasis">8</EM>) to ensure that the header will be skipped on delivery.See <ACLASS="xref"HREF="ch35_05.htm#SML2-CH-35-SECT-5-16"TITLE="Replacing Headers with H_ACHECK">Section 35.5.16, "Replacing Headers with H_ACHECK"</A> for a discussion of the effect ofthe H_ACHECK flag.</P></DIV></BLOCKQUOTE></DIV><DIVCLASS="refentry"><DIVCLASS="refnamediv"><H3CLASS="refname"><ACLASS="refname"NAME="SML2-CH-20-SECT-3-4">20.3.4 hvalue()</A></H3><PCLASS="refpurpose">Look up a header's field by name</P></DIV><BLOCKQUOTE><DIVCLASS="refsect1"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16847"></A><ACLASS="indexterm"NAME="AUTOID-16849"></A>The <EMCLASS="emphasis">hvalue</EM>() routine can be used to look up a header andoptionally change it, or insert it if it is missing. It is usedlike this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">char *field;<CODECLASS="userinput"><B>field = hvalue(&quot;message-id&quot;, e-&gt;e_header)</B></CODE>if (field == NULL){        /* No Message-ID: in the message, so insert one */}</PRE></BLOCKQUOTE></P><PCLASS="para">&#13;Note that the first argument to <EMCLASS="emphasis">hvalue</EM>() is the name of theheader being looked up (line <EMCLASS="emphasis">3</EM>), without a trailing colon. If you accidentallyinclude the colon, the lookup will always fail.</P><PCLASS="para">The <EMCLASS="emphasis">hvalue</EM>() routine returns a string that is the fieldof the header that is looked up (see <ACLASS="xref"HREF="ch35_03.htm"TITLE="Header Field Contents">Section 35.3, "Header Field Contents"</A>).If a particular header name can exist multiple times (such as<CODECLASS="literal">Received:</CODE>), <EMCLASS="emphasis">hvalue</EM>() will return the first instance.If you need to process all such headers, you will need to scan for them manually.</P></DIV></BLOCKQUOTE></DIV><DIVCLASS="refentry"><DIVCLASS="refnamediv"><H3CLASS="refname"><ACLASS="refname"NAME="SML2-CH-20-SECT-3-5">20.3.5 macid()</A></H3><PCLASS="refpurpose">Convert a text string macro name into an integer</P>(int)</DIV><BLOCKQUOTE><DIVCLASS="refsect1"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16872"></A><ACLASS="indexterm"NAME="AUTOID-16874"></A><ACLASS="indexterm"NAME="AUTOID-16877"></A><ACLASS="indexterm"NAME="AUTOID-16880"></A>Macros, class names, and rule-set names  can be single-character ormulticharacter in form. The <EMCLASS="emphasis">macid</EM>() routine convertsa macro's name from a text string form (literal form) intoan integer. The resulting integer can later be used byother routines such as <EMCLASS="emphasis">macvalue</EM>()and <EMCLASS="emphasis">wordinclass</EM>().</P><PCLASS="para">To illustrate, consider the names <CODECLASS="literal">A</CODE> and <CODECLASS="literal">{foo}</CODE>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int mid;mid = macid(&quot;<CODECLASS="userinput"><B>A</B></CODE>&quot;, NULL);mid = macid(&quot;<CODECLASS="userinput"><B>{foo}</B></CODE>&quot;, NULL);</PRE></BLOCKQUOTE></P><PCLASS="para">The first argument to <EMCLASS="emphasis">macid</EM>() must be a string that contains the name to beconverted. For a single-character name (line <EMCLASS="emphasis">3</EM>) the nameis converted to the character-constant value of the first letter(<CODECLASS="literal">&quot;A&quot;</CODE> becomes <CODECLASS="literal">'A'</CODE>). For a multicharacter name(line <EMCLASS="emphasis">5</EM>) the name must be enclosed in curly braces. The nameis converted to a unique integer value that is either new orone that was previously assigned by an earlier call to <EMCLASS="emphasis">macid</EM>().</P><PCLASS="para">The second argument to <EMCLASS="emphasis">macid</EM> is NULL in our examplesbecause the string in the first argument contained only a name.When other text might appear in the string you may pass a nonnullsecond argument:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="userinput"><B>char *str = &quot;localhost is ${lhost}, so there.&quot;;</B></CODE>char *cp, *ep;int mid;if ((cp = strchr(str, '$')) != NULL){        mid = macid( cp+1, <CODECLASS="userinput"><B>&amp;ep</B></CODE> );}</PRE></BLOCKQUOTE></P><PCLASS="para">The second argument (line <EMCLASS="emphasis">7</EM>) is the address of a character pointer.After the call to <EMCLASS="emphasis">macid</EM>() that character pointer (<CODECLASS="literal">ep</CODE>)contains the address of the first character following the name&nbsp;- thecomma in <CODECLASS="literal">str</CODE> (line <EMCLASS="emphasis">1</EM>).</P></DIV></BLOCKQUOTE></DIV><DIVCLASS="refentry"><DIVCLASS="refnamediv"><H3CLASS="refname"><ACLASS="refname"NAME="SML2-CH-20-SECT-3-6">20.3.6 macvalue()</A></H3><PCLASS="refpurpose">Fetch a macro's value</P></DIV><BLOCKQUOTE><DIVCLASS="refsect1"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16921"></A><ACLASS="indexterm"NAME="AUTOID-16923"></A>The value stored in a macro can be fetched with the <EMCLASS="emphasis">macvalue</EM>()routine. For example,</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">char *val;int mid;val = macvalue( '<CODECLASS="userinput"><B>A</B></CODE>', e);mid = macid( &quot;<CODECLASS="userinput"><B>{foo}</B></CODE>&quot;, NULL);<CODECLASS="userinput"><B>val</B></CODE> = macvalue( <CODECLASS="userinput"><B>mid</B></CODE>, e);</PRE></BLOCKQUOTE></P><PCLASS="para">The first example (line <EMCLASS="emphasis">4</EM>) shows <EMCLASS="emphasis">macvalue</EM>() being used to fetch thevalue stored in a single-character macro name (<CODECLASS="literal">A</CODE>). Thesecond (line <EMCLASS="emphasis">6</EM>) shows a technique that is useful for multicharacter names andfor times when you must process an arbitrary name in a string.The <EMCLASS="emphasis">macid</EM>() routine converts a macro's literal name intoan identifying integer. That integer is then looked up with<EMCLASS="emphasis">macvalue</EM>() to return its value (line <EMCLASS="emphasis">7</EM>).</P><PCLASS="para">If the looked up macro is not defined, <EMCLASS="emphasis">macvalue</EM>() returnsNULL.</P></DIV></BLOCKQUOTE></DIV><DIVCLASS="refentry"><DIVCLASS="refnamediv"><H3CLASS="refname"><ACLASS="refname"NAME="SML2-CH-20-SECT-3-7">20.3.7 -&gt;map-lookup()</A></H3><PCLASS="refpurpose">Look up a key in an external database</P></DIV><BLOCKQUOTE><DIVCLASS="refsect1"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16951"></A><ACLASS="indexterm"NAME="AUTOID-16953"></A><ACLASS="indexterm"NAME="AUTOID-16956"></A><ACLASS="indexterm"NAME="AUTOID-16959"></A>Arbitrary keys can be looked up in external databases by using theroutines that are indirectly set up when a database is declared.For example, consider a <EMCLASS="emphasis">dbm</EM> database that will storelogin names as the keys and the words <CODECLASS="literal">ok</CODE> or <CODECLASS="literal">drop</CODE>as the values. You would first create a source text file withthe <EMCLASS="emphasis">makemap</EM> program (see <ACLASS="xref"HREF="ch33_02.htm"TITLE="Create Files with makemap">Section 33.2</A>). Next youwould declare that database in the configuration file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Kbouncelist dbm -o /etc/bouncelist</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16969"></A>This <CODECLASS="literal">K</CODE> configuration command (see <ACLASS="xref"HREF="ch33_03.htm"TITLE="The K Configuration Command">Section 33.3</A>)gives the internal symbolic name <CODECLASS="literal">bouncelist</CODE> to the database.</P><PCLASS="para">Values can now be looked up using the following code fragment:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">STAB *map;char *p;int  r = 0;map = stab(&quot;bouncelist&quot;, ST_MAP, ST_FIND);if (map == (STAB *)NULL)        return (EX_OK);p = (*map-&gt;s_map.map_class<CODECLASS="userinput"><B>-&gt;map_lookup</B></CODE>)(&amp;map-&gt;s_map, to-&gt;q_ruser, NULL, &amp;r);if (p == NULL)        return (EX_OK);if (strcasecmp(p, &quot;drop&quot;) == 0)        /* drop the message on the floor */</PRE></BLOCKQUOTE></P><PCLASS="para">The lookup is performed by calling the addresses stored in<CODECLASS="literal">map_lookup</CODE> (line <EMCLASS="emphasis">8</EM>). The second argument is the key that is being looked up(here, we use <CODECLASS="literal">to-&gt;q_ruser</CODE>, the login name of the recipientas the key).</P><PCLASS="para">Errors are returned in <CODECLASS="literal">r</CODE>. We ignore those errors here,but you can use them if you wish. They correspond tothe error values listed in <EMCLASS="emphasis">&lt;sysexits.h&gt;</EM>. But note thatnot all lookups change <CODECLASS="literal">r</CODE> (see <EMCLASS="emphasis">map.c</EM> forspecific details).</P></DIV></BLOCKQUOTE></DIV><DIVCLASS="refentry"><DIVCLASS="refnamediv"><H3CLASS="refname"><ACLASS="refname"NAME="SML2-CH-20-SECT-3-8">20.3.8 wordinclass()</A></H3><PCLASS="refpurpose">Look up a word in a class</P>(bool)</DIV><BLOCKQUOTE><DIVCLASS="refsect1"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16995"></A><ACLASS="indexterm"NAME="AUTOID-16997"></A>The words that form a class (see <ACLASS="xref"HREF="ch32_01.htm#SML2-CH-32-SECT-1-1"TITLE="The C Class Command">Section 32.1.1, "The C Class Command"</A>) are stored as symbolsin the symbol table (see <ACLASS="xref"HREF="ch32_02.htm#SML2-CH-32-SECT-2-4"TITLE="Class Name Hashing Algorithm">Section 32.2.4, "Class Name Hashing Algorithm"</A>). The check to seewhether a string of text was included in a given class is done with the<EMCLASS="emphasis">wordinclass</EM>() routine. Single-character class names andmulticharacter class names can be searched:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">int mid;if (wordinclass( &quot;localhost&quot;, <CODECLASS="userinput"><B>'w'</B></CODE>) == TRUE)        /* yes, it was found */mid = macid(&quot;{foo}&quot;, NULL);if (wordinclass( &quot;localhost&quot;, <CODECLASS="userinput"><B>mid</B></CODE>) == FALSE)        /* no, not found */</PRE></BLOCKQUOTE></P><PCLASS="para">The first argument to <EMCLASS="emphasis">macid</EM> is a string that containsthe word being looked up. Care must be taken to ensure thatthe first argument is a legal address and not NULLbecause <EMCLASS="emphasis">wordinclass</EM>() does not check.</P><PCLASS="para">The second argument is either an integer character-constant (such asthe <CODECLASS="literal">'w'</CODE>, line <EMCLASS="emphasis">3</EM>), or an integer identifier returned by <EMCLASS="emphasis">macid</EM>()(line <EMCLASS="emphasis">7</EM>).<ACLASS="indexterm"NAME="AUTOID-17015"></A><ACLASS="indexterm"NAME="AUTOID-17016"></A></P></DIV></BLOCKQUOTE></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch20_02.htm"TITLE="20.2 The Cookbook"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 20.2 The Cookbook"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="sendmail"><IMGSRC="../gifs/txthome.gif"ALT="sendmail"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="PART"HREF="part03.htm"TITLE="III. Administration"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: III. Administration"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">20.2 The Cookbook</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">III. Administration</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="../tcpip/index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>