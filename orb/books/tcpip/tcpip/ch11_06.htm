<HTML><HEAD><TITLE>[Chapter 11] 11.6 Checking Name Service </TITLE><METANAME="DC.title"CONTENT="TCP/IP Network Administration"><METANAME="DC.creator"CONTENT="Craig Hunt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1999-02-04T01:40:49Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-322-7"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch11_01.htm"TITLE="11. Troubleshooting TCP/IP "><LINKREL="prev"HREF="ch11_05.htm"TITLE="11.5 Checking Routing "><LINKREL="next"HREF="ch11_07.htm"TITLE="11.7 Analyzing Protocol Problems "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="TCP/IP Network Administration"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="TCP/IP Network Administration"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/tsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_05.htm"TITLE="11.5 Checking Routing "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 11.5 Checking Routing "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 11<BR>Troubleshooting TCP/IP </FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_07.htm"TITLE="11.7 Analyzing Protocol Problems "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 11.7 Analyzing Protocol Problems "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="TCP2-CH-11-SECT-6">11.6 Checking Name Service </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="TCP2-CH-11-IX-TROUBLESHOOTING-NAME-SERVICE"></A><ACLASS="indexterm"NAME="TCP2-CH-11-IX-NAME-SERVER-NS-TROUBLESHOOTING"></A><ACLASS="indexterm"NAME="AUTOID-16098"></A>Name server problems are indicated when the &quot;unknown host&quot; errormessage is returned by the user's application. Name server problemscan usually be diagnosed with <BCLASS="emphasis.bold">nslookup</B> or <BCLASS="emphasis.bold">dig</B>.<BCLASS="emphasis.bold">nslookup</B> is discussed in detail in <ACLASS="xref"HREF="ch08_01.htm"TITLE="Configuring DNS Name Service ">Chapter 8</A>. <BCLASS="emphasis.bold">dig</B> is analternative tool with similar functionality that is discussed in thischapter. Before looking at <BCLASS="emphasis.bold">dig</B>, let's take another look at<BCLASS="emphasis.bold">nslookup</B> and see how it is used to troubleshoot name service.</P><PCLASS="para"><ACLASS="indexterm"NAME="TCP2-CH-11-IX-NSLOOKUP-IN-TROUBLESHOOTING-TROUBLESHOOTING"></A>The three features of <BCLASS="emphasis.bold">nslookup</B> covered in <ACLASS="xref"HREF="ch08_01.htm"TITLE="Configuring DNS Name Service ">Chapter 8</A> areparticularly important for troubleshooting remote name serverproblems. These features are its ability to:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16116"></A>Locate the authoritative servers for the remote domainusing the NS query</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16120"></A>Obtain all records about the remote host using the ANYquery</P></LI><LICLASS="listitem"><PCLASS="para">Browse all entries in the remote zone using<BCLASS="emphasis.bold">nslookup</B>'s <BCLASS="emphasis.bold">ls</B> and <BCLASS="emphasis.bold">view</B> commands</P></LI></UL><PCLASS="para">When troubleshooting a remote server problem, directly query theauthoritative servers returned by the NS query. Don't rely oninformation returned by non-authoritative servers. If the problemsthat have been reported are intermittent, query all of theauthoritative servers in turn and compare their answers. Intermittentname server problems are sometimes caused by the remote serversreturning different answers to the same query.</P><PCLASS="para">The ANY query returns all records about a host, thus giving thebroadest range of troubleshooting information. Simply knowing whatinformation is (and isn't) available can solve a lot of problems. Forexample, if the query returns an MX record but no A record, it is easyto understand why the user couldn't <BCLASS="emphasis.bold">telnet</B> to that host! Manyhosts are accessible to mail that are not accessible by other networkservices. In this case, the user is confused and is trying to use theremote host in an inappropriate manner.</P><PCLASS="para">If you are unable to locate any information about the hostname thatthe user gave you, perhaps the hostname is incorrect. Given that thehostname you have is wrong, looking for the correct name is liketrying to find a needle in a haystack. However,<ACLASS="indexterm"NAME="AUTOID-16131"></A><BCLASS="emphasis.bold">nslookup</B> can help. Use <BCLASS="emphasis.bold">nslookup</B>'s <BCLASS="emphasis.bold">ls</B> command to dumpthe remote zone file, and redirect the listing to a file. Then use<ACLASS="indexterm"NAME="AUTOID-16136"></A><BCLASS="emphasis.bold">nslookup</B>'s <BCLASS="emphasis.bold">view</B> command to browse through the file, lookingfor names similar to the one the user supplied. Many problems arecaused by a mistaken hostname.</P><PCLASS="para">All of the <BCLASS="emphasis.bold">nslookup</B> features and commands mentioned here areused in <ACLASS="xref"HREF="ch08_01.htm"TITLE="Configuring DNS Name Service ">Chapter 8</A>. However, some examples using these commands tosolve real name server problems will be helpful. The three examplesthat follow are based on actual trouble reports.[7]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] The host and server names are fictitious, but the problems werereal.</P></BLOCKQUOTE><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="TCP2-CH-11-SECT-6.0.1">11.6.1 Some systems work, others don't </A></H3><PCLASS="para">A user reported that she could resolve a certain hostname from herworkstation, but could not resolve the same hostname from the centralsystem. However, the central system could resolve other hostnames. Weran several tests and found that we could resolve the hostname on somesystems and not on others. There seemed to be no predictable patternto the failure. So we used <BCLASS="emphasis.bold">nslookup</B> to check the remoteservers.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>nslookup</B></CODE>Default Server:  almond.nuts.comAddress:  172.16.12.1&gt; <CODECLASS="userinput"><B>set type=NS</B></CODE>&gt; <CODECLASS="userinput"><B>foo.edu.</B></CODE>Server:  almond.nuts.comAddress:  172.16.12.1foo.edu        nameserver = gerbil.foo.edufoo.edu        nameserver = red.big.comfoo.edu        nameserver = shrew.foo.edugerbil.foo.edu   inet address = 198.97.99.2red.big.com   inet address = 184.6.16.2shrew.foo.edu    inet address = 198.97.99.1&gt; <CODECLASS="userinput"><B>set type=ANY</B></CODE>&gt; <CODECLASS="userinput"><B>server gerbil.foo.edu</B></CODE>Default Server:  gerbil.foo.eduAddress:  198.97.99.2&gt; <CODECLASS="userinput"><B>hamster.foo.edu</B></CODE>Server:  gerbil.foo.eduAddress:  198.97.99.2hamster.foo.edu        inet address = 198.97.99.8&gt; <CODECLASS="userinput"><B>server red.big.com</B></CODE>Default Server:  red.big.comAddress:  184.6.16.2&gt; <CODECLASS="userinput"><B>hamster.foo.edu</B></CODE>Server:  red.big.comAddress:  184.6.16.2* red.big.com can't find hamster.foo.edu: Non-existent domain</PRE></BLOCKQUOTE></P><PCLASS="para">This sample <BCLASS="emphasis.bold">nslookup</B> session contains several steps.The first step is to locate the authoritative servers for the hostname in question (<EMCLASS="emphasis">hamster.foo.edu</EM>). We set the query type to NSto get the name server records, and query for the domain(<EMCLASS="emphasis">foo.edu</EM>) in which the hostname is found. This returns threenames of authoritative servers: <EMCLASS="emphasis">gerbil.foo.edu</EM>, <EMCLASS="emphasis">red.big.com</EM>,and <EMCLASS="emphasis">shrew.foo.edu</EM>.</P><PCLASS="para">Next, we set the query type to ANY to look for any records related tothe hostname in question. Then we set the server to the first serverin the list, <EMCLASS="emphasis">gerbil.foo.edu</EM>, and query for<EMCLASS="emphasis">hamster.foo.edu</EM>.  This returns an address record. So server<EMCLASS="emphasis">gerbil.foo.edu</EM> works fine. We repeat the test using<EMCLASS="emphasis">red.big.com</EM> as the server, and it fails. No records arereturned.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16172"></A>The next step is to get SOA records from each server and see if they are the same:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">&gt; <CODECLASS="userinput"><B>set type=SOA</B></CODE>&gt; <CODECLASS="userinput"><B>foo.edu.</B></CODE>Server:  red.big.comAddress:  184.6.16.2foo.edu        origin = gerbil.foo.edu	mail addr = amanda.gerbil.foo.edu	serial=10164, refresh=43200, retry=3600, expire=3600000,	min=2592000&gt; <CODECLASS="userinput"><B>server gerbil.foo.edu</B></CODE>Default Server:  gerbil.foo.eduAddress:  198.97.99.2&gt; <CODECLASS="userinput"><B>foo.edu.</B></CODE>Server:  gerbil.foo.eduAddress:  198.97.99.2foo.edu        origin = gerbil.foo.edu	mail addr = amanda.gerbil.foo.edu	serial=10164, refresh=43200, retry=3600, expire=3600000,	min=2592000&gt; <CODECLASS="userinput"><B>exit</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">If the SOA records have different serial numbers, perhaps the zonefile, and therefore the hostname, has not yet been downloaded to thesecondary server. If the serial numbers are the same and the data isdifferent, as in this case,there is a definite problem. Contact the remote domain administratorand notify her of the problem. The administrator'smailing address is shown in the &quot;mail addr&quot; field of the SOA record.In our example,we would send mail to <EMCLASS="emphasis">amanda@gerbil.foo.edu</EM> reportingthe problem.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="TCP2-CH-11-SECT-6.0.2">11.6.2 The data is here and the server can't find it! </A></H3><PCLASS="para">This problem was reported by the administrator of one of our secondaryname servers. The administrator reported that his server could notresolve a certain hostname in a domain for which his server was asecondary server. The primary server was, however, able to resolve thename. The administrator dumped his cache (more on dumping the server<ACLASS="indexterm"NAME="AUTOID-16186"></A>cache in the next section), and he could see in the dump that hisserver had the correct entry for the host. But his server still wouldnot resolve that hostname to an IP address!</P><PCLASS="para">The problem was replicated on several other secondary servers. Theprimary server would resolve the name; the secondary servers wouldn't.All servers had the same SOA serial number, and a dump of the cache oneach server showed that they all had the correct address records forthe hostname in question. So why wouldn't they resolve the hostnameto an address?</P><PCLASS="para">Visualizing the difference between the way primary and secondaryservers load theirdata made us suspicious ofthe zone file transfer. Primary servers load the data directly fromlocal disk files. Secondary servers transfer the data from the primaryserver via a zone file transfer. Perhaps the zone files were gettingcorrupted. We displayed the zone file on one of the secondary servers,and it showed the following data:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cat /usr/etc/sales.nuts.com.hosts</B></CODE>PCpma      IN   A   172.16.64.159      IN   HINFO   &quot;pc&quot; &quot;n3/800salesnutscom&quot;PCrkc      IN   A   172.16.64.155      IN   HINFO   &quot;pc&quot; &quot;n3/800salesnutscom&quot;PCafc      IN   A   172.16.64.189      IN   HINFO   &quot;pc&quot; &quot;n3/800salesnutscom&quot;accu      IN   A   172.16.65.27cmgds1   IN   A   172.16.130.40cmg      IN   A   172.16.130.30PCgns      IN   A   172.16.64.167      IN   HINFO   &quot;pc&quot; &quot;(3/800salesnutscom&quot;gw      IN   A   172.16.65.254zephyr   IN   A   172.16.64.188      IN   HINFO   &quot;Sun&quot; &quot;sparcstation&quot;ejw      IN   A   172.16.65.17PCecp      IN   A   172.16.64.193      IN   HINFO   &quot;pc&quot; &quot;nLsparcstationstcom&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">Notice the odd display in the last field of the HINFO statement foreach PC.[8]This data might have been corrupted in the transfer or itmight be bad on the primary server. We used <BCLASS="emphasis.bold">nslookup</B> to checkthat.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] See <ACLASS="xref"HREF="appd_01.htm"TITLE="A dhcpd Reference">Appendix D, <CITECLASS="appendix">A dhcpd Reference</CITE></A>, for a detailed description of the HINFO statement.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>nslookup</B></CODE>Default Server:  almond.nuts.comAddress:  172.16.12.1&gt; <CODECLASS="userinput"><B>server acorn.sales.nuts.com</B></CODE>Default Server:  acorn.sales.nuts.comAddress:  172.16.6.1&gt; <CODECLASS="userinput"><B>set query=HINFO</B></CODE>&gt; <CODECLASS="userinput"><B>PCwlg.sales.nuts.com</B></CODE>Server:  acorn.sales.nuts.comAddress:  172.16.6.1PCwlg.sales.nuts.com     CPU=pc  OS=ovpacket size error (0xf7fff590 != 0xf7fff528)&gt; <CODECLASS="userinput"><B>exit</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">In this <BCLASS="emphasis.bold">nslookup</B> example, we set the server to<EMCLASS="emphasis">acorn.sales.nuts.com</EM>, which is the primary server for<ACLASS="indexterm"NAME="AUTOID-16209"></A><EMCLASS="emphasis">sales.nuts.com</EM>. Next we queried for the HINFO record for one ofthe hosts that appeared to have a corrupted record. The &quot;packet sizeerror&quot; message clearly indicates that <BCLASS="emphasis.bold">nslookup</B> was even havingtrouble retrieving the HINFO record directly from the primary server.We contacted the administrator of the primary server and told him aboutthe problem, pointing out the records that appeared to be in error. Hediscovered that he had forgotten to put an operating system entry onsome of the HINFO records. He corrected this, and it fixed theproblem.<ACLASS="indexterm"NAME="AUTOID-16213"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="TCP2-CH-11-SECT-6.0.3">11.6.3 Cache corruption </A></H3><PCLASS="para">The problem described above was caused by having the name server cache<ACLASS="indexterm"NAME="AUTOID-16217"></A>corrupted by bad data. Cache corruption can occur even if your systemis not a secondary server. Sometimes the root server entries in thecache become corrupted. Dumping the cache can help diagnose thesetypes of problems.</P><PCLASS="para">For example, a user reported intermittent name server failures. Shehad no trouble with any hostnames within the local domain, or withsome names outside the local domain, but names in several differentremote domains would not resolve. <BCLASS="emphasis.bold">nslookup</B> tests produced nosolid clues, so the name server cache was dumped and examined for<ACLASS="indexterm"NAME="AUTOID-16222"></A>problems. The root server entries were corrupted, so <BCLASS="emphasis.bold">named</B> wasreloaded to clear the cache and reread the <EMCLASS="emphasis">named.ca</EM> file.Here's how it was done.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16229"></A>The SIGINT signal causes <BCLASS="emphasis.bold">named</B> to dump the name server cache tothe file <EMCLASS="emphasis">/var/tmp/named_dump.db</EM>. The following command passes<BCLASS="emphasis.bold">named</B> this signal:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <CODECLASS="userinput"><B>kill -INT `cat /etc/named.pid`</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16238"></A><ACLASS="indexterm"NAME="AUTOID-16240"></A>The process ID of <BCLASS="emphasis.bold">named</B> can be obtained from<EMCLASS="emphasis">/etc/named.pid</EM>, as in the example above, because <BCLASS="emphasis.bold">named</B>writes its process ID in that file during startup.[9]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] On our Linux system the process ID is written to <EMCLASS="emphasis">/var/run/named.pid</EM>.</P></BLOCKQUOTE><PCLASS="para">Once SIGINT causes <BCLASS="emphasis.bold">named</B> to snapshot its cache to the file, wecan then examine thefirst part of the file to see if the names andaddresses of the root servers are correct. For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <CODECLASS="userinput"><B>head -10 /var/tmp/named_dump.db</B></CODE>; Dumped at Wed Sep 18 08:45:58 1991; --- Cache &amp; Data ---$ORIGIN ..       80805   IN      SOA     NS.NIC.DDN.MIL. HOSTMASTER.NIC.DDN.MIL.		( 910909 10800 900 604800 86400 )        479912  IN      NS      NS.NIC.DDN.MIL.        479912  IN      NS      AOS.BRL.MIL.        479912  IN      NS      A.ISI.EDU.        479912  IN      NS      C.NYSER.NET.        479912  IN      NS      TERP.UMD.EDU.</PRE></BLOCKQUOTE></P><PCLASS="para">The cache shown above is clean. If intermittent name server problemslead you to suspect a cache corruption problem, examine the cache andcheck the names and addresses of all the root servers. The following symptomsmight indicate a problem with the root server cache:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16258"></A><ACLASS="indexterm"NAME="AUTOID-16260"></A>Incorrect root server names. The section on <EMCLASS="emphasis">/etc/named.ca</EM> in<ACLASS="xref"HREF="ch08_01.htm"TITLE="Configuring DNS Name Service ">Chapter 8</A> explains how you can locate the correct root server names.The easiest way to do this is to get the file<ACLASS="indexterm"NAME="AUTOID-16265"></A><ACLASS="indexterm"NAME="AUTOID-16267"></A><EMCLASS="emphasis">domain/named.root</EM> from the InterNIC.</P></LI><LICLASS="listitem"><PCLASS="para">No address or an incorrect address for any of the servers. Again, thecorrect addresses are in <EMCLASS="emphasis">domain/named.root</EM>.</P></LI><LICLASS="listitem"><PCLASS="para">A name other than root (<CODECLASS="literal">.</CODE>) in the name field of the first rootserver NS record, or the wildcard character (<CODECLASS="literal">*</CODE>) occurring inthe name field of a root or top-level name server. The structure of NSrecords is described in <ACLASS="xref"HREF="appd_01.htm"TITLE="A dhcpd Reference">Appendix D</A>.</P></LI></UL><PCLASS="para">A &quot;bad cache&quot; with multiple errors might look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <CODECLASS="userinput"><B>head -10 /var/tmp/named_dump.db</B></CODE>; Dumped at Wed Sep 18 08:45:58 1991; --- Cache &amp; Data ---$ORIGIN .arpa   80805   IN     SOA    SRI-NIC.ARPA.  HOSTMASTER.SRI-NIC.ARPA.		( 910909 10800 900 604800 86400 )       479912  IN     NS     NS.NIC.DDN.MIL.       479912  IN     NS     AOS.BRL.MIL.       479912  IN     NS     A.ISI.EDU.       479912  IN     NS     C.NYSER.NET.       479912  IN     NS     TERP.UMD.EDU.*      479912  IN     NS     NS.FOO.MIL.</PRE></BLOCKQUOTE></P><PCLASS="para">This contrived example has three glaring errors. The &quot;arpa&quot; entry inthe first field of the SOA record is invalid, and is the most infamousform of cache corruption. The last NS record is also invalid.NS.FOO.MIL. is not a valid root server, and an asterisk (<CODECLASS="literal">*</CODE>) inthe first field of a root server record is not normal.</P><PCLASS="para">If you see problems like these, force <BCLASS="emphasis.bold">named</B> to reload its cachewith the SIGHUP signal as shown below:<ACLASS="indexterm"NAME="AUTOID-16286"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <CODECLASS="userinput"><B>kill -HUP `cat /etc/named.pid`</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">This clears the cache and reloads the valid root server entries fromyour <EMCLASS="emphasis">named.ca</EM> file.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-16294"></A><ACLASS="indexterm"NAME="AUTOID-16296"></A><ACLASS="indexterm"NAME="AUTOID-16298"></A>If you know which system is corrupting your cache, instruct your systemto ignore updates from the culprit by using the <BCLASS="emphasis.bold">bogusns</B> statementin the <EMCLASS="emphasis">/etc/named.boot</EM> file. The <BCLASS="emphasis.bold">bogusns</B> statement liststhe IP addresses of name servers whose information cannot be trusted.For example, in the previous section we described a problem where<EMCLASS="emphasis">acorn.sales.nuts.com</EM> (172.16.16.1) was causing cache corruptionwith improperly formatted HINFO records. The following entry in the<EMCLASS="emphasis">named.boot</EM> file blocks queries to <EMCLASS="emphasis">acorn.sales.nuts.com</EM> andthus blocks the cache corruption:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">bogusns 172.16.16.1</PRE></BLOCKQUOTE></P><PCLASS="para">The <BCLASS="emphasis.bold">bogusns</B> entry is only a temporary measure. It is designed tokeep things running while the remote domain administrator has a chanceto diagnose and repair the problem. Once the remote system is fixed,remove the <BCLASS="emphasis.bold">bogusns</B> entry from <EMCLASS="emphasis">named.boot</EM>.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="TCP2-CH-11-SECT-6.1">11.6.4 dig: An Alternative to nslookup </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="TCP2-CH-11-IX-DIG"></A>An alternative to <BCLASS="emphasis.bold">nslookup</B> for making name service queries is<BCLASS="emphasis.bold">dig</B>. <BCLASS="emphasis.bold">dig</B> queries are usually entered as single-linecommands, while <BCLASS="emphasis.bold">nslookup</B> is usually run as an interactivesession. But the <BCLASS="emphasis.bold">dig</B> command performs essentially the samefunction as <BCLASS="emphasis.bold">nslookup</B>. Which you use is mostly a matter ofpersonal choice. They both work well.</P><PCLASS="para">As an example, we'll use <BCLASS="emphasis.bold">dig</B> to ask the root server<EMCLASS="emphasis">terp.umd.edu</EM> for the NS records for the <EMCLASS="emphasis">mit.edu</EM> domain. Todo this, enter the following command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>dig @terp.umd.edu mit.edu ns</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">In this example, <EMCLASS="emphasis">@terp.umd.edu</EM> is the server that is beingqueried. The server can be identified by name or IP address. Ifyou're troubleshooting a problem in a remote domain, specify anauthoritative server for that domain. In this example we're asking forthe names of servers for a top-level domain (<EMCLASS="emphasis">mit.edu</EM>), so we aska root server.</P><PCLASS="para">If you don't specify a server explicitly, <BCLASS="emphasis.bold">dig</B> uses the local nameserver, or the name server defined in the <EMCLASS="emphasis">/etc/resolv.conf</EM> file.<ACLASS="indexterm"NAME="AUTOID-16337"></A><ACLASS="indexterm"NAME="AUTOID-16339"></A>(<ACLASS="xref"HREF="ch08_01.htm"TITLE="Configuring DNS Name Service ">Chapter 8</A> describes <EMCLASS="emphasis">resolv.conf</EM>.)   Optionally,<ACLASS="indexterm"NAME="AUTOID-16344"></A>you can set the environment variable LOCALRES to the name of analternate <EMCLASS="emphasis">resolv.conf</EM> file. This alternate file will then beused in place of <EMCLASS="emphasis">/etc/resolv.conf</EM> for <BCLASS="emphasis.bold">dig</B>queries. Setting the LOCALRES variable will only affect <BCLASS="emphasis.bold">dig</B>.Other programs that use name service will continue to use<EMCLASS="emphasis">/etc/resolv.conf</EM>.</P><PCLASS="para">The last item on our sample command line is <EMCLASS="emphasis">ns</EM>. This is the querytype. A query type is a value that requests a specific type of DNSinformation. It is similar to the value used in <BCLASS="emphasis.bold">nslookup</B>'s<ACLASS="indexterm"NAME="AUTOID-16354"></A><ACLASS="indexterm"NAME="AUTOID-16356"></A><BCLASS="emphasis.bold">set type</B> command. <ACLASS="xref"HREF="ch11_06.htm#TCP2-CH-11-TAB-0"TITLE="dig Query Types">Table 11.1</A>shows the possible <BCLASS="emphasis.bold">dig</B> querytypes and their meanings.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="TCP2-CH-11-TAB-0">Table 11.1: dig Query Types</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Query Type</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">DNS Record Requested</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">a</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Address records</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">any</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any type of record</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">mx</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Mail Exchange records</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">ns</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Name Server records</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">soa</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Start of Authority records</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">hinfo</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Host Info records</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">axfr</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">All records in the zone</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">txt</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Text records</TD></TR></TBODY></TABLE><PCLASS="para">Notice that the function of <BCLASS="emphasis.bold">nslookup</B>'s <BCLASS="emphasis.bold">ls</B> command isperformed by the <BCLASS="emphasis.bold">dig</B> query type <BCLASS="emphasis.bold">axfr</B>.</P><PCLASS="para"><BCLASS="emphasis.bold">dig</B> also has an option that is useful for locating a hostnamewhen you have only an IP address. If you only have the IP address of ahost, you may want to find out the hostname because numeric addressesare more prone to typos. Having the hostname can reduce the user's<ACLASS="indexterm"NAME="AUTOID-16401"></A>problems. The <EMCLASS="emphasis">in-addr.arpa</EM> domain converts addresses to hostnames,and <BCLASS="emphasis.bold">dig</B> provides a simple way to enter <EMCLASS="emphasis">in-addr.arpa</EM> domainqueries. Using the <BCLASS="emphasis.bold">-x</B> option, you can query for a number to name conversion without having to manually reverse the numbers and add &quot;in-addr.arpa.&quot; Forexample, to query for the hostname of IP address 18.72.0.3, simplyenter:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>dig -x 18.72.0.3</B></CODE>; &lt;&lt;&gt;&gt; DiG 2.1 &lt;&lt;&gt;&gt; -x ;; res options: init recurs defnam dnsrch;; got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 6;; flags: qr aa rd ra; Ques: 1, Ans: 1, Auth: 0, Addit: 0;; QUESTIONS:;;      3.0.72.18.in-addr.arpa, type = ANY, class = IN;; ANSWERS:3.0.72.18.in-addr.arpa. 21600   PTR     BITSY.MIT.EDU.;; Total query time: 74 msec;; FROM: peanut to SERVER: default -- 172.16.12.1;; WHEN: Sat Jul 12 11:12:55 1997;; MSG SIZE  sent: 40  rcvd: 67</PRE></BLOCKQUOTE></P><PCLASS="para">The answer to our query is BITSY.MIT.EDU, but <BCLASS="emphasis.bold">dig</B> displays lotsof other output. The first five lines and the last four lines provideinformation and statistics about the query. For our purposes, the onlyimportant information is the answer.<ACLASS="indexterm"NAME="AUTOID-16413"></A><ACLASS="indexterm"NAME="AUTOID-16414"></A><ACLASS="indexterm"NAME="AUTOID-16415"></A>[10]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[10] To see a single-line answer to this query, pipe <BCLASS="emphasis.bold">dig</B>'s output to<BCLASS="emphasis.bold">grep</B>; e.g., <BCLASS="emphasis.bold">dig -x 18.72.0.3 | grep PTR</B>.</P></BLOCKQUOTE></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_05.htm"TITLE="11.5 Checking Routing "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 11.5 Checking Routing "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="TCP/IP Network Administration"><IMGSRC="../gifs/txthome.gif"ALT="TCP/IP Network Administration"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_07.htm"TITLE="11.7 Analyzing Protocol Problems "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 11.7 Analyzing Protocol Problems "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">11.5 Checking Routing </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">11.7 Analyzing Protocol Problems </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><PCLASS="nav"><FONTSIZE="-1">[ <AHREF="../index.htm"TITLE="The Networking CD Bookshelf">Library Home</A> | <AHREF="../dnsbind/index.htm"TITLE="DNS &amp; BIND">DNS &amp; BIND</A> | <AHREF="index.htm"TITLE="TCP/IP Network Administration">TCP/IP</A> | <AHREF="../sendmail/index.htm"TITLE="sendmail">sendmail</A> | <AHREF="../smdref/index.htm"TITLE="sendmail Desktop Reference">sendmail Reference</A> | <AHREF="../firewall/index.htm"TITLE="Building Internet Firewalls">Firewalls</A> | <AHREF="../puis/index.htm"TITLE="Practical UNIX &amp; Internet Security">Practical Security</A> ]</FONT></P></DIV></BODY></HTML>