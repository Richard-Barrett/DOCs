<HTML><HEAD><TITLE>[Chapter 1] 1.6 Files</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T20:50:54Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch01_01.htm"TITLE="1. Korn Shell Basics"><LINKREL="prev"HREF="ch01_05.htm"TITLE="1.5 Interactive Shell Use"><LINKREL="next"HREF="ch01_07.htm"TITLE="1.7 Input and Output"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch01_05.htm"TITLE="1.5 Interactive Shell Use"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 1.5 Interactive Shell Use"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 1<BR>Korn Shell Basics</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch01_07.htm"TITLE="1.7 Input and Output"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 1.7 Input and Output"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-1-SECT-6">1.6 Files</A></H2><PCLASS="para">Although arguments to commands aren't always files, filesare the most important types of &quot;things&quot; on any UNIX system.A file can contain any kind of information, and indeed thereare different types of files. Three types areby far the most important:<DLCLASS="variablelist"><DTCLASS="term"><BCLASS="emphasis.bold">Regular files</B></DT><DDCLASS="listitem"><PCLASS="para">Also called text files;these contain readable characters. For example, this book was created from several regular filesthat contain the text of the book plus human-readable formatting instructions to the <EMCLASS="emphasis">troff</EM> word processor.<ACLASS="indexterm"NAME="AUTOID-677"></A></P></DD><DTCLASS="term"><BCLASS="emphasis.bold">Executable files</B></DT><DDCLASS="listitem"><PCLASS="para">Also called programs; these are invokedas commands. Some can't be read by humans; others-the shell scripts that we'll examine in this book-arejust special text files. The shell itselfis a (non-human-readable) executable file called <EMCLASS="emphasis">ksh</EM>.</P></DD><DTCLASS="term"><BCLASS="emphasis.bold">Directories</B></DT><DDCLASS="listitem"><PCLASS="para">Like folders that containother files-possibly other directories (called<EMCLASS="emphasis">subdirectories</EM>).  </P></DD></DL></P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-1-SECT-6.1">1.6.1 Directories</A></H3><PCLASS="para">Let's review the most important concepts about directories.The fact that directories can contain other directories leadsto a hierarchical structure, more popularlyknown as a <EMCLASS="emphasis">tree</EM>, for all files on a UNIX system.  <ACLASS="xref"HREF="ch01_06.htm#KSH-CH-1-FIG-1"TITLE="A tree of directories and files">Figure 1.2</A>shows part of a typical directory tree;ovals are regular files and rectangles are directories.<ACLASS="indexterm"NAME="AUTOID-696"></A><H4CLASS="figure"><ACLASS="title"NAME="KSH-CH-1-FIG-1">Figure 1.2: A tree of directories and files</A></H4><IMGCLASS="graphic"SRC="figs/korn0102.gif"ALT="Figure 1.2"></P><PCLASS="para">The top of the tree is a directory called &quot;root&quot;that has no name on the system.[3]All files can be named by expressing their location on thesystem relative to root; such names are built by listingall of the directory names (in order from root), separatedby slashes (<BCLASS="emphasis.bold">/</B>), followed by the file's name. This wayof naming files is called a <EMCLASS="emphasis">full</EM> (or <EMCLASS="emphasis">absolute</EM>)<EMCLASS="emphasis">pathname</EM>.<ACLASS="indexterm"NAME="AUTOID-709"></A><ACLASS="indexterm"NAME="AUTOID-711"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] Most introductory UNIX tutorials say that root has the name <BCLASS="emphasis.bold">/</B>.We stand by this alternative explanation because it is morelogically consistent.</P></BLOCKQUOTE><PCLASS="para">For example, saythere is a file called <EMCLASS="emphasis">memo</EM> that is in the directory<EMCLASS="emphasis">fred</EM>, which is in the directory <EMCLASS="emphasis">users</EM>, whichis in the root directory. This file's full pathnameis <EMCLASS="emphasis">/users/fred/memo</EM>.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-1-SECT-6.1.1">1.6.1.1 The working directory</A></H4><PCLASS="para">Of course, it's annoying to have to use full pathnames whenever you need to specify a file. So there is also theconcept of the working directory(sometimes called the current directory), which is thedirectory you are &quot;in&quot; at any given time. If you give apathname with no leading slash, then the location of the file is worked out relativeto the working directory. Such pathnames are called<EMCLASS="emphasis">relative</EM> pathnames; you'll use them much more oftenthan full pathnames.<ACLASS="indexterm"NAME="AUTOID-723"></A><ACLASS="indexterm"NAME="AUTOID-725"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-729"></A>When you log in to the system, your working directory isinitially set to a special directory called your <EMCLASS="emphasis">home</EM>(or <EMCLASS="emphasis">login</EM>) directory. System administrators oftenset up the system so that everyone's home directory nameis the same as their login name, and all home directoriesare contained in a common directory under root.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-735"></A>For example, <EMCLASS="emphasis">/users/billr</EM> is a typical home directory.If this is your working directoryand you give the command <BCLASS="emphasis.bold">lp memo</B>, then the system looksfor the file <EMCLASS="emphasis">memo</EM> in <EMCLASS="emphasis">/users/billr</EM>. If you havea directory called <EMCLASS="emphasis">bob</EM> in your home directory, and itcontains the file <EMCLASS="emphasis">statreport</EM>, then you can print it withthe command <BCLASS="emphasis.bold">lp bob/statreport</B>.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-1-SECT-6.1.2">1.6.1.2 Tilde notation</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-TILDE-NOTATION"></A><ACLASS="indexterm"NAME="KSH-CH-1-IX-TILDE"></A>As you can well imagine, home directories occur often in pathnames. Although many systems are organized so that allhome directories have a common parent (such as <EMCLASS="emphasis">/home</EM>or <EMCLASS="emphasis">/users</EM>), you should not have to rely on that beingthe case, nor should you even have to know what the absolutepathname of someone's home directory is.  </P><PCLASS="para">Therefore, the Korn shell has a way of abbreviating homedirectories: just precede the name of the user with a tilde (<BCLASS="emphasis.bold">~</B>).For example, you could refer to the file <EMCLASS="emphasis">memo</EM> in user fred's home directory as <EMCLASS="emphasis">~fred/memo</EM>.This is an absolute pathname, so it doesn't matterwhat your working directory is when you use it. If fred's homedirectory has a subdirectory called <EMCLASS="emphasis">bob</EM> and the fileis in there instead, you can use <EMCLASS="emphasis">~fred/bob/memo</EM> as its name.</P><PCLASS="para">Even more convenient, a tilde by itself refers to your own homedirectory. You can refer to a file called <EMCLASS="emphasis">notes</EM> in your homedirectory as <EMCLASS="emphasis">~/notes</EM> (note thedifference between that and <EMCLASS="emphasis">~notes</EM>, which the shell wouldtry to interpret as user <EMCLASS="emphasis">notes</EM>home directory). If <EMCLASS="emphasis">notes</EM> is in your <EMCLASS="emphasis">bob</EM> subdirectory,then you can call it <EMCLASS="emphasis">~/bob/notes</EM>. This notation ishandiest when your working directory is not in your home directorytree, e.g., when it's some &quot;system&quot; directory like <EMCLASS="emphasis">/tmp</EM>.<ACLASS="indexterm"NAME="AUTOID-768"></A><ACLASS="indexterm"NAME="AUTOID-769"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-1-SECT-6.1.3">1.6.1.3 Changing working directories</A></H4><PCLASS="para">If you want to change your working directory, use the command <BCLASS="emphasis.bold">cd</B>.If you don't remember your working directory, the command<BCLASS="emphasis.bold">pwd</B> tells the shell to print it.  </P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-CD"></A><BCLASS="emphasis.bold">cd</B> takes as argument the name of the directory youwant to become your working directory. It can be relativeto your current directory, it can contain a tilde, or it canbe absolute (starting witha slash). If you omit the argument, <BCLASS="emphasis.bold">cd</B> changes to yourhome directory (i.e., it's the same as <BCLASS="emphasis.bold">cd ~</B> ).</P><PCLASS="para"><ACLASS="xref"HREF="ch01_06.htm#KSH-CH-1-TAB-0"TITLE="Sample cd Commands">Table 1.1</A>gives some sample <BCLASS="emphasis.bold">cd</B> commands. Each commandassumes that your working directory is <EMCLASS="emphasis">/users/billr</EM>just before the command is executed, and thatyour directory structure looks like <ACLASS="xref"HREF="ch01_06.htm#KSH-CH-1-FIG-1"TITLE="A tree of directories and files">Figure 1.2</A>.<ACLASS="indexterm"NAME="AUTOID-786"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-1-TAB-0">Table 1.1: Sample cd Commands</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Command</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">New Working Directory</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">cd bob</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">/users/billr/bob</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">cd bob/dave</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">/users/billr/bob/dave</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">cd ~/bob/dave</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">/users/billr/bob/dave</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">cd /usr/lib</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">/usr/lib</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">cd ..</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">/users</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">cd ../pete</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">/users/pete</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">cd ~pete</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">/users/pete</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">cd billr pete</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">/users/pete</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">cd illr arry</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">/users/barry</EM></TD></TR></TBODY></TABLE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-843"></A><ACLASS="indexterm"NAME="AUTOID-845"></A>The first four are straightforward. The next two use a specialdirectory called <CODECLASS="literal">..</CODE> (two dots), which means &quot;parent of thisdirectory.&quot; Every directory has one of these;it's auniversal way to get to the directory above the currentone in the hierarchy-which is called the parent directory.[4]<ACLASS="indexterm"NAME="AUTOID-856"></A><ACLASS="indexterm"NAME="AUTOID-859"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] Each directory also has the special directory <CODECLASS="literal">.</CODE>(single dot), which just means &quot;this directory.&quot;Thus, <BCLASS="emphasis.bold">cd</B> <CODECLASS="literal">.</CODE> effectively does nothing.Both <CODECLASS="literal">.</CODE> and <CODECLASS="literal">..</CODE> are actually special hidden filesin each directory that point to the directory itself and to itsparent directory, respectively. Root is its own parent.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-863"></A>The last two examples in the table use a new form of the <BCLASS="emphasis.bold">cd</B>command, which is not included in most Bourne shells. Theform is <BCLASS="emphasis.bold">cd</B> <EMCLASS="emphasis">old new</EM>. It takes the full pathname ofthe current working directory and tries to find the string<BCLASS="emphasis.bold">old</B> in it. If it finds the string, it substitutes <BCLASS="emphasis.bold">new</B>and changes to the resulting directory.  </P><PCLASS="para">In the first of thetwo examples, the shell substitutes <EMCLASS="emphasis">pete</EM> for <EMCLASS="emphasis">billr</EM> in the current directory name and makes the result the new current directory. The last example shows that the substitution neednot be a complete filename: substituting <EMCLASS="emphasis">arry</EM> for <EMCLASS="emphasis">illr</EM>in <EMCLASS="emphasis">/users/billr</EM> yields <EMCLASS="emphasis">/users/barry</EM>.(If the <EMCLASS="emphasis">old</EM> string can't be found in the current directoryname, the shell prints an error message.)</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-880"></A>Another new feature of the Korn shell's <BCLASS="emphasis.bold">cd</B> command isthe form <BCLASS="emphasis.bold">cd -</B>, which changes to whatever directory youwere in before the current one. For example, if you start outin <EMCLASS="emphasis">/usr/lib</EM>, type <BCLASS="emphasis.bold">cd</B> without an argument to go to your home directory, and then type <BCLASS="emphasis.bold">cd -</B>, you willbe back in <EMCLASS="emphasis">/usr/lib</EM>.<ACLASS="indexterm"NAME="AUTOID-889"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-1-SECT-6.2">1.6.2 Filenames and Wildcards</A></H3><PCLASS="para">Sometimes you need to run a command on more than one fileat a time.  <ACLASS="indexterm"NAME="KSH-CH-1-IX-LS"></A>The most common example of such a command is<EMCLASS="emphasis">ls</EM>, which lists information about files. In its simplestform, without options or arguments, it lists the names of allfiles in the working directory except special hidden files,whose names begin with a dot (<BCLASS="emphasis.bold">.</B>).<ACLASS="indexterm"NAME="AUTOID-897"></A></P><PCLASS="para">If you give <EMCLASS="emphasis">ls</EM> filename arguments,it will list those files-which is sort of silly: if your current directory has the files <EMCLASS="emphasis">bob</EM> and <EMCLASS="emphasis">fred</EM> in itand you type <BCLASS="emphasis.bold">ls bob fred</B>, the system will simply parrotthe filenames back at you.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-906"></A>Actually, <EMCLASS="emphasis">ls</EM> is more often used with options that tell itto list information about the files, like the <BCLASS="emphasis.bold">-l</B> (long) option,which tells <EMCLASS="emphasis">ls</EM> to list the file's owner, size, time oflast modification, and other information, or <BCLASS="emphasis.bold">-a</B> (all), whichalso lists the hidden files described above.  <ACLASS="indexterm"NAME="AUTOID-913"></A>But sometimes youwant to verify the existence of a certain group of files withouthaving to know all of their names; for example, if you use the<EMCLASS="emphasis">WordPerfect</EM> word processor, you might want to see which filesin your current directory have names that end in <EMCLASS="emphasis">.wp</EM>.</P><PCLASS="para">Filenames are so important in UNIX that the shell provides abuilt-in way to specify the pattern of a set of filenameswithout having to know all of the names themselves.  <ACLASS="indexterm"NAME="AUTOID-917"></A>You canuse special characters, called <EMCLASS="emphasis">wildcards</EM>, in filenamesto turn them into patterns. We'll show the three basictypes of wildcards that all major UNIX shells support, and we'llsave the Korn shell's set of advanced wildcard operators for<ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A>.  <ACLASS="xref"HREF="ch01_06.htm#KSH-CH-1-TAB-1"TITLE="Basic Wildcards">Table 1.2</A> lists the basic wildcards.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-1-TAB-1">Table 1.2: Basic Wildcards</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Wildcard</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Matches</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">?</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any single character</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">*</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any string of characters</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[<EMCLASS="emphasis">set</EM>]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any character in <EMCLASS="emphasis">set</EM> </TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[!<EMCLASS="emphasis">set</EM>]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any character <EMCLASS="emphasis">not</EM> in <EMCLASS="emphasis">set</EM></TD></TR></TBODY></TABLE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-951"></A><ACLASS="indexterm"NAME="AUTOID-954"></A>The <CODECLASS="literal">?</CODE> wildcard matches any single character, so thatif your directory contains the files <EMCLASS="emphasis">program.c</EM>,<EMCLASS="emphasis">program.log</EM>, and<EMCLASS="emphasis">program.o</EM>, then the expression <BCLASS="emphasis.bold">program</B><BCLASS="emphasis.bold">.</B><CODECLASS="literal">?</CODE> matches<EMCLASS="emphasis">program.c</EM> and <EMCLASS="emphasis">program.o</EM> but not <EMCLASS="emphasis">program.log</EM>.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-WILDCARDS-SPLAT"></A><ACLASS="indexterm"NAME="KSH-CH-1-IX-WILDCARD"></A>The asterisk (<CODECLASS="literal">*</CODE>) is more powerful and far more widely-used; it matchesany string of characters. The expression <BCLASS="emphasis.bold">program.</B><CODECLASS="literal">*</CODE>will match all three files in the previous paragraph;<EMCLASS="emphasis">WordPerfect</EM> users can use the expression<BCLASS="emphasis.bold">*.wp</B> to match their input files.[5]<ACLASS="indexterm"NAME="AUTOID-984"></A><ACLASS="indexterm"NAME="AUTOID-986"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] MS-DOS and VAX/VMS users should note that there is <EMCLASS="emphasis">nothing special</EM>about the dot (.) in UNIX filenames (aside from the leading dot, which&quot;hides&quot; the file); it's just another character. For example,<BCLASS="emphasis.bold">ls *</B> lists all files in the current directory; you don'tneed <BCLASS="emphasis.bold">*.*</B> as you do on other systems.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="xref"HREF="ch01_06.htm#KSH-CH-1-TAB-2"TITLE="Using the * Wildcard">Table 1.3</A>should give you a better idea ofhow the asterisk works. Assume that you have the files <EMCLASS="emphasis">bob</EM>, <EMCLASS="emphasis">darlene</EM>, <EMCLASS="emphasis">dave</EM>, <EMCLASS="emphasis">ed</EM>, <EMCLASS="emphasis">frank</EM>, and <EMCLASS="emphasis">fred</EM> in your working directory.  </P><PCLASS="para">Notice that <CODECLASS="literal">*</CODE> can stand for nothing: both <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">ed</B> and <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">e</B><CODECLASS="literal">*</CODE> match<EMCLASS="emphasis">ed</EM>.  Also notice that the last example shows what the shelldoes if it can't match anything: it just leaves the stringwith the wildcard untouched.<ACLASS="indexterm"NAME="AUTOID-1004"></A><ACLASS="indexterm"NAME="AUTOID-1005"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-1-TAB-2">Table 1.3: Using the <CODECLASS="literal">*</CODE> <EMCLASS="emphasis">Wildcard</EM></A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Expression</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Yields</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">fr<CODECLASS="literal">*</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">frank fred</B></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">*</CODE>ed</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">ed fred</B></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">b<CODECLASS="literal">*</CODE> </TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">bob</B></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">*</CODE>e<CODECLASS="literal">*</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">darlene dave ed fred</B></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">*</CODE>r<CODECLASS="literal">*</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">darlene frank fred</B></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">*</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">bob darlene dave ed frank fred</B></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">d<CODECLASS="literal">*</CODE>e</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">darlene dave</B></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">g<CODECLASS="literal">*</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">g<CODECLASS="literal">*</CODE></B></TD></TR></TBODY></TABLE><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-WILDCARDS-DASH"></A><ACLASS="indexterm"NAME="KSH-CH-1-IX-WILDCARDS-RANGES"></A><ACLASS="indexterm"NAME="KSH-CH-1-IX-DASH-WILDCARD"></A>The remaining wildcard is the <EMCLASS="emphasis">set</EM> construct.A set is a list of characters (e.g., abc),an inclusive range (e.g., a-z), or some combination of the two. If you want the dash character to be part of a list, justlist it first or last. <ACLASS="xref"HREF="ch01_06.htm#KSH-CH-1-TAB-3"TITLE="Using the Set Construct Wildcards">Table 1.4</A>should explain things more clearly.<ACLASS="indexterm"NAME="AUTOID-1070"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-1-TAB-3">Table 1.4: Using the Set Construct Wildcards</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Expression</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Matches</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">[abc]</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">a, b, or c</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">[.,;]</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Period, comma, or semicolon</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">[-_]</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Dash and underscore</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">[a-c]</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">a, b, or c</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">[a-z]</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">All lowercase letters</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">[!0-9]</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">All non-digits</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">[0-9!]</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">All digits and exclamation point</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">[a-zA-Z]</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">All lower- and uppercase letters</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">[a-zA-Z0-9_-]</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">All letters, all digits, underscore, and dash</TD></TR></TBODY></TABLE><PCLASS="para">In the original wildcard example, <BCLASS="emphasis.bold">program.[co]</B> and<BCLASS="emphasis.bold">program.[a-z]</B> both match<EMCLASS="emphasis">program.c</EM> and <EMCLASS="emphasis">program.o</EM>, but not <EMCLASS="emphasis">program.log</EM>.</P><PCLASS="para">An exclamation point after the left bracket lets you&quot;negate&quot; a set.  <ACLASS="indexterm"NAME="AUTOID-1124"></A>For example, <BCLASS="emphasis.bold">[!</B><CODECLASS="literal">.;</CODE><BCLASS="emphasis.bold">]</B> matches any characterexcept period and semicolon;  <BCLASS="emphasis.bold">[!a-zA-Z]</B> matches any character that isn't a letter.<ACLASS="indexterm"NAME="AUTOID-1131"></A><ACLASS="indexterm"NAME="AUTOID-1132"></A><ACLASS="indexterm"NAME="AUTOID-1133"></A></P><PCLASS="para">The range notation is handy, but you shouldn't make too manyassumptions about what characters are included in a range.It's safe to use a range for uppercase letters, lowercaseletters, digits, or any subranges thereof (e.g., <BCLASS="emphasis.bold">[f-q]</B>, <BCLASS="emphasis.bold">[2-6]</B>).Don't use rangeson punctuation characters or mixed-case letters: e.g.,<BCLASS="emphasis.bold">[a-Z]</B> and <BCLASS="emphasis.bold">[A-z]</B> should not be trusted to include all of theletters and nothing more. The problem is that such ranges arenot entirely portable between different types of computers.[6]<ACLASS="indexterm"NAME="AUTOID-1141"></A><ACLASS="indexterm"NAME="AUTOID-1143"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] Specifically, ranges depend on the character encoding schemeyour computer uses. The vast majority use ASCII, but IBMmainframes use EBCDIC.</P></BLOCKQUOTE><PCLASS="para">The process of matching expressions containingwildcards to filenames is called wildcard expansion.This is just one of several steps the shell takes whenreading and processing a command line; another that we have alreadyseen is tilde expansion, where tildes are replaced withhome directories where applicable. We'll see others inlater chapters, and the full details of the process are enumerated in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A>.</P><PCLASS="para">However, it's important tobe aware that the commands that you run only see theresults of wildcard expansion.That is, they just see a list of arguments, and they haveno knowledge of how those arguments came into being.<ACLASS="indexterm"NAME="AUTOID-1148"></A><ACLASS="indexterm"NAME="AUTOID-1151"></A>For example, if you type <BCLASS="emphasis.bold">ls fr* </B> and your filesare as on the previous page, then the shell expands the commandline to <BCLASS="emphasis.bold">ls fred frank</B> and invokes the command <EMCLASS="emphasis">ls</EM>with arguments <BCLASS="emphasis.bold">fred</B> and <BCLASS="emphasis.bold">frank</B>. If you type <BCLASS="emphasis.bold">ls g*</B>,then (because there is no match) <EMCLASS="emphasis">ls</EM> will be giventhe literal string <BCLASS="emphasis.bold">g*</B> and will complain with the error message,<BCLASS="emphasis.bold">g* not found.</B>[7]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] This is different from the C shell's wildcard mechanism, whichprints an error message and doesn't execute the command at all.</P></BLOCKQUOTE><PCLASS="para">Here is another example that should help you understandwhy this is important.  <ACLASS="indexterm"NAME="AUTOID-1166"></A>Suppose you are a C programmer.This just means that you deal with files whose names endin <EMCLASS="emphasis">.c</EM> (programs, a.k.a. source files), <EMCLASS="emphasis">.h</EM> (header files for programs), and <EMCLASS="emphasis">.o</EM>(object code files that aren't human-readable) as well asother files.  </P><PCLASS="para">Let's say you want to list all source, object, and header files in your working directory.<ACLASS="indexterm"NAME="AUTOID-1172"></A><ACLASS="indexterm"NAME="AUTOID-1175"></A><ACLASS="indexterm"NAME="AUTOID-1178"></A><ACLASS="indexterm"NAME="AUTOID-1181"></A>The command <BCLASS="emphasis.bold">ls</B> <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">.[cho]</B> does the trick.  The shell expands <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">.[cho]</B> toall files whose names end in a period followed by a <BCLASS="emphasis.bold">c</B>, <BCLASS="emphasis.bold">h</B>, or <BCLASS="emphasis.bold">o</B> and passes the resulting list to <EMCLASS="emphasis">ls</EM> asarguments.  </P><PCLASS="para">In other words, <EMCLASS="emphasis">ls</EM> will see the filenamesjust as if they were all typed in individually-but noticethat we assumed no knowledge of the actual filenameswhatsoever! We let the wildcards do the work.</P><PCLASS="para">As you gain experience with the shell, reflect on whatlife would be like without wildcards. Pretty miserable,we would say.   </P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch01_05.htm"TITLE="1.5 Interactive Shell Use"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 1.5 Interactive Shell Use"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch01_07.htm"TITLE="1.7 Input and Output"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 1.7 Input and Output"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">1.5 Interactive Shell Use</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">1.7 Input and Output</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>