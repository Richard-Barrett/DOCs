<HTML><HEAD><TITLE>[Chapter 1] 1.7 Input and Output</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T20:51:35Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch01_01.htm"TITLE="1. Korn Shell Basics"><LINKREL="prev"HREF="ch01_06.htm"TITLE="1.6 Files"><LINKREL="next"HREF="ch01_08.htm"TITLE="1.8 Background Jobs"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch01_06.htm"TITLE="1.6 Files"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 1.6 Files"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 1<BR>Korn Shell Basics</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch01_08.htm"TITLE="1.8 Background Jobs"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 1.8 Background Jobs"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-1-SECT-7">1.7 Input and Output</A></H2><PCLASS="para">The software field-really, any scientific field-tends to advance most quickly and impressivelyon those few occasions when someone (i.e., not a committee) comesup with an idea that is small in concept yet enormous in itsimplications. The standard input and output scheme of UNIXhas to be on the short list of such ideas,along with such classic innovations as the LISP language,the relational data model, and object-oriented programming.<ACLASS="indexterm"NAME="AUTOID-1198"></A></P><PCLASS="para">The UNIX I/O scheme is based on two dazzlingly simple ideas.First, UNIX file I/O takes the form of arbitrarilylong sequences of characters (bytes). In contrast, file systems of older vintage have more complicated I/O schemes (e.g., &quot;block,&quot; &quot;record,&quot; &quot;card image,&quot; etc.).Second, everything on the system thatproduces or accepts data is treated as a file; this includeshardware devices like disk drives and terminals. Older systemstreated every device differently. Both of these ideas have madesystems programmers' lives much more pleasant.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-1-SECT-7.1">1.7.1 Standard I/O</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-STANDARD-IO"></A><ACLASS="indexterm"NAME="AUTOID-1207"></A>By convention, each UNIX program has a singleway of accepting input called <EMCLASS="emphasis">standard input</EM>, a single wayof producing output called <EMCLASS="emphasis">standard output</EM>, and a single wayof producing error messages called <EMCLASS="emphasis">standard error output</EM>,usually shortened to <EMCLASS="emphasis">standard error</EM>.Of course, a program can have other input and output sources as well,as we will see in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A>.</P><PCLASS="para">Standard I/O was the first scheme of its kind that was designedspecifically for interactive users at terminals, rather thanthe older batch style of use that usually involves decks ofpunch-cards. Since the UNIX shell provides the user interface, it should come as no surprise that standard I/O was designed tofit in very neatly with the shell.</P><PCLASS="para">All shells handle standard I/O in basically the same way.Each program that you invoke has all three standard I/O channelsset to your terminal or workstation, so that standard input isyour keyboard, and standard output and error are your screen orwindow.  <ACLASS="indexterm"NAME="KSH-CH-1-IX-MAIL"></A>For example, the <EMCLASS="emphasis">mail</EM> utility prints messagesto you on the standard output, and when you use it to send messagesto other users, it accepts your input on the standard input.This means that you view messages on your screen and type new ones in on your keyboard.</P><PCLASS="para">When necessary, you can redirect input and output to come from or go to a file instead. If you want tosend the contents of a pre-existing file to someone as mail,you redirect <EMCLASS="emphasis">mail</EM>'s standard input so that it reads fromthat file instead of your keyboard.  </P><PCLASS="para">You can alsohook up programs into a <EMCLASS="emphasis">pipeline</EM>, in which the standard outputof one program feeds directly into the standard inputof another; for example, you could feed <EMCLASS="emphasis">mail</EM> outputdirectly to the <EMCLASS="emphasis">lp</EM> program so that messages are printedinstead of shown on the screen.<ACLASS="indexterm"NAME="AUTOID-1226"></A></P><PCLASS="para">This makes it possible to use UNIX utilities asbuilding blocks for bigger programs. Many UNIX utility programsare meant to be used in this way: they each perform a specific type of filtering operation on input text.Although this isn't a textbook on UNIX utilities, they areessential to productive shell use. The more popular filteringutilities are listed in <ACLASS="xref"HREF="ch01_07.htm#KSH-CH-1-TAB-4"TITLE="Popular UNIX Data Filtering Utilities">Table 1.5</A>.<ACLASS="indexterm"NAME="AUTOID-1229"></A><ACLASS="indexterm"NAME="AUTOID-1232"></A><ACLASS="indexterm"NAME="AUTOID-1234"></A><ACLASS="indexterm"NAME="AUTOID-1236"></A><ACLASS="indexterm"NAME="AUTOID-1238"></A><ACLASS="indexterm"NAME="AUTOID-1240"></A><ACLASS="indexterm"NAME="AUTOID-1242"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-1-TAB-4">Table 1.5: Popular UNIX Data Filtering Utilities</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Utility</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Purpose</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">cat</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Copy input to output</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">grep</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Search for strings in the input</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">sort</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Sort lines in the input</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">cut</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Extract columns from input</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">sed</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Perform editing operations on input</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">tr</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Translate characters in the input to other characters</TD></TR></TBODY></TABLE><PCLASS="para">You may have used some of these before and noticed that they takenames of input files as arguments and produce output on standard output.You may not know, however, that all of them (and most other UNIX utilities) accept input from standard input if you omit the argument.[8]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] If a particular UNIX utility doesn't accept standard input whenyou leave out the filename argument, try using <BCLASS="emphasis.bold">-</B> as the argument.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-CAT"></A>For example, the most basic utility is <EMCLASS="emphasis">cat</EM>, which simplycopies its input to its output. If you type <BCLASS="emphasis.bold">cat</B> with afilename argument, it will print out the contents of that fileon your screen. But if you invoke it with noarguments, it will expect standard input and copy it to standardoutput. Try it: <EMCLASS="emphasis">cat</EM> will wait for you to type a line oftext; when you type RETURN, <EMCLASS="emphasis">cat</EM> will parrot the text back at you. To stop theprocess, hit <KBDCLASS="keycap">[CTRL-D]</KBD> at the beginning of a line (see below forwhat this character means). You will see <BCLASS="emphasis.bold">^</B><BCLASS="emphasis.bold">D</B> when youtype <KBDCLASS="keycap">[CTRL-D]</KBD>. Here's what this should look like:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">cat</B><BCLASS="emphasis.bold">Here is a line of text.</B>Here is a line of text.<BCLASS="emphasis.bold">This is another line of text.</B>This is another line of text.<BCLASS="emphasis.bold">^D</B>$</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-1-SECT-7.2">1.7.2 I/O Redirection</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-IOREDIRECTION"></A><EMCLASS="emphasis">cat</EM> is actually short for &quot;catenate,&quot; i.e., link together.It accepts multiplefilename arguments and copies them to the standard output.But let's pretend, for the moment, that <EMCLASS="emphasis">cat</EM> and other utilities don't acceptfilename arguments and accept only standard input. As we saidabove, the shell lets you redirect standard input so that it comesfrom a file.  <ACLASS="indexterm"NAME="KSH-CH-1-IX-IOREDIR-IN"></A><ACLASS="indexterm"NAME="KSH-CH-1-IX-REDIROUT"></A>The notation <EMCLASS="emphasis">command</EM> <BCLASS="emphasis.bold">&lt;</B> <EMCLASS="emphasis">filename</EM> does this; it sets things up so that <EMCLASS="emphasis">command</EM> takes standard inputfrom a file instead of from a terminal.</P><PCLASS="para">For example, if you have a file called <EMCLASS="emphasis">fred</EM> that containssome text, then <BCLASS="emphasis.bold">cat &lt; fred</B> will print <EMCLASS="emphasis">fred</EM>'s contentsout onto your terminal.  <ACLASS="indexterm"NAME="AUTOID-1319"></A><BCLASS="emphasis.bold">sort &lt; fred</B> will sort the lines inthe <EMCLASS="emphasis">fred</EM> file and print the result on your terminal(remember: we're pretending that utilities don't takefilename arguments).</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-IOREDIR-OUT"></A><ACLASS="indexterm"NAME="KSH-CH-1-IX-REDIRIN"></A>Similarly, <EMCLASS="emphasis">command</EM> <BCLASS="emphasis.bold">&gt;</B> <EMCLASS="emphasis">filename</EM> causes the <EMCLASS="emphasis">command</EM>'sstandard output to be redirected to the named file.  <ACLASS="indexterm"NAME="AUTOID-1334"></A>The classic &quot;canonical&quot; example of this is <BCLASS="emphasis.bold">date &gt; now</B>:the <EMCLASS="emphasis">date</EM> command prints the current date and time on thestandard output; the above command saves it in a file called <EMCLASS="emphasis">now</EM>.</P><PCLASS="para">Input and output redirectors can be combined.  <ACLASS="indexterm"NAME="AUTOID-1340"></A><ACLASS="indexterm"NAME="AUTOID-1342"></A>For example:the <EMCLASS="emphasis">cp</EM> command is normally used to copy files; if for some reasonit didn't exist or was broken, you could use <EMCLASS="emphasis">cat</EM> in this way:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">cat  &lt;</B> <EMCLASS="emphasis">file1</EM>  <BCLASS="emphasis.bold">&gt;</B>  <EMCLASS="emphasis">file2</EM></PRE></BLOCKQUOTE></P><PCLASS="para">This would be similar to <BCLASS="emphasis.bold">cp file1 file2</B>.<ACLASS="indexterm"NAME="AUTOID-1354"></A><ACLASS="indexterm"NAME="AUTOID-1355"></A><ACLASS="indexterm"NAME="AUTOID-1356"></A><ACLASS="indexterm"NAME="AUTOID-1357"></A><ACLASS="indexterm"NAME="AUTOID-1358"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-1-SECT-7.3">1.7.3 Pipelines</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-IOPIPELINES"></A><ACLASS="indexterm"NAME="KSH-CH-1-IX-PIPE"></A>It is also possible to redirect the output of a command intothe standard input of another command instead of a file.The construct that does this is called the pipe, notatedas <BCLASS="emphasis.bold">|</B>. A command line that includes two or more commandsconnected with pipes is called a pipeline.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-1-IX-MORE"></A>Pipes are very often used with the <EMCLASS="emphasis">more</EM>command, which works just like <EMCLASS="emphasis">cat</EM> except that it printsits output screen by screen, pausing for the user to typeSPACE (next screen), RETURN (next line), or other commands.If you're in a directory with a large number of files and youwant to see details about them, <BCLASS="emphasis.bold">ls -l | more</B> will giveyou a detailed listing a screen at a time.</P><PCLASS="para">Pipelines can get very complex (see, for example, the <BCLASS="emphasis.bold">lsd</B> function in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A> orthe pipeline version of the C compiler driver in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A>);   they can also be combined with other I/O directors. Tosee a sorted listing of the file <EMCLASS="emphasis">fred</EM> a screen at a time,type <BCLASS="emphasis.bold">sort &lt; fred | more</B>. <ACLASS="indexterm"NAME="AUTOID-1381"></A><ACLASS="indexterm"NAME="AUTOID-1382"></A>To print it instead of viewing iton your terminal, type <BCLASS="emphasis.bold">sort &lt; fred | lp</B>.</P><PCLASS="para">Here's a more complicated example.  <ACLASS="indexterm"NAME="KSH-CH-1-IX-ETCPASSWD"></A>The file <EMCLASS="emphasis">/etc/passwd</EM> stores information about users' accounts on a UNIX system.Each line in the file contains a user's login name, user ID number,encrypted password, home directory, login shell, and other info.The first field of each line is the login name;fields are separated by colons (<CODECLASS="literal">:</CODE>).  A sample line might look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">billr:5Ae40BGR/tePk:284:93:Bill Rosenblatt:/home/billr:/bin/ksh</PRE></BLOCKQUOTE></P><PCLASS="para">To get a sorted listing of all users on the system, type:<ACLASS="indexterm"NAME="AUTOID-1393"></A><ACLASS="indexterm"NAME="AUTOID-1395"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">cut -d: -f1 &lt; /etc/passwd | sort</B></PRE></BLOCKQUOTE></P><PCLASS="para">(Actually, you can omit the <BCLASS="emphasis.bold">&lt;</B>, since <EMCLASS="emphasis">cut</EM> acceptsinput filename arguments.)The <EMCLASS="emphasis">cut</EM> command extracts the first field (<BCLASS="emphasis.bold">-f1</B>),where fields are separated by colons (<BCLASS="emphasis.bold">-d:</B>), from the input.The entire pipeline will print a list that looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">albillrbobchrisdaveedfrank...</PRE></BLOCKQUOTE></P><PCLASS="para">If you want to send the list directly to the printer (instead ofyour screen), you can extend the pipeline like this:<ACLASS="indexterm"NAME="AUTOID-1409"></A><ACLASS="indexterm"NAME="AUTOID-1411"></A><ACLASS="indexterm"NAME="AUTOID-1413"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">cut -d: -f1 &lt; /etc/passwd | sort | lp</B></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-1419"></A>Now you should see how I/O directors and pipelines support theUNIX building block philosophy.  The notation is extremely terse and powerful. Just asimportant, the pipe concept eliminates the need for messytemporary files to store output of commands before it isfed into other commands.  <ACLASS="indexterm"NAME="AUTOID-1420"></A><ACLASS="indexterm"NAME="AUTOID-1421"></A><ACLASS="indexterm"NAME="AUTOID-1422"></A></P><PCLASS="para">For example, to do the same sortof thing as the above command line on other operating systems(assuming that equivalent utilities were available...), you would need three commands.  <ACLASS="indexterm"NAME="AUTOID-1424"></A>On <SPANCLASS="acronym">DEC</SPAN>'s VAX/VMS system, theymight look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">cut [etc]passwd /d=&quot;:&quot; /f=1 /out=temp1</B>$ <BCLASS="emphasis.bold">sort temp1 /out=temp2</B>$ <BCLASS="emphasis.bold">print temp2</B></PRE></BLOCKQUOTE></P><PCLASS="para">After sufficient practice,you will find yourself routinely typing in powerful commandpipelines that do in one line what it would take several commands(and temporary files) in other operating systems to accomplish.<ACLASS="indexterm"NAME="AUTOID-1433"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch01_06.htm"TITLE="1.6 Files"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 1.6 Files"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch01_08.htm"TITLE="1.8 Background Jobs"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 1.8 Background Jobs"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">1.6 Files</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">1.8 Background Jobs</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>