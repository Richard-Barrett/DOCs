<HTML><HEAD><TITLE>[Chapter 3] 3.4 Shell Variables</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T20:58:51Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch03_01.htm"TITLE="3. Customizing Your Environment"><LINKREL="prev"HREF="ch03_03.htm"TITLE="3.3 Options"><LINKREL="next"HREF="ch03_05.htm"TITLE="3.5 Customization and Subprocesses"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch03_03.htm"TITLE="3.3 Options"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 3.3 Options"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 3<BR>Customizing Your Environment</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch03_05.htm"TITLE="3.5 Customization and Subprocesses"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 3.5 Customization and Subprocesses"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-3-SECT-4">3.4 Shell Variables</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-VARS"></A><ACLASS="indexterm"NAME="AUTOID-4244"></A><ACLASS="indexterm"NAME="AUTOID-4248"></A><ACLASS="indexterm"NAME="AUTOID-4252"></A><ACLASS="indexterm"NAME="AUTOID-4255"></A>There are several characteristics of your environment that youmay want to customize but that cannot be expressed as an on/off choice.Characteristics of this type are specified in shell variables.Shell variables can specify everything from yourprompt string to how often the shell checks for new mail.</P><PCLASS="para">Like an alias, a shell variable is a name that has a valueassociated with it.  <ACLASS="indexterm"NAME="AUTOID-4259"></A>The Korn shell keeps track of severalbuilt-in shell variables; shell programmers can add their own.By convention, built-in variables have names in all capital letters.<ACLASS="indexterm"NAME="AUTOID-4262"></A><ACLASS="indexterm"NAME="AUTOID-4265"></A>The syntax for defining variables is somewhat similar to thesyntax for aliases:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><EMCLASS="emphasis">varname</EM>=<EMCLASS="emphasis">value</EM></PRE></BLOCKQUOTE></P><PCLASS="para">There must be no space on either side of theequal sign, and if the value is more than one word, it mustbe surrounded by quotes.  <ACLASS="indexterm"NAME="AUTOID-4273"></A>To use the value of a variable in acommand, precede its name by a dollar sign (<BCLASS="emphasis.bold">$</B>).  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4279"></A>You candelete a variable with the command <BCLASS="emphasis.bold">unset</B> <EMCLASS="emphasis">varname</EM>.Normally this isn't useful, since all variables that don't existare assumed to be null, i.e., equal to the empty string &quot;&quot;.But if you use the option <BCLASS="emphasis.bold">nounset</B> (see <ACLASS="xref"HREF="ch03_03.htm#KSH-CH-3-TAB-0"TITLE="Basic Shell Options">Table 3.1</A>),which causesthe shell to indicate an error when it encounters an undefinedvariable, then you may be interested in <BCLASS="emphasis.bold">unset</B>.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-PRINT"></A>The easiest way to check a variable's value is to use the<BCLASS="emphasis.bold">print</B> built-in command.  [7]All <BCLASS="emphasis.bold">print</B> does is print itsarguments, but not until the shell has evaluated them. Thisincludes-among other things that will be discussed later-taking the values of variables and expanding filename wildcards.So, if the variable <BCLASS="emphasis.bold">fred</B> has the value <BCLASS="emphasis.bold">bob</B>, typing:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] The Korn shell supports the old command <EMCLASS="emphasis">echo</EM>,which does much the same thing, for backward compatibilityreasons.  <ACLASS="indexterm"NAME="AUTOID-4294"></A><ACLASS="indexterm"NAME="AUTOID-4296"></A><ACLASS="indexterm"NAME="AUTOID-4300"></A>However, we strongly recommend <BCLASS="emphasis.bold">print</B> becauseits options are the same on all UNIX systems, whereas <EMCLASS="emphasis">echo</EM>'soptions differ between BSD-derived and System V-derived UNIXversions.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">print &quot;$fred&quot;</B></PRE></BLOCKQUOTE></P><PCLASS="para">will cause the shell to simply print <BCLASS="emphasis.bold">bob</B>.If the variable is undefined, the shell will print a blank line.A more verbose way to do this is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">print &quot;The value of \$</B><EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold"> is</B> \&quot;$<EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold">\&quot;.&quot;</B></PRE></BLOCKQUOTE></P><PCLASS="para">The first dollar sign and the inner double quotes are backslash-escaped (i.e., preceded with <BCLASS="emphasis.bold">\</B> so the shelldoesn't try to interpret them; see <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A>) so thatthey appear literally in the output, which for the above example would be:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">The value of $fred is &quot;bob&quot;.</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4327"></A><ACLASS="indexterm"NAME="AUTOID-4328"></A></P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-3-SECT-4.1">3.4.1 Variables and Quoting</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-QUOTING-VARS"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-VARS-QUOTING-RULES"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-WEAK-QUOTES"></A>Notice that we used double quotes around variables (and stringscontaining them) in these <BCLASS="emphasis.bold">print</B> examples. In <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A>we said that some special characters inside double quotesare still interpreted (while none are interepreted inside singlequotes).  <ACLASS="indexterm"NAME="AUTOID-4342"></A><ACLASS="indexterm"NAME="AUTOID-4345"></A>We've seen one of these special characters already:the tilde (<BCLASS="emphasis.bold">~</B>), which is expanded to your (or another user's)home directory.</P><PCLASS="para">Another special character that &quot;survives&quot; double quotes isthe dollar sign&nbsp;- meaning that variables are evaluated.It's possible to do without the double quotes in some cases;for example, we could have written the above <BCLASS="emphasis.bold">print</B>command this way:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">print The value of \$</B><EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold"> is \&quot;$</B><EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold">\&quot;</B>.</PRE></BLOCKQUOTE></P><PCLASS="para">But double quotes are more generally correct.</P><PCLASS="para">Here's why. Suppose we did this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">fred=&gt;</B>'<BCLASS="emphasis.bold">Four spaces between these    words.</B>'</PRE></BLOCKQUOTE></P><PCLASS="para">Then if we entered the command <BCLASS="emphasis.bold">print $fred</B>, the resultwould be:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Four spaces between these words.</PRE></BLOCKQUOTE></P><PCLASS="para">What happened to the extra spaces? Without the doublequotes, the shell split the string into wordsafter substituting the variable's value, as it normallydoes when it processes command lines. The double quotescircumvent this part of the process (by making the shell thinkthat the whole quoted string is a single word).</P><PCLASS="para">Therefore the command <BCLASS="emphasis.bold">print</B> <CODECLASS="literal">&quot;$</CODE><BCLASS="emphasis.bold">fred</B><CODECLASS="literal">&quot;</CODE> prints this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Four spaces between these    words.</PRE></BLOCKQUOTE></P><PCLASS="para">This becomes particularly important when we start dealingwith variables that contain user or file input later on.</P><PCLASS="para">Double quotes also allow other special characters towork, as we'll see in Chapters 4, 6, and 7.But for now,we'll revise the &quot;When in doubt, use single quotes&quot; rule in<ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A> by adding, &quot;...unless a string contains a variable,in which case you should use double quotes.&quot; <ACLASS="indexterm"NAME="AUTOID-4379"></A><ACLASS="indexterm"NAME="AUTOID-4380"></A><ACLASS="indexterm"NAME="AUTOID-4381"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-3-SECT-4.2">3.4.2 Built-in Variables</A></H3><PCLASS="para">As with options, some built-in shell variables are meaningful to generalUNIX users, while others are arcana for hackers. We'll look atthe more generally useful ones here, and we'll save some of the more obscure ones for later chapters.Again, <ACLASS="xref"HREF="appb_01.htm"TITLE="Reference Lists">Appendix B</A> contains a complete list.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-3-SECT-4.2.1">3.4.2.1 Editing mode variables</A></H4><PCLASS="para">Several shell variables relate to the command-line editing modesthat we saw in the previous chapter. These are listed in<ACLASS="xref"HREF="ch03_04.htm#KSH-CH-3-TAB-1"TITLE="Editing Mode Variables">Table 3.2</A>.</P><PCLASS="para">The first two of these are sometimes used by texteditors and other screen-oriented programs, which rely on the variablesbeing set correctly. Although the Korn shelland most windowing systems should know how to set them correctly, you should look at the values of <BCLASS="emphasis.bold">COLUMNS</B> and <BCLASS="emphasis.bold">LINES</B>if you are having display trouble with a screen-oriented program.<ACLASS="indexterm"NAME="AUTOID-4393"></A><ACLASS="indexterm"NAME="AUTOID-4396"></A><ACLASS="indexterm"NAME="AUTOID-4398"></A><ACLASS="indexterm"NAME="AUTOID-4401"></A><ACLASS="indexterm"NAME="AUTOID-4403"></A><ACLASS="indexterm"NAME="AUTOID-4406"></A><ACLASS="indexterm"NAME="AUTOID-4408"></A><ACLASS="indexterm"NAME="AUTOID-4411"></A><ACLASS="indexterm"NAME="AUTOID-4413"></A><ACLASS="indexterm"NAME="AUTOID-4416"></A><ACLASS="indexterm"NAME="AUTOID-4418"></A><ACLASS="indexterm"NAME="AUTOID-4421"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-3-TAB-1">Table 3.2: Editing Mode Variables</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Variable</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">COLUMNS</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Width, in character columns, of your terminal. The standard value is 80 (sometimes 132), though if you are using a windowing system like X, you could give a terminal window any size you wish.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">LINES</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Length of your terminal in text lines. The standard value forterminals is 24, but for IBM PC-compatible monitors it's 25; onceagain, if you are using a windowing system, you can usually resizeto any amount.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">HISTFILE</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Name of history file, on which the editing modes operate.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">EDITOR</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Pathname of your favorite text editor; the suffix (<EMCLASS="emphasis">macs</EM> or <EMCLASS="emphasis">vi</EM>)determines which editing mode to use.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">VISUAL</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Similar to EDITOR; used if EDITOR is not set or vice versa.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">FCEDIT</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Pathname of editor to use with the <BCLASS="emphasis.bold">fc</B> command.</P></TD></TR></TBODY></TABLE></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-3-SECT-4.2.2">3.4.2.2 Mail Variables</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-MAIL"></A>Since the <EMCLASS="emphasis">mail</EM> program is not running allthe time, there is no way for it to inform you when you get new mail;therefore the shell does this instead.  [8]The shell can't actually check for incoming mail, but it can look at yourmail file periodically and determine whether the file has been modified since the last check.The variables listed in <ACLASS="xref"HREF="ch03_04.htm#KSH-CH-3-TAB-2"TITLE="Mail Variables">Table 3.3</A>let you control how this works.<ACLASS="indexterm"NAME="AUTOID-4483"></A><ACLASS="indexterm"NAME="AUTOID-4485"></A><ACLASS="indexterm"NAME="AUTOID-4487"></A><ACLASS="indexterm"NAME="AUTOID-4489"></A><ACLASS="indexterm"NAME="AUTOID-4492"></A><ACLASS="indexterm"NAME="AUTOID-4495"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] <ACLASS="indexterm"NAME="AUTOID-4472"></A><ACLASS="indexterm"NAME="AUTOID-4476"></A><ACLASS="indexterm"NAME="AUTOID-4478"></A>BSD UNIX users should note that the <EMCLASS="emphasis">biff</EM> command on those systems does a better job of this; while the Korn shellonly prints &quot;you have mail&quot; messages right before it printscommand prompts, <EMCLASS="emphasis">biff</EM> can do so at any time.</P></BLOCKQUOTE><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-3-TAB-2">Table 3.3: Mail Variables</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Variable</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">MAIL</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Name of file to check for incoming mail (i.e., your mail file)</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">MAILCHECK</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">How often, in seconds, to check for new mail (default 600 seconds,or 10 minutes)</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">MAILPATH</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">List of filenames, separated by colons (<CODECLASS="literal">:</CODE>), to check for incoming mail</P></TD></TR></TBODY></TABLE><PCLASS="para">Under the simplest scenario, you use the standard UNIX mail program,and your mail file is <EMCLASS="emphasis">/usr/mail/yourname</EM> or somethingsimilar.  <ACLASS="indexterm"NAME="AUTOID-4524"></A><ACLASS="indexterm"NAME="AUTOID-4526"></A>In this case, you would just set the variable <BCLASS="emphasis.bold">MAIL</B>to this filename if you want your mail checked:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">MAIL=/usr/mail/yourname</PRE></BLOCKQUOTE></P><PCLASS="para">If your systemadministrator hasn't already done it for you, put a line like thisin your <EMCLASS="emphasis">.profile</EM>.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-MAILPATH"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-ENV-VARS-MAILPATH"></A>However, some people use nonstandard mailers thatuse multiple mail files;<BCLASS="emphasis.bold">MAILPATH</B> was designed to accommodate this.The Korn shell will use the value of <BCLASS="emphasis.bold">MAIL</B> as the nameof the file to check, unless <BCLASS="emphasis.bold">MAILPATH</B> is set, in which case the shell will check each file in the <BCLASS="emphasis.bold">MAILPATH</B>list for new mail. You can use this mechanism to have the shellprint a different message for each mail file:for each mail filename in <BCLASS="emphasis.bold">MAILPATH</B>, append a question mark followedby the message you want printed. </P><PCLASS="para">For example, let's say you have a mail system that automaticallysorts your mail into files according to the username of the sender.You have mail files called <EMCLASS="emphasis">/usr/mail/you/fritchie</EM>, <EMCLASS="emphasis">/usr/mail/you/droberts</EM>, <EMCLASS="emphasis">/usr/mail/you/jphelps</EM>, etc.You define your <BCLASS="emphasis.bold">MAILPATH</B> as follows:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">MAILPATH=/usr/mail/you/fritchie:/usr/mail/you/droberts:\/usr/mail/you/jphelps</PRE></BLOCKQUOTE></P><PCLASS="para">If you get mail from Jennifer Phelps,then the file <EMCLASS="emphasis">/usr/mail/you/jphelps</EM> will change. The Kornshell will notice the change within 10 minutes and print the message:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">you have mail in /usr/mail/you/jphelps.</PRE></BLOCKQUOTE></P><PCLASS="para">If you are in the middle of running a command, the shell willwait until the command finishes (or is suspended) to print the message.To customize this further, you could define <BCLASS="emphasis.bold">MAILPATH</B> to be:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">MAILPATH=\/usr/mail/you/fritchie?You have mail from Fiona.:\/usr/mail/you/droberts?Mail from Dave has arrived.:\/usr/mail/you/jphelps?There is new mail from Jennifer.</PRE></BLOCKQUOTE></P><PCLASS="para">The backslashes at the end of each line allow you to continueyour command on the next line. But be careful: you can't indentsubsequent lines. Now, if you get mail from Jennifer, the shellwill print:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">There is new mail from Jennifer.</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4564"></A><ACLASS="indexterm"NAME="AUTOID-4565"></A><ACLASS="indexterm"NAME="AUTOID-4566"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-3-SECT-4.2.3">3.4.2.3 Prompting Variables</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-PROMPTS"></A>If you have seen enough experienced UNIX users at work, youmay already have realized that the shell's prompt is notengraved in stone. It seems as though one of the favoritepastimes of UNIX hackers is thinking of cute or innovativeprompt strings. We'll give you some of the information youneed to do your own here; the rest will come in the next chapter.</P><PCLASS="para">Actually, the Korn shell uses four prompt strings.  <ACLASS="indexterm"NAME="KSH-CH-3-IX-PS1"></A><ACLASS="indexterm"NAME="AUTOID-4575"></A><ACLASS="indexterm"NAME="AUTOID-4577"></A><ACLASS="indexterm"NAME="AUTOID-4579"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-BUILT-IN-VARS-PS1"></A><ACLASS="indexterm"NAME="AUTOID-4584"></A><ACLASS="indexterm"NAME="AUTOID-4587"></A><ACLASS="indexterm"NAME="AUTOID-4590"></A>They are stored in the variables <BCLASS="emphasis.bold">PS1</B>, <BCLASS="emphasis.bold">PS2</B>, <BCLASS="emphasis.bold">PS3</B>,and <BCLASS="emphasis.bold">PS4</B>.  <ACLASS="indexterm"NAME="AUTOID-4597"></A><ACLASS="indexterm"NAME="AUTOID-4600"></A>The first of these is called the primaryprompt string; it is your usual shell prompt, and its defaultvalue is &quot;<BCLASS="emphasis.bold">$</B> &quot; (a dollar sign followed by a space).Many people like to set their primary promptstring to something containing their login name.  Here is one way to do this:<ACLASS="indexterm"NAME="AUTOID-4605"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PS1=&quot;($LOGNAME)-&gt; &quot;</PRE></BLOCKQUOTE></P><PCLASS="para"><BCLASS="emphasis.bold">LOGNAME</B> is another built-in shell variable, which is set toyour login name when you log in.So, <BCLASS="emphasis.bold">PS1</B> becomes a left parenthesis, followed byyour login name, followed by &quot;<BCLASS="emphasis.bold">)-&gt;</B> &quot;.If your login name is fred, your prompt string will be<CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">(fred)-&gt; </B><CODECLASS="literal">&quot;</CODE>.  <ACLASS="indexterm"NAME="AUTOID-4617"></A><ACLASS="indexterm"NAME="AUTOID-4619"></A>If you are a C shell user and, like manysuch people, are used to having a command number in your prompt string, the Korn shellcan do this similarly to the C shell: if there is an exclamation pointin the prompt string, it will substitute the command number.Thus, if you define your prompt string to be:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PS1=&quot;($LOGNAME !)-&gt;&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">then your prompts will be like <BCLASS="emphasis.bold">(fred 1)-&gt;</B>, <BCLASS="emphasis.bold">(fred 2)-&gt;</B>,and so on.  </P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-PROMPTS-CUSTOM-CURR-DIR"></A>But perhaps the most useful way to set up your prompt stringis so that it always contains yourcurrent directory. This way, you needn't type <BCLASS="emphasis.bold">pwd</B> to rememberwhere you are.  Putting your directory in the prompt is more complicated than the above examples, because yourcurrent directory changes during your login session, whereas yourlogin name and the name of your machine don't. But we canaccommodate this by taking advantage of some of the shell's arcanequoting rules. Here's how:<ACLASS="indexterm"NAME="KSH-CH-3-IX-PWD"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-ENV-VARS-PWD"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PS1='($PWD)-&gt; '</PRE></BLOCKQUOTE></P><PCLASS="para">The difference is the single quotes, instead of double quotes,surrounding the string on the right side of the assignment.Notice thatthis string is evaluated twice:once when the assignment to <BCLASS="emphasis.bold">PS1</B> is done (in your<EMCLASS="emphasis">.profile</EM> or environment file)and then again after every command you enter.Here's what each of these evaluations does:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">The first evaluation just observes the single quotesand returns what is inside them without further processing.As a result, <BCLASS="emphasis.bold">PS1</B> contains the string <BCLASS="emphasis.bold">($</B>PWD)<BCLASS="emphasis.bold">-&gt;</B> .  </P></LI><LICLASS="listitem"><PCLASS="para">After every command, the shell evaluates<BCLASS="emphasis.bold">($PWD)-&gt;</B>. <BCLASS="emphasis.bold">PWD</B> is a built-in variable that is always equal to the current directory, so the result is a primary prompt that always contains the currentdirectory.</P></LI></OL><PCLASS="para">We'll add to this example in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7, Input/Output and Command-line Processing</A>.<ACLASS="indexterm"NAME="AUTOID-4656"></A><ACLASS="indexterm"NAME="AUTOID-4657"></A><ACLASS="indexterm"NAME="AUTOID-4658"></A><ACLASS="indexterm"NAME="AUTOID-4659"></A><ACLASS="indexterm"NAME="AUTOID-4661"></A><BCLASS="emphasis.bold">PS2</B> is called the secondary promptstring; its default value is <BCLASS="emphasis.bold">&gt;</B>.It is used when you type an incomplete line and hitRETURN, as an indication that you must finish your command.For example, assume that you start a quoted string but don'tclose the quote. Then if you hit RETURN, the shell will print <BCLASS="emphasis.bold">&gt;</B> and wait for you to finish the string:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">print &quot;This is a long line,</B>		<EMCLASS="emphasis"># PS1 for the command</EM>&gt; <BCLASS="emphasis.bold">which is terminated down here&quot;</B>	<EMCLASS="emphasis"># PS2 for the continuation</EM>$					<EMCLASS="emphasis"># PS1 for the next command</EM></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4675"></A><ACLASS="indexterm"NAME="AUTOID-4676"></A><ACLASS="indexterm"NAME="AUTOID-4677"></A><ACLASS="indexterm"NAME="AUTOID-4679"></A><ACLASS="indexterm"NAME="AUTOID-4682"></A><ACLASS="indexterm"NAME="AUTOID-4684"></A><BCLASS="emphasis.bold">PS3</B> and <BCLASS="emphasis.bold">PS4</B> relate to shell programming and debugging, respectively;they will be explained in <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5, Flow Control</A> and <ACLASS="xref"HREF="ch09_01.htm"TITLE="Debugging Shell Programs">Chapter 9, Debugging Shell Programs</A>.<ACLASS="indexterm"NAME="AUTOID-4691"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-3-SECT-4.2.4">3.4.2.4 Terminal Types</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-ENV-VARS-TERM"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-TERM"></A>The shell variable <BCLASS="emphasis.bold">TERM</B> is vitally important for any program thatuses your entire screen or window, like a text editor.<ACLASS="indexterm"NAME="AUTOID-4701"></A><ACLASS="indexterm"NAME="AUTOID-4703"></A><ACLASS="indexterm"NAME="AUTOID-4705"></A>Such programs include all screen editors (such as<EMCLASS="emphasis">vi</EM> and <EMCLASS="emphasis">emacs</EM>), <EMCLASS="emphasis">more</EM>, and countless third-partyapplications.</P><PCLASS="para">Because users are spending more and more time within programs, and less and less using the shell itself, itis extremely important that your <BCLASS="emphasis.bold">TERM</B>is set correctly. It's really your system administrator's jobto help you do this (or to do it for you), but in case you needto do it yourself, here are a few guidelines.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-TERMINFO"></A>The value of <BCLASS="emphasis.bold">TERM</B> must be a short character stringwith lowercase letters thatappears as a filename in the <EMCLASS="emphasis">terminfo</EM> database.[9]This database is a two-tiered directory of files under theroot directory <EMCLASS="emphasis">/usr/lib/terminfo</EM>. This directory containssubdirectories with single-character names; these in turn containfiles of terminal information for all terminals whose names beginwith that character. Each file describes how to tell the terminalin question to do certain common things like position the cursor on thescreen, go into reverse video, scroll, insert text, and so on.The descriptions are in binary form (i.e., not readable by humans).</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] <ACLASS="indexterm"NAME="AUTOID-4719"></A><ACLASS="indexterm"NAME="AUTOID-4721"></A><ACLASS="indexterm"NAME="AUTOID-4725"></A><ACLASS="indexterm"NAME="AUTOID-4727"></A>Versions of UNIX not derived from System V use<EMCLASS="emphasis">termcap</EM>, an older-style database of terminal capabilitiesthat uses the single file <EMCLASS="emphasis">/etc/termcap</EM> for all terminaldescriptions.</P></BLOCKQUOTE><PCLASS="para">Names of terminal description files are the same as that of theterminal being described; sometimes an abbreviation is used.<ACLASS="indexterm"NAME="AUTOID-4733"></A><ACLASS="indexterm"NAME="AUTOID-4735"></A>For example, the DEC VT100 has a descriptionin the file <EMCLASS="emphasis">/usr/lib/terminfo/v/vt100</EM>; a monitor fora 386-based PC/AT has a description in the file <EMCLASS="emphasis">/usr/lib/terminfo/A/AT-386M</EM>.  <ACLASS="indexterm"NAME="AUTOID-4739"></A><ACLASS="indexterm"NAME="AUTOID-4741"></A>An <EMCLASS="emphasis">xterm</EM> terminal windowunder the X Window System has a description in <EMCLASS="emphasis">/usr/lib/terminfo/x/xterm</EM>.</P><PCLASS="para">Sometimes your UNIX software will set up <BCLASS="emphasis.bold">TERM</B> correctly; this usually happens for X terminals and PC-based UNIX systems. Therefore,you should check the value of <BCLASS="emphasis.bold">TERM</B> by typing <BCLASS="emphasis.bold">print $TERM</B> before going any further. If you find that your UNIX system isn'tsetting the right value for you (especially likely if your terminalis of a different make than your computer), you need to find theappropriate value of <BCLASS="emphasis.bold">TERM</B> yourself.</P><PCLASS="para">The best way to find the <BCLASS="emphasis.bold">TERM</B> value-if you can't find a local guru to do it for you-is to guess the <EMCLASS="emphasis">terminfo</EM> name and search for a file of that name under <EMCLASS="emphasis">/usr/lib/terminfo</EM> by using <EMCLASS="emphasis">ls</EM>. For example,if your terminal is a Blivitz BL-35A, you could try:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">cd /usr/lib/terminfo</B>$ <BCLASS="emphasis.bold">ls b/bl*</B></PRE></BLOCKQUOTE></P><PCLASS="para">If you are successful, you will see something like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">bl35a           blivitz35a</PRE></BLOCKQUOTE></P><PCLASS="para">In this case, the two names are likely to be synonyms for (links to)the same terminal description, so you could use either one as avalue of <BCLASS="emphasis.bold">TERM</B>. In other words, you could put <EMCLASS="emphasis">either</EM> of thesetwo lines in your <EMCLASS="emphasis">.profile</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">TERM=bl35aTERM=blivitz35a</PRE></BLOCKQUOTE></P><PCLASS="para">If you aren't successful, <EMCLASS="emphasis">ls</EM> won't print anything, and youwill have to make another guess and try again. If you find that<EMCLASS="emphasis">terminfo</EM> contains nothing that resembles your terminal, all isnot lost. Consult your terminal's manual to see if the terminal can emulate a more popular model; nowadays the odds of this are excellent.</P><PCLASS="para">Conversely, <EMCLASS="emphasis">terminfo</EM> may have several entries that relate to yourterminal, for submodels, special modes, etc. If youhave a choice of which entry to use as your value of <BCLASS="emphasis.bold">TERM</B>,we suggest you test each one out with your text editoror any other screen-oriented programs you use and see which oneworks best.<ACLASS="indexterm"NAME="AUTOID-4774"></A></P><PCLASS="para">The process is much simpler if you are using a windowing system,in which your &quot;terminals&quot; are logical portions of the screenrather than physical devices. In this case, operating system-dependent software was written to control yourterminal window(s), so the odds are very good that if it knows howto handle window resizing and complex cursor motion, then it is capable ofdealing with simple things like <BCLASS="emphasis.bold">TERM</B>.  <ACLASS="indexterm"NAME="AUTOID-4777"></A><ACLASS="indexterm"NAME="AUTOID-4779"></A>The X Window System, forexample, automatically sets &quot;xterm&quot; as its value for <BCLASS="emphasis.bold">TERM</B>in an <EMCLASS="emphasis">xterm</EM> terminal window.<ACLASS="indexterm"NAME="AUTOID-4783"></A><ACLASS="indexterm"NAME="AUTOID-4784"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-3-SECT-4.2.5">3.4.2.5 Command Search Path</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-PATH"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-ENV-VARS-PATH"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-FINDING-CMNDS-PATH"></A>Another important variableis <BCLASS="emphasis.bold">PATH</B>, which helps the shell find the commands you enter.</P><PCLASS="para">As you probably know, every commandyou use is actually a file that contains code for your machine torun.[10]<ACLASS="indexterm"NAME="AUTOID-4803"></A><ACLASS="indexterm"NAME="AUTOID-4806"></A>These files are called executable files or justexecutables for short. Theyare stored in various different directories.  <ACLASS="indexterm"NAME="AUTOID-4809"></A><ACLASS="indexterm"NAME="AUTOID-4811"></A>Some directories,like <EMCLASS="emphasis">/bin</EM> or <EMCLASS="emphasis">/usr/bin</EM>, are standard on all UNIX systems;some depend on the particular version of UNIX you are using;some are unique to your machine; if you are a programmer, somemay even be your own. In any case, there is no reason whyyou should have to know where a command's executable file is inorder to run it.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[10] Unless it's a built-in command (one of those shown in<BCLASS="emphasis.bold">boldface</B>, like <BCLASS="emphasis.bold">cd</B> and <BCLASS="emphasis.bold">print</B>),in which case the code is simplypart of the executable file for the entire shell.</P></BLOCKQUOTE><PCLASS="para">That is where <BCLASS="emphasis.bold">PATH</B> comes in. Its value is a list ofdirectories that the shell searches every time you enter a command;[11]the directory names are separated by colons (<CODECLASS="literal">:</CODE>), just like thefiles in <BCLASS="emphasis.bold">MAILPATH</B>.<ACLASS="indexterm"NAME="AUTOID-4821"></A><ACLASS="indexterm"NAME="AUTOID-4823"></A>For example, if you type <BCLASS="emphasis.bold">print $PATH</B>, you will see something like this:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[11] Unless the command name contains a slash (/),in which case the search does not take place.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/sbin:/usr/sbin:/usr/bin:/etc:/usr/ucb:/local/bin</PRE></BLOCKQUOTE></P><PCLASS="para">Why should you care about your path? There are two main reasons.First, once you have read the later chapters of this book andyou try writing your own shell programs, you will wantto test them and eventually set aside a directory for them.Second, your system may be set up so that certain &quot;restricted&quot;commands' executable files are kept in directories that arenot listed in <BCLASS="emphasis.bold">PATH</B>.  For example, there may be adirectory <EMCLASS="emphasis">/usr/games</EM> in which there are executablesthat are verboten during regular working hours.</P><PCLASS="para">Therefore you may want to add directories to your <BCLASS="emphasis.bold">PATH</B>.Let's say you have created a <EMCLASS="emphasis">bin</EM> directory underyour login directory, which is <EMCLASS="emphasis">/home/you</EM>, for yourown shell scripts and programs. To add this directory toyour <BCLASS="emphasis.bold">PATH</B> so that it is there every time you log in,put this line in your <EMCLASS="emphasis">.profile</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PATH=$PATH&quot;:/home/you/bin&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">This sets <BCLASS="emphasis.bold">PATH</B> to whatever it was before, followedimmediately by a colon and <EMCLASS="emphasis">/home/you/bin</EM>.</P><PCLASS="para">This is the &quot;safe&quot; way of doing it. When you enter a command,the shell searches directories in the order theyappear in <BCLASS="emphasis.bold">PATH</B> until it finds an executable file.Therefore, if you have a shell script or program whose nameis the same as an existing command, the shell will usethe existing command-unless you type in the command's full pathnameto disambiguate. For example, if you have created your own version of the <EMCLASS="emphasis">more</EM> command in the above directory and your <BCLASS="emphasis.bold">PATH</B>is set up as in the last example, you will need to type <BCLASS="emphasis.bold">/home/you/bin/more</B>(or just <BCLASS="emphasis.bold">~/bin/more</B>) to get your version.</P><PCLASS="para">The more reckless way of resetting your path is to tell the shell tolook in your directory first by putting it before the otherdirectories in your <BCLASS="emphasis.bold">PATH</B>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PATH=&quot;/home/you/bin:&quot;$PATH</PRE></BLOCKQUOTE></P><PCLASS="para">This is less safe because you are trusting that your own versionof the <EMCLASS="emphasis">more</EM> command works properly.  <ACLASS="indexterm"NAME="AUTOID-4855"></A><ACLASS="indexterm"NAME="AUTOID-4858"></A><ACLASS="indexterm"NAME="AUTOID-4861"></A>But it is also riskyfor a more important reason: system security. If your <BCLASS="emphasis.bold">PATH</B> is set upin this way, you leave open a &quot;hole&quot; that is well known to computer crackers and mischief makers: they caninstall &quot;Trojan horses&quot; and do other things to steal files or do damage. (See <ACLASS="xref"HREF="ch10_01.htm"TITLE="Korn Shell Administration">Chapter 10</A> for more details.)Therefore, unless you have complete control of (and confidence in) everyone who uses your system, use the first of the two methods of adding your own command directory.</P><PCLASS="para">If you need to know which directory a command comes from, you need not lookat directories in your <BCLASS="emphasis.bold">PATH</B> until you find it. The shell built-incommand <BCLASS="emphasis.bold">whence</B> prints the full pathname of the command yougive it as argument, or just the command's name if it's a built-incommand itself (like <BCLASS="emphasis.bold">cd</B>), an alias, or a function(as we'll see in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4, Basic Shell Programming</A>).</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-3-SECT-4.2.6">3.4.2.6 PATH and Tracked Aliases</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-AKAS-TRACKED2"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-FINDING-CMNDS-TRACKED-AKAS"></A>It is worth noting that a search through the directories in your <BCLASS="emphasis.bold">PATH</B>can take time. You won't exactly die if you hold your breath for thelength of time it takes for most computers to search your <BCLASS="emphasis.bold">PATH</B>,but the large number of disk I/O operations involved in some <BCLASS="emphasis.bold">PATH</B> searches can take longer than the command you invoked takesto run!</P><PCLASS="para">The Korn shell provides a way to circumvent PATH searches: the tracked alias mechanismwe saw earlier in this chapter. First, notice that if you specify a commandby giving its full pathname, the shell won't even use your <BCLASS="emphasis.bold">PATH</B>-instead,it will just go directly to the executable file.  </P><PCLASS="para">Tracked aliases do this for you automatically. If you have alias tracking turned on,then the first time you invoke an alias, the shell looks for the executablein the normal way (through <BCLASS="emphasis.bold">PATH</B>). Then it stores the full pathnameas if it were the alias, so that the next time you invoke the command, the shell will use the full pathname and not bother with <BCLASS="emphasis.bold">PATH</B> at all.If you ever change your <BCLASS="emphasis.bold">PATH</B>, the shell marks tracked aliases as &quot;undefined,&quot; so that it will search for the full pathnames again whenyou invoke the corresponding commands.</P><PCLASS="para">In fact, you can add tracked aliases for the sole purpose of avoiding <BCLASS="emphasis.bold">PATH</B>lookup of commands that you use particularly often. Just put a &quot;trivial alias&quot;of the form <BCLASS="emphasis.bold">alias -t</B> <EMCLASS="emphasis">command</EM><BCLASS="emphasis.bold">=</B><EMCLASS="emphasis">command</EM> in your <EMCLASS="emphasis">.profile</EM> orenvironment file; the shell will substitute the full pathname itself.[12]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[12] Actually, the shell predefines tracked aliases for most widely-used UNIXutilities.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-4900"></A><ACLASS="indexterm"NAME="AUTOID-4901"></A><ACLASS="indexterm"NAME="AUTOID-4902"></A><ACLASS="indexterm"NAME="AUTOID-4903"></A><ACLASS="indexterm"NAME="AUTOID-4904"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-3-SECT-4.3">3.4.3 Directory Search Path</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-3-IX-CDPATH"></A><ACLASS="indexterm"NAME="KSH-CH-3-IX-BUILT-IN-VARS-CDPATH"></A><BCLASS="emphasis.bold">CDPATH</B> is a variable whose value, like that of <BCLASS="emphasis.bold">PATH</B>,is a list of directories separated bycolons. Its purpose is to augment the functionality ofthe <BCLASS="emphasis.bold">cd</B> built-in command.</P><PCLASS="para">By default, <BCLASS="emphasis.bold">CDPATH</B> isn't set (meaning that it is null), and when you type <BCLASS="emphasis.bold">cd</B> <EMCLASS="emphasis">dirname</EM>, the shell will look in the currentdirectory for a subdirectory called <EMCLASS="emphasis">dirname</EM>.[13]If you set <BCLASS="emphasis.bold">CDPATH</B>,you give the shell a list of places to look for <EMCLASS="emphasis">dirname</EM>;the list may or may not include the current directory.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[13] As with <BCLASS="emphasis.bold">PATH</B>, this search is disabled when <EMCLASS="emphasis">dirname</EM>starts with a slash.</P></BLOCKQUOTE><PCLASS="para">Here is an example. Consider the alias for thelong <BCLASS="emphasis.bold">cd</B> command from earlier in this chapter:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">alias cdcm=&quot;cd work/projects/devtools/windows/confman&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">Now suppose there were a few directories under this directoryto which you need togo often; they are called <EMCLASS="emphasis">src</EM>, <EMCLASS="emphasis">bin</EM>, and <EMCLASS="emphasis">doc</EM>.You define your <BCLASS="emphasis.bold">CDPATH</B> like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">CDPATH=:~/work/projects/devtools/windows/confman</PRE></BLOCKQUOTE></P><PCLASS="para">In other words, you define your <BCLASS="emphasis.bold">CDPATH</B> to be the empty string (meaning thecurrent directory, wherever you happen to be) followed by<EMCLASS="emphasis">~/work/projects/devtools/windows/confman</EM>.  </P><PCLASS="para">With this setup, if you type <BCLASS="emphasis.bold">cd doc</B>, then the shellwill look in the current directory for a (sub)directory called<EMCLASS="emphasis">doc</EM>. Assuming that it doesn't find one, itlooks in the directory <EMCLASS="emphasis">~/work/projects/devtools/windows/confman</EM>.The shell finds the <EMCLASS="emphasis">dirname</EM> directory there, so you go <EMCLASS="emphasis">directly</EM> there.</P><PCLASS="para">This feature gives you yet another way to save typing when you need to<BCLASS="emphasis.bold">cd</B> often to directories that are buried deep in yourfile hierarchy. You may find yourself going to a specificgroup of directories often as you work on aparticular project, and then changing to another set ofdirectories when you switch to another project. This implies that the<BCLASS="emphasis.bold">CDPATH</B> feature is only useful if you update itwhenever your work habits change; if you don't, you may occasionally find yourself where you don't want to be.<ACLASS="indexterm"NAME="AUTOID-4950"></A><ACLASS="indexterm"NAME="AUTOID-4951"></A></P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-3-SECT-4.3.1">3.4.3.1 Miscellaneous Variables</A></H4><PCLASS="para">We have covered the shell variables that are important fromthe standpoint of customization. There are also several thatserve as status indicators and for various other miscellaneouspurposes. Their meanings are relatively straightforward; the morebasic ones are summarized in <ACLASS="xref"HREF="ch03_04.htm#KSH-CH-3-TAB-3"TITLE="Status Variables">Table 3.4</A>.<ACLASS="indexterm"NAME="AUTOID-4956"></A><ACLASS="indexterm"NAME="AUTOID-4958"></A><ACLASS="indexterm"NAME="AUTOID-4960"></A><ACLASS="indexterm"NAME="AUTOID-4962"></A><ACLASS="indexterm"NAME="AUTOID-4964"></A><ACLASS="indexterm"NAME="AUTOID-4966"></A><ACLASS="indexterm"NAME="AUTOID-4969"></A><ACLASS="indexterm"NAME="AUTOID-4972"></A><ACLASS="indexterm"NAME="AUTOID-4975"></A><ACLASS="indexterm"NAME="AUTOID-4978"></A></P><PCLASS="para">The shell sets the values of these variables (the first threeat login time, the last two whenever you change directories).Although you can also set their values, just like any other variables,it is difficult to imagine any situation where you would want to.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-3-TAB-3">Table 3.4: Status Variables</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Variable</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">HOME</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Name of your home (login) directory</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">SECONDS</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Number of seconds since the shell was invoked</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">SHELL</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Pathname of the shell you are running</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">PWD</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Current directory</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">OLDPWD</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Previous directory before the last <BCLASS="emphasis.bold">cd</B> command</TD></TR></TBODY></TABLE></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch03_03.htm"TITLE="3.3 Options"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 3.3 Options"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch03_05.htm"TITLE="3.5 Customization and Subprocesses"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 3.5 Customization and Subprocesses"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">3.3 Options</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">3.5 Customization and Subprocesses</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>