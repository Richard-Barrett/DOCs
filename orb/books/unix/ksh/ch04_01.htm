<HTML><HEAD><TITLE>[Chapter 4] Basic Shell Programming</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:01:05Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="index.htm"TITLE="Learning the Korn Shell"><LINKREL="prev"HREF="ch03_06.htm"TITLE="3.6 Customization Hints"><LINKREL="next"HREF="ch04_02.htm"TITLE="4.2 Shell Variables"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch03_06.htm"TITLE="3.6 Customization Hints"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 3.6 Customization Hints"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 4</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_02.htm"TITLE="4.2 Shell Variables"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.2 Shell Variables"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="CHAPTER"><H1CLASS="chapter"><ACLASS="title"NAME="KSH-CH4-BASSHELL">4. Basic Shell Programming</A></H1><DIVCLASS="htmltoc"><P><B>Contents:</B><BR><ACLASS="sect1"HREF="#KSH-CH-4-SECT-1"TITLE="4.1 Shell Scripts and Functions">Shell Scripts and Functions</A><BR><ACLASS="sect1"HREF="ch04_02.htm"TITLE="4.2 Shell Variables">Shell Variables</A><BR><ACLASS="sect1"HREF="ch04_03.htm"TITLE="4.3 String Operators">String Operators</A><BR><ACLASS="sect1"HREF="ch04_04.htm"TITLE="4.4 Command Substitution">Command Substitution</A><BR><ACLASS="sect1"HREF="ch04_05.htm"TITLE="4.5 Advanced Examples: pushd and popd">Advanced Examples: pushd and popd</A></P><P></P></DIV><PCLASS="para">If you have become familiar with the customization techniqueswe presented in the previous chapter, you have probably run intovarious modifications to your environment that you want to makebut can't-yet. Shell programming makes these possible.</P><PCLASS="para">The Korn shell has some of the most advanced programmingcapabilities of any command interpreter of its type. Although its syntaxis nowhere near as elegant or consistent as that of most conventionalprogramming languages, its power and flexibility are comparable.In fact, the Korn shell can be used as a complete environment for writingsoftware prototypes.</P><PCLASS="para">Some aspects of Korn shell programming are really extensions ofthe customization techniques we have already seen, while others resemble traditional programming language features. We have structured this chapter so that if you aren'ta programmer, you can read this chapter and do quite a bit more thanyou could with the information in the previous chapter.  <ACLASS="indexterm"NAME="AUTOID-5289"></A><ACLASS="indexterm"NAME="AUTOID-5291"></A>Experience with a conventionalprogramming language like Pascal or C is helpful(though not strictly necessary) for subsequent chapters.Throughout the rest of the book, we will encounter occasionalprogramming problems, called <EMCLASS="emphasis">tasks</EM>, whose solutions make use ofthe concepts we cover.</P><DIVCLASS="sect1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-4-SECT-1">4.1 Shell Scripts and Functions</A></H2><PCLASS="para">A <EMCLASS="emphasis">script</EM>, or file that contains shell commands, is a shellprogram. Your <EMCLASS="emphasis">.profile</EM> and environment files,discussed in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7, Input/Output and Command-line Processing</A> are shell scripts.  </P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-SCRIPTS-RUNNING"></A>You can create a script using the text editor of your choice.Once you have created one,there are two ways to run it.  <ACLASS="indexterm"NAME="AUTOID-5304"></A>One, which we have already covered,is to type <BCLASS="emphasis.bold">. </B><EMCLASS="emphasis">scriptname</EM>(i.e., the command is a dot). This causesthe commands in the script to be read and run as if you typed them in.</P><PCLASS="para">The second way to run a scriptis simply to type its name and hit <BCLASS="emphasis.bold">RETURN</B>, just as ifyou were invoking a built-in command.  This, of course, is the more convenient way.<ACLASS="indexterm"NAME="AUTOID-5311"></A><ACLASS="indexterm"NAME="AUTOID-5314"></A><ACLASS="indexterm"NAME="AUTOID-5316"></A><ACLASS="indexterm"NAME="AUTOID-5318"></A>This method makes the script look just like any other UNIXcommand, and in fact several &quot;regular&quot; commands are implemented asshell scripts (i.e., not as programs originally written in C or someother language), including <EMCLASS="emphasis">spell</EM>, <EMCLASS="emphasis">man</EM> on some systems,and various commands for system administrators.  The resulting lack of distinction between &quot;user command files&quot;and &quot;built-in commands&quot; is one factor in UNIX's extensibilityand, hence, its favored status among programmers.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5323"></A><ACLASS="indexterm"NAME="AUTOID-5325"></A>You can run a script by typing its name onlyif <CODECLASS="literal">.</CODE> (the current directory) is part of your commandsearch path, i.e., is included in your PATH variable(as discussed in <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3, Customizing Your Environment</A>). If <CODECLASS="literal">.</CODE> isn't on your path, you must type <CODECLASS="literal">./</CODE><EMCLASS="emphasis">scriptname</EM>, which is really thesame thing as typing the script's absolute pathname(see <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1, Korn Shell Basics</A>).</P><PCLASS="para">Before you can invoke the shell script by name, you must alsogive it &quot;execute&quot; permission.  <ACLASS="indexterm"NAME="AUTOID-5335"></A>If you are familiar withthe UNIX filesystem, you know that files have three types ofpermissions (read, write, and execute) and that those permissionsapply to three categories of user (the file's owner, a <EMCLASS="emphasis">group</EM> of users, and everyone else). Normally, when you create afile with a text editor, the file is set up with read and write permission for you and read-only permission for everyone else.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5340"></A>Therefore you must give your script execute permission explicitly,by using the <EMCLASS="emphasis">chmod</EM>(1) command. The simplest way to do this is to type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="literal">$</CODE> <BCLASS="emphasis.bold">chmod +x</B> <EMCLASS="emphasis">scriptname</EM></PRE></BLOCKQUOTE></P><PCLASS="para">Your text editor will preserve this permission if you make subsequentchanges to your script.If you don't add execute permission to the script and you try to invoke it,the shell will print the message: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><EMCLASS="emphasis">scriptname</EM><CODECLASS="literal">: cannot execute.</CODE></PRE></BLOCKQUOTE></P><PCLASS="para">But there is a more important difference between the two ways ofrunning shell scripts. While the &quot;dot&quot; methodcauses the commands in the scriptto be run as if they were part of your login session, the &quot;just the name&quot;method causes the shell to do a series of things.<ACLASS="indexterm"NAME="KSH-CH-4-IX-SUBSHELLS"></A>First, it runs another copy of the shell as a subprocess;this is called a <EMCLASS="emphasis">subshell</EM>.The subshell then takes commands from the script, runs them, andterminates, handing control back to the parent shell.</P><PCLASS="para"><ACLASS="xref"HREF="ch04_01.htm#KSH-CH-4-FIG-0"TITLE="Ways to run a shell script">Figure 4.1</A> shows how the shell executes scripts.  Assume you have a simple shell script called <EMCLASS="emphasis">fred</EM> thatcontains the commands <EMCLASS="emphasis">bob</EM> and <EMCLASS="emphasis">dave</EM>.In <ACLASS="xref"HREF="ch04_01.htm#KSH-CH-4-FIG-0"TITLE="Ways to run a shell script">Figure 4.1</A>.a, typing <BCLASS="emphasis.bold">.fred</B> causes the two commands to runin the same shell, just as if you had typed them in by hand.<ACLASS="xref"HREF="ch04_01.htm#KSH-CH-4-FIG-0"TITLE="Ways to run a shell script">Figure 4.1</A>.b shows what happens when you type just <BCLASS="emphasis.bold">fred</B>: the commands run in the subshell while the parent shellwaits for the subshell to finish.  </P><PCLASS="para">You may find it interesting to compare this with the situation in Figure4-1.c, which shows what happens when you type <BCLASS="emphasis.bold">fred &amp;</B>.  <ACLASS="indexterm"NAME="AUTOID-5368"></A>As you will recall from <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A> the <BCLASS="emphasis.bold">&amp;</B> makes the command run inthe <EMCLASS="emphasis">background</EM>, which is really just another term for &quot;subprocess.&quot;It turns out that the only significant difference between <ACLASS="xref"HREF="ch04_01.htm#KSH-CH-4-FIG-0"TITLE="Ways to run a shell script">Figure 4.1</A>.c and Figure 4-1.b is that you have control of your terminal or workstationwhile the command runsmdash;you need not wait until it finishes beforeyou can enter further commands.</P><H4CLASS="figure"><ACLASS="title"NAME="KSH-CH-4-FIG-0">Figure 4.1: Ways to run a shell script</A></H4><IMGCLASS="graphic"SRC="figs/korn0401.gif"ALT="Figure 4.1"><PCLASS="para">There are many ramifications to using subshells.  <ACLASS="indexterm"NAME="AUTOID-5378"></A><ACLASS="indexterm"NAME="AUTOID-5381"></A>An important one is that the <EMCLASS="emphasis">export</EM>ed environment variablesthat we saw in the last chapter (e.g., TERM, LOGNAME, <SPANCLASS="acronym">PWD</SPAN>)are known in subshells, whereas other shell variables (such as anythat you define in your <EMCLASS="emphasis">.profile</EM> without an <EMCLASS="emphasis">export</EM>statement) are not.</P><PCLASS="para">Other issues involving subshellsare too complex to go into now; see <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A>,and <ACLASS="xref"HREF="ch08_01.htm"TITLE="Process Handling">Chapter 8, Process Handling</A>,for more details about subshell I/Oand process characteristics, respectively. For now, just bearin mind that a script normally runs in a subshell.<ACLASS="indexterm"NAME="AUTOID-5390"></A><ACLASS="indexterm"NAME="AUTOID-5391"></A></P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-4-SECT-1.1">4.1.1 Functions</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-FUNCTIONS-DEFINITION"></A><ACLASS="indexterm"NAME="AUTOID-5398"></A><ACLASS="indexterm"NAME="AUTOID-5400"></A>The Korn shell's <EMCLASS="emphasis">function</EM> feature is an expanded version of a similarfacility in the System V Bourne shell and a few other shells.A function is sort of a script-within-a-script;you use it to define some shell code by name andstore it in the shell's memory, to beinvoked and run later.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-FUNCTIONS-ADVANTAGES-SCRIPTS"></A>Functions improve the shell's programmability significantly,for two main reasons. First,when you invoke a function, it is already in the shell's memory(except for autoloaded functions; see section titled &quot;Autoloaded Functions&quot;); thereforea function runs faster.Modern computers have plenty of memory, so there is no need to worryabout the amount of space a typical function takes up.    For this reason, most people define as manyfunctions as possible rather than keep lots of scripts around.</P><PCLASS="para">The other advantage of functions is that they are idealfor organizing long shell scripts into modular &quot;chunks&quot; ofcode that are easier to develop and maintain. If you aren't a programmer,ask one what life would be like without functions (also called<EMCLASS="emphasis">procedures</EM> or <EMCLASS="emphasis">subroutines</EM> in other languages) andyou'll probably get an earful.<ACLASS="indexterm"NAME="AUTOID-5410"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5412"></A>To define a function, you can use either one of two forms:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function <EMCLASS="emphasis">functname</EM> {    <EMCLASS="emphasis">shell commands</EM>}</PRE></BLOCKQUOTE></P><PCLASS="para">or:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><EMCLASS="emphasis">functname</EM> () {    <EMCLASS="emphasis">shell commands</EM>}</PRE></BLOCKQUOTE></P><PCLASS="para">There is no difference between the two.  <ACLASS="indexterm"NAME="AUTOID-5425"></A><ACLASS="indexterm"NAME="AUTOID-5427"></A><ACLASS="indexterm"NAME="AUTOID-5429"></A><ACLASS="indexterm"NAME="AUTOID-5431"></A>Perhaps the first form was created to appeal to Pascal, Modula, and Adaprogrammers, while the second resembles C;in any case, we will use the first form in this book.  <ACLASS="indexterm"NAME="AUTOID-5433"></A>You can also delete a function definition with the command <BCLASS="emphasis.bold">unset -f</B> <EMCLASS="emphasis">functname</EM>.</P><PCLASS="para">When you define a function,you tell the shell to store its name and definition (i.e., the shell commands it contains) in memory.  <ACLASS="indexterm"NAME="AUTOID-5439"></A><ACLASS="indexterm"NAME="AUTOID-5440"></A>If you want to run the function later, justtype in its name followed by any arguments, as if it were a shell script.  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5444"></A>You can findout what functions are defined in your login session by typing<BCLASS="emphasis.bold">functions</B>.  [1]The shell will print not just the names but the definitionsof all functions, in alphabetical order by function name.Since this may result in long output, you might want to pipethe output through <EMCLASS="emphasis">more</EM> or redirect it to a file for examinationwith a text editor.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] This is actually an alias for <BCLASS="emphasis.bold">typeset -f</B>; see <ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6, Command-line Options and Typed Variables</A>.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5454"></A>Apart from the advantages, there are two important differencesbetweeen functions and scripts.  First, functions do not run inseparate processes, as scripts are when you invoke them by name; the&quot;semantics&quot; of running a function are more like those ofyour <EMCLASS="emphasis">.profile</EM> when you log in orany script when invoked with the &quot;dot&quot; command.  Second, if a function hasthe same name as a script or executable program, the function takesprecedence.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5459"></A>This is a good time to show the order of precedence forthe various sources of commands.  When you type a command to theshell, it looks in the following places until it finds a match:<ACLASS="indexterm"NAME="AUTOID-5462"></A><ACLASS="indexterm"NAME="AUTOID-5465"></A><ACLASS="indexterm"NAME="AUTOID-5468"></A><ACLASS="indexterm"NAME="AUTOID-5471"></A><ACLASS="indexterm"NAME="AUTOID-5474"></A><ACLASS="indexterm"NAME="AUTOID-5477"></A></P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Keywords</EM> such as <BCLASS="emphasis.bold">function</B> and several others,like <BCLASS="emphasis.bold">if</B> and <BCLASS="emphasis.bold">for</B>, that we will see in <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5, Flow Control</A></P></LI><LICLASS="listitem"><PCLASS="para">Aliases[2]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] However, it is possible to define an alias for a keyword, e.g., <BCLASS="emphasis.bold">alias aslongas=while</B>.  See <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A> for more details.</P></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Built-ins</EM> like <BCLASS="emphasis.bold">cd</B> and <BCLASS="emphasis.bold">whence</B></P></LI><LICLASS="listitem"><PCLASS="para">Functions</P></LI><LICLASS="listitem"><PCLASS="para">Scripts and executable programs, for which the shell searchesin the directories listed in the <BCLASS="emphasis.bold">PATH</B> environment variable</P></LI></OL><PCLASS="para">We'll examine this process in more detail in the section oncommand-line processing in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A>. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5508"></A><ACLASS="indexterm"NAME="AUTOID-5510"></A>If you need to know the exact source of a command, there isan option to the <BCLASS="emphasis.bold">whence</B> built-in command that we saw in <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A>.  <BCLASS="emphasis.bold">whence</B> by itself willprint the pathname of a command if the commandis a script or executableprogram, but it will only parrot the command's name back if itis anything else.But if you type <BCLASS="emphasis.bold">whence -v</B> <EMCLASS="emphasis">commandname</EM>,you get more complete information, such as:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">whence -v cd</B>cd is a shell builtin$ <BCLASS="emphasis.bold">whence -v function</B>function is a keyword$ <BCLASS="emphasis.bold">whence -v man</B>man is /usr/bin/man$ <BCLASS="emphasis.bold">whence -v ll</B>ll is an alias for ls -l</PRE></BLOCKQUOTE></P><PCLASS="para">We will refer mainly to scripts throughout the remainder of this book, but unless we note otherwise, you should assume that whatever wesay applies equally to functions.  </P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-4-SECT-1.1.1">4.1.1.1 Autoloaded functions</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-FUNCTIONS-AUTOLOADED"></A>The simplest place to put your function definitions is in your<EMCLASS="emphasis">.profile</EM> or environment file.  This is fine for a small number offunctions, but if you accumulate lots of them-as many shellprogrammers eventually do-you may find that logging in orinvoking shell scripts (both of which involve processing your environment file) takes anunacceptably long time, and that it's hard to navigate so manyfunction definitions in a single file.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-AUTOLOAD"></A><ACLASS="indexterm"NAME="AUTOID-5535"></A>The Korn shell's <BCLASS="emphasis.bold">autoload</B> feature addresses these problems.If you put the command <BCLASS="emphasis.bold">autoload</B> <EMCLASS="emphasis">fname</EM>[3]in your <EMCLASS="emphasis">.profile</EM> or environment file, instead of the function'sdefinition, then the shell won't read in the definition of <EMCLASS="emphasis">fname</EM>until it's actually called.  <BCLASS="emphasis.bold">autoload</B> can take more than one argument.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] <BCLASS="emphasis.bold">autoload</B> is actually an alias for <BCLASS="emphasis.bold">typeset -fu</B>; see <ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6</A>.</P></BLOCKQUOTE><PCLASS="para">How does the shell know where to get the definition of an autoloadedfunction?  <ACLASS="indexterm"NAME="AUTOID-5550"></A><ACLASS="indexterm"NAME="AUTOID-5552"></A>It uses the built-invariable <BCLASS="emphasis.bold">FPATH</B>, which is a list of directories like <BCLASS="emphasis.bold">PATH</B>.The shell looks for a file called <EMCLASS="emphasis">fname</EM>that contains the definition of function <EMCLASS="emphasis">fname</EM>in each of the directories in <BCLASS="emphasis.bold">FPATH</B>.</P><PCLASS="para">For example, assume this code is in your environment file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">FPATH=~/funcsautoload dave</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5564"></A>When you invoke the command <EMCLASS="emphasis">dave</EM>, the shell willlook in the directory <EMCLASS="emphasis">~/funcs</EM> for a file called <EMCLASS="emphasis">dave</EM> thathas the definition of function <EMCLASS="emphasis">dave</EM>.  If it doesn't find the file,or if the file exists but doesn't contain the proper function definition,the shell will complain with a &quot;not found&quot; message, just as ifthe command didn't exist at all.</P><PCLASS="para">Function autoloading and <BCLASS="emphasis.bold">FPATH</B> are also useful toolsfor system administrators who need to set up system-wideKorn shell environments.  See <ACLASS="xref"HREF="ch10_01.htm"TITLE="Korn Shell Administration">Chapter 10, Korn Shell Administration</A>.<ACLASS="indexterm"NAME="AUTOID-5572"></A></P></DIV></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch03_06.htm"TITLE="3.6 Customization Hints"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 3.6 Customization Hints"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_02.htm"TITLE="4.2 Shell Variables"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.2 Shell Variables"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">3.6 Customization Hints</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">4.2 Shell Variables</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>