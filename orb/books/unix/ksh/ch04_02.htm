<HTML><HEAD><TITLE>[Chapter 4] 4.2 Shell Variables</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:03:49Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch04_01.htm"TITLE="4. Basic Shell Programming"><LINKREL="prev"HREF="ch04_01.htm"TITLE="4.1 Shell Scripts and Functions"><LINKREL="next"HREF="ch04_03.htm"TITLE="4.3 String Operators"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_01.htm"TITLE="4.1 Shell Scripts and Functions"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.1 Shell Scripts and Functions"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 4<BR>Basic Shell Programming</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_03.htm"TITLE="4.3 String Operators"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.3 String Operators"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-4-SECT-2">4.2 Shell Variables</A></H2><PCLASS="para">A major piece of the Korn shell's programming functionality relates to shell variables.  We've already seen the basics ofvariables.  To recap briefly: they are named places to store data, usually in the form of character strings, and their values can beobtained by preceding their names with dollar signs (<BCLASS="emphasis.bold">$</B>).Certain variables, called <EMCLASS="emphasis">environment variables</EM>, are conventionallynamed in all capital letters, and their values are made known(with the <BCLASS="emphasis.bold">export</B> statement) to subprocesses.</P><PCLASS="para">If you are a programmer, you already know that just aboutevery major programming language uses variables in some way; in fact,an important way of characterizing differences between languagesis comparing their facilities for variables.  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5581"></A>The chief difference betweenthe Korn shell's variable schema and those of conventional languages is that the Korn shell's places heavy emphasis on character strings.  <ACLASS="indexterm"NAME="AUTOID-5584"></A><ACLASS="indexterm"NAME="AUTOID-5586"></A><ACLASS="indexterm"NAME="AUTOID-5588"></A><ACLASS="indexterm"NAME="AUTOID-5590"></A>(Thus it has more in common with a special-purposelanguage like SNOBOL than a general-purpose one like Pascal.)This is also true of the Bourne shell and theC shell, but the Korn shell goes beyond them by having additionalmechanisms for handling integers (explicitly) and simple arrays.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-4-SECT-2.1">4.2.1 Positional Parameters</A></H3><PCLASS="para">As we have already seen, you can define values for variableswith statements of the form <BCLASS="emphasis.bold">varname</B><BCLASS="emphasis.bold">=</B><BCLASS="emphasis.bold">value</B>, e.g.:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">fred=bob</B>$ <BCLASS="emphasis.bold">print &quot;$fred&quot;</B>bob</PRE></BLOCKQUOTE></P><PCLASS="para">Some environmentvariables are predefined by the shell when you log in.  There areother built-in variables that are vital to shell programming.We will look at a few of them now and save the others for later.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5604"></A><ACLASS="indexterm"NAME="AUTOID-5608"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-POSITIONAL-PARAMETERS"></A>The most important special, built-in variablesare called <EMCLASS="emphasis">positional parameters</EM>.These hold the command-line arguments to scripts when they areinvoked.  Positional parameters have names <BCLASS="emphasis.bold">1</B>, <BCLASS="emphasis.bold">2</B>, <BCLASS="emphasis.bold">3</B>, etc., meaning that their values are denoted by <BCLASS="emphasis.bold">$1</B>, <BCLASS="emphasis.bold">$2</B>, <BCLASS="emphasis.bold">$3</B>, etc.  There is alsoa positional parameter <BCLASS="emphasis.bold">0</B>, whose value is the name of the script(i.e., the command typed in to invoke it).  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5623"></A><ACLASS="indexterm"NAME="AUTOID-5626"></A><ACLASS="indexterm"NAME="AUTOID-5629"></A><ACLASS="indexterm"NAME="AUTOID-5632"></A>Two special variables contain all of the positional parameters(except positional parameter <BCLASS="emphasis.bold">0</B>): <CODECLASS="literal">*</CODE> and <BCLASS="emphasis.bold">@</B>.  The difference between them is subtle but important, andit's apparent only when they are within double quotes.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5639"></A><ACLASS="indexterm"NAME="AUTOID-5641"></A><CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$*</B><CODECLASS="literal">&quot;</CODE> is a single string that consists of all of the positionalparameters, separated by the first character in the environmentvariable <BCLASS="emphasis.bold">IFS</B> (internal field separator), which is a space, TAB, and NEWLINE by default.  On the other hand, <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$@</B><CODECLASS="literal">&quot;</CODE> is equal to <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$1</B><CODECLASS="literal">&quot;</CODE> <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$2</B><CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">...</B> <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$</B><EMCLASS="emphasis">N</EM><CODECLASS="literal">&quot;</CODE>,where <EMCLASS="emphasis">N</EM> is thenumber of positional parameters.  That is, it's equal to <EMCLASS="emphasis">N</EM>separate double-quoted strings, which are separated by spaces.We'll explore the ramifications of this difference in a little while.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5665"></A><ACLASS="indexterm"NAME="AUTOID-5668"></A><ACLASS="indexterm"NAME="AUTOID-5671"></A>The variable <BCLASS="emphasis.bold">#</B> holds the number of positional parameters(as a character string).All of these variables are &quot;read-only,&quot; meaning that you can'tassign new values to them within scripts.</P><PCLASS="para">For example, assume that you have the following simple shell script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">print &quot;fred: $@&quot;print &quot;$0: $1 and $2&quot;print &quot;$# arguments&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">Assume further that the script is called <EMCLASS="emphasis">fred</EM>.  Then if you type <BCLASS="emphasis.bold">fred bob dave</B>, you will see the followingoutput:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">fred: bob davefred: bob and dave2 arguments</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5684"></A>In this case, <BCLASS="emphasis.bold">$3</B>, <BCLASS="emphasis.bold">$4</B>, etc., are all unset,which means that the shell will substitute the empty(or null) string for them.[4]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] Unless the option <BCLASS="emphasis.bold">nounset</B> is turned on.</P></BLOCKQUOTE><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-4-SECT-2.1.1">4.2.1.1 Positional parameters in functions</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-POS-PARAMS-FUNCTIONS"></A><ACLASS="indexterm"NAME="AUTOID-5697"></A>Shell functions use positional parameters and special variableslike <CODECLASS="literal">*</CODE> and <BCLASS="emphasis.bold">#</B> in exactly the same way as shell scripts do.If you wanted to define <EMCLASS="emphasis">fred</EM> as a function, you could putthe following in your <EMCLASS="emphasis">.profile</EM> or environment file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function fred {    print &quot;fred: $*&quot;    print &quot;$0: $1 and $2&quot;    print &quot;$# arguments&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">You will get the same result if you type <BCLASS="emphasis.bold">fred bob dave</B>.</P><PCLASS="para">Typically, several shellfunctions are defined within a single shell script.  Thereforeeach function will need to handle its own arguments, which in turnmeans that each function needs to keep track of positional parametersseparately.  <ACLASS="indexterm"NAME="AUTOID-5709"></A>Sure enough, each function has itsown copies of these variables (even though functions don'trun in their own subshells, as scripts do); we say that such variablesare <EMCLASS="emphasis">local</EM> to the function.  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5714"></A>However, other variables defined within functions are not local[5](they are <EMCLASS="emphasis">global</EM>), meaning that their values are known throughoutthe entire shell script.  For example, assume that you have a shell script called <EMCLASS="emphasis">ascript</EM> that contains this:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] However, see the section on <BCLASS="emphasis.bold">typeset</B> in <ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6</A> for away of making variables local to functions.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function afunc {    print in function $0: $1 $2    var1=&quot;in function&quot;}var1=&quot;outside of function&quot;print var1: $var1print $0: $1 $2afunc funcarg1 funcarg2print var1: $var1print $0: $1 $2</PRE></BLOCKQUOTE></P><PCLASS="para">If you invoke this script by typing <BCLASS="emphasis.bold">ascript arg1 arg2</B>,you will see this output:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">var1: outside of functionascript: arg1 arg2in function afunc: funcarg1 funcarg2var1: in functionascript: arg1 arg2</PRE></BLOCKQUOTE></P><PCLASS="para">In other words, the function <EMCLASS="emphasis">afunc</EM> changes the value of thevariable <BCLASS="emphasis.bold">var1</B> from &quot;outside of function&quot; to &quot;in function,&quot; and that change isknown outside the function, while <BCLASS="emphasis.bold">$0</B>, <BCLASS="emphasis.bold">$1</B>, and <BCLASS="emphasis.bold">$2</B>have different values in the function and the main script.<ACLASS="xref"HREF="ch04_02.htm#KSH-CH-4-FIG-1"TITLE="Functions have their own positional parameters">Figure 4.2</A> shows this graphically.</P><H4CLASS="figure"><ACLASS="title"NAME="KSH-CH-4-FIG-1">Figure 4.2: Functions have their own positional parameters</A></H4><IMGCLASS="graphic"SRC="figs/korn0402.gif"ALT="Figure 4.2"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5740"></A>It is possible to make other variables local tofunctions by using the <BCLASS="emphasis.bold">typeset</B> command, which we'll see in<ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6</A>.<ACLASS="indexterm"NAME="AUTOID-5745"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-QUOTING-DOUBLE-QUOTES"></A>Now that we have this background, let's take a closer look at <BCLASS="emphasis.bold">&quot;$@&quot;</B> and <BCLASS="emphasis.bold">&quot;$</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">&quot;</B>.  These variablesare two of the shell's greatest idiosyncracies, so we'll discuss some of the most common sources of confusion.</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5756"></A><ACLASS="indexterm"NAME="AUTOID-5758"></A>Why are the elements of <BCLASS="emphasis.bold">&quot;$</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">&quot;</B>separated by the first character of <BCLASS="emphasis.bold">IFS</B> instead of just spaces?To give you output flexibility.  As a simple example, let's sayyou want to print a list of positional parameters separated by commas.This script would do it:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">IFS=,print $*</PRE></BLOCKQUOTE></P><PCLASS="para">Changing <BCLASS="emphasis.bold">IFS</B> in a script is fairly risky, but it's probably OKas long as nothing else in the script depends on it.  If this scriptwere called <EMCLASS="emphasis">arglist</EM>, then the command <BCLASS="emphasis.bold">arglist bob dave ed</B>would produce the output <BCLASS="emphasis.bold">bob,dave,ed</B>.  <ACLASS="xref"HREF="ch10_01.htm"TITLE="Korn Shell Administration">Chapter 10</A>containsanother example of changing <BCLASS="emphasis.bold">IFS</B>.</P></LI><LICLASS="listitem"><PCLASS="para">Why does <BCLASS="emphasis.bold">&quot;$@&quot;</B> act like <EMCLASS="emphasis">N</EM> separate double-quoted strings?To allow you to use them again as separate values.  For example,say you want to call a function within your script with the same listof positional parameters, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function countargs {    print &quot;$# args.&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">Assume your script is called with the same arguments as <EMCLASS="emphasis">arglist</EM>above.  Then if it contains the command <BCLASS="emphasis.bold">countargs</B> <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$*</B><CODECLASS="literal">&quot;</CODE>,the function will print <BCLASS="emphasis.bold">1 args</B>.  But if the command is <BCLASS="emphasis.bold">countargs</B> <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$@</B><CODECLASS="literal">&quot;</CODE>, the function will print <BCLASS="emphasis.bold">3 args</B>.</P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5793"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-4-SECT-2.2">4.2.2 More on Variable Syntax</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5797"></A>Before we show the many things you can do with shell variables,we have to make a confession: the syntaxof <BCLASS="emphasis.bold">$</B><EMCLASS="emphasis">varname</EM> for taking the value of a variable is notquite accurate.  Actually, it's the simple form of the more generalsyntax, which is <BCLASS="emphasis.bold">${</B><EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold">}</B>. </P><PCLASS="para">Why two syntaxes?  <ACLASS="indexterm"NAME="AUTOID-5807"></A>For one thing, the more general syntaxis necessary if your code refers to more than nine positional parameters: you must use <BCLASS="emphasis.bold">${10}</B> for the tenth instead of <BCLASS="emphasis.bold">$10</B>.<ACLASS="indexterm"NAME="AUTOID-5812"></A>Aside from that, consider the example, from <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A>,of setting your primary prompt variable (<BCLASS="emphasis.bold">PS1</B>) to your login name:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><BCLASS="emphasis.bold">PS1=&quot;($LOGNAME)-&gt; &quot;</B></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5819"></A>This happens to work because the right parenthesis immediatelyfollowing <BCLASS="emphasis.bold">LOGNAME</B> is &quot;special&quot; (in the sense of the special characters introduced in <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A>)so that the shell doesn'tmistake it for part of the variable name.  Now suppose that, forsome reason, you want your prompt to be your login name followedby an underscore.  If you type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><BCLASS="emphasis.bold">PS1=&quot;$LOGNAME_ &quot;</B></PRE></BLOCKQUOTE></P><PCLASS="para">then the shell will try to use &quot;LOGNAME_&quot; as the name of thevariable, i.e., to take the value of <BCLASS="emphasis.bold">$LOGNAME_</B>.  Since there isno such variable, the value defaults to <EMCLASS="emphasis">null</EM>(the empty string, &quot;&quot;), and <BCLASS="emphasis.bold">PS1</B> is set to just a single space.</P><PCLASS="para">For this reason, the full syntax for taking the value of a variableis <BCLASS="emphasis.bold">${</B><EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold">}</B>.  So if we used</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><BCLASS="emphasis.bold">PS1=&quot;${LOGNAME}_ &quot;</B></PRE></BLOCKQUOTE></P><PCLASS="para">we would get the desired <BCLASS="emphasis.bold">$</B><EMCLASS="emphasis">yourname</EM><BCLASS="emphasis.bold">_</B>.It is safe to omit the curly brackets (<BCLASS="emphasis.bold">{}</B>) if thevariable name is followed by a character that isn't a letter,digit, or underscore.</P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_01.htm"TITLE="4.1 Shell Scripts and Functions"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.1 Shell Scripts and Functions"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_03.htm"TITLE="4.3 String Operators"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.3 String Operators"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">4.1 Shell Scripts and Functions</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">4.3 String Operators</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>