<HTML><HEAD><TITLE>[Chapter 4] 4.3 String Operators</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:04:52Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch04_01.htm"TITLE="4. Basic Shell Programming"><LINKREL="prev"HREF="ch04_02.htm"TITLE="4.2 Shell Variables"><LINKREL="next"HREF="ch04_04.htm"TITLE="4.4 Command Substitution"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_02.htm"TITLE="4.2 Shell Variables"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.2 Shell Variables"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 4<BR>Basic Shell Programming</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_04.htm"TITLE="4.4 Command Substitution"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.4 Command Substitution"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-4-SECT-3">4.3 String Operators</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5845"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-STRING-OPERATORS"></A>The curly-bracket syntax allows for the shell's <EMCLASS="emphasis">string operators</EM>.String operators allow you to manipulate values ofvariables in various useful ways without having to write full-blownprograms or resort to external UNIX utilities.You can do a lot with string-handling operators even ifyou haven't yet mastered the programming featureswe'll see in later chapters.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5853"></A>In particular, string operators let youdo the following:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Ensure that variables exist (i.e., are defined and have non-null values)</P></LI><LICLASS="listitem"><PCLASS="para">Set default values for variables</P></LI><LICLASS="listitem"><PCLASS="para">Catch errors that result from variables not being set</P></LI><LICLASS="listitem"><PCLASS="para">Remove portions of variables' values that match patterns</P></LI></UL><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-4-SECT-3.1">4.3.1 Syntax of String Operators</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-STRING-OPERATORS-SYNTAX"></A>The basic idea behind the syntax of string operatorsis that special characters that denote operations are insertedbetween the variable's name and the right curly brackets.Any argument that the operator may need is inserted to the operator's right.</P><PCLASS="para">The first group of string-handling operators testsfor the existence of variables and allows substitutions ofdefault values under certain conditions.  These are listed in <ACLASS="xref"HREF="ch04_03.htm#KSH-CH-4-TAB-0"TITLE="Substitution Operators">Table 4.1</A>.[6]<ACLASS="indexterm"NAME="AUTOID-5876"></A><ACLASS="indexterm"NAME="AUTOID-5879"></A><ACLASS="indexterm"NAME="AUTOID-5882"></A><ACLASS="indexterm"NAME="AUTOID-5885"></A><ACLASS="indexterm"NAME="AUTOID-5888"></A><ACLASS="indexterm"NAME="AUTOID-5891"></A><ACLASS="indexterm"NAME="AUTOID-5894"></A><ACLASS="indexterm"NAME="AUTOID-5897"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] The colon (<CODECLASS="literal">:</CODE>) in each of these operators is actually optional.If the colon is omitted, then change &quot;exists and isn't null&quot;to &quot;exists&quot; in each definition, i.e., theoperator tests for existence only. </P></BLOCKQUOTE><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-4-TAB-0">Table 4.1: Substitution Operators</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operator</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Substitution</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">${</B><EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold">:-</B><EMCLASS="emphasis">word</EM><BCLASS="emphasis.bold">}</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">If <EMCLASS="emphasis">varname</EM> exists and isn't null, return its value;otherwise return <EMCLASS="emphasis">word</EM>.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">Purpose</B>:</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Returning a default value if the variable is undefined.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">Example</B>:</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><BCLASS="emphasis.bold">${count:-0}</B> evaluates to 0 if <BCLASS="emphasis.bold">count</B> is undefined.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">${</B><EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold">:=</B><EMCLASS="emphasis">word}</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">If <EMCLASS="emphasis">varname</EM> exists and isn't null, return its value;otherwise set it to <EMCLASS="emphasis">word</EM> and then return its value.[7]</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">Purpose</B>:</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Setting a variable to a default value if it is undefined.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">Example</B>:</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><CODECLASS="literal">$</CODE><BCLASS="emphasis.bold">{count:=0}</B> sets <BCLASS="emphasis.bold">count</B> to 0 if it is undefined.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">${</B><EMCLASS="emphasis">varname</EM><CODECLASS="literal">:?</CODE><EMCLASS="emphasis">message</EM><BCLASS="emphasis.bold">}</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">If <EMCLASS="emphasis">varname</EM> exists and isn't null, return its value;otherwise print <EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold">:</B> followed by <EMCLASS="emphasis">message</EM>,and abort the current command or script.Omitting <EMCLASS="emphasis">message</EM> produces the default message<BCLASS="emphasis.bold">parameter null or not set</B>.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">Purpose</B>:</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Catching errors that result from variables being undefined.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">Example</B>:</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><BCLASS="emphasis.bold">{count</B><CODECLASS="literal">:?&quot;</CODE><BCLASS="emphasis.bold">undefined!</B><CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">}</B>  prints <BCLASS="emphasis.bold">&quot;count: undefined!&quot;</B>and exits if <BCLASS="emphasis.bold">count</B> is undefined.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">${</B><EMCLASS="emphasis">varname</EM><CODECLASS="literal">:+</CODE><EMCLASS="emphasis">word</EM><BCLASS="emphasis.bold">}</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">If <EMCLASS="emphasis">varname</EM> exists and isn't null, return <EMCLASS="emphasis">word</EM>;otherwise return null.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">Purpose</B>:</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Testing for the existence of a variable.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">Example</B>:</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><BCLASS="emphasis.bold">${count:+1}</B> returns 1 (which could mean &quot;true&quot;) if <BCLASS="emphasis.bold">count</B> is defined.</P></TD></TR></TBODY></TABLE><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] <ACLASS="indexterm"NAME="AUTOID-5943"></A><ACLASS="indexterm"NAME="AUTOID-5945"></A><ACLASS="indexterm"NAME="AUTOID-5947"></A>Pascal, Modula, and Ada programmers may find it helpful to recognize thesimilarity of this to the assignment operators in those languages.</P></BLOCKQUOTE><PCLASS="para">The first two of these operators are ideal for setting defaults forcommand-line arguments in case the user omits them.  We'll usethe first one in our first programming task.<ACLASS="indexterm"NAME="AUTOID-6018"></A></P><DIVCLASS="task"><H4>Task 4.1</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">You have a large album collection, and you want to write somesoftware to keep track of it.  Assume that you have a file of data onhow many albums you have by each artist.  Lines in the file looklike this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">14	Bach, J.S.1	Balachander, S.21	Beatles6	Blakey, Art</PRE></BLOCKQUOTE></P><PCLASS="para">Write a program that prints the <EMCLASS="emphasis">N</EM> highest lines, i.e., the <EMCLASS="emphasis">N</EM> artistsby whom you have the most albums.  The default for <EMCLASS="emphasis">N</EM> should be 10.The program should take one argument for the name of the input fileand an optional second argument for how many lines to print.</P></BLOCKQUOTE><PCLASS="para">By far the best approach to this type of script is touse built-in UNIX utilities, combining them with I/O redirectorsand pipes.  This is the classic &quot;building-block&quot; philosophyof UNIX that is another reason for its great popularity withprogrammers.  The building-block technique lets us write a first version of the script that is only one line long:<ACLASS="indexterm"NAME="KSH-CH-4-IX-BACKSLASH-DASH"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-STRING-OPERATORS-COLON"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sort -nr $1 | head -${2:-10}</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6038"></A><ACLASS="indexterm"NAME="AUTOID-6040"></A>Here is how this works:the <EMCLASS="emphasis">sort</EM>(1) program sorts the data in the file whose nameis given as the first argument (<BCLASS="emphasis.bold">$1</B>). The <BCLASS="emphasis.bold">-n</B> option tells <EMCLASS="emphasis">sort</EM>to interpret the first word on each line as a number(instead of as a character string);the <BCLASS="emphasis.bold">-r</B> tells it to reverse the comparisons, so as to sort indescending order.</P><PCLASS="para">The outputof <EMCLASS="emphasis">sort</EM> is piped into the <EMCLASS="emphasis">head</EM>(1) utility, which, whengiven the argument <BCLASS="emphasis.bold">-</B><EMCLASS="emphasis">N</EM>, prints the first <EMCLASS="emphasis">N</EM> lines of its input onthe standard output.  The expression <BCLASS="emphasis.bold">-${2:-10}</B> evaluates to a dash (<BCLASS="emphasis.bold">-</B>)followed by the second argument if it is given, or to -10 if it's not;notice that the variable in this expression is <BCLASS="emphasis.bold">2</B>, which isthe second positional parameter.</P><PCLASS="para">Assume the script we want to write is called <EMCLASS="emphasis">highest</EM>.  Then if the user types<BCLASS="emphasis.bold">highest myfile</B>, the line that actually runs is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sort -nr myfile | head -10</PRE></BLOCKQUOTE></P><PCLASS="para">Or if the user types <BCLASS="emphasis.bold">highest myfile 22</B>, the line that runs is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sort -nr myfile | head -22</PRE></BLOCKQUOTE></P><PCLASS="para">Make sure you understand how the <BCLASS="emphasis.bold">:-</B> string operator providesa default value.</P><PCLASS="para">This is a perfectly good, runnable script-but it has a fewproblems.  First, its one line is a bit cryptic.  While thisisn't much of a problem for such a tiny script, it's notwise to write long, elaborate scripts in this manner.  A few minorchanges will make the code more readable.  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6069"></A><ACLASS="indexterm"NAME="AUTOID-6072"></A><ACLASS="indexterm"NAME="AUTOID-6074"></A>First, we can addcomments to the code; anything between # and the end ofa line is a comment.  At a minimum,the script should start with a few comment lines that indicatewhat the script does and what arguments it accepts.  Second, wecan improve the variable names by assigning the values of thepositional parameters to regular variables with mnemonic names.Finally, we can add blank lines to space things out; blank lines,like comments, are ignored.  Here is a more readable version:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">##	highest filename [howmany]##	Print howmany highest-numbered lines in file filename.#	The input file is assumed to have lines that start with#	numbers.  Default for howmany is 10.#filename=$1howmany=${2:-10}sort -nr $filename | head -$howmany</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6080"></A><ACLASS="indexterm"NAME="AUTOID-6081"></A><ACLASS="indexterm"NAME="AUTOID-6082"></A>The square brackets around <BCLASS="emphasis.bold">howmany</B> in the commentsadhere to the convention in UNIX documentationthat square brackets denote optional arguments.</P><PCLASS="para">The changes we just made improve the code's readability but not how it runs.What if the user were to invoke the script without any arguments?Remember that positional parameters defaultto null if they aren't defined.  If there are no arguments, then <BCLASS="emphasis.bold">$1</B> and <BCLASS="emphasis.bold">$2</B> are both null.The variable <BCLASS="emphasis.bold">howmany</B> (<BCLASS="emphasis.bold">$2</B>) is set up to default to 10, but there isno default for <BCLASS="emphasis.bold">filename</B> (<BCLASS="emphasis.bold">$1</B>).  The result would be that this command runs:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sort -nr | head -10</PRE></BLOCKQUOTE></P><PCLASS="para">As it happens, if <EMCLASS="emphasis">sort</EM> is called without a filename argument,it expects input to come from standard input, e.g.,  a pipe (|) or a user's terminal.  Since it doesn't have the pipe,it will expect the terminal.  This means that the script will appear to hang!Although you could always type <KBDCLASS="keycap">[CTRL-D]</KBD> or <KBDCLASS="keycap">[CTRL-C]</KBD> to get out of the script, a naiveuser might not know this.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-BACKSLASH-QUERY"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-STRING-OPERATORS-BSLASH-QUERY"></A>Therefore we need to make sure that the user supplies at leastone argument.  There are a few ways of doing this; one of theminvolves another string operator.  We'll replace the line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">filename=$1</PRE></BLOCKQUOTE></P><PCLASS="para">with:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">filename=${1:?&quot;filename missing.&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">This will cause two things to happen if a user invokes thescript without any arguments: first the shell will printthe somewhat unfortunate message:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">highest: 1: filename missing.</PRE></BLOCKQUOTE></P><PCLASS="para">to the standard error output. Second, the script will exit without running the remaining code.</P><PCLASS="para">With a somewhat &quot;kludgy&quot; modification, we canget a slightly better error message.  Consider this code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">filename=$1filename=${filename:?&quot;missing.&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">This results in the message:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">highest: filename: missing.</PRE></BLOCKQUOTE></P><PCLASS="para">(Make sure you understand why.)  Of course, there are ways of printingwhatever message is desired; we'll find out how in <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5</A>.<ACLASS="indexterm"NAME="AUTOID-6123"></A><ACLASS="indexterm"NAME="AUTOID-6124"></A></P><PCLASS="para">Before we move on, we'll look more closely at the two remainingoperators in <ACLASS="xref"HREF="ch04_03.htm#KSH-CH-4-TAB-0"TITLE="Substitution Operators">Table 4.1</A>and see how we can incorporate them intoour task solution.  <ACLASS="indexterm"NAME="KSH-CH-4-IX-BACKSLASH-EQUALS"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-STRING-OPERATORS-EQUALS"></A>The <BCLASS="emphasis.bold">:=</B> operator does roughly thesame thing as <BCLASS="emphasis.bold">:-</B>, except that it has the &quot;side effect&quot;of setting thevalue of the variable to the given word if the variable doesn't exist.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6136"></A><ACLASS="indexterm"NAME="AUTOID-6139"></A>Therefore we would like to use <BCLASS="emphasis.bold">:=</B> in our script in place of <BCLASS="emphasis.bold">:-</B>,but we can't; we'd be trying to set thevalue of a positional parameter, which is not allowed.  Butif we replaced:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">howmany=${2:-10}</PRE></BLOCKQUOTE></P><PCLASS="para">with just:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">howmany=$2</PRE></BLOCKQUOTE></P><PCLASS="para">and moved the substitution down to the actual command line (as wedid at the start), then we could use the <BCLASS="emphasis.bold">:=</B> operator:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sort -nr $filename | head -${howmany:=10}</PRE></BLOCKQUOTE></P><PCLASS="para">Using <BCLASS="emphasis.bold">:=</B> has the added benefit of setting the value of <BCLASS="emphasis.bold">howmany</B>to 10 in case we need it afterwards in later versions of the script.<ACLASS="indexterm"NAME="AUTOID-6156"></A><ACLASS="indexterm"NAME="AUTOID-6157"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-BACKSLASH-PLUS"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-STRING-OPERATORS-BSLASH-PLUS"></A>The final substitution operator is <BCLASS="emphasis.bold">:+</B>.  Here is how we can use itin our example:  Let's say we want to give the user the option ofadding a header line to the script's output.  If he or she typesthe option <BCLASS="emphasis.bold">-h</B>, then the output will be preceded by the line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">ALBUMS  ARTIST</PRE></BLOCKQUOTE></P><PCLASS="para">Assume further that this option ends up in the variable <BCLASS="emphasis.bold">header</B>,i.e., <BCLASS="emphasis.bold">$header</B> is <BCLASS="emphasis.bold">-h</B> if the option is set or null if not.(Later we will see how to do this without disturbing the otherpositional parameters.)</P><PCLASS="para">The expression: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">${header:+&quot;ALBUMS  ARTIST\n&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">yields null if the variable <BCLASS="emphasis.bold">header</B> is null,or <BCLASS="emphasis.bold"><SPANCLASS="acronym">ALBUMS  ARTIST</SPAN>\n</B> if it is non-null.  <ACLASS="indexterm"NAME="AUTOID-6180"></A>This means that we can put the line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">print -n ${header:+&quot;ALBUMS  ARTIST\n&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">right before the command line that does the actual work.   The <BCLASS="emphasis.bold">-n</B> option to <BCLASS="emphasis.bold">print</B>causes it <EMCLASS="emphasis">not</EM> to print a LINEFEED after printing itsarguments.  Therefore this <BCLASS="emphasis.bold">print</B> statement will print nothing-not even a blank line-if <BCLASS="emphasis.bold">header</B> is null; otherwise it will print the header lineand a LINEFEED (\n).<ACLASS="indexterm"NAME="AUTOID-6192"></A><ACLASS="indexterm"NAME="AUTOID-6193"></A><ACLASS="indexterm"NAME="AUTOID-6194"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-4-SECT-3.2">4.3.2 Patterns and Regular Expressions</A></H3><PCLASS="para">We'll continue refining our solution to Task 4-1 later in this chapter.The next type of string operator is used to match portions of avariable's string value against <EMCLASS="emphasis">patterns</EM>.  Patterns, as we saw in <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A> are strings that can containwildcard characters (<CODECLASS="literal">*</CODE>, <CODECLASS="literal">?</CODE>, and <BCLASS="emphasis.bold">[]</B> for character sets and ranges).</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6204"></A><ACLASS="indexterm"NAME="AUTOID-6208"></A>Wildcards have been standard features of all UNIX shells goingback (at least) to the Version 6 Bourne shell.  But the Korn shellis the first shell to add to their capabilities.  <ACLASS="indexterm"NAME="KSH-CH-4-IX-REGULAR-EXPRESSIONS"></A><ACLASS="indexterm"NAME="AUTOID-6212"></A><ACLASS="indexterm"NAME="AUTOID-6214"></A><ACLASS="indexterm"NAME="AUTOID-6216"></A><ACLASS="indexterm"NAME="AUTOID-6218"></A><ACLASS="indexterm"NAME="AUTOID-6220"></A><ACLASS="indexterm"NAME="AUTOID-6222"></A>It adds a setof operators, called <EMCLASS="emphasis">regular expression</EM> (or <EMCLASS="emphasis">regexp</EM> for short)operators,that give it much of the string-matching power of advanced UNIX utilitieslike <EMCLASS="emphasis">awk</EM>(1),<EMCLASS="emphasis">egrep</EM>(1) (extended <EMCLASS="emphasis">grep</EM>(1)) and the <EMCLASS="emphasis">emacs</EM> editor,albeit with a different syntax.  These capabilities go beyond thosethat you may be used to in other UNIX utilities like <EMCLASS="emphasis">grep</EM>,<EMCLASS="emphasis">sed</EM>(1) and <EMCLASS="emphasis">vi</EM>(1).</P><PCLASS="para">Advanced UNIX users will find the Korn shell's regular expressioncapabilities occasionally useful for script writing, although they border on overkill.  (Part of the problem is the inevitablesyntactic clash with the shell's myriad other special characters.)Therefore we won't go into great detail about regular expressions here.For more comprehensive information, the &quot;last word&quot;on practical regular expressions in UNIX is <EMCLASS="emphasis">sed &amp; awk</EM>, an O'Reilly Nutshell Handbook by Dale Dougherty.If you are already comfortable with <EMCLASS="emphasis">awk</EM> or <EMCLASS="emphasis">egrep</EM>, youmay want to skip the following introductory section and go to &quot;Korn Shell Versus awk/egrep Regular Expressions&quot; below,where we explain the shell's regular expression mechanism bycomparing it with the syntax used in those two utilities.Otherwise, read on.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-4-SECT-3.2.1">4.3.2.1 Regular expression basics</A></H4><PCLASS="para">Think of regular expressions as strings that match patternsmore powerfully than the standard shell wildcard schema.Regular expressions began as an idea in theoretical computerscience, but they have found their way into many nooks and crannies ofeveryday, practical computing.  The syntax used to represent themmay vary, but the concepts are very much the same.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-REGEXPS-SYNTAX"></A>A shell regular expression can contain regular characters, standardwildcard characters, and additional operators that are more powerful than wildcards.  Each such operatorhas the form <EMCLASS="emphasis">x</EM>(<EMCLASS="emphasis">exp</EM><BCLASS="emphasis.bold">)</B>, where <EMCLASS="emphasis">x</EM> is the particularoperator and <EMCLASS="emphasis">exp</EM> is any regular expression (often simplya regular string).  The operator determines how many occurrencesof <EMCLASS="emphasis">exp</EM> a string that matches the pattern can contain.See <ACLASS="xref"HREF="ch04_03.htm#KSH-CH-4-TAB-1"TITLE="Regular Expression Operators">Table 4.2</A> and <ACLASS="xref"HREF="ch04_03.htm#KSH-CH-4-TAB-2"TITLE="Regular Expression Operator Examples">Table 4.3</A>.<ACLASS="indexterm"NAME="AUTOID-6252"></A><ACLASS="indexterm"NAME="AUTOID-6255"></A><ACLASS="indexterm"NAME="AUTOID-6258"></A><ACLASS="indexterm"NAME="AUTOID-6261"></A><ACLASS="indexterm"NAME="AUTOID-6264"></A><ACLASS="indexterm"NAME="AUTOID-6267"></A><ACLASS="indexterm"NAME="AUTOID-6270"></A><ACLASS="indexterm"NAME="AUTOID-6273"></A><ACLASS="indexterm"NAME="AUTOID-6276"></A><ACLASS="indexterm"NAME="AUTOID-6279"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-4-TAB-1">Table 4.2: Regular Expression Operators</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operator</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">*</CODE>(<EMCLASS="emphasis">exp</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">0 or more occurrences of <EMCLASS="emphasis">exp</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">+</CODE>(<EMCLASS="emphasis">exp</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">1 or more occurrences of <EMCLASS="emphasis">exp</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">?</CODE>(<EMCLASS="emphasis">exp</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">0 or 1 occurrences of <EMCLASS="emphasis">exp</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">@</B>(<EMCLASS="emphasis">exp1</EM>|<EMCLASS="emphasis">exp2</EM>|...)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">exp1</EM> or <EMCLASS="emphasis">exp2</EM> or...</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">!</B>(<EMCLASS="emphasis">exp</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Anything that doesn't match <EMCLASS="emphasis">exp</EM>[8]</P></TD></TR></TBODY></TABLE><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] Actually, <BCLASS="emphasis.bold">!(</B><EMCLASS="emphasis">exp</EM>) is not a regular expression operator by the standard technical definition, though it is a handy extension.</P></BLOCKQUOTE><ACLASS="indexterm"NAME="AUTOID-6327"></A><ACLASS="indexterm"NAME="AUTOID-6328"></A><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-4-TAB-2">Table 4.3: Regular Expression Operator Examples</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Expression</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Matches</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">x</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">x</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">*</CODE>(<EMCLASS="emphasis">x</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Null string, <EMCLASS="emphasis">x</EM>, <EMCLASS="emphasis">xx</EM>, <EMCLASS="emphasis">xxx</EM>, ...</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">+</CODE>(<EMCLASS="emphasis">x</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">x</EM>, <EMCLASS="emphasis">xx</EM>, <EMCLASS="emphasis">xxx</EM>, ...</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">?</CODE>(<EMCLASS="emphasis">x</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Null string, <EMCLASS="emphasis">x</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">!</CODE>(<EMCLASS="emphasis">x</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any string except <EMCLASS="emphasis">x</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">@</CODE>(<EMCLASS="emphasis">x</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">x</EM> (see below)</TD></TR></TBODY></TABLE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6379"></A>Regular expressions are extremely useful when dealing with arbitrarytext, as you already know if you have used <EMCLASS="emphasis">grep</EM> or theregular-expression capabilities of any UNIX editor.  They aren'tnearly as useful for matching filenames and other simpletypes of information with which shell users typically work.<ACLASS="indexterm"NAME="AUTOID-6382"></A>Furthermore, most things you can do with the shell's regularexpression operators can also be done (though possibly with morekeystrokes and less efficiency) by piping the output of a shellcommand through <EMCLASS="emphasis">grep</EM> or <EMCLASS="emphasis">egrep</EM>.</P><PCLASS="para">Nevertheless, here are a few examples of how shell regularexpressions can solve filename-listing problems.  Some ofthese will come in handy in later chapters as pieces of solutionsto larger tasks.</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6390"></A>The <EMCLASS="emphasis">emacs</EM> editor supports customization files whose namesend in <EMCLASS="emphasis">.el</EM> (for Emacs LISP) or <EMCLASS="emphasis">.elc</EM> (for Emacs LISP Compiled).List all <EMCLASS="emphasis">emacs</EM> customization files in the current directory.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6398"></A>In a directory of C source code, list all files that are notnecessary.  Assume that &quot;necessary&quot; files end in <EMCLASS="emphasis">.c</EM> or <EMCLASS="emphasis">.h</EM>, orare named <EMCLASS="emphasis">Makefile</EM> or <EMCLASS="emphasis">README</EM>.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6406"></A>Filenames in the VAX/VMS operating systemend in a semicolon followed by a versionnumber, e.g., <EMCLASS="emphasis">fred.bob;23</EM>.  List all VAX/VMS-stylefilenames in the current directory.</P></LI></OL><PCLASS="para">Here are the solutions:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6413"></A><ACLASS="indexterm"NAME="AUTOID-6416"></A>In the first of these, we are looking for files that end in <EMCLASS="emphasis">.el</EM>with an optional <EMCLASS="emphasis">c</EM>.  The expression that matches this is <BCLASS="emphasis.bold"><CODECLASS="literal">*</CODE>.el<CODECLASS="literal">?</CODE>(c)</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6426"></A><ACLASS="indexterm"NAME="AUTOID-6429"></A>The second example depends on the four standard subexpressions <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">.c</B>, <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">.h</B>, <BCLASS="emphasis.bold">Makefile</B>, and <BCLASS="emphasis.bold">README</B>.  The entire expression is <BCLASS="emphasis.bold">!(</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">.c|</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">.h|Makefile|README)</B>, which matches anythingthat does not match any of the four possibilities.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6445"></A><ACLASS="indexterm"NAME="AUTOID-6448"></A>The solution to the third example starts with <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">\</B><CODECLASS="literal">;</CODE>: the shellwildcard <CODECLASS="literal">*</CODE> followed by a backslash-escaped semicolon.  Then, we could usethe regular expression <BCLASS="emphasis.bold">+([0-9])</B>, which matches one or morecharacters in the range <BCLASS="emphasis.bold">[0-9]</B>, i.e., one or more digits.This is almost correct (and probably close enough), but it doesn'ttake into account that the first digit cannot be 0.  <ACLASS="indexterm"NAME="AUTOID-6457"></A><ACLASS="indexterm"NAME="AUTOID-6460"></A>Therefore the correct expression is <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">\;[1-9]</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">([0-9])</B>, which matchesanything that ends with a semicolon, a digit from 1 to 9, and<EMCLASS="emphasis">zero</EM> or more digits from 0 to 9.</P></LI></OL><PCLASS="para">Regular expression operators are an interesting addition to the Kornshell's features, but you can get along well without them-evenif you intend to do a substantial amount of shell programming.</P><PCLASS="para">In our opinion, the shell's authors missed an opportunity to buildinto the wildcard mechanism the ability to match files by <EMCLASS="emphasis">type</EM>(regular, directory, executable, etc., as in some of the conditionaltests we will see in <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5</A>) as well as by name component.We feel that shell programmers would have found this more useful thanarcane regular expression operators.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-REGEXPS-VS-AWK-EGREP"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-AWK"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-EGREP"></A>The following section compares Korn shell regular expressions to analogous features in <EMCLASS="emphasis">awk</EM> and <EMCLASS="emphasis">egrep</EM>.  If you aren't familiarwith these, skip to the section entitled &quot;Pattern-matching Operators.&quot; </P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-4-SECT-3.2.2">4.3.2.2 Korn shell versus awk/egrep regular expressions</A></H4><PCLASS="para"><ACLASS="xref"HREF="ch04_03.htm#KSH-CH-4-TAB-3"TITLE="Shell Versus egrep/awk Regular Expression Operators">Table 4.4</A>is an expansion of <ACLASS="xref"HREF="ch04_03.htm#KSH-CH-4-TAB-1"TITLE="Regular Expression Operators">Table 4.2</A>: the middle column showsthe equivalents in <EMCLASS="emphasis">awk</EM>/<EMCLASS="emphasis">egrep</EM> of the shell's regularexpression operators.  <ACLASS="indexterm"NAME="AUTOID-6489"></A><ACLASS="indexterm"NAME="AUTOID-6492"></A><ACLASS="indexterm"NAME="AUTOID-6495"></A><ACLASS="indexterm"NAME="AUTOID-6498"></A><ACLASS="indexterm"NAME="AUTOID-6501"></A><ACLASS="indexterm"NAME="AUTOID-6504"></A><ACLASS="indexterm"NAME="AUTOID-6507"></A><ACLASS="indexterm"NAME="AUTOID-6510"></A><ACLASS="indexterm"NAME="AUTOID-6513"></A><ACLASS="indexterm"NAME="AUTOID-6516"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-4-TAB-3">Table 4.4: Shell Versus egrep/awk Regular Expression Operators</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Korn Shell</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">egrep/awk</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">*</CODE>(<EMCLASS="emphasis">exp</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">exp</EM><CODECLASS="literal">*</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">0 or more occurrences of <EMCLASS="emphasis">exp</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">+(<EMCLASS="emphasis">exp</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">exp</EM>+</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">1 or more occurrences of <EMCLASS="emphasis">exp</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">?</CODE>(<EMCLASS="emphasis">exp</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">exp</EM><CODECLASS="literal">?</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">0 or 1 occurrences of <EMCLASS="emphasis">exp</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">@(<EMCLASS="emphasis">exp1</EM>|<EMCLASS="emphasis">exp2</EM>|...)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">exp1</EM>|<EMCLASS="emphasis">exp2</EM>|...</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">exp1</EM> or <EMCLASS="emphasis">exp2</EM> or...</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">!</B>(<EMCLASS="emphasis">exp</EM>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">(none)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Anything that doesn't match <EMCLASS="emphasis">exp</EM></TD></TR></TBODY></TABLE><PCLASS="para">These equivalents are close but not quite exact.Actually, an <EMCLASS="emphasis">exp</EM> within any of the Korn shell operators can be a series of<EMCLASS="emphasis">exp1</EM>|<EMCLASS="emphasis">exp2</EM>|... alternates.  But because the shell would interpretan expression like <BCLASS="emphasis.bold">dave|fred|bob</B>as a pipeline of commands, you must use <BCLASS="emphasis.bold">@(dave|fred|bob)</B>for alternates by themselves.</P><PCLASS="para">For example:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">@(dave|fred|bob)</B> matches <BCLASS="emphasis.bold">dave</B>, <BCLASS="emphasis.bold">fred</B>, or <BCLASS="emphasis.bold">bob</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">(dave|fred|bob)</B> means, &quot;0 or more occurrencesof <BCLASS="emphasis.bold">dave</B>, <BCLASS="emphasis.bold">fred</B>, or <BCLASS="emphasis.bold">bob</B>&quot;.  This expression matches strings likethe null string, <BCLASS="emphasis.bold">dave</B>, <BCLASS="emphasis.bold">davedave</B>, <BCLASS="emphasis.bold">fred</B>, <BCLASS="emphasis.bold">bobfred</B>, <BCLASS="emphasis.bold">bobbobdavefredbobfred</B>, etc.  </P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">+(dave|fred|bob)</B> matches any of the above except the null string.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">?(dave|fred|bob)</B> matches the null string, <BCLASS="emphasis.bold">dave</B>, <BCLASS="emphasis.bold">fred</B>, or <BCLASS="emphasis.bold">bob</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">!(dave|fred|bob)</B> matches anything except <BCLASS="emphasis.bold">dave</B>, <BCLASS="emphasis.bold">fred</B>, or<BCLASS="emphasis.bold">bob</B>.</P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6612"></A><ACLASS="indexterm"NAME="AUTOID-6613"></A><ACLASS="indexterm"NAME="AUTOID-6614"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6616"></A>It is worth re-emphasizing that shell regular expressions can stillcontain standard shell wildcards.  <ACLASS="indexterm"NAME="AUTOID-6619"></A><ACLASS="indexterm"NAME="AUTOID-6622"></A><ACLASS="indexterm"NAME="AUTOID-6625"></A><ACLASS="indexterm"NAME="AUTOID-6627"></A>Thus, the shell wildcard <BCLASS="emphasis.bold">?</B>(match any single character) is the equivalent to <BCLASS="emphasis.bold">.</B> in<EMCLASS="emphasis">egrep</EM> or <EMCLASS="emphasis">awk</EM>, and the shell's character set operator<BCLASS="emphasis.bold">[</B>...<BCLASS="emphasis.bold">]</B> is the same as in those utilities.[9]<ACLASS="indexterm"NAME="AUTOID-6650"></A><ACLASS="indexterm"NAME="AUTOID-6653"></A><ACLASS="indexterm"NAME="AUTOID-6656"></A><ACLASS="indexterm"NAME="AUTOID-6659"></A>For example, the expression <BCLASS="emphasis.bold">+([0-9])</B> matches a number, i.e., one or more digits.  The shell wildcard character <CODECLASS="literal">*</CODE> is equivalentto the shell regular expression <CODECLASS="literal">*</CODE>(<CODECLASS="literal">?)</CODE>.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] <ACLASS="indexterm"NAME="AUTOID-6638"></A><ACLASS="indexterm"NAME="AUTOID-6640"></A><ACLASS="indexterm"NAME="AUTOID-6642"></A><ACLASS="indexterm"NAME="AUTOID-6644"></A>And, for that matter, the same as in<EMCLASS="emphasis">grep</EM>, <EMCLASS="emphasis">sed</EM>, <EMCLASS="emphasis">ed</EM>, <EMCLASS="emphasis">vi</EM>, etc.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6667"></A><ACLASS="indexterm"NAME="AUTOID-6669"></A>A few <EMCLASS="emphasis">egrep</EM> and <EMCLASS="emphasis">awk</EM> regexp operators do not have equivalentsin the Korn shell.  These include:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">The beginning- and end-of-line operators <BCLASS="emphasis.bold">^</B> and <BCLASS="emphasis.bold">$</B>.</P></LI><LICLASS="listitem"><PCLASS="para">The beginning- and end-of-word operators <BCLASS="emphasis.bold">\&lt;</B> and <BCLASS="emphasis.bold">\&gt;</B>.</P></LI><LICLASS="listitem"><PCLASS="para">Repeat factors like <BCLASS="emphasis.bold">\{</B><EMCLASS="emphasis">N</EM><BCLASS="emphasis.bold">\}</B> and <BCLASS="emphasis.bold">\{</B><EMCLASS="emphasis">M</EM><BCLASS="emphasis.bold">,</B><EMCLASS="emphasis">N</EM><BCLASS="emphasis.bold">\}</B>.</P></LI></UL><PCLASS="para">The first two pairs are hardly necessary, since the Korn shell doesn'tnormally operate on text files and does parse strings into words itself.<ACLASS="indexterm"NAME="AUTOID-6693"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-4-SECT-3.3">4.3.3 Pattern-matching Operators</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-PATMATCH-OPERATORS"></A><ACLASS="indexterm"NAME="AUTOID-6699"></A><ACLASS="xref"HREF="ch04_03.htm#KSH-CH-4-TAB-4"TITLE="Pattern-matching Operators">Table 4.5</A>lists the Korn shell's pattern-matching operators.<ACLASS="indexterm"NAME="KSH-CH-4-IX-PATMATCH-OPERATORS-SYNTAX"></A><ACLASS="indexterm"NAME="AUTOID-6707"></A><ACLASS="indexterm"NAME="AUTOID-6710"></A><ACLASS="indexterm"NAME="AUTOID-6713"></A><ACLASS="indexterm"NAME="AUTOID-6716"></A><ACLASS="indexterm"NAME="AUTOID-6719"></A><ACLASS="indexterm"NAME="AUTOID-6722"></A><ACLASS="indexterm"NAME="AUTOID-6725"></A><ACLASS="indexterm"NAME="AUTOID-6728"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-4-TAB-4">Table 4.5: Pattern-matching Operators</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operator</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">$</B>{<EMCLASS="emphasis">variable</EM>#<EMCLASS="emphasis">pattern</EM>}</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">If the pattern matches the beginning of the variable's value,delete the shortest part that matches and return the rest.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">$</B>{<BCLASS="emphasis.bold">variable</B>##<EMCLASS="emphasis">pattern</EM>}</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">If the pattern matches the beginning of the variable's value,delete the longest part that matches and return the rest.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">$</B>{<BCLASS="emphasis.bold">variable</B>%<EMCLASS="emphasis">pattern</EM>}</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">If the pattern matches the end of the variable's value,delete the shortest part that matches and return the rest.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">$</B>{<EMCLASS="emphasis">variable</EM>%%<EMCLASS="emphasis">pattern</EM>}</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">If the pattern matches the end of the variable's value,delete the longest part that matches and return the rest.</P></TD></TR></TBODY></TABLE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6768"></A></P><PCLASS="para">These can be hard to remember, so here's a handy mnemonicdevice: <BCLASS="emphasis.bold">#</B> matches the front because number signs <EMCLASS="emphasis">precede</EM>numbers; <BCLASS="emphasis.bold">%</B> matches the rear because percent signs <EMCLASS="emphasis">follow</EM>numbers.</P><PCLASS="para">The classic use for pattern-matching operators is in strippingoff components of pathnames, such as directory prefixes and filename suffixes.With that in mind,here is an example that shows how all of the operators work.Assume that the variable <BCLASS="emphasis.bold">path</B> has the value<EMCLASS="emphasis">/home /billr/mem/long.file.name</EM>; then:<ACLASS="indexterm"NAME="AUTOID-6777"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><BCLASS="emphasis.bold">Expression         	  Result</B>${path##/*/}                       long.file.name${path#/*/}              billr/mem/long.file.name$path              /home/billr/mem/long.file.name${path%.*}         /home/billr/mem/long.file${path%%.*}        /home/billr/mem/long</PRE></BLOCKQUOTE></P><PCLASS="para">The two patterns used here are <CODECLASS="literal">/*/</CODE>, which matches anything betweentwo slashes, and <BCLASS="emphasis.bold">.</B><CODECLASS="literal">*</CODE>, which matches a dot followed by anything.</P><PCLASS="para">We will incorporate one of these operators into our nextprogramming task.</P><DIVCLASS="task"><H4>Task 4.2</H4><BLOCKQUOTECLASS="taskinfo"><ACLASS="indexterm"NAME="AUTOID-6790"></A><PCLASS="para">You are writing a C compiler, and you want to use the Korn shell foryour front-end.[10]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[10] Don't laugh-many UNIX compilers have shell scripts as front-ends.</P></BLOCKQUOTE></BLOCKQUOTE><PCLASS="para">Think of a C compiler as a pipeline of data processingcomponents. C source code is input to the beginning of the pipeline,and object code comes out of the end; there are several steps in between.The shell script's task, among many other things, is to control theflow of data through the components and to designate output files.</P><PCLASS="para">You need to write the part of the script that takes the name of theinput C source file and creates from it the name of the outputobject code file. That is, you must take a filename ending in <EMCLASS="emphasis">.c</EM>and create a filename that is similar except that it ends in <EMCLASS="emphasis">.o</EM>.</P><PCLASS="para">The task at hand is to strip the <EMCLASS="emphasis">.c</EM> off the filename and append <EMCLASS="emphasis">.o</EM>. A single shell statement will do it:<ACLASS="indexterm"NAME="KSH-CH-4-IX-PERCENT-PATMATCH-OPERATOR"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-PATMATCH-OPERATORS-PERCENT"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">objname=${filename%.c}.o</PRE></BLOCKQUOTE></P><PCLASS="para">This tells the shell to look at the end of <BCLASS="emphasis.bold">filename</B> for <EMCLASS="emphasis">.c</EM>. If there is a match,return <BCLASS="emphasis.bold">$filename</B> with the match deleted. So if <BCLASS="emphasis.bold">filename</B>had the value <BCLASS="emphasis.bold">fred.c</B>, the expression <BCLASS="emphasis.bold">${filename%.c}</B> wouldreturn <BCLASS="emphasis.bold">fred</B>. The <EMCLASS="emphasis">.o</EM> is appended to make the desired <BCLASS="emphasis.bold">fred.o</B>,which is stored in the variable <BCLASS="emphasis.bold">objname</B>.</P><PCLASS="para">If <BCLASS="emphasis.bold">filename</B> had an inappropriate value (without <EMCLASS="emphasis">.c</EM>)such as <BCLASS="emphasis.bold">fred.a</B>,the above expression would evaluate to <BCLASS="emphasis.bold">fred.a.o</B>: since there wasno match, nothing is deleted from the value of <BCLASS="emphasis.bold">filename</B>, and <EMCLASS="emphasis">.o</EM> is appended anyway.  <ACLASS="indexterm"NAME="AUTOID-6828"></A>And, if <BCLASS="emphasis.bold">filename</B> contained morethan one dot-e.g., if it were the <EMCLASS="emphasis">y.tab.c</EM> that is so infamousamong compiler writers-the expression would still produce the desired<EMCLASS="emphasis">y.tab.o</EM>.<ACLASS="indexterm"NAME="AUTOID-6833"></A><ACLASS="indexterm"NAME="AUTOID-6836"></A>Notice that this would not be true if we used <BCLASS="emphasis.bold">%%</B> in the expressioninstead of <BCLASS="emphasis.bold">%</B>.  <ACLASS="indexterm"NAME="AUTOID-6841"></A><ACLASS="indexterm"NAME="AUTOID-6842"></A>The former operator uses the longest matchinstead of the shortest, so it would match <EMCLASS="emphasis">.tab.o</EM> andevaluate to <BCLASS="emphasis.bold">y.o</B> rather than<BCLASS="emphasis.bold">y.tab.o</B>. So the single <BCLASS="emphasis.bold">%</B> is correct in this case.  </P><PCLASS="para">A longest-match deletion would be preferable, however, in the following task.</P></DIV><DIVCLASS="task"><H4>Task 4.3</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">You are implementing a filter that prepares a text file for printer output. You want to put the file's name-withoutany directory prefix-on the &quot;banner&quot; page.Assume that, in your script, you have the pathname of the fileto be printed stored in the variable <BCLASS="emphasis.bold">pathname</B>.</P></BLOCKQUOTE><ACLASS="indexterm"NAME="KSH-CH-4-IX-POUNDS-PATMATCH-OPERATOR"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-PATMATCH-OPERATORS-POUNDS"></A><PCLASS="para">Clearly the objective is to remove the directory prefix from the pathname.The following line will do it:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">bannername=${pathname##*/}</PRE></BLOCKQUOTE></P><PCLASS="para">This solution is similar to the first line in the examples shown before.If <BCLASS="emphasis.bold">pathname</B> were just a filename, the pattern <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">/</B> (anythingfollowed by a slash) would not match and the value of the expressionwould be <BCLASS="emphasis.bold">pathname</B> untouched. If <BCLASS="emphasis.bold">pathname</B> were something like<EMCLASS="emphasis">fred/bob</EM>, the prefix <EMCLASS="emphasis">fred/</EM> would match the pattern and be deleted,leaving just <BCLASS="emphasis.bold">bob</B> as the expression's value. The same thing wouldhappen if <BCLASS="emphasis.bold">pathname</B> were something like <EMCLASS="emphasis">/dave/pete/fred/bob</EM>:since the <BCLASS="emphasis.bold">##</B> deletes the longest match, it deletes the entire <EMCLASS="emphasis">/dave/pete/fred/</EM>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6875"></A><ACLASS="indexterm"NAME="AUTOID-6878"></A>If we used <BCLASS="emphasis.bold">#</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">/</B> instead of <BCLASS="emphasis.bold">##</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">/</B>, the expressionwould have the incorrect value <EMCLASS="emphasis">dave/pete/fred/bob</EM>, because theshortest instance of &quot;anything followed by a slash&quot; at the beginningof the string is just a slash (<BCLASS="emphasis.bold">/</B>).</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6890"></A>The construct <BCLASS="emphasis.bold">$</B>{<EMCLASS="emphasis">variable</EM><BCLASS="emphasis.bold">##</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">/}</B> is actually equivalentto the UNIX utility <EMCLASS="emphasis">basename</EM>(1).  <ACLASS="indexterm"NAME="AUTOID-6898"></A><ACLASS="indexterm"NAME="AUTOID-6899"></A><EMCLASS="emphasis">basename</EM> takes a pathnameas argument and returns the filename only; it is meant to be usedwith the shell's command substitution mechanism (see below). <EMCLASS="emphasis">basename</EM> isless efficient than <BCLASS="emphasis.bold">$</B>{<EMCLASS="emphasis">variable</EM><BCLASS="emphasis.bold">##/</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">}</B> because it runs in its own separate process rather thanwithin the shell.  <ACLASS="indexterm"NAME="AUTOID-6907"></A><ACLASS="indexterm"NAME="AUTOID-6909"></A><ACLASS="indexterm"NAME="AUTOID-6912"></A>Another utility, <EMCLASS="emphasis">dirname</EM>(1), does essentiallythe opposite of <EMCLASS="emphasis">basename</EM>: it returns the directory prefix only.It is equivalent to the Korn shell expression <BCLASS="emphasis.bold">$</B>{<EMCLASS="emphasis">variable</EM><BCLASS="emphasis.bold">%/</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">}</B>and is less efficient for the same reason.</P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-4-SECT-3.4">4.3.4 Length Operator</A></H3><PCLASS="para">There are two remaining operators on variables.  <ACLASS="indexterm"NAME="AUTOID-6925"></A><ACLASS="indexterm"NAME="AUTOID-6928"></A>One is <BCLASS="emphasis.bold">$</B>{#<EMCLASS="emphasis">varname</EM>}, whichreturns the length of the value of the variable as a characterstring. (In <ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6</A> we will see how to treat thisand similar values as actual numbers so they can be used in arithmetic expressions.) For example,if <BCLASS="emphasis.bold">filename</B> has the value <BCLASS="emphasis.bold">fred.c</B>, then <BCLASS="emphasis.bold">${#filename}</B> would have the value <BCLASS="emphasis.bold">6</B>.  The other operator (<BCLASS="emphasis.bold">$</B>{#<EMCLASS="emphasis">array</EM><BCLASS="emphasis.bold">[</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">]}</B>) has to do with array variables, which are also discussed in <ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6</A>.</P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_02.htm"TITLE="4.2 Shell Variables"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.2 Shell Variables"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_04.htm"TITLE="4.4 Command Substitution"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.4 Command Substitution"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">4.2 Shell Variables</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">4.4 Command Substitution</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>