<HTML><HEAD><TITLE>[Chapter 4] 4.4 Command Substitution</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:06:12Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch04_01.htm"TITLE="4. Basic Shell Programming"><LINKREL="prev"HREF="ch04_03.htm"TITLE="4.3 String Operators"><LINKREL="next"HREF="ch04_05.htm"TITLE="4.5 Advanced Examples: pushd and popd"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_03.htm"TITLE="4.3 String Operators"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.3 String Operators"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 4<BR>Basic Shell Programming</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_05.htm"TITLE="4.5 Advanced Examples: pushd and popd"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.5 Advanced Examples: pushd and popd"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-4-SECT-4">4.4 Command Substitution</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-COMMAND-SUBSTITUTION"></A>From the discussion so far, we've seen two ways of getting values into variables: by assignmentstatements and by the user supplying them as command-linearguments (positional parameters). There is another way:<EMCLASS="emphasis">command substitution</EM>, which allows you to use thestandard output of a command as if it were the value of a variable.You will soon see how powerful this feature is.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6951"></A>The syntax of command substitution is:[11]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[11] <ACLASS="indexterm"NAME="AUTOID-6956"></A><ACLASS="indexterm"NAME="AUTOID-6958"></A><ACLASS="indexterm"NAME="AUTOID-6960"></A>Bourne and C shell users should note that the command substitutionsyntax of those shells, <CODECLASS="literal">`</CODE><EMCLASS="emphasis">UNIX command</EM><CODECLASS="literal">`</CODE> (with backwardquotes, a.k.a. grave accents), is also supported by the Kornshell for backward compatibility reasons. However, Korn shell documentationconsiders this syntax archaic. It is harder to read and lessconducive to nesting.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$(<EMCLASS="emphasis">UNIX command</EM>)</PRE></BLOCKQUOTE></P><PCLASS="para">The command inside the parenthesis is run, andanything the command writes to standard output is returned asthe value of the expression.  These constructs can be nested, i.e., the UNIX commandcan contain command substitutions.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6971"></A>Here are some simple examples:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">The value of <BCLASS="emphasis.bold">$(pwd</B>) is the current directory(same as the environment variable <BCLASS="emphasis.bold">$PWD</B>).</P></LI><LICLASS="listitem"><PCLASS="para">The value of <BCLASS="emphasis.bold">$(ls)</B> is the names of all files in thecurrent directory, separated by NEWLINEs.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6984"></A>To find out detailed information about a command if you don'tknow where its file resides, type <BCLASS="emphasis.bold">ls -l $(whence -p</B> <EMCLASS="emphasis">command</EM>).The <BCLASS="emphasis.bold">-p</B> option forces <BCLASS="emphasis.bold">whence</B> to do a pathname lookupand not consider keywords, built-ins, etc.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6993"></A>To get the contents of a file into a variable, you can use <EMCLASS="emphasis">varname</EM><BCLASS="emphasis.bold">=$(&lt; </B><EMCLASS="emphasis">filename</EM>).<BCLASS="emphasis.bold">$(cat</B> <EMCLASS="emphasis">filename</EM>) will do the same thing, butthe shell catches the former as a built-in shorthand andruns it more efficiently.  </P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7003"></A><ACLASS="indexterm"NAME="AUTOID-7005"></A>If you want to edit (with <EMCLASS="emphasis">emacs</EM>) every chapter of your book on the Korn shell that has the phrase &quot;command substitution,&quot; assuming that your chapter files all begin with <EMCLASS="emphasis">ch</EM>, you could type: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><BCLASS="emphasis.bold">emacs $(grep -l 'command substitution' ch</B><CODECLASS="literal">*</CODE>)</PRE></BLOCKQUOTE></P><PCLASS="para">The <BCLASS="emphasis.bold">-l</B> option to <EMCLASS="emphasis">grep</EM> prints only the names of filesthat contain matches.</P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7018"></A>Command substitution, like variable and tilde expansion, is donewithin double quotes. Therefore, our rule in <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A> and <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A>,about using single quotes for strings unless they contain variableswill now be extended: &quot;When in doubt, use single quotes, unlessthe string contains variables or command substitutions, in whichcase use double quotes.&quot;</P><PCLASS="para">You will undoubtedly think of many ways to use commandsubstitution as you gain experience with the Korn shell.One that is a bit more complex than those mentioned previously relatesto a customization task that wesaw in <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A>: personalizing your prompt string.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-PROMPTS-CUSTOM-MACHINE-NAME"></A><ACLASS="indexterm"NAME="AUTOID-7030"></A><ACLASS="indexterm"NAME="AUTOID-7033"></A>Recall that you can personalize your prompt string by assigning a value to the variable<BCLASS="emphasis.bold">PS1</B>. If you are on a network of computers, and you use differentmachines from time to time, you may find it handy to have thename of the machine you're on in your prompt string.  <ACLASS="indexterm"NAME="AUTOID-7036"></A>Mostnewer versions of UNIX have the command <EMCLASS="emphasis">hostname</EM>(1), whichprints the network name of the machine you are on to standard output.(If you do not have this command, you may have a similar one like<EMCLASS="emphasis">gethostname</EM>.) This command enables you to get the machine name intoyour prompt string by putting a line like this in your <EMCLASS="emphasis">.profile</EM> or environment file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PS1=&quot;$(hostname) \$ &quot;</PRE></BLOCKQUOTE></P><PCLASS="para">(The second dollar sign must be preceded by a backslash so thatthe shell will take it literally.)For example, if your machine had the name <BCLASS="emphasis.bold">coltrane</B>, then thisstatement would set your prompt string to &quot;<BCLASS="emphasis.bold">coltrane</B> $ &quot;.<ACLASS="indexterm"NAME="AUTOID-7046"></A></P><PCLASS="para">Command substitution helps us with the solution to the nextprogramming task, which relates to the album database in Task 4-1.</P><DIVCLASS="task"><H4>Task 4.4</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">The file used in Task 4-1 is actually a report derived froma bigger table of data about albums. This table consists of severalcolumns, or <EMCLASS="emphasis">fields</EM>, to whicha user refers by names like &quot;artist,&quot; &quot;title,&quot; &quot;year,&quot; etc.The columns are separated by vertical bars (<BCLASS="emphasis.bold">|</B>, the same as the UNIXpipe character).To deal with individual columns in the table, field names need to be converted to field numbers.</P><PCLASS="para">Suppose there is a shell function called <EMCLASS="emphasis">getfield</EM> that takes the field name as argument and writes the correspondingfield number on the standard output. Use this routine to helpextract a column from the data table.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-CUT"></A>The <EMCLASS="emphasis">cut</EM>(1) utility is a natural for this task.<EMCLASS="emphasis">cut</EM> is a data filter: it extracts columns from tabular data.[12]If you supply the numbers of columns you want to extract from the input,<EMCLASS="emphasis">cut</EM> will print only those columns on the standard output.Columns can be character positions or-relevant in this example-fields that are separated by <SPANCLASS="acronym">TAB</SPAN> characters or other delimiters.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[12] <ACLASS="indexterm"NAME="AUTOID-7062"></A><ACLASS="indexterm"NAME="AUTOID-7065"></A><ACLASS="indexterm"NAME="AUTOID-7068"></A>Some older BSD-derived systems don't have <EMCLASS="emphasis">cut</EM>, but you can use <EMCLASS="emphasis">awk</EM> instead.  Whenever you see a command of the form:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">cut -f<EMCLASS="emphasis">N</EM> -d<EMCLASS="emphasis">C filename</EM></PRE></BLOCKQUOTE></P><PCLASS="para">Use this instead:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">awk -F<EMCLASS="emphasis">C</EM> '{print $<EMCLASS="emphasis">N</EM>}' <EMCLASS="emphasis">filename</EM></PRE></BLOCKQUOTE></P></BLOCKQUOTE><PCLASS="para">Assume that the data table in our task is a file called<EMCLASS="emphasis">albums</EM> and that it looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Coltrane, John|Giant Steps|Atlantic|1960|JaColtrane, John|Coltrane Jazz|Atlantic|1960|JaColtrane, John|My Favorite Things|Atlantic|1961|JaColtrane, John|Coltrane Plays the Blues|Atlantic|1961|Ja...</PRE></BLOCKQUOTE></P><PCLASS="para">Here is how we would use <EMCLASS="emphasis">cut</EM> to extract the fourth(year) column:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">cut -f4 -d\| albums</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7095"></A>The <BCLASS="emphasis.bold">-d</B> argument is used to specify the characterused as field delimiter (<SPANCLASS="acronym">TAB</SPAN> is the default).The vertical bar must be backslash-escaped so that theshell doesn't try to interpret it as a pipe.</P><PCLASS="para">From this line of code and the <EMCLASS="emphasis">getfield</EM> routine, we caneasily derive the solution to the task. Assume that the first argument to <EMCLASS="emphasis">getfield</EM> is the nameof the field the user wants to extract. Then the solution is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">fieldname=$1cut -f$(getfield $fieldname) -d\| albums</PRE></BLOCKQUOTE></P><PCLASS="para">If we called this script with the argument <BCLASS="emphasis.bold">year</B>, the output would be:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">1960196019611961...</PRE></BLOCKQUOTE></P></DIV><ACLASS="indexterm"NAME="AUTOID-7109"></A><PCLASS="para">Here's another small task that makes use of <EMCLASS="emphasis">cut</EM>.</P><DIVCLASS="task"><H4>Task 4.5</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7115"></A>Send a mail message to everyone who is currently logged in.</P></BLOCKQUOTE><ACLASS="indexterm"NAME="AUTOID-7117"></A><PCLASS="para">The command <EMCLASS="emphasis">who</EM>(1) tells you who is logged in (as well as whichterminal they're on and when they logged in). Its output looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">billr      console      May 22 07:57fred       tty02        May 22 08:31bob        tty04        May 22 08:12</PRE></BLOCKQUOTE></P><PCLASS="para">The fields are separated by spaces, not <SPANCLASS="acronym">TAB</SPAN>s.  <ACLASS="indexterm"NAME="AUTOID-7125"></A>Since we need the firstfield, we can get away with using a space as the field separatorin the <EMCLASS="emphasis">cut</EM> command. (Otherwise we'd have to use the optionto <EMCLASS="emphasis">cut</EM> that uses character columns instead of fields.)To provide a space character as an argumenton a command line, you can surround it by quotes:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="literal">$ </CODE><BCLASS="emphasis.bold">who | cut -d' ' -f1</B></PRE></BLOCKQUOTE></P><PCLASS="para">With the above <EMCLASS="emphasis">who</EM> output, this command's output wouldlook like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">billrfredbob</PRE></BLOCKQUOTE></P><PCLASS="para">This leads directly to a solution to the task. Just type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">mail $(who | cut -d<CODECLASS="literal">' '</CODE>  -f1)</B></PRE></BLOCKQUOTE></P><PCLASS="para">The command <BCLASS="emphasis.bold">mail billr fred bob</B> will run and then you can type your message.</P></DIV><PCLASS="para">Here is another task that shows how useful command pipelines can bein command substitution.</P><DIVCLASS="task"><H4>Task 4.6</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">The <EMCLASS="emphasis">ls</EM> command gives you pattern-matching capabilitywith wildcards, but it doesn't allow you to select files by<EMCLASS="emphasis">modification date</EM>. Devise a mechanism that lets you do this.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7151"></A>This task was inspired by the feature of the VAX/VMS operating systemthat lets you specify files by date with <BCLASS="emphasis.bold">BEFORE</B> and <BCLASS="emphasis.bold">SINCE</B>parameters.We'll do this in a limited way now and add features in the next chapter.</P><PCLASS="para">Here is a function that allows you to list all files that werelast modified on the date you give as argument. Once again, wechoose a function for speed reasons. No pun is intendedby the function's name:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function lsd {    date=$1    ls -l | grep -i '^.\{41\}$date' | cut -c55-}</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7159"></A>This function depends on the column layout of the <BCLASS="emphasis.bold">ls -l</B> command.In particular, it depends on dates starting in column 42 andfilenames starting in column 55. If this isn't the case in yourversion of UNIX, you will need to adjust the column numbers.[13]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[13] <ACLASS="indexterm"NAME="AUTOID-7166"></A><ACLASS="indexterm"NAME="AUTOID-7168"></A>For example, <BCLASS="emphasis.bold">ls -l</B> on SunOS 4.1.x has dates starting incolumn 33 and filenames starting in column 46.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7174"></A><ACLASS="indexterm"NAME="AUTOID-7176"></A>We use the <EMCLASS="emphasis">grep</EM> search utility to match the date givenas argument (in the form <EMCLASS="emphasis">Mon</EM> <EMCLASS="emphasis">DD</EM>, e.g., <BCLASS="emphasis.bold">Jan 15</B> or <BCLASS="emphasis.bold">Oct&nbsp;&nbsp;6</B>, the latter having two spaces) to the outputof <BCLASS="emphasis.bold">ls -l</B>. This gives us a long listing of only those fileswhose dates match the argument. The <BCLASS="emphasis.bold">-i</B> option to <EMCLASS="emphasis">grep</EM>allows you to use all lowercase letters in the month name, whilethe rather fancy argument means, &quot;Match any line that contains 41characters followed by the function argument.&quot; For example, typing <BCLASS="emphasis.bold">lsd</B> <CODECLASS="literal">'</CODE><BCLASS="emphasis.bold">jan 15</B><CODECLASS="literal">'</CODE> causes <EMCLASS="emphasis">grep</EM> to search for linesthat match any 41 characters followed by <BCLASS="emphasis.bold">jan</B> <BCLASS="emphasis.bold">15</B> (or <BCLASS="emphasis.bold">Jan</B> <BCLASS="emphasis.bold">15</B>).[14]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[14] <ACLASS="indexterm"NAME="AUTOID-7198"></A><ACLASS="indexterm"NAME="AUTOID-7202"></A>Some older BSD-derived versions of UNIX (without System Vextensions) do not support the <BCLASS="emphasis.bold">\{</B><EMCLASS="emphasis">N</EM><BCLASS="emphasis.bold">\}</B> option. For thisexample, use 41 periods in a row instead of <BCLASS="emphasis.bold">.\{41\}</B>.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7210"></A>The output of <EMCLASS="emphasis">grep</EM> is piped through our ubiquitous friend <EMCLASS="emphasis">cut</EM> to retrieve the filenames only.The argument to <EMCLASS="emphasis">cut</EM> tells it to extract characters in column55 through the end of the line.</P><PCLASS="para">With command substitution, you can use this function with <EMCLASS="emphasis">any</EM>command that accepts filename arguments. For example, if you wantto print all files in your current directory that were last modifiedtoday, and today is January 15th, you could type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">lp $(lsd <CODECLASS="literal">'</CODE>jan 15<CODECLASS="literal">'</CODE>)</B></PRE></BLOCKQUOTE></P><PCLASS="para">The output of <EMCLASS="emphasis">lsd</EM> is on multiple lines (one for eachfilename), but <SPANCLASS="acronym">LINEFEED</SPAN>s are legal field separators for the<EMCLASS="emphasis">lp</EM> command, because the environment variable <BCLASS="emphasis.bold">IFS</B>(see earlier in this chapter) contains LINEFEED by default.<ACLASS="indexterm"NAME="AUTOID-7228"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_03.htm"TITLE="4.3 String Operators"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.3 String Operators"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_05.htm"TITLE="4.5 Advanced Examples: pushd and popd"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 4.5 Advanced Examples: pushd and popd"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">4.3 String Operators</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">4.5 Advanced Examples: pushd and popd</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>