<HTML><HEAD><TITLE>[Chapter 4] 4.5 Advanced Examples: pushd and popd</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:06:54Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch04_01.htm"TITLE="4. Basic Shell Programming"><LINKREL="prev"HREF="ch04_04.htm"TITLE="4.4 Command Substitution"><LINKREL="next"HREF="ch05_01.htm"TITLE="5. Flow Control"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_04.htm"TITLE="4.4 Command Substitution"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.4 Command Substitution"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 4<BR>Basic Shell Programming</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch05_01.htm"TITLE="5. Flow Control"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5. Flow Control"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-4-SECT-5">4.5 Advanced Examples: pushd and popd</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-4-IX-PUSHD"></A><ACLASS="indexterm"NAME="KSH-CH-4-IX-POPD"></A>We will conclude this chapter with a couple of functions thatyou may find handy in your everyday UNIX use.  </P><DIVCLASS="task"><H4>Task 4.7</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">The functions<EMCLASS="emphasis">pushd</EM> and <EMCLASS="emphasis">popd</EM> implement a <EMCLASS="emphasis">stack</EM> of directoriesthat enable you to move to another directory temporarily and havethe shell remember where you were.  <ACLASS="indexterm"NAME="AUTOID-7242"></A>The C shell includes thesefunctions, but for some reason the Korn shell omits them.Implement them as shell functions.</P></BLOCKQUOTE><PCLASS="para">We will start by implementing a significant subset of theircapabilities and finish the implementation in <ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6</A>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7247"></A>If you don't know what a stack is, think of a spring-loadeddish receptacle in a cafeteria. When you place dishes on thereceptacle, the spring compresses so that the top stays at roughlythe same level. The dish most recently placed on the stack isthe first to be taken when someone wants food; thus, thestack is known as a &quot;last-in, first-out&quot; or <EMCLASS="emphasis">LIFO</EM> structure.[15]Putting something onto a stack is known in computer scienceparlance as <EMCLASS="emphasis">pushing</EM>, and taking something off the topis called <EMCLASS="emphasis">popping</EM>.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[15] Victims of the early-90s recession will also recognizethis mechanism in the context of corporate layoff policies.</P></BLOCKQUOTE><PCLASS="para">A stack is very handy for remembering directories, as we will see;it can &quot;hold your place&quot; up to an arbitrary number of times.<ACLASS="indexterm"NAME="AUTOID-7255"></A>The <BCLASS="emphasis.bold">cd -</B> form of the <BCLASS="emphasis.bold">cd</B> command does this, but onlyto one level. For example: if you are in <EMCLASS="emphasis">firstdir</EM> and then you change to <EMCLASS="emphasis">seconddir</EM>, you can type <BCLASS="emphasis.bold">cd -</B> to go back.But if you start out in <EMCLASS="emphasis">firstdir</EM>, then change to <EMCLASS="emphasis">seconddir</EM>,and then go to <EMCLASS="emphasis">thirddir</EM>, you can use <BCLASS="emphasis.bold">cd -</B> only togo back to <EMCLASS="emphasis">seconddir</EM>. If you type <BCLASS="emphasis.bold">cd -</B> again,you will be back in <EMCLASS="emphasis">thirddir</EM>, because it is the previousdirectory.  [16]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[16] <ACLASS="indexterm"NAME="AUTOID-7272"></A><ACLASS="indexterm"NAME="AUTOID-7274"></A>Think of <BCLASS="emphasis.bold">cd -</B> as a synonym for <BCLASS="emphasis.bold">cd $OLDPWD</B>; see the previous chapter.</P></BLOCKQUOTE><PCLASS="para">If you want the &quot;nested&quot; remember-and-change functionality that willtake you back to <EMCLASS="emphasis">firstdir</EM>, you need a stack of directoriesalong with the <EMCLASS="emphasis">pushd</EM> and <EMCLASS="emphasis">popd</EM> commands. Here is how thesework:[17]<ACLASS="indexterm"NAME="AUTOID-7293"></A><ACLASS="indexterm"NAME="AUTOID-7296"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[17] <ACLASS="indexterm"NAME="AUTOID-7285"></A>More accurately, this is how the C shell does it, and yes,it <EMCLASS="emphasis">is</EM> somewhat counterintuitive.A more intuitive way would be:</P></BLOCKQUOTE><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">The first time <BCLASS="emphasis.bold">pushd</B> dir is called, <BCLASS="emphasis.bold">pushd cd</B>s to <EMCLASS="emphasis">dir</EM> andpushes the current directory followed by <EMCLASS="emphasis">dir</EM> onto the stack.</P></LI><LICLASS="listitem"><PCLASS="para">Subsequent calls to <BCLASS="emphasis.bold">pushd cd</B> to <EMCLASS="emphasis">dir</EM> and push <EMCLASS="emphasis">dir</EM> only onto the stack.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">popd</B> removes the top directory off the stack, revealing anew top. Then it <BCLASS="emphasis.bold">cd</B>s to the new top directory.</P></LI></UL><PCLASS="para">For example, consider the series of events in <ACLASS="xref"HREF="ch04_05.htm#KSH-CH-4-TAB-5"TITLE="pushd/popd Example">Table 4.6</A>.Assume that youhave just logged in, and that you are in your home directory (<EMCLASS="emphasis">/home/you</EM>).  </P><PCLASS="para">We will implement a stack as an environment variable containing alist of directories separated by spaces.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-4-TAB-5">Table 4.6: pushd/popd Example</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Command </TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Stack Contents</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Result Directory</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">pushd fred</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/home/you/fred  /home/you</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/home/you/fred</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">pushd /etc</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/etc  /home/you/fred  /home/you</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/etc</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">popd</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/home/you/fred  /home/you</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/home/you/fred</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">popd</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/home/you</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/home/you</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">popd</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">&lt;empty&gt;</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">(error)</TD></TR></TBODY></TABLE><PCLASS="para">Your directory stack should be initialized to the null string when you log in.To do this, put this in your <EMCLASS="emphasis">.profile</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">DIRSTACK=&quot;&quot;export DIRSTACK</PRE></BLOCKQUOTE></P><PCLASS="para">Do <EMCLASS="emphasis">not</EM> put this in your environment file if you have one.  The <BCLASS="emphasis.bold">export</B> statement guarantees that DIRSTACK is known to allsubprocesses; you want to initialize it only once. If you put thiscode in an environment file, it will get reinitialized in every subshell, which you probably don't want.</P><PCLASS="para">Next, we need to implement <EMCLASS="emphasis">pushd</EM> and <EMCLASS="emphasis">popd</EM> as functions.Here are our initial versions:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function pushd {		# push current directory onto stack    dirname=$1    cd ${dirname:?&quot;missing directory name.&quot;}    DIRSTACK=&quot;$dirname ${DIRSTACK:-$PWD}&quot;    print &quot;$DIRSTACK&quot;}   function popd {		# pop directory off stack, cd to new top    DIRSTACK=${DIRSTACK#* }    cd ${DIRSTACK%% *}    print &quot;$PWD&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">Notice that there isn't much code! Let's go through the two functionsand see how they work, starting with <EMCLASS="emphasis">pushd</EM>.The first line merely saves the first argument in the variable<BCLASS="emphasis.bold">dirname</B> for readability reasons.</P><PCLASS="para">The second line's main purpose is to change to the new directory.<ACLASS="indexterm"NAME="AUTOID-7369"></A><ACLASS="indexterm"NAME="AUTOID-7372"></A>We use the <CODECLASS="literal">:?</CODE> operator to handle the error when the argument ismissing: if the argument is given, then the expression<BCLASS="emphasis.bold">${dirname</B><CODECLASS="literal">:?&quot;</CODE><BCLASS="emphasis.bold">missing directory name.</B><CODECLASS="literal">&quot;}</CODE> evaluates to <BCLASS="emphasis.bold">$</B><BCLASS="emphasis.bold">dirname</B>, but ifit is not given, the shell will print the message <BCLASS="emphasis.bold">pushd: dirname: missing directory name</B> and exit from the function.</P><PCLASS="para">The third line of the function pushes the new directory onto thestack.  <ACLASS="indexterm"NAME="AUTOID-7384"></A><ACLASS="indexterm"NAME="AUTOID-7387"></A>The expression <BCLASS="emphasis.bold"><SPANCLASS="acronym">${DIRSTACK</SPAN></B><CODECLASS="literal">:</CODE><BCLASS="emphasis.bold">-$PWD}</B> evaluates to <BCLASS="emphasis.bold">$DIRSTACK</B> if it is non-null or <SPANCLASS="acronym">$PWD</SPAN> (the current directory)if it is null. The expression within double quotes, then,consists of the argument given, followed by a single space, followedby <SPANCLASS="acronym">DIRSTACK</SPAN> or the current directory. The double quotes ensurethat all of this is packaged into a single string for assignmentback to <SPANCLASS="acronym">DIRSTACK</SPAN>. Thus, this line of code handles thespecial initial case (when the stack is empty) as well as the moreusual case (when it's not empty).</P><PCLASS="para">The last line merely prints the contents of the stack, with theimplication that the leftmost directory is both the current directoryand at the top of the stack.  <ACLASS="indexterm"NAME="AUTOID-7400"></A><ACLASS="indexterm"NAME="AUTOID-7402"></A><ACLASS="indexterm"NAME="AUTOID-7405"></A><ACLASS="indexterm"NAME="AUTOID-7407"></A>(This is why we chose spaces toseparate directories, rather than the more customary colons as inPATH and MAILPATH.)</P><PCLASS="para">The <EMCLASS="emphasis">popd</EM> function makes yet anotheruse of the shell's pattern-matching operators.<ACLASS="indexterm"NAME="AUTOID-7412"></A><ACLASS="indexterm"NAME="AUTOID-7415"></A>Its first line uses the <BCLASS="emphasis.bold">#</B> operator, which tries to deletethe shortest match of the pattern &quot;<CODECLASS="literal">*</CODE>&quot; (anything followed by a space)from the value of DIRSTACK. The result is that the top directory(and the space following it) is deleted from the stack.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7421"></A><ACLASS="indexterm"NAME="AUTOID-7424"></A>The second line of <EMCLASS="emphasis">popd</EM> uses the pattern-matching operator<BCLASS="emphasis.bold">%%</B> to delete the <EMCLASS="emphasis">longest</EM> match to the pattern &quot; <CODECLASS="literal">*</CODE>&quot; (a space followed by anything) from DIRSTACK. This extractsthe top directory as argument to <BCLASS="emphasis.bold">cd</B>, but doesn't affect thevalue of DIRSTACK because there is no assignment.The final line just prints a confirmation message.</P><PCLASS="para">This code is deficient in three ways: first, it has no provision for errors.For example:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">What if the user tries to push a directory that doesn't existor is invalid?  </P></LI><LICLASS="listitem"><PCLASS="para">What if the user tries <EMCLASS="emphasis">popd</EM> and the stack is empty?  </P></LI></UL><PCLASS="para">Test your understanding of the code by figuring out how itwould respond to these error conditions.The second deficiency is that it implements only someof the functionality of the C shell's <EMCLASS="emphasis">pushd</EM> and <EMCLASS="emphasis">popd</EM> commands-albeit the most useful parts.In the next chapter, we will see how to overcome both of these deficiencies.</P><PCLASS="para">The third problem with the code is that it will not work if, for some reason, a directory name contains a space. The code will treat the spaceas a separator character. We'll accept this deficiency for now. However, when you read about arrays in <ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6</A>, <EMCLASS="emphasis">Command-line Options and TypedVariables</EM>, think about how you might use them to rewrite this code and eliminate the problem.<ACLASS="indexterm"NAME="AUTOID-7445"></A><ACLASS="indexterm"NAME="AUTOID-7446"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_04.htm"TITLE="4.4 Command Substitution"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.4 Command Substitution"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch05_01.htm"TITLE="5. Flow Control"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5. Flow Control"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">4.4 Command Substitution</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">5. Flow Control</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>