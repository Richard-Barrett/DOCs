<HTML><HEAD><TITLE>[Chapter 5] Flow Control</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:07:32Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="index.htm"TITLE="Learning the Korn Shell"><LINKREL="prev"HREF="ch04_05.htm"TITLE="4.5 Advanced Examples: pushd and popd"><LINKREL="next"HREF="ch05_02.htm"TITLE="5.2 for"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_05.htm"TITLE="4.5 Advanced Examples: pushd and popd"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.5 Advanced Examples: pushd and popd"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 5</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_02.htm"TITLE="5.2 for"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.2 for"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="CHAPTER"><H1CLASS="chapter"><ACLASS="title"NAME="KSH-CH5-FLOWCON">5. Flow Control</A></H1><DIVCLASS="htmltoc"><P><B>Contents:</B><BR><ACLASS="sect1"HREF="#KSH-CH-5-SECT-1"TITLE="5.1 if/else">if/else</A><BR><ACLASS="sect1"HREF="ch05_02.htm"TITLE="5.2 for">for</A><BR><ACLASS="sect1"HREF="ch05_03.htm"TITLE="5.3 case">case</A><BR><ACLASS="sect1"HREF="ch05_04.htm"TITLE="5.4 select">select</A><BR><ACLASS="sect1"HREF="ch05_05.htm"TITLE="5.5 while and until">while and until</A></P><P></P></DIV><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7450"></A>If you are a programmer, you may have read the last chapter-with its claim at the outset that the Korn shell has an advancedset of programming capabilities&nbsp;- and wondered where many featuresfrom conventional languages are.Perhaps the most glaringly obvious &quot;hole&quot; in our coveragethus far concerns <EMCLASS="emphasis">flow control</EM> constructslike <BCLASS="emphasis.bold">if</B>, <BCLASS="emphasis.bold">for</B>, <BCLASS="emphasis.bold">while</B>, and so on.</P><PCLASS="para">Flow control gives a programmer the power to specify thatonly certain portions of a program run, or that certain portionsrun repeatedly, according to conditions such as the valuesof variables, whether or not commands execute properly, and others.We call this the ability to control the flow ofa program's execution.</P><PCLASS="para">Almost every shellscript or function shown thus far has had no flow control-they havejust been lists of commandsto be run! Yet the Korn shell, like the C and Bourne shells,has all of the flow control abilities you would expect and more;we will examine them in this chapter. We'll use them toenhance the solutions to some of the programming tasks we saw inthe last chapter and to solve tasks that we will introduce here.</P><PCLASS="para">Although we have attempted to explain flow control sothat non-programmers can understand it, we also sympathize withprogrammers who dread having to slog through yet another<EMCLASS="emphasis">tabula rasa</EM> explanation. For this reason, some of ourdiscussions relate the Korn shell's flow-control mechanisms tothose that programmers should know already. Thereforeyou will be in a better positionto understand this chapter if you already have a basic knowledgeof flow control concepts.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-FLOW-CONTROL-SUMMARY-CONSTRUCTS"></A>The Korn shell supports the following flow control constructs:</P><DLCLASS="variablelist"><DTCLASS="term"><BCLASS="emphasis.bold">if</B>/<BCLASS="emphasis.bold">else</B></DT><DDCLASS="listitem"><PCLASS="para">Execute a list of statements if a certain condition is/is not true</P></DD><DTCLASS="term"><BCLASS="emphasis.bold">for</B></DT><DDCLASS="listitem"><PCLASS="para">Execute a list of statements a fixed number of times</P></DD><DTCLASS="term"><BCLASS="emphasis.bold">while</B></DT><DDCLASS="listitem"><PCLASS="para">Execute a list of statements repeatedly <EMCLASS="emphasis">while</EM> a certain conditionholds true</P></DD><DTCLASS="term"><BCLASS="emphasis.bold">until</B></DT><DDCLASS="listitem"><PCLASS="para">Execute a list of statements repeatedly <EMCLASS="emphasis">until</EM> a certain conditionholds true</P></DD><DTCLASS="term"><BCLASS="emphasis.bold">case</B></DT><DDCLASS="listitem"><PCLASS="para">Execute one of several lists of statements depending on the valueof a variable</P></DD></DL><PCLASS="para">In addition, the Korn shell provides a new type of flow-controlconstruct:</P><DLCLASS="variablelist"><DTCLASS="term"><BCLASS="emphasis.bold">select</B></DT><DDCLASS="listitem"><PCLASS="para">Allow the user to select one of a list of possibilities from a menu<ACLASS="indexterm"NAME="AUTOID-7501"></A></P></DD></DL><PCLASS="para">We will cover each of these, but be warned:the syntax is not pretty.</P><DIVCLASS="sect1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-5-SECT-1">5.1 if/else</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-IF"></A><ACLASS="indexterm"NAME="AUTOID-7508"></A><ACLASS="indexterm"NAME="AUTOID-7511"></A><ACLASS="indexterm"NAME="AUTOID-7514"></A>The simplest type of flow control construct is the <EMCLASS="emphasis">conditional</EM>,embodied in the Korn shell's <BCLASS="emphasis.bold">if</B> statement. You use aconditional when you want to choose whether or not to do something,or to choose among a small number of things to do, according tothe truth or falsehood of <EMCLASS="emphasis">conditions</EM>. Conditions testvalues of shell variables, characteristics of files, whether ornot commands run successfully, and other factors. The shellhas a large set of built-in tests that are relevant tothe task of shell programming.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7521"></A>The <BCLASS="emphasis.bold">if</B> construct has the following syntax:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if <EMCLASS="emphasis">condition</EM>then    <EMCLASS="emphasis">statements</EM>[elif <EMCLASS="emphasis">condition</EM>    then <EMCLASS="emphasis">statements</EM>...][else    <EMCLASS="emphasis">statements</EM>]fi</PRE></BLOCKQUOTE></P><PCLASS="para">The simplest form (without the <BCLASS="emphasis.bold">elif</B> and <BCLASS="emphasis.bold">else</B> parts, a.k.a. <EMCLASS="emphasis">clauses</EM>)executes the <EMCLASS="emphasis">statements</EM> only if the <EMCLASS="emphasis">condition</EM> is true.If you add an <BCLASS="emphasis.bold">else</B> clause, you get the ability to executeone set of statements if a condition is true or another set ofstatements if the condition is false. You can use as many<BCLASS="emphasis.bold">elif</B> (a contraction of &quot;else if&quot;) clauses as you wish; they introducemore conditions, and thus more choices for which set of statementsto execute. If you use one or more <BCLASS="emphasis.bold">elif</B>s, you can think ofthe <BCLASS="emphasis.bold">else</B> clause as the &quot;if all <EMCLASS="emphasis">else</EM> fails&quot; part.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-5-SECT-1.1">5.1.1 Exit Status and Return</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-EXIT-STATUS"></A><ACLASS="indexterm"NAME="AUTOID-7548"></A><ACLASS="indexterm"NAME="AUTOID-7550"></A>Perhaps the only aspect of this syntax that differs from thatof conventional languages like C and Pascal isthat the &quot;condition&quot; is really a list of statements rather than themore usual Boolean (true or false) expression.How is the truth or falsehood of the condition determined?It has to do with a general UNIX concept that we haven'tcovered yet: the <EMCLASS="emphasis">exit status</EM> of commands.</P><PCLASS="para">Every UNIX command, whether it comes from source code in C,some other language, or a shell script/function, returns aninteger code to its calling process-the shell in this case-when it finishes.  <ACLASS="indexterm"NAME="AUTOID-7554"></A>This is called the exit status. 0 is <EMCLASS="emphasis">usually</EM>the &quot;OK&quot; exit status, while anything else (1 to 255)<EMCLASS="emphasis">usually</EM> denotes an error.[1]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] <ACLASS="indexterm"NAME="AUTOID-7561"></A>Because this is a &quot;convention&quot; and not a &quot;law,&quot; there are exceptions.For example, <EMCLASS="emphasis">diff</EM> (1) (find differences between two files)returns 0 for &quot;no differences,&quot; 1 for &quot;differences found,&quot; or 2 foran error such as an invalid filename argument.</P></BLOCKQUOTE><PCLASS="para"><BCLASS="emphasis.bold">if</B> checks the exit status of the <EMCLASS="emphasis">last</EM> statement in the listfollowing the <BCLASS="emphasis.bold">if</B> keyword.[2](The list is usually just a single statement.)If the status is 0, the condition evaluates to true; if it is anything else,the condition is considered false. The same is truefor each condition attached to an <BCLASS="emphasis.bold">elif</B> statement (if any).</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] <ACLASS="indexterm"NAME="AUTOID-7570"></A>LISP programmers will find this idea familiar.</P></BLOCKQUOTE><PCLASS="para">This enables us to write code of the form:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if command ran successfullythen    normal processingelse    error processingfi</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-PUSHD"></A>More specifically, we can now improve on the <EMCLASS="emphasis">pushd</EM> functionthat we saw in the last chapter:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function pushd {		# push current directory onto stack    dirname=$1    cd ${dirname:?&quot;missing directory name.&quot;}    DIRSTACK=&quot;$dirname ${DIRSTACK:-$PWD}&quot;    print $DIRSTACK}</PRE></BLOCKQUOTE></P><PCLASS="para">This function requires a valid directory as its argument.Let's look at how it handles error conditions:if no argument is given, the second line of code prints an errormessage and exits. This is fine.</P><PCLASS="para">However, the functionreacts deceptively when an argument is given that isn't a validdirectory. In case you didn't figure it out when reading thelast chapter, here is what happens: the <BCLASS="emphasis.bold">cd</B> fails, leavingyou in the same directory you were in. This is also appropriate.But then the third line of code pushes the bad directory onto thestack anyway, and the last line prints a message that leads you tobelieve that the push was successful.</P><PCLASS="para">We need to prevent the bad directory from being pushed and toprint an error message. Here is how we can do this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function pushd {                # push current directory onto stack    dirname=$1    if cd ${dirname:?&quot;missing directory name.&quot;}   # if cd was successful    then        DIRSTACK=&quot;$dirname ${DIRSTACK:-$PWD}&quot;        print $DIRSTACK    else        print still in $PWD.    fi}</PRE></BLOCKQUOTE></P><PCLASS="para">The call to <BCLASS="emphasis.bold">cd</B> is now inside an <BCLASS="emphasis.bold">if</B> construct.If <BCLASS="emphasis.bold">cd</B> is successful, it will return 0; the next two linesof code are run, finishing the <EMCLASS="emphasis">pushd</EM> operation.But if the <BCLASS="emphasis.bold">cd</B> fails, it returns with exit status1, and <EMCLASS="emphasis">pushd</EM> willprint a message saying that you haven't gone anywhere.<ACLASS="indexterm"NAME="AUTOID-7595"></A></P><PCLASS="para">You can usually rely on built-in commands and standardUNIX utilities to return appropriate exit statuses, but whatabout your own shell scripts and functions?For example, what if you wrote a <BCLASS="emphasis.bold">cd</B> function thatoverrides the built-in command?</P><PCLASS="para">Let's say you have the following code in your <EMCLASS="emphasis">.profile</EM>or environment file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function _cd {    &quot;cd&quot; $*    print $OLDPWD -&gt; $PWD}alias cd=_cd</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7603"></A><ACLASS="indexterm"NAME="AUTOID-7605"></A><ACLASS="indexterm"NAME="AUTOID-7607"></A><ACLASS="indexterm"NAME="AUTOID-7610"></A>The function <EMCLASS="emphasis">_cd</EM> simply changes directories and printsa message saying where you were and where you are now.Because functions have lower priority than built-in commandsin the shell's order of command lookup, we need to define <BCLASS="emphasis.bold">cd</B> itself as an alias sothat it overrides the built-in <BCLASS="emphasis.bold">cd</B>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7617"></A>The function calls the built-in <BCLASS="emphasis.bold">cd</B> command, but noticethat it's surrounded in double quotes: that prevents the shellfrom looking it up as an alias. (This may seem like a kludgein the aliasing mechanism, but it's really just a ramificationof the shell's command-line processing rules, which we listin <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7, Input/Output and Command-line Processing</A>.)  [3]If it did find <BCLASS="emphasis.bold">cd</B> as an alias, the shell would go intoan &quot;infinite recursion&quot; in which the alias is expandedto <EMCLASS="emphasis">_cd</EM>, which runs the function, which calls <BCLASS="emphasis.bold">cd</B>,which the shell expands to the alias again, etc.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] <ACLASS="indexterm"NAME="AUTOID-7624"></A>A related result of command-line processingis that if you surround a command with <EMCLASS="emphasis">single</EM> quotes, the shell won't look it up as an aliasor as a function.</P></BLOCKQUOTE><PCLASS="para">Anyway, we want this function to return the same exitstatus that the built-in <BCLASS="emphasis.bold">cd</B> returns.The problem is that the exit status is reset by every command,so it &quot;disappears&quot; if you don't save it immediately. In this function,the built-in <BCLASS="emphasis.bold">cd</B>'s exit status disappears when the <BCLASS="emphasis.bold">print</B>statement runs (and sets its own exit status).</P><PCLASS="para">Therefore, we need to save the status that <BCLASS="emphasis.bold">cd</B>sets and use it as the entire function's exit status.Two shell features we haven't seen yet provide the way.<ACLASS="indexterm"NAME="AUTOID-7637"></A><ACLASS="indexterm"NAME="AUTOID-7640"></A>First is the special shell variable<CODECLASS="literal">?</CODE>, whose value (<BCLASS="emphasis.bold">$</B><CODECLASS="literal">?</CODE>) is the exit status of the lastcommand that ran. For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">cd <EMCLASS="emphasis">baddir</EM>print $?</PRE></BLOCKQUOTE></P><PCLASS="para">causes the shell to print <BCLASS="emphasis.bold">1</B>, while:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">cd <EMCLASS="emphasis">gooddir</EM>print $?</PRE></BLOCKQUOTE></P><PCLASS="para">causes the shell to print <BCLASS="emphasis.bold">0</B>.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-5-SECT-1.1.1">5.1.1.1 Return</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-RETURN"></A>The second feature we needis the statement <BCLASS="emphasis.bold">return</B> <EMCLASS="emphasis">N</EM>, which causes the surroundingscript or function to exit with exit status <EMCLASS="emphasis">N</EM>.<EMCLASS="emphasis">N</EM> is actually optional; it defaults to 0. Scripts thatfinish without a <BCLASS="emphasis.bold">return</B> statement (i.e., every one wehave seen so far) return whatever the last statement returns.If you use <BCLASS="emphasis.bold">return</B> within a function, it will just exit thefunction.  <ACLASS="indexterm"NAME="AUTOID-7667"></A>(In contrast, the statement <BCLASS="emphasis.bold">exit</B> <EMCLASS="emphasis">N</EM> exitsthe entire script, no matter how deeply you are nested in functions.)</P><PCLASS="para">Getting back to our example: if the call to &quot;real&quot; <BCLASS="emphasis.bold">cd</B> were last inour <EMCLASS="emphasis">_cd</EM> function, it would behave properly. Unfortunately,we really need the assignment statement where it is, so that we can avoid lotsof ugly error processing. Therefore we need to save <BCLASS="emphasis.bold">cd</B>'sexit status and return it as the function's exit status. Here ishow to do it:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function _cd {    &quot;cd&quot; $*    es=$?    print $OLDPWD -&gt; $PWD    return $es}</PRE></BLOCKQUOTE></P><PCLASS="para">The second line saves the exit status of <BCLASS="emphasis.bold">cd</B> in the variable<BCLASS="emphasis.bold">es</B>; the fourth returns it as the function's exit status.We'll see a more substantial &quot;wrapper&quot; for <BCLASS="emphasis.bold">cd</B> in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7683"></A><ACLASS="indexterm"NAME="AUTOID-7684"></A><ACLASS="indexterm"NAME="AUTOID-7686"></A>Exit statuses aren't very useful for anything other thantheir intended purpose. In particular, you may be tempted to usethem as &quot;return values&quot; of functions, as you would with functionsin C or Pascal. That won't work;you should use variables or command substitutioninstead to simulate this effect.</P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-5-SECT-1.2">5.1.2 Combinations of Exit Statuses</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-EXIT-STATUS-LOGICAL-COMBINATIONS"></A>One of the more obscure parts of Korn shell syntax allows youto combine exit statuses logically, so that you can test morethan one thing at a time.  </P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-AMPAMP-FOR-EXIT-STATS"></A><ACLASS="indexterm"NAME="KSH-CH-5-IX-PIPEPIPE-EXIT-STATS"></A>The syntax <EMCLASS="emphasis">statement1</EM><BCLASS="emphasis.bold"> &amp;&amp;</B> <EMCLASS="emphasis">statement2</EM> means, &quot;execute<EMCLASS="emphasis">statement1</EM>, and if its exit status is 0, execute <EMCLASS="emphasis">statement2</EM>.&quot;The syntax <EMCLASS="emphasis">statement1</EM><BCLASS="emphasis.bold"> || </B><EMCLASS="emphasis">statement2</EM> is the converse:it means, &quot;execute <EMCLASS="emphasis">statement1</EM>, and if its exit status is<EMCLASS="emphasis">not</EM> 0, execute <EMCLASS="emphasis">statement2</EM>.&quot;</P><PCLASS="para">At first, these look like &quot;if/then&quot; and &quot;if not/then&quot; constructs,respectively. But they are really intended for use within conditions of <BCLASS="emphasis.bold">if</B> constructs-as C programmers willreadily understand.  </P><PCLASS="para">It's much more useful to think of these constructs as &quot;and&quot; and&quot;or,&quot; respectively. Consider this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if <EMCLASS="emphasis">statement1</EM> &amp;&amp; <EMCLASS="emphasis">statement2</EM>then    ...fi</PRE></BLOCKQUOTE></P><PCLASS="para">In this case, <EMCLASS="emphasis">statement1</EM> is executed. If it returns a 0status, then presumably it ran without error. Then <EMCLASS="emphasis">statement2</EM>runs. The <BCLASS="emphasis.bold">then</B> clause is executed if <EMCLASS="emphasis">statement2</EM> returnsa 0 status. Conversely, if <EMCLASS="emphasis">statement1</EM> fails (returns anon-0 exit status), then <EMCLASS="emphasis">statement2</EM> doesn't even run;the &quot;last statement&quot; in the condition was <EMCLASS="emphasis">statement1</EM>, whichfailed-so the <BCLASS="emphasis.bold">then</B> clause doesn't run. Taken all together,it's fair to conclude that the <BCLASS="emphasis.bold">then</B> clause runs if<EMCLASS="emphasis">statement1</EM> and <EMCLASS="emphasis">statement2</EM> both succeeded.</P><PCLASS="para">Similarly, consider this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if <EMCLASS="emphasis">statement1</EM> || <EMCLASS="emphasis">statement2</EM>then    ...fi</PRE></BLOCKQUOTE></P><PCLASS="para">If <EMCLASS="emphasis">statement1</EM> succeeds, then <EMCLASS="emphasis">statement2</EM> does <EMCLASS="emphasis">not</EM>run. This makes <EMCLASS="emphasis">statement1</EM> the last statement, which meansthat the <BCLASS="emphasis.bold">then</B> clause runs. On the other hand, if <EMCLASS="emphasis">statement1</EM>fails, then <EMCLASS="emphasis">statement2</EM> runs, and whether the <BCLASS="emphasis.bold">then</B> clauseruns or not depends on the success of <EMCLASS="emphasis">statement2</EM>. The upshotis that the <BCLASS="emphasis.bold">then</B> clause runs if <EMCLASS="emphasis">statement1 or statement2</EM>succeeds.</P><PCLASS="para">As a simple example, assume that we need to write a script that checksa file for the presence of two words and just prints a messagesaying whether <EMCLASS="emphasis">either</EM> word is in the file or not.<ACLASS="indexterm"NAME="AUTOID-7750"></A>We can use <EMCLASS="emphasis">grep</EM> for this: it returns exit status 0 ifit found the given string in its input, non-0 if not:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">filename=$1word1=$2word2=$3if grep $word1 $filename || grep $word2 $filenamethen    print &quot;$word1 or $word2 is in $filename.&quot;fi</PRE></BLOCKQUOTE></P><PCLASS="para">The <BCLASS="emphasis.bold">then</B> clause of this code runs if either <EMCLASS="emphasis">grep</EM>statement succeeds. Now assume that we want the script to say whether or not the input file contains <EMCLASS="emphasis">both</EM> words.Here's how to do it:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">filename=$1word1=$2word2=$3if grep $word1 $filename &amp;&amp; grep $word2 $filenamethen    print &quot;$word1 and $word2 are both in $filename.&quot;fi</PRE></BLOCKQUOTE></P><PCLASS="para">We'll see more examples of these logical operators later in this chapter and in the code for the <EMCLASS="emphasis">kshdb</EM> debugger in<ACLASS="xref"HREF="ch09_01.htm"TITLE="Debugging Shell Programs">Chapter 9, Debugging Shell Programs</A>.<ACLASS="indexterm"NAME="AUTOID-7764"></A><ACLASS="indexterm"NAME="AUTOID-7765"></A><ACLASS="indexterm"NAME="AUTOID-7766"></A><ACLASS="indexterm"NAME="AUTOID-7767"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-5-SECT-1.3">5.1.3 Condition Tests</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-CND-TSTS"></A><ACLASS="indexterm"NAME="AUTOID-7773"></A>Exit statuses are the only things an <BCLASS="emphasis.bold">if</B> construct can test. But that doesn't mean you cancheck only whether or not commands ran properly. The shell providesa way of testing a variety of conditions with the <BCLASS="emphasis.bold">[[ ]]</B>construct.[4]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] <ACLASS="indexterm"NAME="AUTOID-7780"></A><ACLASS="indexterm"NAME="AUTOID-7783"></A><ACLASS="indexterm"NAME="AUTOID-7786"></A>The Korn shell also accepts the external <EMCLASS="emphasis">[]</EM> and<EMCLASS="emphasis">test</EM> commands.<ACLASS="indexterm"NAME="AUTOID-7792"></A><ACLASS="indexterm"NAME="AUTOID-7795"></A>The <BCLASS="emphasis.bold">[[ ]]</B> construct has many more options andis better integrated into the Korn shell language:specifically, word splitting and wildcard expansionaren't done within <BCLASS="emphasis.bold">[[</B> and <BCLASS="emphasis.bold">]]</B>, making quotingless necessary.</P></BLOCKQUOTE><PCLASS="para">You can use the construct to check many different attributes of a file(whether it exists, what type of file it is, what its permissionsand ownership are, etc.), compare two files to see which is newer,do comparisons and pattern matching on strings, and more.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7803"></A><BCLASS="emphasis.bold">[[</B> <EMCLASS="emphasis">condition</EM><BCLASS="emphasis.bold"> ]]</B> is actually a statement just like anyother, except that the only thing it does is return an exit statusthat tells whether <EMCLASS="emphasis">condition</EM> is true or not. Thus it fitswithin the <BCLASS="emphasis.bold">if</B> construct's syntax of <BCLASS="emphasis.bold">if</B> <EMCLASS="emphasis">statements</EM>.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-5-SECT-1.3.1">5.1.3.1 String comparisons</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-CND-TSTS-STR-COMPARISON-OPRTRS"></A>The double square brackets (<BCLASS="emphasis.bold">[[]]</B>) surround expressions that includevarious types of <EMCLASS="emphasis">operators</EM>. We willstart with the string comparison operators, which are listedin <ACLASS="xref"HREF="ch05_01.htm#KSH-CH-5-TAB-0"TITLE="String Comparison Operators">Table 5.1</A>.(Notice that there are no operators for &quot;greater than or equal&quot; or &quot;less than or equal.&quot;)In the table, <EMCLASS="emphasis">str</EM> refers to an expression witha string value, and <EMCLASS="emphasis">pat</EM> refers to a pattern that can containwildcards (just like the patterns in the string-handling operatorswe saw in the last chapter).<ACLASS="indexterm"NAME="AUTOID-7824"></A><ACLASS="indexterm"NAME="AUTOID-7828"></A><ACLASS="indexterm"NAME="AUTOID-7832"></A><ACLASS="indexterm"NAME="AUTOID-7836"></A><ACLASS="indexterm"NAME="AUTOID-7840"></A><ACLASS="indexterm"NAME="AUTOID-7844"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-5-TAB-0">Table 5.1: String Comparison Operators</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operator </TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">True if...</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str</EM> = <EMCLASS="emphasis">pat</EM>[5]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str</EM> matches <EMCLASS="emphasis">pat</EM>.</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str</EM> != <EMCLASS="emphasis">pat</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str</EM> does not match <EMCLASS="emphasis">pat</EM>.</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str1</EM> &lt; <EMCLASS="emphasis">str2</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str1</EM> is less than <EMCLASS="emphasis">str2</EM>.</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str1</EM> &gt; <EMCLASS="emphasis">str2</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str1</EM> is greater than <EMCLASS="emphasis">str2</EM>.</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-n</B> <EMCLASS="emphasis">str</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str</EM> is not null (has length greater than 0).</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-z</B> <EMCLASS="emphasis">str</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">str</EM> is null (has length 0).</TD></TR></TBODY></TABLE><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] Notethat there is only one equal sign (<BCLASS="emphasis.bold">=</B>).This is a common source of errors.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-POPD"></A>We can use one of these operators to improve our <EMCLASS="emphasis">popd</EM> function,which reacts badly if you try to pop and thestack is empty. Recall that the code for <EMCLASS="emphasis">popd</EM> is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function popd {			# pop directory off the stack, cd there    DIRSTACK=${DIRSTACK#* }    cd ${DIRSTACK%% *}    print &quot;$PWD&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">If the stack is empty, then <BCLASS="emphasis.bold">$DIRSTACK</B> is the null string,as is the expression <BCLASS="emphasis.bold">${DIRSTACK%% *}</B>. This means that youwill change to your home directory; instead, we want <EMCLASS="emphasis">popd</EM> to printan error message and do nothing.</P><PCLASS="para">To accomplish this, we need to test for an empty stack, i.e., whether<BCLASS="emphasis.bold">$DIRSTACK</B> is null or not. Here is one way to do it:<ACLASS="indexterm"NAME="AUTOID-7912"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function popd {                 # pop directory off the stack, cd there    if [[ -n $DIRSTACK ]]; then        DIRSTACK=${DIRSTACK#* }        cd ${DIRSTACK%% *}        print &quot;$PWD&quot;    else        print &quot;stack empty, still in $PWD.&quot;    fi}</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7919"></A>Notice that instead of putting <BCLASS="emphasis.bold">then</B> on a separate line,we put it on the same line as the <BCLASS="emphasis.bold">if</B> after a semicolon,which is the shell's standard statement separator character.</P><PCLASS="para">We could have used operators other than <BCLASS="emphasis.bold">-n</B>.  <ACLASS="indexterm"NAME="AUTOID-7926"></A>For example,we could have used <BCLASS="emphasis.bold">-z</B> and switched the code in the <BCLASS="emphasis.bold">then</B>and <BCLASS="emphasis.bold">else</B> clauses. We also could have used:[6]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] <ACLASS="indexterm"NAME="AUTOID-7935"></A>Note that this code does <EMCLASS="emphasis">not</EM> work under the older <EMCLASS="emphasis">[ ]</EM>or <EMCLASS="emphasis">test</EM> syntax, which will complain about a missing argumentif the variable is null.  <ACLASS="indexterm"NAME="AUTOID-7941"></A>This means that it is no longer necessary to surroundboth sides with double quotes (or to usehacks like <BCLASS="emphasis.bold">[ x$DIRSTACK = x ]</B>) as you had to withthe Bourne shell;the Korn shell's <BCLASS="emphasis.bold">[[</B>/<BCLASS="emphasis.bold">]]</B> syntax handles null values correctly.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ $DIRSTACK = &quot;&quot; ]]; then        ...</PRE></BLOCKQUOTE></P><ACLASS="indexterm"NAME="AUTOID-7948"></A><PCLASS="para">While we're cleaning up code we wrote in the last chapter,let's fix up the error handling in the <EMCLASS="emphasis">highest</EM> script(Task 4-1). The code for that script is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">filename=${1:?&quot;filename missing.&quot;}howmany=${2:-10}sort -nr $filename | head -$howmany</PRE></BLOCKQUOTE></P><PCLASS="para">Recall that if you omit the first argument (the filename),the shell prints the message <BCLASS="emphasis.bold">highest: 1: filename missing</B>.We can make this better by substituting a more standard &quot;usage&quot; message:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ -z $1 ]]; then    print 'usage: howmany filename [-N]'else    filename=$1    howmany=${2:-10}    sort -nr $filename | head -$howmanyfi</PRE></BLOCKQUOTE></P><PCLASS="para">It is considered better programming style to enclose allof the code in the <BCLASS="emphasis.bold">if</B>-<BCLASS="emphasis.bold">then</B>-<BCLASS="emphasis.bold">else</B>, but such code canget confusing if you are writing a long script in which you needto check for errors and bail out at several points along the way.Therefore, a more usual style for shell programming is this:<ACLASS="indexterm"NAME="AUTOID-7961"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ -z $1 ]]; then    print 'usage: howmany filename [-N]'    return 1fifilename=$1howmany=${2:-10}sort -nr $filename | head -$howmany</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7968"></A>The <BCLASS="emphasis.bold">return</B> statement informs any calling program that needs to know whether it ransuccessfully or not.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-C-COMPILERS"></A>As an example of the <BCLASS="emphasis.bold">=</B> and <BCLASS="emphasis.bold">!=</B> operators, we can add the shell script front end to a C compiler to our solution for Task 4-2. Recall that we are given a filenameending in <EMCLASS="emphasis">.c</EM> (the source code file),and we need to construct a filename that is thesame but ends in <EMCLASS="emphasis">.o</EM> (the object code file).The modifications we will make have to do with other types offiles that can be passed to a C compiler.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-5-SECT-1.3.2">5.1.3.2 About C Compilers</A></H4><PCLASS="para">Before we get to the shell code, it is necessary to understanda few things about C compilers.We already know that they translate C source code intoobject code. Actually, they are part of <EMCLASS="emphasis">compilation systems</EM>that also perform several other tasks. The term &quot;compiler&quot; is oftenused instead of &quot;compilation system,&quot; so we'll use it in both senses.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-ASSEMBLY-LANGUAGE"></A><ACLASS="indexterm"NAME="AUTOID-7985"></A><ACLASS="indexterm"NAME="AUTOID-7988"></A><ACLASS="indexterm"NAME="KSH-CH-5-IX-LINKING"></A><ACLASS="indexterm"NAME="AUTOID-7993"></A>We're interested here in two tasks that compilers perform otherthan compiling C code:they can translate <EMCLASS="emphasis">assembly language</EM> code into object code,and they can<EMCLASS="emphasis">link</EM> object code files together to form an <EMCLASS="emphasis">executable</EM> program.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-C-PROGRAMMING-LANGUAGE"></A><EMCLASS="emphasis">Assembly language</EM> works at a level that is close tothe bare computer; each assembly statementis directly translatable into a statement of object code-asopposed to C or other higher-level languages, in which a single sourcestatement could translate to dozens of object code instructions.Translating a file of assembly language code into object codeis called, not surprisingly, <EMCLASS="emphasis">assembling</EM> the code.</P><PCLASS="para">Although many people consider assembly language to be quaintlyold-fashioned&nbsp;- like a typewriter in this age ofWYSIWYG word processing and desktop publishing-some programmers still need to use it when dealing with precisedetails of computer hardware. It's not uncommon for a program toconsist of several files' worth of code in a higher-level language(such as C) and a few low-level routines in assembly language.<ACLASS="indexterm"NAME="AUTOID-8005"></A></P><PCLASS="para">The other task we'll worry about is called <EMCLASS="emphasis">linking</EM>. Most real-world programs,unlike those assigned for a first-year programming class, consist ofseveral files of source code, possibly written by several differentprogrammers.  <ACLASS="indexterm"NAME="AUTOID-8008"></A>These files are compiled into object code; then the objectcode must be combined to form the final, runnable program, known asan <EMCLASS="emphasis">executable</EM>. The taskof combining is often called &quot;linking&quot;: each object code component usuallycontains references to other components, and these references mustbe resolved or &quot;linked&quot; together.</P><PCLASS="para">C compilation systems are capable of assembling files of assembly languageinto object codeand linking object code files into executables. In particular, acompiler callsa separate <EMCLASS="emphasis">assembler</EM> to deal with assembly code and a <EMCLASS="emphasis">linker</EM>(also known as a &quot;loader,&quot; &quot;linking loader,&quot; or &quot;link editor&quot;)to deal with object code files. These separate tools are known inthe UNIX world as <EMCLASS="emphasis">as</EM> and <EMCLASS="emphasis">ld</EM>, respectively. The C compiler itself is invoked with the command <EMCLASS="emphasis">cc</EM>.</P><PCLASS="para">We can express all of these steps in terms of the suffixes of filespassed as arguments to the C compiler. Basically, the compiler doesthe following:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">If the argument ends in <EMCLASS="emphasis">.c</EM> it's a C source file;compile into a <EMCLASS="emphasis">.o</EM> object code file.</P></LI><LICLASS="listitem"><PCLASS="para">If the argument ends in <EMCLASS="emphasis">.s</EM>, it's assembly language;assemble into a <EMCLASS="emphasis">.o</EM> file.</P></LI><LICLASS="listitem"><PCLASS="para">If the argument ends in <EMCLASS="emphasis">.o</EM>, do nothing; save for the linking step later.</P></LI><LICLASS="listitem"><PCLASS="para">If the argument ends in some other suffix, print an error message andexit.[7]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] For the purposes of this example. We know this isn't strictly true in real life.</P></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8037"></A><ACLASS="indexterm"NAME="AUTOID-8041"></A>Link all <EMCLASS="emphasis">.o</EM> object code files into an executable file called <EMCLASS="emphasis">a.out</EM>.This file is usually renamed to something more descriptive.</P></LI></OL><PCLASS="para">Step 3 allows object code files that have already been compiled(or assembled) to be re-used to build other executables.<ACLASS="indexterm"NAME="AUTOID-8046"></A>For example, an object code file that implements an interface toa <SPANCLASS="acronym">CD-ROM</SPAN> drive could be useful in any program that reads from <SPANCLASS="acronym">CD-ROMS</SPAN>.</P><PCLASS="para"><ACLASS="xref"HREF="ch05_01.htm#KSH-CH-5-FIG-0"TITLE="Files produced by a C compiler">Figure 5.1</A> should make the compilation process clearer; it shows how the compiler processesthe C source files <EMCLASS="emphasis">a.c</EM> and <EMCLASS="emphasis">b.c</EM>, the assembly language file<EMCLASS="emphasis">c.s</EM>, and the already-compiled object code file <EMCLASS="emphasis">d.o</EM>.In other words, it shows how the compiler handles the command<BCLASS="emphasis.bold">cc a.c b.c c.s d.o</B>.</P><H4CLASS="figure"><ACLASS="title"NAME="KSH-CH-5-FIG-0">Figure 5.1: Files produced by a C compiler</A></H4><IMGCLASS="graphic"SRC="figs/korn0501.gif"ALT="Figure 5.1"><PCLASS="para">Here is how we would begin to implement this behavior in a shell script.Assume that thevariable <BCLASS="emphasis.bold">filename</B> holds the argument in question, and that<EMCLASS="emphasis">ccom</EM> is the name of the program that actually compiles a C sourcefile into object code. Assume further that <EMCLASS="emphasis">ccom</EM> and <EMCLASS="emphasis">as</EM>(assembler) take arguments for the names of the source and object files:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ $filename = *.c ]]; then    objname=${filename%.c}.o    ccom $filename $objnameelif [[ $filename = *.s ]]; then    objname=${filename%.s}.o    as $filename $objnameelif [[ $filename != *.o ]]; then    print &quot;error: $filename is not a source or object file.&quot;    return 1fi<EMCLASS="emphasis">further processing...</EM></PRE></BLOCKQUOTE></P><PCLASS="para">Recall from the previous chapter that the expression<BCLASS="emphasis.bold">${filename%.c}.o</B> deletes <EMCLASS="emphasis">.c</EM> from <BCLASS="emphasis.bold">filename</B> andappends <EMCLASS="emphasis">.o</EM>; <BCLASS="emphasis.bold">${filename%.s}.o</B> does the analogousthing for files ending in <EMCLASS="emphasis">.s</EM>.</P><PCLASS="para">The &quot;further processing&quot; is the link step, which we will see whenwe complete this example later in the chapter.<ACLASS="indexterm"NAME="AUTOID-8076"></A><ACLASS="indexterm"NAME="AUTOID-8077"></A><ACLASS="indexterm"NAME="AUTOID-8078"></A><ACLASS="indexterm"NAME="AUTOID-8079"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-5-SECT-1.3.3">5.1.3.3 File Attribute Checking</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-CND-TSTS-FILE-ATTR-OPRTRS"></A>The other kind of operator that can be used in conditionalexpressions checks a file for certain properties. There are 21 such operators. Wewill cover those of most general interest here; the rest referto arcana like sticky bits, sockets, and file descriptors,and thus are of interest only to systems hackers. Refer to<ACLASS="xref"HREF="appb_01.htm"TITLE="Reference Lists">Appendix B, Reference Lists</A> for the complete list. <ACLASS="xref"HREF="ch05_01.htm#KSH-CH-5-TAB-1"TITLE="File Attribute Operators">Table 5.2</A>lists those thatwe will examine.<ACLASS="indexterm"NAME="AUTOID-8088"></A><ACLASS="indexterm"NAME="AUTOID-8092"></A><ACLASS="indexterm"NAME="AUTOID-8096"></A><ACLASS="indexterm"NAME="AUTOID-8100"></A><ACLASS="indexterm"NAME="AUTOID-8104"></A><ACLASS="indexterm"NAME="AUTOID-8108"></A><ACLASS="indexterm"NAME="AUTOID-8112"></A><ACLASS="indexterm"NAME="AUTOID-8116"></A><ACLASS="indexterm"NAME="AUTOID-8120"></A><ACLASS="indexterm"NAME="AUTOID-8124"></A><ACLASS="indexterm"NAME="AUTOID-8128"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-5-TAB-1">Table 5.2: File Attribute Operators</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operator </TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">True if...</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-a <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">file</EM> exists</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-d <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">file</EM> is a directory</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-f <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><EMCLASS="emphasis">file</EM> is a regular file (i.e., not a directory or other special type of file)</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-r <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">You have read permission on <EMCLASS="emphasis">file</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-s <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">file</EM> exists and is not empty</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-w <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">You have write permission on <EMCLASS="emphasis">file</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-x <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">You have execute permission on <EMCLASS="emphasis">file</EM>,or directory search permission if it is a directory</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-O <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">You own <EMCLASS="emphasis">file</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-G <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Your group ID is the same as that of <EMCLASS="emphasis">file</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">file1</EM> -nt <EMCLASS="emphasis">file2</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">file1</EM> is newer than <EMCLASS="emphasis">file2</EM>[8]</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">file1</EM> -ot <EMCLASS="emphasis">file2</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><EMCLASS="emphasis">file1</EM> is older than <EMCLASS="emphasis">file2</EM></TD></TR></TBODY></TABLE><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] Specifically, the <BCLASS="emphasis.bold">-nt</B> and <BCLASS="emphasis.bold">-ot</B> operators compare <EMCLASS="emphasis">modification times</EM> of two files.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8207"></A><ACLASS="indexterm"NAME="AUTOID-8210"></A><ACLASS="indexterm"NAME="AUTOID-8213"></A>Before we get to an example, you should know that conditionalexpressions inside <BCLASS="emphasis.bold">[[</B> and <BCLASS="emphasis.bold">]]</B> can also be combined usingthe logical operators <BCLASS="emphasis.bold">&amp;&amp;</B> and <BCLASS="emphasis.bold">||</B>, just as we sawwith plain shell commands above, in the section entitled &quot;Combinationsof Exit Statuses.&quot; It's also possible tocombine shell commands with conditional expressionsusing logical operators, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if <CODECLASS="replaceable"><I>command</I></CODE> &amp;&amp; [[ <CODECLASS="replaceable"><I>condition</I></CODE> ]]; then    ...</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A> contains an example of this combination.</P><PCLASS="para">You can also negate thetruth value of a conditional expression by preceding it withan exclamation point (<BCLASS="emphasis.bold">!</B>), so that <BCLASS="emphasis.bold">!</B> <EMCLASS="emphasis">expr</EM> evaluates totrue only if <EMCLASS="emphasis">expr</EM> is false.<ACLASS="indexterm"NAME="AUTOID-8231"></A>Furthermore, you can make complex logical expressions of conditional operators bygrouping them with parentheses.[9]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] <ACLASS="indexterm"NAME="AUTOID-8236"></A>It turns out that this is true outside of the <BCLASS="emphasis.bold">[[</B>/<BCLASS="emphasis.bold">]]</B>construct as well. As we will see in <ACLASS="xref"HREF="ch08_01.htm"TITLE="Process Handling">Chapter 8, Process Handling</A>the construct <BCLASS="emphasis.bold">(</B><EMCLASS="emphasis">statement list</EM><BCLASS="emphasis.bold">)</B> runs the statement listin a subshell, whose exit status is that of the last statement in the list. However, there is no equivalent of the negation (!)operator outside of the <BCLASS="emphasis.bold">[[</B>/<BCLASS="emphasis.bold">]]</B> construct, although therewill be in future releases.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-PUSHD2"></A>Here is how we would use two of the file operators to embellish(yet again) our <EMCLASS="emphasis">pushd</EM> function. Instead of having <BCLASS="emphasis.bold">cd</B>determine whether the argument given is a valid directory-i.e., by returning with a bad exit status if it's not-wecan do the checking ourselves. Here is the code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function pushd {                # push current directory onto stack    dirname=$1    if [[ -d $dirname &amp;&amp; -x $dirname ]]; then        cd $dirname        DIRSTACK=&quot;$dirname ${DIRSTACK:-$PWD}&quot;        print &quot;$DIRSTACK&quot;    else        print &quot;still in $PWD.&quot;    fi}</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8255"></A><ACLASS="indexterm"NAME="AUTOID-8259"></A>The conditional expression evaluates to true only if the argument<BCLASS="emphasis.bold">$1</B> is a directory (<BCLASS="emphasis.bold">-d</B>) <EMCLASS="emphasis">and</EM> the user has permissionto change to it (<BCLASS="emphasis.bold">-x</B>).[10]Notice that this conditional also handles the case where theargument is missing: <BCLASS="emphasis.bold">$dirname</B> is null, and since the nullstring isn't a valid directory name, the conditional will fail.<ACLASS="indexterm"NAME="AUTOID-8271"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[10] Remember thatthe same permission flag that determines execute permissionon a regular file determines search permission on a directory.This is whythe <BCLASS="emphasis.bold">-x</B> operator checks both things depending on file type.</P></BLOCKQUOTE><PCLASS="para">Here is a more comprehensive example of the use of file operators.</P><DIVCLASS="task"><H4>Task 5.1</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8276"></A>Write a script that prints essentially the same information as <BCLASS="emphasis.bold">ls -l</B> but in a more user-friendly way.</P></BLOCKQUOTE><PCLASS="para">Although this task requires relatively long-winded code, itis a straightforward application of many of the file operators:<ACLASS="indexterm"NAME="AUTOID-8281"></A><ACLASS="indexterm"NAME="AUTOID-8285"></A><ACLASS="indexterm"NAME="AUTOID-8289"></A><ACLASS="indexterm"NAME="AUTOID-8293"></A><ACLASS="indexterm"NAME="AUTOID-8297"></A><ACLASS="indexterm"NAME="AUTOID-8301"></A><ACLASS="indexterm"NAME="AUTOID-8305"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ ! -a $1 ]]; then    print &quot;file $1 does not exist.&quot;    return 1fiif [[ -d $1 ]]; then    print -n &quot;$1 is a directory that you may &quot;    if [[ ! -x $1 ]]; then        print -n &quot;not &quot;    fi    print &quot;search.&quot;elif [[ -f $1 ]]; then    print &quot;$1 is a regular file.&quot;else    print &quot;$1 is a special type of file.&quot;fiif [[ -O $1 ]]; then    print 'you own the file.'else    print 'you do not own the file.'fiif [[ -r $1 ]]; then    print 'you have read permission on the file.'fiif [[ -w $1 ]]; then    print 'you have write permission on the file.'fiif [[ -x $1 &amp;&amp; ! -d $1 ]]; then    print 'you have execute permission on the file.'fi</PRE></BLOCKQUOTE></P><PCLASS="para">We'll call this script <EMCLASS="emphasis">fileinfo</EM>. Here's how it works:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8316"></A>The first conditional tests if the file given as argumentdoes <EMCLASS="emphasis">not</EM> exist (the exclamation point is the &quot;not&quot; operator;the spaces around it are required). If the file does not exist, the scriptprints an error message and exits with error status.</P></LI><LICLASS="listitem"><PCLASS="para">The second conditional tests if the file is a directory.<ACLASS="indexterm"NAME="AUTOID-8322"></A>If so, the first <EMCLASS="emphasis">print</EM> prints part of a message; remember that the<BCLASS="emphasis.bold">-n</B> option tells <EMCLASS="emphasis">print</EM> not to print a LINEFEED at the end.The inner conditional checks if you do <EMCLASS="emphasis">not</EM> have searchpermission on the directory. If you don't have search permission, the word &quot;not&quot; is added tothe partial message. Then, the message is completed with&quot;search.&quot; and a LINEFEED.</P></LI><LICLASS="listitem"><PCLASS="para">The <BCLASS="emphasis.bold">elif</B> clause checks if the file is a regular file;if so, it prints a message.</P></LI><LICLASS="listitem"><PCLASS="para">The <BCLASS="emphasis.bold">else</B> clause accounts for the various special file typeson recent UNIX systems, such as sockets, devices, FIFO files, etc.We assume that the casual user isn't interested in details of these.</P></LI><LICLASS="listitem"><PCLASS="para">The next conditional tests to see if the file is owned by you(i.e., if its owner ID is the same as your login ID). If so, itprints a message saying that you own it.</P></LI><LICLASS="listitem"><PCLASS="para">The next two conditionals test for your read and write permission onthe file.</P></LI><LICLASS="listitem"><PCLASS="para">The last conditional checks if you can execute the file.It checks to see if you have execute permission and thatthe file is <EMCLASS="emphasis">not</EM> a directory. (If the file were a directory,execute permission would really mean directory search permission.)</P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8344"></A><ACLASS="indexterm"NAME="AUTOID-8345"></A>As an example of <EMCLASS="emphasis">fileinfo</EM>'s output, assume that you do an <BCLASS="emphasis.bold">ls -l</B> ofyour current directory and it contains these lines:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">-rwxr-xr-x   1 billr    other        594 May 28 09:49 bob-rw-r-r-     1 billr    other      42715 Apr 21 23:39 custom.tbldrwxr-xr-x   2 billr    other         64 Jan 12 13:42 exp-r-r-r-      1 root     other        557 Mar 28 12:41 lpst</PRE></BLOCKQUOTE></P><PCLASS="para"><EMCLASS="emphasis">custom.tbl</EM> and <EMCLASS="emphasis">lpst</EM> are regular text files,<EMCLASS="emphasis">exp</EM> is a directory,and <EMCLASS="emphasis">bob</EM> is a shell script.Typing <BCLASS="emphasis.bold">fileinfo bob</B> produces this output:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">bob is a regular file.you own the file.you have read permission on the file.you have write permission on the file.you have execute permission on the file.</PRE></BLOCKQUOTE></P><PCLASS="para">Typing <BCLASS="emphasis.bold">fileinfo custom.tbl</B> results in this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">custom.tbl is a regular file.you own the file.you have read permission on the file.you have write permission on the file.</PRE></BLOCKQUOTE></P><PCLASS="para">Typing <BCLASS="emphasis.bold">fileinfo exp</B> results in this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">exp is a directory that you may search.you own the file.you have read permission on the file.you have write permission on the file.</PRE></BLOCKQUOTE></P><PCLASS="para">Finally, typing <BCLASS="emphasis.bold">fileinfo lpst</B> produces this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">lpst is a regular file.you do not own the file.you have read permission on the file.</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A> contains an example of the <BCLASS="emphasis.bold">-nt</B> test operator.</P></DIV></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-5-SECT-1.4">5.1.4 Integer Conditionals</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-CND-TSTS-INTR-COMPARISON-OPRTRS"></A><ACLASS="indexterm"NAME="AUTOID-8381"></A>The shell also provides a set of <EMCLASS="emphasis">arithmetic</EM> tests.  These are different from <EMCLASS="emphasis">character string</EM> comparisonslike <BCLASS="emphasis.bold">&lt;</B> and <BCLASS="emphasis.bold">&gt;</B>, which compare <EMCLASS="emphasis">lexicographic</EM> valuesof strings, not numeric values. For example, &quot;6&quot; is greater than&quot;57&quot; lexicographically, just as &quot;p&quot; is greater than &quot;ox,&quot;but of course the opposite is true when they're comparedas integers.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8390"></A>The integer comparison operatorsare summarized in <ACLASS="xref"HREF="ch05_01.htm#KSH-CH-5-TAB-2"TITLE="Arithmetic Test Operators">Table 5.3</A>.FORTRAN programmers will findtheir syntax slightly familiar.<ACLASS="indexterm"NAME="AUTOID-8393"></A><ACLASS="indexterm"NAME="AUTOID-8397"></A><ACLASS="indexterm"NAME="AUTOID-8401"></A><ACLASS="indexterm"NAME="AUTOID-8405"></A><ACLASS="indexterm"NAME="AUTOID-8409"></A><ACLASS="indexterm"NAME="AUTOID-8413"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-5-TAB-2">Table 5.3: Arithmetic Test Operators</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Test</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Comparison</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-lt</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Less than</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-le</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Less than or equal</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-eq</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Equal</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-ge</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Greater than or equal</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-gt</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Greater than</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-ne</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Not equal</TD></TR></TBODY></TABLE><PCLASS="para">You'll find these to be of the most use in the context of theinteger variables we'll see in the next chapter. They're necessary if you want to combine integer tests with other types oftests within the same conditional expression.  </P><PCLASS="para">However, the shell has a separate syntax for conditionalexpressions that involve integers only. It's considerablymore efficient, so you should use it in preference to the arithmetictest operators listed above.Again, we'll cover the shell's integer conditionals in the next chapter.<ACLASS="indexterm"NAME="AUTOID-8445"></A><ACLASS="indexterm"NAME="AUTOID-8446"></A><ACLASS="indexterm"NAME="AUTOID-8447"></A></P></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch04_05.htm"TITLE="4.5 Advanced Examples: pushd and popd"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 4.5 Advanced Examples: pushd and popd"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_02.htm"TITLE="5.2 for"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.2 for"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">4.5 Advanced Examples: pushd and popd</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">5.2 for</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>