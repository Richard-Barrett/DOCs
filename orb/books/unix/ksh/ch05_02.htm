<HTML><HEAD><TITLE>[Chapter 5] 5.2 for</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:09:00Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch05_01.htm"TITLE="5. Flow Control"><LINKREL="prev"HREF="ch05_01.htm"TITLE="5.1 if/else"><LINKREL="next"HREF="ch05_03.htm"TITLE="5.3 case"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_01.htm"TITLE="5.1 if/else"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.1 if/else"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 5<BR>Flow Control</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_03.htm"TITLE="5.3 case"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.3 case"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-5-SECT-2">5.2 for</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-FOR"></A>The most obvious enhancement we could make to the previous scriptis the ability to report on multiple files instead of just one.Tests like <BCLASS="emphasis.bold">-a</B> and <BCLASS="emphasis.bold">-d</B> only take singlearguments, so we need a way of calling the code once for each filegiven on the command line.</P><PCLASS="para">The way to do this-indeed, the way to do many thingswith the Korn shell-is with a looping construct.  The simplest and most widelyapplicable of the shell's looping constructs is the<BCLASS="emphasis.bold">for</B> loop. We'll use <BCLASS="emphasis.bold">for</B> to enhance <EMCLASS="emphasis">fileinfo</EM> soon.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8460"></A>The <BCLASS="emphasis.bold">for</B> loop allows you to repeat a section of code a fixednumber of times. During each time through the code (known as an<EMCLASS="emphasis">iteration</EM>), a special variable called a <EMCLASS="emphasis">loop variable</EM> isset to a different value; this way each iteration can do somethingslightly different.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8467"></A><ACLASS="indexterm"NAME="AUTOID-8470"></A><ACLASS="indexterm"NAME="AUTOID-8472"></A>The <BCLASS="emphasis.bold">for</B> loop is somewhat, but not entirely,similar to its counterparts in conventional languages like C and Pascal.The chief difference is that the shell's <BCLASS="emphasis.bold">for</B> loop doesn't letyou specify a number of times to iterate or arange of values over which to iterate; instead, itonly lets you give a fixed list of values. In other words,you can't do anything like this Pascal-type code, which executes<EMCLASS="emphasis">statements</EM> 10 times:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for x := 1 to 10 dobegin    <EMCLASS="emphasis">statements...</EM>end</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8481"></A>(You need the <BCLASS="emphasis.bold">while</B> construct, which we'll see soon, toconstruct this type of loop. You also need the ability to do integerarithmetic, which we will see in <ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6, Command-line Options and Typed Variables</A>.)</P><PCLASS="para">However, the <BCLASS="emphasis.bold">for</B> loop is ideal for working witharguments on the command line and with sets offiles (e.g., all files in a given directory). We'll look at anexample of each of these.  <ACLASS="indexterm"NAME="AUTOID-8487"></A>But first, we'll show the syntax for the <BCLASS="emphasis.bold">for</B> construct:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for <CODECLASS="replaceable"><I>name</I></CODE> [in <CODECLASS="replaceable"><I>list</I></CODE>]do    <CODECLASS="replaceable"><I>statements that can use</I></CODE> $name...done</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8497"></A><ACLASS="indexterm"NAME="AUTOID-8500"></A><ACLASS="indexterm"NAME="AUTOID-8504"></A>The <EMCLASS="emphasis">list</EM> is a list of names. (If <BCLASS="emphasis.bold">in</B> <EMCLASS="emphasis">list</EM> is omitted,the list defaults to <CODECLASS="literal">&quot;</CODE>$@<CODECLASS="literal">&quot;</CODE>, i.e., the quoted list of command-linearguments, but we'll always supply the <BCLASS="emphasis.bold">in</B> <EMCLASS="emphasis">list</EM> for thesake of clarity.)  In our solutions to the following task, we'll show two simple ways tospecify lists. </P><DIVCLASS="task"><H4>Task 5.2</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">You work in an environment with several computers in a local network.Write a shell script that tells you who is logged into each machine on the network.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-FINGER"></A>The command <EMCLASS="emphasis">finger</EM>(1) can be used (among other things)to find the names of users logged into a remote system; the command<BCLASS="emphasis.bold">finger @</B><EMCLASS="emphasis">systemname</EM> does this. Its output depends onthe version of UNIX, but it looks something like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[motet.early.com]Trying 127.146.63.17...-User-    -Full name-       -What- Idle TTY -Console Location-hildy    Hildegard von Bingen  ksh   2d5h p1  jem.cal (Telnet)mikes    Michael Schultheiss   csh   1:21 r4  ncd2.cal (X display 0)orlando  Orlando di Lasso      csh     28 r7  maccala (Telnet)marin    Marin Marais          mush  1:02 pb  mussell.cal (Telnet)johnd    John Dowland          tcsh    17 p0  nugget.west.nobis. (X Window)</PRE></BLOCKQUOTE></P><PCLASS="para">In this output, <EMCLASS="emphasis">motet.early.com</EM> is the full network name of the remotemachine.</P><PCLASS="para">Assume the systems in your network are called <EMCLASS="emphasis">fred</EM>, <EMCLASS="emphasis">bob</EM>, <EMCLASS="emphasis">dave</EM>, and <EMCLASS="emphasis">pete</EM>.Then the following code would do the trick:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for sys in fred bob dave petedo    finger @$sys    printdone</PRE></BLOCKQUOTE></P><PCLASS="para">This works no matter which of the systems you are currently logged into.It prints output for each machine similar to the above, with blanklines in between.</P><PCLASS="para">A slightly better solution would be to store the names of the systemsin an environment variable.This way, if systems are added to your network and youneed a list of their names in more than one script, you need changethem in only one place. If a variable's value is several words separatedby blanks (or TABS), <BCLASS="emphasis.bold">for</B> will treat it as a list of words.</P><PCLASS="para">Here is the improved solution. First, put lines in your<EMCLASS="emphasis">.profile</EM> or environment filethat define the variable <BCLASS="emphasis.bold">SYSNAMES</B> and makeit an environment variable:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">SYSNAMES=&quot;fred bob dave pete&quot;export SYSNAMES</PRE></BLOCKQUOTE></P><PCLASS="para">Then, the script can look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for sys in $SYSNAMESdo    finger @$sys    printdone</PRE></BLOCKQUOTE></P></DIV><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8547"></A>The foregoing illustrated a simple use of <BCLASS="emphasis.bold">for</B>, but it's much more common to use <BCLASS="emphasis.bold">for</B> to iterate through a list of  command-line arguments.  To show this, we can enhance the <EMCLASS="emphasis">fileinfo</EM> script above toaccept multiple arguments. First, we write a bit of &quot;wrapper&quot;code that does the iteration:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for filename in &quot;$@&quot; ; do    finfo $filename    printdone</PRE></BLOCKQUOTE></P><PCLASS="para">Next, we make the original script into a function called <EMCLASS="emphasis">finfo</EM>:[11]<ACLASS="indexterm"NAME="AUTOID-8557"></A><ACLASS="indexterm"NAME="AUTOID-8561"></A><ACLASS="indexterm"NAME="AUTOID-8565"></A><ACLASS="indexterm"NAME="AUTOID-8569"></A><ACLASS="indexterm"NAME="AUTOID-8573"></A><ACLASS="indexterm"NAME="AUTOID-8577"></A><ACLASS="indexterm"NAME="AUTOID-8581"></A><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function finfo {    if [[ ! -a $1 ]]; then        print &quot;file $1 does not exist.&quot;        return 1    fi    ...}</PRE></BLOCKQUOTE></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[11] A function can have the same name as a script; however, thisisn't good programming practice.</P></BLOCKQUOTE><PCLASS="para">The complete script consists of the <BCLASS="emphasis.bold">for</B> loop code andthe above function, in either order; good programming styledictates that the function definition should go first.</P><PCLASS="para">The <EMCLASS="emphasis">fileinfo</EM> script works as follows: in the <BCLASS="emphasis.bold">for</B> statement,<CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$@</B><CODECLASS="literal">&quot;</CODE> is a list of all positional parameters.For each argument, the body of the loop is runwith <BCLASS="emphasis.bold">filename</B> set to that argument. In other words,the function <EMCLASS="emphasis">fileinfo</EM> is called once foreach value of <BCLASS="emphasis.bold">$filename</B> as its first argument (<BCLASS="emphasis.bold">$1</B>).The call to <EMCLASS="emphasis">print</EM> after the call to <EMCLASS="emphasis">fileinfo</EM> merelyprints a blank line between sets of information about each file.</P><PCLASS="para">Given a directory with the same files as the previous example,typing <BCLASS="emphasis.bold">fileinfo *</B> would produce the following output:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">bob is a regular file.you own the file.you have read permission on the file.you have write permission on the file.you have execute permission on the file.custom.tbl is a regular file.you own the file.you have read permission on the file.you have write permission on the file.exp is a directory that you may search.you own the file.you have read permission on the file.you have write permission on the file.lpst is a regular file.you do not own the file.you have read permission on the file.</PRE></BLOCKQUOTE></P><PCLASS="para">Here is a programming task that exploits the other majoruse of <BCLASS="emphasis.bold">for</B>.<ACLASS="indexterm"NAME="AUTOID-8606"></A></P><DIVCLASS="task"><H4>Task 5.3</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">Your UNIX system has the ability to transfer files from an <SPANCLASS="acronym">MS-DOS</SPAN> system,but it leaves the <SPANCLASS="acronym">DOS</SPAN> filenames intact. Write a script thattranslates the filenames in a given directoryfrom <SPANCLASS="acronym">DOS</SPAN> format to a more UNIX-friendly format.</P></BLOCKQUOTE><PCLASS="para"><SPANCLASS="acronym">DOS</SPAN> filenames have the format <EMCLASS="emphasis">FILENAME.<SPANCLASS="acronym">EXT</SPAN></EM>. <EMCLASS="emphasis"><SPANCLASS="acronym">FILENAME</SPAN></EM>can be up to eight characters long;<EMCLASS="emphasis"><SPANCLASS="acronym">EXT</SPAN></EM> is an extension that can be up to three characters.The dot is required even if the extension is null;letters are all uppercase. We want to do the following:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Translate letters from uppercase to lowercase.</P></LI><LICLASS="listitem"><PCLASS="para">If the extension is null, remove the dot.</P></LI></OL><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-TR"></A>The first tool we will need for this job is the UNIX <EMCLASS="emphasis">tr</EM>(1)utility, which translates characters on a one-to-one basis.Given the arguments <EMCLASS="emphasis">charset1</EM> and <EMCLASS="emphasis">charset2</EM>, it willtranslate characters in the standard input that are members of<EMCLASS="emphasis">charset1</EM> into corresponding characters in <EMCLASS="emphasis">charset2</EM>.The two sets are ranges of characters enclosed in square brackets (<BCLASS="emphasis.bold">[]</B>in standard regular-expression form in the manner of <EMCLASS="emphasis">grep</EM>, <EMCLASS="emphasis">awk</EM>,<EMCLASS="emphasis">ed</EM>, etc.). More to the point, <BCLASS="emphasis.bold">tr [A-Z] [a-z]</B> takesits standard input, converts uppercase letters to lowercase,and writes the converted text to the standard output.</P><PCLASS="para">That takes care of the first step in the translation process.We can use a Korn shell string operator to handle the second.Here is the code for a script we'll call <EMCLASS="emphasis">dosmv</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for filename in ${1:+$1/}* ; do    newfilename=$(print $filename | tr [A-Z] [a-z])    newfilename=${newfilename%.}    print &quot;$filename -&gt; $newfilename&quot;    mv $filename $newfilenamedone</PRE></BLOCKQUOTE></P><PCLASS="para">The * in the <BCLASS="emphasis.bold">for</B> construct is <EMCLASS="emphasis">not</EM> the sameas <BCLASS="emphasis.bold">$</B>*. It's a wildcard, i.e., all files in a directory.</P><PCLASS="para">This script acceptsa directory name as argument, the default being the currentdirectory.  <ACLASS="indexterm"NAME="AUTOID-8649"></A><ACLASS="indexterm"NAME="AUTOID-8652"></A>The expression <BCLASS="emphasis.bold">${1:+$1/}</B> evaluates to theargument (<BCLASS="emphasis.bold">$1</B>) with a slash appended if the argument issupplied, or the null string if it isn't supplied.So the entire expression <BCLASS="emphasis.bold">${1:+$1/}*</B> evaluatesto all files in the given directory, or all files inthe current directory if no argument is given.</P><PCLASS="para">Therefore, <BCLASS="emphasis.bold">filename</B> takes on the value of each filenamein the list. <BCLASS="emphasis.bold">filename</B> gets translated into <BCLASS="emphasis.bold">newfilename</B>in two steps. (We could have done it in one, but readability wouldhave suffered.) The first step uses <EMCLASS="emphasis">tr</EM> in a pipeline withina command substitution construct. Our old friend <BCLASS="emphasis.bold">print</B> makes the value of <BCLASS="emphasis.bold">filename</B> the standard input to <EMCLASS="emphasis">tr</EM>.<EMCLASS="emphasis">tr</EM>'s output becomes the value of the command substitutionexpression, which is assigned to <BCLASS="emphasis.bold">newfilename</B>. Thus, if<BCLASS="emphasis.bold">$filename</B> were <EMCLASS="emphasis">DOSFILE.<SPANCLASS="acronym">TXT</SPAN></EM>, <BCLASS="emphasis.bold">newfilename</B> would become<EMCLASS="emphasis">dosfile.txt</EM>.<ACLASS="indexterm"NAME="AUTOID-8673"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8675"></A><ACLASS="indexterm"NAME="AUTOID-8678"></A>The second step uses one of the shell's pattern-matching operators,the one that deletes the shortest match it finds at the end of thestring. The pattern here is <CODECLASS="literal">.,</CODE> which means a dot at the end ofthe string.[12]This means that the expression <BCLASS="emphasis.bold">${newfilename%.}</B> willdelete a dot from <BCLASS="emphasis.bold">$newfilename</B> only if it's at the end ofthe string; otherwise the expression will leave <BCLASS="emphasis.bold">$newfilename</B>intact. For example, if <BCLASS="emphasis.bold">$newfilename</B> is <EMCLASS="emphasis">dosfile.txt</EM>,it will be untouched, but if it's <EMCLASS="emphasis">dosfile.</EM>, the expression willchange it to <EMCLASS="emphasis">dosfile</EM> without the final dot. In either case,the new value is assigned back to <EMCLASS="emphasis">newfilename</EM>.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[12] UNIX regular expression mavens should remember that this isshell wildcard syntax, in which dots are not operators and thereforedo not need to be backslash-escaped.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8693"></A>The last statement in the <BCLASS="emphasis.bold">for</B> loop body does the filerenaming with the standard UNIX <EMCLASS="emphasis">mv</EM>(1) command. Before that,a <BCLASS="emphasis.bold">print</B> command simply informs the user of what's happening.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-MS-DOS"></A>There is one little problem with the solution on the previous page: if there are any files inthe given directory that <EMCLASS="emphasis">aren't</EM> DOS files (in particular,if there are files whose names don't contain uppercase letters anddon't contain a dot), then the conversion will do nothing to thosefilenames and <EMCLASS="emphasis">mv</EM> will be called with two identical arguments.<EMCLASS="emphasis">mv</EM> will complain with the message: <BCLASS="emphasis.bold">mv: filename and</B><EMCLASS="emphasis">filename</EM><BCLASS="emphasis.bold"> are identical</B>.  <ACLASS="indexterm"NAME="KSH-CH-5-IX-GREP"></A>We can solve this problem by letting <EMCLASS="emphasis">grep</EM> determine whethereach file has a DOS filename or not. The <EMCLASS="emphasis">grep</EM> regularexpression:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[^a-z]\{1,8\}\.[^a-z]\{0,3\}</PRE></BLOCKQUOTE></P><PCLASS="para">is adequate (forthese purposes) for matching DOS-format filenames.  [13]The character class<BCLASS="emphasis.bold">[^a-z]</B> means &quot;any character <EMCLASS="emphasis">except</EM> a lowercase letter.&quot;[14]So the entire regularexpression means: &quot;Between 1 and 8 non-lowercase letters,followed by a dot, followed by 0 to 3 non-lowercase letters.&quot;</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[13] As with the <BCLASS="emphasis.bold">lsd</B> function in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4, Basic Shell Programming</A> older BSD-derived versions ofUNIX don't support the &quot;repeat count&quot; operator within <EMCLASS="emphasis">grep</EM>.You must use this instead:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[^a-z][^a-z]?[^a-z]?[^a-z]?[^a-z]?[^a-z]?[^a-z]?[^a-z]?\.[^a-z]?[^a-z]?[^a-z]?</PRE></BLOCKQUOTE></P><PCLASS="para">[14] To be completely precise, this class also excludes NEWLINEs.</P></BLOCKQUOTE><PCLASS="para">When <EMCLASS="emphasis">grep</EM> runs, it normally prints all of the lines in its standardinput that match the pattern you give it as argument. But we onlyneed it to test whether or not the pattern is matched. Luckily,<EMCLASS="emphasis">grep</EM>'s exit status is &quot;well-behaved&quot;: it's 0 if there is amatch in the input, 1 if not. Therefore, we canuse the exit status to test for a match.  <ACLASS="indexterm"NAME="AUTOID-8728"></A>We also need to discard<EMCLASS="emphasis">grep</EM>'s output; to do this, we redirect it to the specialfile <EMCLASS="emphasis">/dev/null</EM>, which is colloquially known as the &quot;bit bucket.&quot;[15]Any output directed to <EMCLASS="emphasis">/dev/null</EM> effectively disappears.Thus, the command line:<BLOCKQUOTECLASS="screen"><PRECLASS="screen">print &quot;$filename&quot; | grep '[^a-z]\{1,8\}\.[^a-z]\{0,3\}' &gt; /dev/null</PRE></BLOCKQUOTE></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[15] Some Berkeley-derived versions of UNIX have a -s (&quot;silent&quot;)option to <EMCLASS="emphasis">grep</EM> that suppresses standard output, thereby makingredirection to <EMCLASS="emphasis">/dev/null</EM> unnecessary.</P></BLOCKQUOTE><PCLASS="para">prints nothing andreturns exit status 0 if the filename is in DOS format, 1 if not.</P><PCLASS="para">Now we can modify our <EMCLASS="emphasis">dosmv</EM> script to incorporate this code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">dos_regexp='[^a-z]\{1,8\}\.[^a-z]\{0,3\}'for filename in ${1:+$1/}* ; doif print $filename | grep $dos_regexp &gt; /dev/null; thennewfilename=$(print $filename | tr [A-Z] [a-z])newfilename=${newfilename%.}print &quot;$filename -&gt; $newfilename&quot;mv $filename $newfilenamefidone</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8744"></A>For readability reasons, we use the variable <BCLASS="emphasis.bold">dos_regexp</B> to holdthe DOS filename-matching regular expression.</P><PCLASS="para">If you are familiar with an operating system other than DOS and UNIX,you may want to test your script-writing prowess at this point bywriting a script that translates filenames from that system's formatinto UNIX format. Use the above script as a guideline.<ACLASS="indexterm"NAME="AUTOID-8747"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-VAX-VMS"></A>In particular, if you know DEC's VAX/VMS operating system,here's a programming challenge:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Write a script called <EMCLASS="emphasis">vmsmv</EM> that is similar to <EMCLASS="emphasis">dosmv</EM>but works on VAX/VMS filenames instead of DOS filenames.Remember that VAX/VMS filenames end with semicolons and versionnumbers.</P></LI><LICLASS="listitem"><PCLASS="para">Modify your script so that ifthere are several versions of the same file, it renames only thelatest version (with the highest version number).</P></LI><LICLASS="listitem"><PCLASS="para">Modify further so that your script erases old versions of files.</P></LI></OL><PCLASS="para">The first of these is a relatively straightforward modificationof <EMCLASS="emphasis">dosmv</EM>. Number 2 is difficult; here's a strategy hint:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Develop a regular expression that matches VAX/VMS filenames(you need this for No. 1 anyway).</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8767"></A><ACLASS="indexterm"NAME="AUTOID-8769"></A><ACLASS="indexterm"NAME="AUTOID-8771"></A>Get a list of base names (sans version numbers) of filesin the given directory by piping <EMCLASS="emphasis">ls</EM> through <EMCLASS="emphasis">grep</EM>(with the above regular expression),<EMCLASS="emphasis">cut</EM>, and <EMCLASS="emphasis">sort -u</EM>. Use <EMCLASS="emphasis">cut</EM> witha semicolon as &quot;field separator&quot;; make sure that you quote thesemicolon so that the shell doesn't treat it as a statement separator.<EMCLASS="emphasis">sort -u</EM> removes duplicatesafter sorting. Use command substitution tosave the resulting list in a variable.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8781"></A>Use a <BCLASS="emphasis.bold">for</B> loop on the list of base names.For each name, get the highest version numberof the file (just the number, not the whole name).  Do this with another pipeline:pipe <EMCLASS="emphasis">ls</EM> through <EMCLASS="emphasis">cut</EM>, <EMCLASS="emphasis">sort -n</EM>, and <EMCLASS="emphasis">tail -1</EM>.<EMCLASS="emphasis">sort -n</EM> sorts in numerical (not lexicographical) order;<EMCLASS="emphasis">tail -N</EM> outputs the last <EMCLASS="emphasis">N</EM> lines of its input.Again, use command substitution to capture the output of thispipeline in a variable.</P></LI><LICLASS="listitem"><PCLASS="para">Append the highest version number to the base name; this is thefile to rename in UNIX format.</P></LI></UL><PCLASS="para">Once you have completed No. 2, you can do No. 3 by adding a singleline of code to your script; see if you can figure out how.<ACLASS="indexterm"NAME="AUTOID-8794"></A><ACLASS="indexterm"NAME="AUTOID-8795"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_01.htm"TITLE="5.1 if/else"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.1 if/else"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_03.htm"TITLE="5.3 case"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.3 case"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">5.1 if/else</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">5.3 case</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>