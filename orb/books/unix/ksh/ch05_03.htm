<HTML><HEAD><TITLE>[Chapter 5] 5.3 case</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:09:25Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch05_01.htm"TITLE="5. Flow Control"><LINKREL="prev"HREF="ch05_02.htm"TITLE="5.2 for"><LINKREL="next"HREF="ch05_04.htm"TITLE="5.4 select"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_02.htm"TITLE="5.2 for"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.2 for"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 5<BR>Flow Control</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_04.htm"TITLE="5.4 select"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.4 select"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-5-SECT-3">5.3 case</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-CASE"></A><ACLASS="indexterm"NAME="AUTOID-8801"></A><ACLASS="indexterm"NAME="AUTOID-8803"></A>The next flow control construct we will cover is <BCLASS="emphasis.bold">case</B>.While the <BCLASS="emphasis.bold">case</B> statement in Pascal and the similar <BCLASS="emphasis.bold">switch</B>statement in C can be used to test simple values like integers andcharacters, the Korn shell's <BCLASS="emphasis.bold">case</B> construct lets you teststrings against patterns that can contain wildcard characters.Like its conventional language counterparts, <BCLASS="emphasis.bold">case</B> lets youexpress a series of if-then-else type statements in a concise way.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8811"></A>The syntax of <BCLASS="emphasis.bold">case</B> is as follows:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">case <EMCLASS="emphasis">expression</EM> in    <EMCLASS="emphasis">pattern1</EM> )        <EMCLASS="emphasis">statements ;;</EM>    <EMCLASS="emphasis">pattern2</EM> )        <EMCLASS="emphasis">statements ;;</EM>    ...esac</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8823"></A>Any of the <EMCLASS="emphasis">pattern</EM>s can actually be several patterns separatedby pipe characters (<BCLASS="emphasis.bold">|</B>). If <EMCLASS="emphasis">expression</EM> matchesone of the patterns, its corresponding statements are executed.If there are several patterns separated by pipe characters, theexpression can match any of them in order for the associated statementsto be run. The patterns are checked in order until a match is found;if none is found, nothing happens.</P><PCLASS="para">This rather ungainly syntax should become clearer with an example.<ACLASS="indexterm"NAME="KSH-CH-5-IX-C-COMPILERS-2"></A>An obvious choice is to revisit our solution to Task 4-2, the front-endfor the C compiler. Earlier in this chapter, we wrote somecode, that processed input files according to their suffixes(<EMCLASS="emphasis">.c</EM> <EMCLASS="emphasis">.s</EM>, or <EMCLASS="emphasis">.o</EM> for C, assembly, or object code, respectively).</P><PCLASS="para">We can improve upon this solution in two ways.  <ACLASS="indexterm"NAME="AUTOID-8836"></A>First, we canuse <BCLASS="emphasis.bold">for</B> to allow multiple files to be processed at one time;second, we can use <BCLASS="emphasis.bold">case</B> to streamline the code:<ACLASS="indexterm"NAME="AUTOID-8840"></A><ACLASS="indexterm"NAME="AUTOID-8843"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for filename in $*; do    case $filename in        *.c )            objname=${filename%.c}.o            ccom $filename $objname ;;        *.s )            objname=${filename%.s}.o            as $filename $objname ;;        *.o ) ;;        *   )            print &quot;error: $filename is not a source or object file.&quot;            return 1 ;;    esacdone</PRE></BLOCKQUOTE></P><PCLASS="para">The <BCLASS="emphasis.bold">case</B> construct in this code handles four cases. The firsttwo are similar to the <BCLASS="emphasis.bold">if</B> and first <BCLASS="emphasis.bold">elif</B> cases in thecode earlier in this chapter; they call the compiler or the assembler if thefilename ends in <EMCLASS="emphasis">.c</EM> or <EMCLASS="emphasis">.s</EM> respectively.</P><PCLASS="para">After that, the code is a bit different. Recall that if thefilename ends in <EMCLASS="emphasis">.o</EM> nothing is to be done (on the assumptionthat the relevant files will be linked later). If the filenamedoes not end in <EMCLASS="emphasis">.o</EM> there is an error. We handle this withthe case <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">.o )</B>, which has no statements. There is nothingwrong with a &quot;case&quot; for which the script does nothing.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8860"></A>The final case is <CODECLASS="literal">*</CODE>, which is a catchallfor whatever didn't match the other cases.  <ACLASS="indexterm"NAME="AUTOID-8864"></A><ACLASS="indexterm"NAME="AUTOID-8866"></A>(In fact, a <CODECLASS="literal">*</CODE> caseis analogous to a <BCLASS="emphasis.bold">default</B> case in C and an <BCLASS="emphasis.bold">otherwise</B>case in some Pascal-derived languages.)</P><PCLASS="para">The surrounding <BCLASS="emphasis.bold">for</B> loop processes all command-line argumentsproperly.  <ACLASS="indexterm"NAME="KSH-CH-5-IX-LINKING-2"></A>This leads to a further enhancement: now that we knowhow to process all arguments, we should be able to write thecode that passes all of the object files to the linker(the program <EMCLASS="emphasis">ld</EM>) at the end.  We can do this by building up a string of object filenames, separated by spaces, and hand that off to the linker whenwe've processed all of the input files. We initialize the stringto null and append an object file name each time one is created,i.e., during each iteration of the <BCLASS="emphasis.bold">for</B> loop.The code for this is simple, requiring only minor additions:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">objfiles=&quot;&quot;for filename in $*; do    case $filename in        *.c )            objname=${filename%.c}.o            ccom $filename $objname ;;        *.s )            objname=${filename%.s}.o            as $filename $objname ;;        *.o )            objname=$filename ;;        *   )            print &quot;error: $filename is not a source or object file.&quot;            return 1 ;;    esac    objfiles=&quot;$objfiles $objname&quot;doneld $objfiles</PRE></BLOCKQUOTE></P><PCLASS="para">The first line in this version of the script initializes thevariable <BCLASS="emphasis.bold">objfiles</B> to null.[16]We added a line of code inthe <BCLASS="emphasis.bold">*.o</B> case to set <BCLASS="emphasis.bold">objname</B> equal to <BCLASS="emphasis.bold">$filename</B>,because we already know it's an object file. Thus, the valueof <BCLASS="emphasis.bold">objname</B> is set in every case-except for the error case,in which the routine prints a message and bails out.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[16] This isn't strictly necessary, because all variables areassumed to be null if not explicitly initialized(unless the <BCLASS="emphasis.bold">nounset</B> option is turned on). Itjust makes the code easier to read.</P></BLOCKQUOTE><PCLASS="para">The last line of code in the <BCLASS="emphasis.bold">for</B> loop body appends a space andthe latest <BCLASS="emphasis.bold">$objname</B> to <BCLASS="emphasis.bold">objfiles</B>. Callingthis script with the same arguments as in Figure 5.1 would resultin <BCLASS="emphasis.bold">$objfiles</B> being equal to &quot;&nbsp;a.o b.o c.o d.o&quot;when the <BCLASS="emphasis.bold">for</B> loop finishes (the leading space doesn't matter).This list of object filenames is given to <EMCLASS="emphasis">ld</EM> as a single argument,but the shell divides it up into multiple file names properly.<ACLASS="indexterm"NAME="AUTOID-8895"></A><ACLASS="indexterm"NAME="AUTOID-8896"></A></P><PCLASS="para">We'll return to this example once more in <ACLASS="xref"HREF="ch06_01.htm"TITLE="Command-line Options and Typed Variables">Chapter 6</A>when we discuss how to handle dash options on the command line.Meanwhile, here is a new task whose initial solution will use <BCLASS="emphasis.bold">case</B>.<ACLASS="indexterm"NAME="KSH-CH-5-IX-TERM"></A><ACLASS="indexterm"NAME="KSH-CH-5-IX-ENVVARS-TERM"></A></P><DIVCLASS="task"><H4>Task 5.4</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">You are a system administrator,[17] and you need toset up the system so that users' <BCLASS="emphasis.bold">TERM</B> environment variablesreflectcorrectly what type of terminal they are on. Write some code thatdoes this.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[17] Our condolences.</P></BLOCKQUOTE></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8912"></A>The code for the solution to this task should go into the file<EMCLASS="emphasis">/etc/profile</EM>, which is the master startup file that is runfor each user <EMCLASS="emphasis">before</EM> his or her <EMCLASS="emphasis">.profile</EM>.</P><PCLASS="para">For the time being, we will assume that you have a traditionalmainframe-style setup, in which terminals are hard-wired tothe computer.  <ACLASS="indexterm"NAME="AUTOID-8918"></A>This means that you can determine which (physical)terminal is being used by the line (or <EMCLASS="emphasis">tty</EM>) it is on.This is typically a name like <EMCLASS="emphasis">/dev/ttyNN</EM>,where <EMCLASS="emphasis">NN</EM> is the line number.You can find your tty with the command <EMCLASS="emphasis">tty</EM>(1),which prints it on the standard output.</P><PCLASS="para">Let's assume that your system has ten lines plus a systemconsole line (<EMCLASS="emphasis">/dev/console</EM>), with the following terminals:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Lines tty01, tty03, and tty04 are Givalt GL35a's(<EMCLASS="emphasis">terminfo</EM> name &quot;gl35a&quot;).</P></LI><LICLASS="listitem"><PCLASS="para">Line tty07 is a Tsoris T-2000 (&quot;t2000&quot;).</P></LI><LICLASS="listitem"><PCLASS="para">Line tty08 and the console are Shande 531s (&quot;s531&quot;).</P></LI><LICLASS="listitem"><PCLASS="para">The rest are Vey VT99s (&quot;vt99&quot;).</P></LI></UL><PCLASS="para">Here is the code that does the job:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">case $(tty) in    /dev/tty0[134]            ) TERM=gl35a ;;    /dev/tty07                ) TERM=t2000 ;;    /dev/tty08 | /dev/console ) TERM=s531  ;;    *                         ) TERM=vt99  ;;esac</PRE></BLOCKQUOTE></P><PCLASS="para">The value that <BCLASS="emphasis.bold">case</B> checks is the result of command substitution.Otherwise, the only thing new about this code is the pipe characterafter <EMCLASS="emphasis">/dev/tty08</EM>.  This means that<EMCLASS="emphasis">/dev/tty08</EM> and <EMCLASS="emphasis">/dev/console</EM> are alternate patterns for the casethat sets <BCLASS="emphasis.bold">TERM</B> to &quot;s531&quot;.</P><PCLASS="para">Note that it is <EMCLASS="emphasis">not</EM> possibleto put alternate patterns on separate lines unless you use backslashcontinuation characters at the end of all but the last line,i.e., the line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/dev/tty08 | /dev/console ) TERM=s531  ;;</PRE></BLOCKQUOTE></P><PCLASS="para">could be changed to the slightly more readable:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/dev/tty08 | \    /dev/console   ) TERM=s531  ;;</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-8953"></A><ACLASS="indexterm"NAME="AUTOID-8954"></A>The backslash must be at the end of the line. If you omit it,or if there are characters (even blanks) following it, the shellcomplains with a syntax error message.</P><PCLASS="para">This problem is actually better solved using a file that containsa table of lines and terminal types. We'll see how to do it this wayin <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A>.<ACLASS="indexterm"NAME="AUTOID-8957"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_02.htm"TITLE="5.2 for"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.2 for"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_04.htm"TITLE="5.4 select"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 5.4 select"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">5.2 for</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">5.4 select</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>