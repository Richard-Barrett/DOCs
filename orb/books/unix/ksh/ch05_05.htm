<HTML><HEAD><TITLE>[Chapter 5] 5.5 while and until</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:09:52Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch05_01.htm"TITLE="5. Flow Control"><LINKREL="prev"HREF="ch05_04.htm"TITLE="5.4 select"><LINKREL="next"HREF="ch06_01.htm"TITLE="6. Command-line Options and Typed Variables"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_04.htm"TITLE="5.4 select"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.4 select"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 5<BR>Flow Control</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch06_01.htm"TITLE="6. Command-line Options and Typed Variables"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6. Command-line Options and Typed Variables"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-5-SECT-5">5.5 while and until</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-WHILE"></A><ACLASS="indexterm"NAME="KSH-CH-5-IX-UNTIL"></A>The remaining two flow control constructs the Korn shell providesare <BCLASS="emphasis.bold">while</B> and <BCLASS="emphasis.bold">until</B>.  These are similar; theyboth allow a section of code to be run repetitively while (or until)a certain condition holds true.  <ACLASS="indexterm"NAME="AUTOID-9143"></A><ACLASS="indexterm"NAME="AUTOID-9145"></A>They also resembleanalogous constructs in Pascal (<BCLASS="emphasis.bold">while</B>/<BCLASS="emphasis.bold">do</B>and <BCLASS="emphasis.bold">repeat</B>/<BCLASS="emphasis.bold">until</B>) and C (<BCLASS="emphasis.bold">while</B> and <BCLASS="emphasis.bold">do</B>/<BCLASS="emphasis.bold">until</B>).</P><PCLASS="para"><BCLASS="emphasis.bold">while</B> and <BCLASS="emphasis.bold">until</B> are actually most useful when combinedwith features we will see in the next chapter, such as integerarithmetic, input/output of variables, and command-line processing.Yet we can show a useful example even with the machinery we havecovered so far.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9158"></A>The syntax for <BCLASS="emphasis.bold">while</B> is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">while <EMCLASS="emphasis">condition</EM>do    <EMCLASS="emphasis">statements...</EM>done</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9167"></A>For <BCLASS="emphasis.bold">until</B>, just substitute <BCLASS="emphasis.bold">until</B> for <BCLASS="emphasis.bold">while</B> in the above example.<ACLASS="indexterm"NAME="AUTOID-9173"></A>As with <BCLASS="emphasis.bold">if</B>, the <EMCLASS="emphasis">condition</EM> is really a list of<EMCLASS="emphasis">statements</EM> that are run;the exit status of the last one is used as the value ofthe condition. You can use a conditional with <BCLASS="emphasis.bold">[[</B> and <BCLASS="emphasis.bold">]]</B>here, just as you can with <BCLASS="emphasis.bold">if</B>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9183"></A><ACLASS="indexterm"NAME="AUTOID-9186"></A>Note that the <EMCLASS="emphasis">only</EM> difference between<BCLASS="emphasis.bold">while</B> and <BCLASS="emphasis.bold">until</B> is the way the condition is handled.In <BCLASS="emphasis.bold">while</B>, the loop executes as long as the condition is true;in <BCLASS="emphasis.bold">until</B>, it runs as long as the condition is false.So far, so familiar. <ACLASS="indexterm"NAME="AUTOID-9194"></A><ACLASS="indexterm"NAME="AUTOID-9196"></A><BCLASS="emphasis.bold">BUT</B>: the <BCLASS="emphasis.bold">until</B> condition is checkedat the <EMCLASS="emphasis">top</EM> of the loop, <EMCLASS="emphasis">not</EM> at the bottom as it isin analogous constructs in C and Pascal.</P><PCLASS="para">The result is that you can convert any <BCLASS="emphasis.bold">until</B> into a <BCLASS="emphasis.bold">while</B>by simply negating the condition. The only place where <BCLASS="emphasis.bold">until</B>might be better is something like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">until <EMCLASS="emphasis">command</EM>; do    <EMCLASS="emphasis">statements...</EM>done</PRE></BLOCKQUOTE></P><PCLASS="para">The meaning of this is essentially, &quot;Do <EMCLASS="emphasis">statements</EM> until<EMCLASS="emphasis">command</EM> runs correctly.&quot; This is not, in our opinion, a likelycontingency.  <ACLASS="indexterm"NAME="AUTOID-9213"></A>Therefore we will use <BCLASS="emphasis.bold">while</B> throughout the rest of this book.</P><PCLASS="para">Here is a task that is a good candidate for <BCLASS="emphasis.bold">while</B>.</P><DIVCLASS="task"><H4>Task 5.5</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9220"></A>Implement a simplified version of the shell's built-in<BCLASS="emphasis.bold">whence</B> command.</P></BLOCKQUOTE><ACLASS="indexterm"NAME="KSH-CH-5-IX-PATH"></A><ACLASS="indexterm"NAME="KSH-CH-5-IX-ENVVARS-PATH"></A><PCLASS="para">By &quot;simplified,&quot; we mean that we will implement only the partthat checks all of the directories in your <BCLASS="emphasis.bold">PATH</B> for the commandyou give as argument (we won't implement checking for aliases,built-in commands, etc.).</P><PCLASS="para">We can do this by picking off the directories in <BCLASS="emphasis.bold">PATH</B> one byone, using one of the shell's pattern-matching operators, andseeing if there is a file with the given name in the directorythat you have permission to execute. Here is the code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">path=$PATH:dir=${path%%:*}while [[ -n $path ]]; do    if [[ -x $dir/$1 &amp;&amp; ! -d $dir/$1 ]]; then        print &quot;$dir/$1&quot;        return    fi    path=${path#*:}    dir=${path%%:*}donereturn 1</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9235"></A><ACLASS="indexterm"NAME="AUTOID-9238"></A><ACLASS="indexterm"NAME="AUTOID-9241"></A><ACLASS="indexterm"NAME="AUTOID-9244"></A><ACLASS="indexterm"NAME="AUTOID-9247"></A><ACLASS="indexterm"NAME="AUTOID-9251"></A><ACLASS="indexterm"NAME="AUTOID-9255"></A>The first line of this code saves <BCLASS="emphasis.bold">$PATH</B> in <BCLASS="emphasis.bold">path</B>, our own temporarycopy. We append a colon to the end so that every directory in <BCLASS="emphasis.bold">$path</B>ends in a colon (in <BCLASS="emphasis.bold">$PATH</B>, colons are used only <EMCLASS="emphasis">between</EM>directories); subsequent code depends on this being the case.</P><PCLASS="para">The next line picks the first directory off of <BCLASS="emphasis.bold">$path</B>by using the operator that deletes the longest match to the patterngiven. In this case, we delete the longest match to the pattern<CODECLASS="literal">:*</CODE>, i.e., a colon followed by anything. This gives us the firstdirectory in <BCLASS="emphasis.bold">$path</B>, which we store in the variable <BCLASS="emphasis.bold">dir</B>.</P><PCLASS="para">The condition in the <BCLASS="emphasis.bold">while</B> loop checks if <BCLASS="emphasis.bold">$path</B> is non-null.If it is not null, it constructs the full pathname <BCLASS="emphasis.bold">$dir/$1</B> and sees ifthere is a file by that name for which you have execute permission(and that is not a directory).If so, it prints the full pathname and exits the routine witha 0 (&quot;OK&quot;) exit status.</P><PCLASS="para">If a file is not found, then this code is run:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">path=${path#*:}dir=${path%%:*}</PRE></BLOCKQUOTE></P><PCLASS="para">The first of these uses another shell string operator: this onedeletes the shortest match to the pattern givenfrom the front of the string. By now, this type of operator shouldbe familiar. This line deletes the front directory from <BCLASS="emphasis.bold">$path</B>and assigns the result back to <BCLASS="emphasis.bold">path</B>.The second line is the same as before the <BCLASS="emphasis.bold">while</B>: it findsthe (new) front directory in <BCLASS="emphasis.bold">$path</B> and assigns it to <BCLASS="emphasis.bold">dir</B>.This sets up the loop for another iteration.</P><PCLASS="para">Thus, the code loops through all of the directories in <BCLASS="emphasis.bold">PATH</B>.It exits when it finds a matching executable file or when it has&quot;eaten up&quot; the entire <BCLASS="emphasis.bold">PATH</B>.If no matching executable file is found, it prints nothingand exits with an error status.<ACLASS="indexterm"NAME="AUTOID-9285"></A><ACLASS="indexterm"NAME="AUTOID-9286"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-5-IX-FILE-COMMAND"></A>We can enhance this script a bit by taking advantage of the UNIXutility <EMCLASS="emphasis">file</EM>(1). <EMCLASS="emphasis">file</EM> examines files given as argumentsand determines what type they are, based on the file's <EMCLASS="emphasis">magicnumber</EM> and various heuristics (educated guesses). A magic numberis a field in the header of an executable file that the linker setsto identify what type of executable it is.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9294"></A><ACLASS="indexterm"NAME="AUTOID-9297"></A>If <EMCLASS="emphasis">filename</EM> is an executable program (compiled from C or some otherlanguage), then typing <BCLASS="emphasis.bold">file</B> <EMCLASS="emphasis">filename</EM> produces output similar to this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><EMCLASS="emphasis">filename</EM>: ELF 32-bit LSB executable 80386 Version 1</PRE></BLOCKQUOTE></P><PCLASS="para">However, if <EMCLASS="emphasis">filename</EM> is not an executable program, it will examinethe first few lines and try to guess what kind of information thefile contains.  <ACLASS="indexterm"NAME="AUTOID-9307"></A><ACLASS="indexterm"NAME="AUTOID-9309"></A>If the file contains text (as opposed to binary data),<EMCLASS="emphasis">file</EM> will look for indications that it is English, shellcommands, C, FORTRAN, <EMCLASS="emphasis">troff</EM>(1) input, and various other things.<EMCLASS="emphasis">file</EM> is wrong sometimes, but it is mostly correct.</P><PCLASS="para">We can just substitute <EMCLASS="emphasis">file</EM> for <EMCLASS="emphasis">print</EM>to print a more informative message in our script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">path=$PATHdir=${path%%:*}while [[ -n $path ]]; do    if [[ -x $dir/$1 &amp;&amp; ! -d $dir/$1 ]]; then	  file $dir/$1	  return    fi    path=${path#*:}    dir=${path%%:*}donereturn 1</PRE></BLOCKQUOTE></P><PCLASS="para">Assume that <EMCLASS="emphasis">fred</EM> is an executable file in the directory<EMCLASS="emphasis">/usr/bin</EM>, and that <EMCLASS="emphasis">bob</EM> is a shell script in <EMCLASS="emphasis">/usr/local/bin</EM>.Then typing <BCLASS="emphasis.bold">file fred</B> produces this output:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/usr/bin/fred: ELF 32-bit LSB executable 80386 Version 1</PRE></BLOCKQUOTE></P><PCLASS="para">And typing <BCLASS="emphasis.bold">file bob</B> has this result:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/usr/local/bin/bob: commands text</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9332"></A><ACLASS="indexterm"NAME="AUTOID-9333"></A><ACLASS="indexterm"NAME="AUTOID-9336"></A>Before we end this chapter, we have two final notes. First, notice that the statement<BCLASS="emphasis.bold">dir=${path%%:*}</B> appears in two places, before the startof the loop and as the last statement in the loop's body.<ACLASS="indexterm"NAME="AUTOID-9340"></A><ACLASS="indexterm"NAME="AUTOID-9342"></A>Some diehard C hackers are offended by this Pascal-like codingtechnique. Certain features of the C language allow programmersto create loops of the form:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">while <EMCLASS="emphasis">iterative-step</EM>; <EMCLASS="emphasis">condition</EM>; do    ...done</PRE></BLOCKQUOTE></P><PCLASS="para">This is the same as the form of the script above: the <EMCLASS="emphasis">iterative-step</EM> runs just before the <EMCLASS="emphasis">condition</EM>each time around the loop. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9352"></A>We can write our script this way:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">path=$PATHwhile dir=${path%%:*}; [[ -n $path ]]; do    if [[ -x $dir/$1 &amp;&amp; ! -d $dir/$1 ]]; then	file $dir/$1	return    fi    path=${path#*:}donereturn 1</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9358"></A>Although this example doesn't show great programming style, it does make thecode smaller-hence its popularity with C programmers. Make sure you understand that our script is functionally identicalto the previous script.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9361"></A>Finally, just to show how little difference there is between<BCLASS="emphasis.bold">while</B> and <BCLASS="emphasis.bold">until</B>, we note that the line</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">until [[ ! -n $path ]]; do</PRE></BLOCKQUOTE></P><PCLASS="para">can be used in place of</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">while [[ -n $path ]]; do</PRE></BLOCKQUOTE></P><PCLASS="para">with identical results.</P><PCLASS="para">We'll see additional examples of <BCLASS="emphasis.bold">while</B> in the next chapter.<ACLASS="indexterm"NAME="AUTOID-9373"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_04.htm"TITLE="5.4 select"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.4 select"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch06_01.htm"TITLE="6. Command-line Options and Typed Variables"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6. Command-line Options and Typed Variables"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">5.4 select</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">6. Command-line Options and Typed Variables</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>