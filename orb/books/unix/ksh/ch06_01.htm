<HTML><HEAD><TITLE>[Chapter 6] Command-line Options and Typed Variables</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:10:00Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="index.htm"TITLE="Learning the Korn Shell"><LINKREL="prev"HREF="ch05_05.htm"TITLE="5.5 while and until"><LINKREL="next"HREF="ch06_02.htm"TITLE="6.2 Integer Variables and Arithmetic"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_05.htm"TITLE="5.5 while and until"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.5 while and until"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 6</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Integer Variables and Arithmetic"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.2 Integer Variables and Arithmetic"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="CHAPTER"><H1CLASS="chapter"><ACLASS="title"NAME="KSH-CH6-OPSTYPED">6. Command-line Options and Typed Variables</A></H1><DIVCLASS="htmltoc"><P><B>Contents:</B><BR><ACLASS="sect1"HREF="#KSH-CH-6-SECT-1"TITLE="6.1 Command-line Options">Command-line Options</A><BR><ACLASS="sect1"HREF="ch06_02.htm"TITLE="6.2 Integer Variables and Arithmetic">Integer Variables and Arithmetic</A><BR><ACLASS="sect1"HREF="ch06_03.htm"TITLE="6.3 Arrays">Arrays</A></P><P></P></DIV><PCLASS="para">You should have a healthy grasp of shell programming techniquesnow that you have gone through the previous chapters. What youhave learned up to this pointenables you to write many nontrivial, useful shell scripts and functions.</P><PCLASS="para">Still, you may have noticed some remaining gaps in the knowledgeyou need to write shell code that behaves like the UNIX commands youare used to. In particular, if you are an experienced UNIX user, it might have occurred to you that none of the example scripts shown so far have theability to handle <EMCLASS="emphasis">options</EM> (preceded by a dash (<BCLASS="emphasis.bold">-</B>))on the command line.  <ACLASS="indexterm"NAME="AUTOID-9380"></A><ACLASS="indexterm"NAME="AUTOID-9382"></A>And if youprogram in a conventional language like C or Pascal, you will havenoticed that the only type of data that we have seen in shell variablesis character strings; we haven't seen how to do arithmetic, for example.</P><PCLASS="para">These capabilities are certainly crucial to the shell's ability tofunction as a useful UNIX programming language. In this chapter, we willshow how the Korn shell supports these and related features.</P><DIVCLASS="sect1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-6-SECT-1">6.1 Command-line Options</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-COMMAND-LINE-OPTIONS"></A><ACLASS="indexterm"NAME="AUTOID-9390"></A><ACLASS="indexterm"NAME="AUTOID-9394"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-POSITIONAL-PARAMETERS"></A>We have already seen many examples of the <EMCLASS="emphasis">positional parameters</EM>(variables called <BCLASS="emphasis.bold">1</B>, <BCLASS="emphasis.bold">2</B>, <BCLASS="emphasis.bold">3</B>, etc.)that the shell uses to store the command-linearguments to a shell script or function when it runs. We have alsoseen related variables like <CODECLASS="literal">*</CODE> (for the string of all arguments)and <BCLASS="emphasis.bold">#</B> (for the number of arguments).</P><PCLASS="para">Indeed, these variables hold all of the information on the user'scommand-line. But consider what happens when options are involved.Typical UNIX commands have the form <EMCLASS="emphasis">command </EM>[-<EMCLASS="emphasis">options</EM>]<EMCLASS="emphasis">args</EM>, meaning that there can be 0 or more options. If a shell script processes the command <BCLASS="emphasis.bold">fred bob pete</B>, then <BCLASS="emphasis.bold">$1</B> is &quot;bob&quot;and <BCLASS="emphasis.bold">$2</B> is &quot;pete&quot;.  But if the command is <BCLASS="emphasis.bold">fred -o bob pete</B>,then <BCLASS="emphasis.bold">$1</B> is <BCLASS="emphasis.bold">-o</B>, <BCLASS="emphasis.bold">$2</B> is &quot;bob&quot;, and <BCLASS="emphasis.bold">$3</B> is &quot;pete&quot;.</P><PCLASS="para">You might think you could write code like this to handle it:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ $1 = -o ]]; then    <EMCLASS="emphasis">code that processes the -o option</EM>    1=$2    2=$3fi<ICLASS="lineannotation">normal processing of $1 and $2...</I></PRE></BLOCKQUOTE></P><PCLASS="para">But this code has several problems. First, assignments like<BCLASS="emphasis.bold">1=$2</B> are illegal because positional parameters are read-only.Even if they were legal, another problem is thatthis kind of code imposes limitations on how many argumentsthe script can handle-which is very unwise. Furthermore,if this command had several possible options, thecode to handle all of them would get very messy very quickly.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-1.1">6.1.1 shift</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-SHIFT"></A>Luckily, the shell provides a way around this problem.The command <BCLASS="emphasis.bold">shift</B> performs the function of:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">1=$22=$3...</PRE></BLOCKQUOTE></P><PCLASS="para">for every argument, regardless of how many there are. If you supplya numeric argument to <BCLASS="emphasis.bold">shift</B>, it will shift the arguments thatmany times over; for example, <BCLASS="emphasis.bold">shift 3</B> has this effect:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">1=$42=$5...</PRE></BLOCKQUOTE></P><PCLASS="para">This leads immediately to some code that handles a single option(call it <BCLASS="emphasis.bold">-o</B>) and arbitrarily many arguments:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ $1 = -o ]]; then    <EMCLASS="emphasis">process the -o option</EM>    shiftfi<ICLASS="lineannotation">normal processing of arguments...</I></PRE></BLOCKQUOTE></P><PCLASS="para">After the <BCLASS="emphasis.bold">if</B> construct, <BCLASS="emphasis.bold">$1</B>, <BCLASS="emphasis.bold">$2</B>, etc., are set tothe correct arguments.<ACLASS="indexterm"NAME="AUTOID-9448"></A></P><PCLASS="para">We can use <BCLASS="emphasis.bold">shift</B> together with the programming featureswe have seen so far to implement simple option schemes. However,we will need additional help when things get more complex.The <BCLASS="emphasis.bold">getopts</B> built-in command, which we will introducelater, provides this help.</P><PCLASS="para"><BCLASS="emphasis.bold">shift</B> by itself gives us enough power to implement the <BCLASS="emphasis.bold">-N</B>option to the <EMCLASS="emphasis">highest</EM> script we saw in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4, Basic Shell Programming</A>(Task 4-1).Recall that this script takes an input file that lists artistsand the number of albums you have by them. It sorts the listand prints out the <EMCLASS="emphasis">N</EM> highest numbers, in descending order.The code that does the actual data processing is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">filename=$1howmany=${2:-10}sort -nr $filename | head -$howmany</PRE></BLOCKQUOTE></P><PCLASS="para">Our original syntax for calling this script was <BCLASS="emphasis.bold">highest</B> <EMCLASS="emphasis">filename</EM><BCLASS="emphasis.bold"> [-</B><EMCLASS="emphasis">N</EM><BCLASS="emphasis.bold">]</B>, where <EMCLASS="emphasis">N</EM> defaults to10 if omitted. Let's change this to a more conventional UNIX syntax,in which options are given before arguments: <BCLASS="emphasis.bold">highest [-</B><EMCLASS="emphasis">N</EM><BCLASS="emphasis.bold">]</B> <EMCLASS="emphasis">filename</EM>. Here is how we would writethe script with this syntax:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ $1 = -+([0-9]) ]]; then    howmany=$1    shiftelif [[ $1 = -* ]]; then    print 'usage: highest [-N] filename'    return 1else    howmany=&quot;-10&quot;fifilename=$1sort -nr $filename | head $howmany</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9474"></A>In this code, the option is considered to be supplied if <BCLASS="emphasis.bold">$1</B>matches the pattern <BCLASS="emphasis.bold">-+([0-9])</B>. This uses one of the Korn shell'sregular expression operators, which we saw in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A>.Notice that we didn't surround the pattern with quotes(even double quotes); if we did, the shell would interpret it literally,not as a pattern. This pattern means&quot;A dash followed by one or more digits.&quot; If <BCLASS="emphasis.bold">$1</B> matches,then we assign it to the variable <BCLASS="emphasis.bold">howmany</B>.</P><PCLASS="para">If <BCLASS="emphasis.bold">$1</B> doesn't match, we test to see if it's an option at all,i.e., if it matches the pattern <BCLASS="emphasis.bold">-</B><CODECLASS="literal">*</CODE>.  If it does, then it's invalid;we print an error message and exit with error status. If we reach the final(<BCLASS="emphasis.bold">else</B>) case, we assume that <BCLASS="emphasis.bold">$1</B> is a filename and treat it as such in the ensuing code. The rest of the script processes the data as before.</P><PCLASS="para">We can extend what we have learned so farto a general technique for handling multipleoptions. For the sake of concreteness, assume that our script is called <EMCLASS="emphasis">bob</EM> and we want to handlethe options <BCLASS="emphasis.bold">-a</B>, <BCLASS="emphasis.bold">-b</B>, and <BCLASS="emphasis.bold">-c</B>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">while [[ $1 = -* ]]; do    case $1 in 	-a ) <CODECLASS="replaceable"><I>process option -a</I></CODE> ;;	-b ) <CODECLASS="replaceable"><I>process option -b</I></CODE> ;;	-c ) <CODECLASS="replaceable"><I>process option -c</I></CODE> ;;	*  ) print 'usage: bob [-a] [-b] [-c] args...'	     return 1    esac    shiftdone<ICLASS="lineannotation">normal processing of arguments...</I></PRE></BLOCKQUOTE></P><PCLASS="para">This code checks <BCLASS="emphasis.bold">$1</B> repeatedly as long as it starts with a dash(<BCLASS="emphasis.bold">-</B>).  <ACLASS="indexterm"NAME="AUTOID-9502"></A>Then the <BCLASS="emphasis.bold">case</B> constructruns the appropriate code depending on which option <BCLASS="emphasis.bold">$1</B> is.If the option is invalid&nbsp;- i.e., if it starts with a dash butisn't <BCLASS="emphasis.bold">-a</B>, <BCLASS="emphasis.bold">-b</B>, or <BCLASS="emphasis.bold">-c</B>&nbsp;- then the script prints a usage messageand returns with an error exit status. After each option isprocessed, the arguments are shifted over. The result is thatthe positional parameters are set to the actual arguments whenthe <BCLASS="emphasis.bold">while</B> loop finishes.</P><PCLASS="para">Notice that this code is capable of handling options of arbitrarylength, not just one letter (e.g., <BCLASS="emphasis.bold">-fred</B> instead of <BCLASS="emphasis.bold">-a</B>).</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-1.2">6.1.2 Options with Arguments</A></H3><PCLASS="para">We need to add one more ingredient to make option processing really useful.Recall that many commands have options that take their <EMCLASS="emphasis">own</EM>arguments.  <ACLASS="indexterm"NAME="AUTOID-9517"></A>For example, the <EMCLASS="emphasis">cut</EM> command, on which we reliedheavily in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A>, accepts the option <BCLASS="emphasis.bold">-d</B> with an argumentthat determines the field delimiter (if it is not the default TAB).To handle this type of option, we just use another <BCLASS="emphasis.bold">shift</B> when we are processing the option.</P><PCLASS="para">Assume that, in our <EMCLASS="emphasis">bob</EM> script, the option <BCLASS="emphasis.bold">-b</B> requiresits own argument. Here is the modified code that will process it:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">while [[ $1 = -* ]]; do    case $1 in 	-a ) <CODECLASS="replaceable"><I>process option -a</I></CODE> ;;	-b ) <CODECLASS="replaceable"><I>process option -b</I></CODE> 	     <CODECLASS="replaceable"><I>$2 is the option's argument</I></CODE>	     shift ;;	-c ) <CODECLASS="replaceable"><I>process option -c</I></CODE> ;;	*  ) print 'usage: bob [-a] [-b barg] [-c] args...'	     return 1    esac    shiftdone<ICLASS="lineannotation">normal processing of arguments...</I></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9535"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-1.3">6.1.3 getopts</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-GETOPTS"></A>So far, we have a complete, though still constrained, wayof handling command-line options. The above code does not allow a user to combine arguments with a single dash, e.g., <BCLASS="emphasis.bold">-abc</B> instead of <BCLASS="emphasis.bold">-a -b -c</B>. It also doesn't allow one tospecify arguments to optionswithout a space in between, e.g., <BCLASS="emphasis.bold">-barg</B> in addition to <BCLASS="emphasis.bold">-b arg.</B>[1]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] <ACLASS="indexterm"NAME="AUTOID-9547"></A>Although most UNIX commands allow this, it is actually contrary to theCommand Syntax Standard Rules in <EMCLASS="emphasis">intro</EM>(1) of the <EMCLASS="emphasis">User's Manual</EM>.</P></BLOCKQUOTE><PCLASS="para">The shell provides a built-in wayto deal with multiple complex options without these constraints.The built-in command <BCLASS="emphasis.bold">getopts</B>[2]can be used as the condition of the <BCLASS="emphasis.bold">while</B> in an option-processingloop. Given a specification of which options are validand which require their own arguments, it sets up thebody of the loop to process each option in turn.  </P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] <ACLASS="indexterm"NAME="AUTOID-9556"></A><ACLASS="indexterm"NAME="AUTOID-9558"></A><ACLASS="indexterm"NAME="AUTOID-9560"></A><BCLASS="emphasis.bold">getopts</B> replaces the external command <EMCLASS="emphasis">getopt(1)</EM>,used in Bourne shell programming;<BCLASS="emphasis.bold">getopts</B> is better integrated into the shell's syntax and runs moreefficiently. C programmers will recognize <BCLASS="emphasis.bold">getopts</B> as very similarto the standard library routine <EMCLASS="emphasis">getopt(3)</EM>.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9569"></A><BCLASS="emphasis.bold">getopts</B> takes two arguments. The firstis a string that can contain lettersand colons. Each letter is a valid option; if a letter is followedby a colon, the option requires an argument.  <BCLASS="emphasis.bold">getopts</B> picksoptions off the command line and assigns each one (without theleading dash) to a variable whosename is <BCLASS="emphasis.bold">getopts</B>' second argument.  <ACLASS="indexterm"NAME="AUTOID-9575"></A>As long as there are optionsleft to process, <BCLASS="emphasis.bold">getopts</B> will return exit status 0; when theoptions are exhausted, it returns exit status 1, causing the <BCLASS="emphasis.bold">while</B>loop to exit.</P><PCLASS="para"><BCLASS="emphasis.bold">getopts</B> does a few other things that make option processingeasier; we'll encounter them as we examinehow to use <BCLASS="emphasis.bold">getopts</B> in the preceding example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">while getopts &quot;:ab:c&quot; opt; do    case $opt in 	a  ) <CODECLASS="replaceable"><I>process option -a</I></CODE> ;;	b  ) <CODECLASS="replaceable"><I>process option -b</I></CODE> 	     <CODECLASS="replaceable"><I>$OPTARG is the option's argument</I></CODE> ;;	c  ) <CODECLASS="replaceable"><I>process option -c</I></CODE> ;;	\? ) print 'usage: bob [-a] [-b barg] [-c] args...'	     return 1    esacdoneshift $(($OPTIND - 1))<ICLASS="lineannotation">normal processing of arguments...</I></PRE></BLOCKQUOTE></P><PCLASS="para">The call to <BCLASS="emphasis.bold">getopts</B> in the <BCLASS="emphasis.bold">while</B> condition sets upthe loop to accept the options <BCLASS="emphasis.bold">-a</B>, <BCLASS="emphasis.bold">-b</B>, and <BCLASS="emphasis.bold">-c</B>,and specifies that <BCLASS="emphasis.bold">-b</B> takes an argument. (We will explainthe <BCLASS="emphasis.bold">:</B> that starts the option string in a moment.) Each time theloop body is executed, it will have the latest option available,without a dash (<BCLASS="emphasis.bold">-</B>), in the variable <BCLASS="emphasis.bold">opt</B>.  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9601"></A><ACLASS="indexterm"NAME="AUTOID-9604"></A>If the user types aninvalid option, <BCLASS="emphasis.bold">getopts</B> normally prints an unfortunateerror message (of the form <BCLASS="emphasis.bold">cmd: getopts: o bad option(s)</B>)and sets <BCLASS="emphasis.bold">opt</B> to <BCLASS="emphasis.bold">?</B>.However-now here's an obscure kludge-if you begin the option letter string with a colon, <BCLASS="emphasis.bold">getopts</B> won't print the message.[3]We recommend that you specify the colon and provide your own errormessage in a case that handles <BCLASS="emphasis.bold">?</B>, as above.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] <ACLASS="indexterm"NAME="AUTOID-9614"></A>Evidently this was deemed necessary because you can't redirect<BCLASS="emphasis.bold">getopts</B>' standard error output to <EMCLASS="emphasis">/dev/null</EM>; theresult is (usually) a core dump.</P></BLOCKQUOTE><PCLASS="para">We have modified the code in the <BCLASS="emphasis.bold">case</B> construct toreflect what <BCLASS="emphasis.bold">getopts</B> does. <ACLASS="indexterm"NAME="AUTOID-9622"></A>But notice that there are no more <BCLASS="emphasis.bold">shift</B> statements inside the<BCLASS="emphasis.bold">while</B> loop: <BCLASS="emphasis.bold">getopts</B> does not rely on <BCLASS="emphasis.bold">shift</B>s tokeep track of where it is. It is unnecessary to shift arguments over until <BCLASS="emphasis.bold">getopts</B> is finished, i.e., until the <BCLASS="emphasis.bold">while</B>loop exits.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9631"></A><ACLASS="indexterm"NAME="AUTOID-9633"></A><ACLASS="indexterm"NAME="AUTOID-9636"></A>If an option has an argument, <BCLASS="emphasis.bold">getopts</B> stores it in the variable<BCLASS="emphasis.bold">OPTARG</B>, which can be used in the code that processes theoption.</P><PCLASS="para">The one <BCLASS="emphasis.bold">shift</B> statement left is after the <BCLASS="emphasis.bold">while</B> loop.<ACLASS="indexterm"NAME="AUTOID-9644"></A><ACLASS="indexterm"NAME="AUTOID-9646"></A><ACLASS="indexterm"NAME="AUTOID-9649"></A><BCLASS="emphasis.bold">getopts</B> stores in the variable <BCLASS="emphasis.bold">OPTIND</B> the number of the next argument to be processed; in this case, that's the numberof the first (non-option) command-line argument. For example,if the command line were <BCLASS="emphasis.bold">bob -ab pete</B>, then <BCLASS="emphasis.bold">$OPTIND</B>would be &quot;2&quot;.  If it were <BCLASS="emphasis.bold">bob -a -b pete</B>, then <BCLASS="emphasis.bold">$OPTIND</B>would be &quot;3&quot;.  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9659"></A>The expression <BCLASS="emphasis.bold">$(($OPTIND - 1))</B> is anarithmetic expression (as we'll see later in this chapter) equalto <BCLASS="emphasis.bold">$OPTIND</B> minus 1. This value is used as the argument to<BCLASS="emphasis.bold">shift</B>. The result is that the correct number of argumentsare shifted out of the way, leaving the &quot;real&quot; argumentsas <BCLASS="emphasis.bold">$1</B>, <BCLASS="emphasis.bold">$2</B>, etc.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9667"></A>Before we continue, now is a good time to summarize everythingthat <BCLASS="emphasis.bold">getopts</B> does:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Its first argument is a string containing all valid option letters.If an option requires an argument, a colon follows its letter inthe string. An initial colon causes <BCLASS="emphasis.bold">getopts</B> not to print anerror message when the user gives an invalid option.</P></LI><LICLASS="listitem"><PCLASS="para">Its second argument is the name of a variable that will holdeach option letter (without any leading dash) as it is processed.</P></LI><LICLASS="listitem"><PCLASS="para">If an option takes an argument, the argument is stored in the variable<BCLASS="emphasis.bold">OPTARG</B>.</P></LI><LICLASS="listitem"><PCLASS="para">The variable <BCLASS="emphasis.bold">OPTIND</B> contains a number equal to the nextcommand-line argument to be processed. After <BCLASS="emphasis.bold">getopts</B> is done,it equals the number of the first &quot;real&quot; argument.</P></LI></OL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9685"></A><ACLASS="indexterm"NAME="AUTOID-9688"></A>The advantages of <BCLASS="emphasis.bold">getopts</B> are that it minimizes extra codenecessary to process options and fully supports the standard UNIX optionsyntax (as specified in <EMCLASS="emphasis">intro(1)</EM> of the <EMCLASS="emphasis">User's Manual</EM>).<ACLASS="indexterm"NAME="AUTOID-9694"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-C-COMPILERS"></A>As a more concrete example, let's return toour C compiler front end (Task 4-2). So far,we have given our script the ability to process C source files(ending in <EMCLASS="emphasis">.c</EM>), assembly code files (<EMCLASS="emphasis">.s</EM>), and object codefiles (<EMCLASS="emphasis">.o</EM>). Here is the latest version of the script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">objfiles=&quot;&quot;for filename in &quot;$@&quot;; do    case $filename in         *.c )             objname=${filename%.c}.o            compile $filename $objname ;;        *.s )            objname=${filename%.s}.o            assemble $filename $objname ;;        *.o )             objname=$filename ;;        *   )             print &quot;error: $filename is not a source or object file.&quot;            return 1 ;;    esac    objfiles=&quot;$objfiles $objname&quot;doneld $objfiles</PRE></BLOCKQUOTE></P><PCLASS="para">Now we can give the script the ability to handle options. To know whatoptions we'll need, we'll have to discuss further what compilers do.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-6-SECT-1.3.1">6.1.3.1 More About C Compilers</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9707"></A>The C compiler on a typical modern UNIX system (ANSI C on System V Release 4) has roughly 30 different command-lineoptions, but we'll limit ourselves to the most widely-used ones.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9712"></A>Here's what we'll implement. All compilers provide the ability to eliminate the final linking step, i.e., thecall to the linker <EMCLASS="emphasis">ld</EM>. This is useful for compiling C code intoobject code files that will be linked later, and for taking advantageof the compiler's error checking separately before trying to link. The <BCLASS="emphasis.bold">-c</B>option suppresses the link step, producing only the compiled object codefiles.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9717"></A>C compilers are also capable of including lots of extra information in an object code file that can be used by a debugger (though it is ignored bythe linker and the running program). If you don't know what adebugger is, see <ACLASS="xref"HREF="ch09_01.htm"TITLE="Debugging Shell Programs">Chapter 9, Debugging Shell Programs</A>.The debugger needs lots of informationabout the original C code to be able to do its job; theoption <BCLASS="emphasis.bold">-g</B> directs the compiler to include this information in  its object-code output.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9722"></A>If you aren't already familiar with UNIX C compilers, you may havethought it strange when you saw in the last chapter that the linkerputs its output (the executable program) in a file called <EMCLASS="emphasis">a.out</EM>.This convention is a historical relic that no one has bothered tochange.  <ACLASS="indexterm"NAME="AUTOID-9725"></A>Although it's certainly possible to change the executable'sname with the <EMCLASS="emphasis">mv</EM> command, the C compiler provides the option<BCLASS="emphasis.bold">-o</B> <EMCLASS="emphasis">filename</EM>, which uses <EMCLASS="emphasis">filename</EM> instead of <EMCLASS="emphasis">a.out</EM>.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-OBJECT-CODE-LIBRARIES"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-LINKING"></A>Another option we will support here has to do with<EMCLASS="emphasis">libraries</EM>. A library is a collection of objectcode, <EMCLASS="emphasis">some</EM> of which is to be included in the executable atlink time. (This is in contrast to a precompiled object code file,<EMCLASS="emphasis">all</EM> of which is linked in.) Each library includes a large amount of object code that supports a certain type of interfaceor activity; typical UNIX systems have libraries for things likenetworking, math functions, and graphics.</P><PCLASS="para">Libraries are extremely useful as building blocks that help programmerswrite complex programs without having to &quot;reinvent the wheel&quot; every time.<ACLASS="indexterm"NAME="AUTOID-9741"></A>The C compiler option <BCLASS="emphasis.bold">-l</B> <EMCLASS="emphasis">name</EM> tells the linker to include whatevercode is necessary from the library <EMCLASS="emphasis">name</EM>[4]in the executable it builds.  <ACLASS="indexterm"NAME="AUTOID-9752"></A>One particular library called <EMCLASS="emphasis">c</EM>(the file <EMCLASS="emphasis">libc.a</EM>) is always included. This is knownas the C runtime library; it contains code forC's standard input and output capability, among other things.<ACLASS="indexterm"NAME="AUTOID-9757"></A><ACLASS="indexterm"NAME="AUTOID-9758"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] This is actually a file called <EMCLASS="emphasis">lib</EM>name<EMCLASS="emphasis">.a</EM> in a standard librarydirectory such as <EMCLASS="emphasis">/lib</EM>.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9760"></A>Finally, it is possible for a good C compiler to do certain thingsthat make its output object code smaller and more efficient. Collectively,these things are called <EMCLASS="emphasis">optimization</EM>. You can think of an<EMCLASS="emphasis">optimizer</EM> as an extra step in the compilation processthat looks back at the object-code output and changes it for the better. The option <BCLASS="emphasis.bold">-O</B>invokes the optimizer.</P><PCLASS="para"><ACLASS="xref"HREF="ch06_01.htm#KSH-CH-6-TAB-0"TITLE="Popular C Compiler Options">Table 6.1</A>summarizes the options we will build into our C compilerfront end.<ACLASS="indexterm"NAME="AUTOID-9768"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-6-TAB-0">Table 6.1: Popular C Compiler Options</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Option</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-c</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Produce object code only; do not invoke the linker</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-g</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Include debugging information in object code files</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-l</B> <EMCLASS="emphasis">lib</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Include the library <EMCLASS="emphasis">lib</EM> when linking</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-o</B> <EMCLASS="emphasis">exefile</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Produce the executable file <EMCLASS="emphasis">exefile</EM> instead of the default <EMCLASS="emphasis">a.out</EM></P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-O</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Invoke the optimizer</TD></TR></TBODY></TABLE><PCLASS="para">You should also bear in mind this information about the options:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">The options <BCLASS="emphasis.bold">-o</B> and <BCLASS="emphasis.bold">-l</B> <EMCLASS="emphasis">lib</EM> are merely passed on to thelinker (<EMCLASS="emphasis">ld</EM>), which processes them on its own.</P></LI><LICLASS="listitem"><PCLASS="para">The <BCLASS="emphasis.bold">-l</B> <EMCLASS="emphasis">lib</EM> option can be used multiple times to link inmultiple libraries.</P></LI><LICLASS="listitem"><PCLASS="para">The <BCLASS="emphasis.bold">-g</B> option is passed to the <EMCLASS="emphasis">ccom</EM> command(the program that does the actual C compilation).</P></LI><LICLASS="listitem"><PCLASS="para">We will assume that the optimizer is a separate program called<EMCLASS="emphasis">optimize</EM> that accepts an object file as argument and optimizesit &quot;in place,&quot; i.e., without producing a separate output file.</P></LI></UL><PCLASS="para">Here is the code for the script <EMCLASS="emphasis">occ</EM> that includes option processing:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># initialize option-related variablesdo_link=truedebug=&quot;&quot;link_libs=&quot;-l c&quot;exefile=&quot;&quot;opt=false# process command-line optionswhile getopts &quot;:cgl:o:O&quot; opt; do    case $opt in         c )    do_link=false ;;        g )    debug=&quot;-g&quot; ;;        l )    link_libs=&quot;$link_libs -l $OPTARG&quot; ;;        o )    exefile=&quot;-o $OPTARG&quot; ;;        O )    opt=true ;;        \? )    print 'usage: occ [-cgO] [-l lib] [-o file] files...'               return 1 ;;    esacdoneshift $(($OPTIND - 1))# process the input filesobjfiles=&quot;&quot;for filename in &quot;$@&quot;; do    case $filename in         *.c )             objname=${filename%.c}.o            ccom $debug $filename $objname             if [[ $opt = true ]]; then                optimize $objname             fi ;;        *.s )            objname=${filename%.s}.o            as $filename $objname ;;        *.o )             objname=$filename ;;        *   )             print &quot;error: $filename is not a source or object file.&quot;            return 1 ;;    esac    objfiles=&quot;$objfiles $objname&quot;doneif [[ $do_link = true ]]; then    ld $exefile $link_libs $objfilesfi</PRE></BLOCKQUOTE></P><PCLASS="para">Let's examine the option-processing part of this code.The first several lines initialize variables that we will use laterto store the status of each of the options. We use &quot;true&quot; and&quot;false&quot; for truth values for readability; they are just stringsand otherwise have no special meaning. The initializationsreflect these assumptions:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">We will want to link.</P></LI><LICLASS="listitem"><PCLASS="para">We will not want the compiler to generate space-consumingdebugger information.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9836"></A>The only object-code library we will need is <EMCLASS="emphasis">c</EM>, the standard C runtime library that is automatically linked in.</P></LI><LICLASS="listitem"><PCLASS="para">The executable file that the linker creates will be the linker'sdefault file, <EMCLASS="emphasis">a.out</EM>.</P></LI><LICLASS="listitem"><PCLASS="para">We will not want to invoke the optimizer.</P></LI></OL><PCLASS="para">The <BCLASS="emphasis.bold">while</B>, <BCLASS="emphasis.bold">getopts</B>, and <BCLASS="emphasis.bold">case</B> constructs process the options in thesame way as the previous example. Here is what the code thathandles each option does:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">If the <BCLASS="emphasis.bold">-c</B> option is given,the <BCLASS="emphasis.bold">do_link</B> flag is set to &quot;false,&quot; which will cause the <BCLASS="emphasis.bold">if</B>condition at the end of the script to be false, meaning that thelinker will not run.</P></LI><LICLASS="listitem"><PCLASS="para">If <BCLASS="emphasis.bold">-g</B> is given, the <BCLASS="emphasis.bold">debug</B> variable is set to &quot;-g&quot;.  This is passed on the command line to the compiler.</P></LI><LICLASS="listitem"><PCLASS="para">Each <BCLASS="emphasis.bold">-l</B> <EMCLASS="emphasis">lib</EM> that is given is appended to the variable<BCLASS="emphasis.bold">link_libs</B>, so that when the <BCLASS="emphasis.bold">while</B> loop exits, <BCLASS="emphasis.bold">$link_libs</B>is the entire string of <BCLASS="emphasis.bold">-l</B> options. This string is passed to the linker.</P></LI><LICLASS="listitem"><PCLASS="para">If <BCLASS="emphasis.bold">-o</B> <EMCLASS="emphasis">file</EM> is given, the <BCLASS="emphasis.bold">exefile</B> variable isset to &quot;-o <EMCLASS="emphasis">file</EM>&quot;.  This string is passed to the linker.</P></LI><LICLASS="listitem"><PCLASS="para">If <BCLASS="emphasis.bold">-O</B> is specified, the <BCLASS="emphasis.bold">opt</B> flag will be set. Thisspecificationcauses the conditional <BCLASS="emphasis.bold">if [[ $opt = true ]]</B> to be true,which means that the optimizer will run.</P></LI></UL><PCLASS="para">The remainder of the code is a modification of the <BCLASS="emphasis.bold">for</B> loopwe have already seen; the modifications are direct results of theabove option processing and should be self-explanatory.<ACLASS="indexterm"NAME="AUTOID-9880"></A><ACLASS="indexterm"NAME="AUTOID-9881"></A></P></DIV></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch05_05.htm"TITLE="5.5 while and until"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 5.5 while and until"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Integer Variables and Arithmetic"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.2 Integer Variables and Arithmetic"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">5.5 while and until</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">6.2 Integer Variables and Arithmetic</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>