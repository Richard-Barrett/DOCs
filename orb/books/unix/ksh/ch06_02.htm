<HTML><HEAD><TITLE>[Chapter 6] 6.2 Integer Variables and Arithmetic</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:10:32Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch06_01.htm"TITLE="6. Command-line Options and Typed Variables"><LINKREL="prev"HREF="ch06_01.htm"TITLE="6.1 Command-line Options"><LINKREL="next"HREF="ch06_03.htm"TITLE="6.3 Arrays"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_01.htm"TITLE="6.1 Command-line Options"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.1 Command-line Options"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 6<BR>Command-line Options and Typed Variables</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_03.htm"TITLE="6.3 Arrays"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.3 Arrays"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-6-SECT-2">6.2 Integer Variables and Arithmetic</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9885"></A><ACLASS="indexterm"NAME="AUTOID-9889"></A><ACLASS="indexterm"NAME="AUTOID-9891"></A>The expression <BCLASS="emphasis.bold">$(($OPTIND - 1))</B> in the last example givesa clue as to how the shell can do integer arithmetic.As you might guess, the shell interprets words surrounded by<BCLASS="emphasis.bold">$((</B> and <BCLASS="emphasis.bold">))</B> as arithmetic expressions. Variablesin arithmetic expressions do <EMCLASS="emphasis">not</EM> need to be precededby dollar signs, though it is not wrong to do so.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9900"></A>Arithmetic expressions are evaluated inside double quotes,like tildes, variables, and command substitutions.We're <EMCLASS="emphasis">finally</EM> in a position to state the definitive ruleabout quoting strings: When in doubt, enclose a string in single quotes, unless itcontains tildes or any expression involving a dollar sign,in which case you should use double quotes.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9905"></A><ACLASS="indexterm"NAME="AUTOID-9908"></A>For example, the <EMCLASS="emphasis">date</EM>(1) command on System V-derivedversions of UNIX accepts arguments that tell it how to formatits output. The argument <BCLASS="emphasis.bold">+%j</B> tells it to print the day ofthe year, i.e., the number of days since December 31st of theprevious year. </P><PCLASS="para">We can use <BCLASS="emphasis.bold">+%j</B> to print a little holiday anticipationmessage:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">print &quot;Only $(( (365-$(date +%j)) / 7 )) weeks until the New Year!&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">We'll show where this fits in the overall scheme of command-lineprocessing in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7, Input/Output and Command-line Processing</A>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9919"></A><ACLASS="indexterm"NAME="AUTOID-9921"></A>The arithmetic expression feature is built in to the Korn shell's syntax, and was available in the Bourne shell (most versions) only through the externalcommand <EMCLASS="emphasis">expr</EM>(1). Thus it is yet another example of adesirable feature provided by an external command (i.e., a syntactic kludge)being better integrated into the shell.  <ACLASS="indexterm"NAME="AUTOID-9924"></A><ACLASS="indexterm"NAME="AUTOID-9926"></A><BCLASS="emphasis.bold">[[</B>/<BCLASS="emphasis.bold">]]</B> and <BCLASS="emphasis.bold">getopts</B> are also examples of this design trend.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-ARITHMETIC-EXPRESSIONS-OPERATORS"></A><ACLASS="indexterm"NAME="AUTOID-9935"></A>Korn shell arithmetic expressions are equivalent totheir counterparts in the C language.[5]Precedence and associativity are the same as in C.<ACLASS="xref"HREF="ch06_02.htm#KSH-CH-6-TAB-1"TITLE="Arithmetic Operators">Table 6.2</A>shows the arithmetic operators that are supported.  Although some of theseare (or contain) special characters, there is no need to backslash-escape them, because they are within the <BCLASS="emphasis.bold">$((</B>...<BCLASS="emphasis.bold">))</B> syntax.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] <ACLASS="indexterm"NAME="AUTOID-9939"></A>The assignment forms of these operators are also permitted.For example, <BCLASS="emphasis.bold">$((x += 2))</B> adds 2 to <BCLASS="emphasis.bold">x</B> and stores the result back in <BCLASS="emphasis.bold">x</B>.</P></BLOCKQUOTE><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-6-TAB-1">Table 6.2: Arithmetic Operators</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operator</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">+</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Plus</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">-</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Minus</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">*</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Times</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Division (with truncation)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">%</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Remainder</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">&lt;&lt;</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Bit-shift left</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">&gt;&gt;</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Bit-shift right</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">&amp;</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Bitwise and</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">|</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Bitwise or</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">~</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Bitwise not</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">^</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Bitwise exclusive or</TD></TR></TBODY></TABLE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-9999"></A>Parentheses can be used to group subexpressions.  <ACLASS="indexterm"NAME="AUTOID-10002"></A><ACLASS="indexterm"NAME="AUTOID-10006"></A>The arithmetic expression syntax also (like C) supports relational operatorsas &quot;truth values&quot; of 1 for true and 0 for false. <ACLASS="xref"HREF="ch06_02.htm#KSH-CH-6-TAB-2"TITLE="Relational Operators">Table 6.3</A>shows the relational operatorsand the logical operators that can be used to combine relational expressions.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-6-TAB-2">Table 6.3: Relational Operators</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operator</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">&lt;</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Less than</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">&gt;</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Greater than</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">&lt;=</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Less than or equal </TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">&gt;=</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Greater than or equal</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">==</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Equal</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">!=</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Not equal</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">&amp;&amp;</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Logical and</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">||</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Logical or</TD></TR></TBODY></TABLE><PCLASS="para">For example, <BCLASS="emphasis.bold">$((3 &gt; 2))</B> has the value 1; <BCLASS="emphasis.bold">$(( (3 &gt; 2) || (4 &lt;= 1) ))</B> alsohas the value 1, since at least one of the two subexpressions is true.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10045"></A>The shell also supports base <EMCLASS="emphasis">N</EM> numbers, where <EMCLASS="emphasis">N</EM> can be up to 36.The notation <EMCLASS="emphasis">B</EM><BCLASS="emphasis.bold">#</B><EMCLASS="emphasis">N</EM> means &quot;<EMCLASS="emphasis">N</EM> base <EMCLASS="emphasis">B</EM>&quot;.Of course, if you omit the <EMCLASS="emphasis">B</EM><BCLASS="emphasis.bold">#</B>, the base defaults to 10.<ACLASS="indexterm"NAME="AUTOID-10057"></A></P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-2.1">6.2.1 Arithmetic Conditionals</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-CONDITION-TESTS-ARITHMETIC"></A><ACLASS="indexterm"NAME="AUTOID-10064"></A><ACLASS="indexterm"NAME="AUTOID-10068"></A>Another construct, closely related to <BCLASS="emphasis.bold">$((...))</B>, is<BCLASS="emphasis.bold">((...))</B> (without the leading dollar sign). We use thisfor evaluating arithmetic condition tests, just as <BCLASS="emphasis.bold">[[...]]</B>is used for string, file attribute, and other types of tests.</P><PCLASS="para"><BCLASS="emphasis.bold">((...))</B> evaluates relational operators differently from<BCLASS="emphasis.bold">$((...))</B> so that you can use it in <BCLASS="emphasis.bold">if</B> and <BCLASS="emphasis.bold">while</B>constructs. Instead of producing a textual result, it just sets itsexit status according to the truth of the expression: 0 if true, 1 otherwise. So, for example, <BCLASS="emphasis.bold">((3 &gt; 2))</B> produces exitstatus 0, as does <BCLASS="emphasis.bold">(( (3 &gt; 2) || (4 &lt;= 1) ))</B>, but<BCLASS="emphasis.bold">(( (3 &gt; 2) &amp;&amp; (4 &lt;= 1) ))</B> has exit status 1 since the second subexpression isn't true.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10083"></A>You can also use numerical values for truth values withinthis construct.  <ACLASS="indexterm"NAME="AUTOID-10087"></A>It's like the analogous concept in C, whichmeans that it's somewhat counterintuitive to non-C programmers:a value of 0 means <EMCLASS="emphasis">false</EM> (i.e., returns exit status 1),and a non-0 value means <EMCLASS="emphasis">true</EM> (returns exit status 0),e.g., <BCLASS="emphasis.bold">(( 14 ))</B> is true. See the code for the <EMCLASS="emphasis">kshdb</EM>debugger in <ACLASS="xref"HREF="ch09_01.htm"TITLE="Debugging Shell Programs">Chapter 9</A> for two more examples of this.<ACLASS="indexterm"NAME="AUTOID-10094"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-2.2">6.2.2 Arithmetic Variables and Assignment</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-LET"></A><ACLASS="indexterm"NAME="AUTOID-10100"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-VARIABLES-INTEGER"></A><ACLASS="indexterm"NAME="AUTOID-10106"></A>The <BCLASS="emphasis.bold">((</B>...<BCLASS="emphasis.bold">))</B> construct can also be used to defineinteger variables and assign values to them. The statement:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">(( <CODECLASS="replaceable"><I>intvar</I></CODE>=<CODECLASS="replaceable"><I>expression</I></CODE> ))</PRE></BLOCKQUOTE></P><PCLASS="para">creates the integer variable <EMCLASS="emphasis">intvar</EM> (if it doesn't already exist)and assigns to it the result of <EMCLASS="emphasis">expression</EM>.</P><PCLASS="para">That syntax isn't intuitive, so the shell provides a betterequivalent: the built-in command <BCLASS="emphasis.bold">let</B>. The syntax is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">let <EMCLASS="emphasis">intvar</EM>=<EMCLASS="emphasis">expression</EM></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10126"></A>It is not necessary (because it's actually redundant)to surround the expression with<BCLASS="emphasis.bold">$((</B> and <BCLASS="emphasis.bold">))</B> in a <BCLASS="emphasis.bold">let</B> statement. As with anyvariable assignment, there must not be any space on either sideof the equal sign (<BCLASS="emphasis.bold">=</B>). It is good practice to surround expressionswith quotes, since many characters are treated as special bythe shell (e.g., <CODECLASS="literal">*</CODE>, <BCLASS="emphasis.bold">#</B>, and parentheses); furthermore, you mustquote expressions that include whitespace (spaces or TABs). See <ACLASS="xref"HREF="ch06_02.htm#KSH-CH-6-TAB-3"TITLE="Sample Integer Expression Assignments">Table 6.4</A>for examples.  <ACLASS="indexterm"NAME="AUTOID-10136"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-6-TAB-3">Table 6.4: Sample Integer Expression Assignments</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Assignment</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Value</TH></TR><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">let x=</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">$x</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">1+4</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">5</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>1 + 4<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">5</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>(2+3) * 5<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">25</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>2 + 3 * 5<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">17</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>17 / 3<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">5</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>17 % 3<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">2</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>1&lt;&lt;4<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">16</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>48&gt;&gt;3<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">6</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>17 &amp; 3<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">1</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>17 | 3<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">19</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>17 ^ 3<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">18</TD></TR></TBODY></TABLE><PCLASS="para">Here is a small task that makes use of integer arithmetic.</P><DIVCLASS="task"><H4>Task 6.1</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">Write a script called <EMCLASS="emphasis">pages</EM> that, given the name of a textfile, tells how many pages of output it contains. Assume thatthere are 66 lines to a page but provide an option allowing theuser to override that.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10209"></A>We'll make our option <BCLASS="emphasis.bold">-</B><EMCLASS="emphasis">N</EM>, a la <EMCLASS="emphasis">head</EM>. The syntax forthis single option is so simple that we need not bother with <BCLASS="emphasis.bold">getopts</B>.Here is the code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ $1 = -+([0-9]) ]]; then    let page_lines=${1#-}    shiftelse    let page_lines=66filet file_lines=&quot;$(wc -l &lt; $1)&quot;let pages=file_lines/page_linesif (( file_lines % page_lines &gt; 0 )); then    let pages=pages+1fiprint &quot;$1 has $pages pages of text.&quot;</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10218"></A>Notice that we use the integer conditional <BCLASS="emphasis.bold">(( file_lines % page_lines &gt; 0 ))</B> rather than the<BCLASS="emphasis.bold">[[</B>...<BCLASS="emphasis.bold">]]</B> form.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-WC"></A>At the heart of this code is the UNIX utility <EMCLASS="emphasis">wc(1)</EM>, which counts the number of lines, words, and characters (bytes) in itsinput. By default, its output looks something like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">8      34     161  bob</PRE></BLOCKQUOTE></P><PCLASS="para"><EMCLASS="emphasis">wc</EM>'s output means that the file <EMCLASS="emphasis">bob</EM> has 8 lines, 34 words, and161 characters. <EMCLASS="emphasis">wc</EM> recognizes the options <BCLASS="emphasis.bold">-l</B>, <BCLASS="emphasis.bold">-w</B>,and <BCLASS="emphasis.bold">-c</B>, which tell it to print only the number of lines,words, or characters, respectively.  </P><PCLASS="para"><EMCLASS="emphasis">wc</EM> normally prints the name of its input file (given as argument).Since we want only the number of lines, we have to do two things.<ACLASS="indexterm"NAME="AUTOID-10239"></A>First, we give it input from file redirection instead,as in <BCLASS="emphasis.bold">wc -l &lt; bob</B> instead of <BCLASS="emphasis.bold">wc -l bob</B>.This produces the number of lines preceded by a single space(which would normally separate the filename from the number).</P><PCLASS="para">Unfortunately, that space complicates matters:the statement <BCLASS="emphasis.bold">let file_lines=$(wc -l &lt; $1)</B> becomes&quot;let file_lines= <EMCLASS="emphasis">N</EM>&quot; after command substitution; the spaceafter the equal sign is an error. That leads to the second modification,the quotes around the command substitution expression. Thestatement <BCLASS="emphasis.bold">let file_lines=&quot;&nbsp;</B><EMCLASS="emphasis">N</EM><BCLASS="emphasis.bold">&quot;</B> is perfectly legal, and<BCLASS="emphasis.bold">let</B> knows how to remove the leading space.<ACLASS="indexterm"NAME="AUTOID-10252"></A></P><PCLASS="para">The first <BCLASS="emphasis.bold">if</B> clause in the <EMCLASS="emphasis">pages</EM> script checks for an option and, if it was given,strips the dash (<BCLASS="emphasis.bold">-</B>) off and assigns it to the variable <BCLASS="emphasis.bold">page_lines</B>.<EMCLASS="emphasis">wc</EM> in the command substitution expression returns the number of lines in the file whose name is given as argument.<ACLASS="indexterm"NAME="AUTOID-10259"></A><ACLASS="indexterm"NAME="AUTOID-10260"></A></P><PCLASS="para">The next group of lines calculates the number of pages and,if there is a remainder after the division, adds 1. Finally,the appropriate message is printed.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10263"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-PUSHD"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-POPD"></A>As a bigger example of integer arithmetic, we will complete our emulation of the C shell's <EMCLASS="emphasis">pushd</EM> and <EMCLASS="emphasis">popd</EM> functions(Task 4-8).  <ACLASS="indexterm"NAME="AUTOID-10271"></A><ACLASS="indexterm"NAME="AUTOID-10273"></A>Remember that these functions operateon <BCLASS="emphasis.bold">DIRSTACK</B>, a stack of directories represented as a stringwith the directory names separated by spaces.<ACLASS="indexterm"NAME="AUTOID-10277"></A><ACLASS="indexterm"NAME="AUTOID-10280"></A>The C shell's <EMCLASS="emphasis">pushd</EM> and <EMCLASS="emphasis">popd</EM> take additionaltypes of arguments, which are:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">pushd +n</B> takes the <EMCLASS="emphasis">n</EM>th directory in the stack(starting with 0), rotates it to the top, and <BCLASS="emphasis.bold">cd</B>s to it.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">pushd</B> without arguments, instead of complaining, swapsthe two top directories on the stack and <BCLASS="emphasis.bold">cd</B>s to the new top.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">popd +n</B> takes the <EMCLASS="emphasis">n</EM>th directory in the stack and justdeletes it.</P></LI></UL><PCLASS="para">The most useful of these features is the ability to get at the <EMCLASS="emphasis">n</EM>th directoryin the stack. Here are the latest versions of both functions: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function pushd { # push current directory onto stack    dirname=$1    if [[ -d $dirname &amp;&amp; -x $dirname ]]; then  	  cd $dirname        DIRSTACK=&quot;$dirname ${DIRSTACK:-$PWD}&quot;        print &quot;$DIRSTACK&quot;    else        print &quot;still in $PWD.&quot;    fi}function popd {  # pop directory off the stack, cd to new top    if [[ -n $DIRSTACK ]]; then        DIRSTACK=${DIRSTACK#* }        cd ${DIRSTACK%% *}        print &quot;$PWD&quot;    else        print &quot;stack empty, still in $PWD.&quot;    fi}</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10304"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-LET2"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-VARS-INT"></A>To get at the <EMCLASS="emphasis">n</EM>th directory, we use a <BCLASS="emphasis.bold">while</B> loop that transfersthe top directory to a temporary copy of the stack <EMCLASS="emphasis">n</EM> times.We'll put the loop into a function called <EMCLASS="emphasis">getNdirs</EM> that lookslike this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function getNdirs{    stackfront=''    let count=0    while (( count &lt; $1 )); do        stackfront=&quot;$stackfront ${DIRSTACK%% *}&quot;        DIRSTACK=${DIRSTACK#* }        let count=count+1    done}</PRE></BLOCKQUOTE></P><PCLASS="para">The argument passed to <EMCLASS="emphasis">getNdirs</EM> is the <EMCLASS="emphasis">n</EM> in question.The variable <BCLASS="emphasis.bold">stackfront</B> is the temporary copy that will containthe first <EMCLASS="emphasis">n</EM> directories when the loop is done. <BCLASS="emphasis.bold">stackfront</B>starts as null; <BCLASS="emphasis.bold">count</B>, which counts the number of loop iterations,starts as 0.  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10325"></A><ACLASS="indexterm"NAME="AUTOID-10328"></A>The first line of the loop bodyappends the top of the stack (<BCLASS="emphasis.bold">${DIRSTACK%%</B> <CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">}</B>) to <BCLASS="emphasis.bold">stackfront</B>;the second line deletes the top from the stack. The last lineincrements the counter for the next iteration.  The entire loop executes<EMCLASS="emphasis">N</EM> times, for values of <BCLASS="emphasis.bold">count</B> from 0 to <EMCLASS="emphasis">N</EM>-1.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10339"></A><ACLASS="indexterm"NAME="AUTOID-10342"></A>When the loop finishes, the last directory in <BCLASS="emphasis.bold">$stackfront</B> isthe <EMCLASS="emphasis">N</EM>th directory. The expression <BCLASS="emphasis.bold">${stackfront##</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold"> }</B>extracts this directory. Furthermore, <BCLASS="emphasis.bold">DIRSTACK</B> now containsthe &quot;back&quot; of the stack, i.e.,the stack <EMCLASS="emphasis">without</EM> the first <EMCLASS="emphasis">n</EM> directories.With this in mind, we can now write the code for the improvedversions of <EMCLASS="emphasis">pushd</EM> and <EMCLASS="emphasis">popd</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function pushd {    if [[ $1 = ++([0-9]) ]]; then        # case of pushd +n: rotate n-th directory to top        let num=${1#+}        getNdirs $num        newtop=${stackfront##* }        stackfront=${stackfront%$newtop}        DIRSTACK=&quot;$newtop $stackfront $DIRSTACK&quot;        cd $newtop    elif [[ -z $1 ]]; then        # case of pushd without args; swap top two directories        firstdir=${DIRSTACK%% *}        DIRSTACK=${DIRSTACK#* }        seconddir=${DIRSTACK%% *}        DIRSTACK=${DIRSTACK#* }         DIRSTACK=&quot;$seconddir $firstdir $DIRSTACK&quot;        cd $seconddir    else  	  cd $dirname        # normal case of pushd dirname        dirname=$1        if [[ -d $dirname &amp;&amp; -x $dirname ]]; then            DIRSTACK=&quot;$dirname ${DIRSTACK:-$PWD}&quot;            print &quot;$DIRSTACK&quot;        else            print still in &quot;$PWD.&quot;        fi    fi}function popd {      # pop directory off the stack, cd to new top    if [[ $1 = ++([0-9]) ]]; then        # case of popd +n: delete n-th directory from stack        let num={$1#+}        getNdirs $num        stackfront=${stackfront% *}        DIRSTACK=&quot;$stackfront $DIRSTACK&quot;    else        # normal case of popd without argument        if [[ -n $DIRSTACK ]]; then            DIRSTACK=${DIRSTACK#* }            cd ${DIRSTACK%% *}            print &quot;$PWD&quot;        else            print &quot;stack empty, still in $PWD.&quot;        fi    fi}</PRE></BLOCKQUOTE></P><PCLASS="para">These functions have grown rather large; let's look at them in turn.<ACLASS="indexterm"NAME="AUTOID-10358"></A>The <BCLASS="emphasis.bold">if</B> at the beginning of <EMCLASS="emphasis">pushd</EM> checks if the firstargument is an option of the form <BCLASS="emphasis.bold">+</B><EMCLASS="emphasis">N</EM>. If so, the firstbody of code is run. The first <BCLASS="emphasis.bold">let</B> simply strips the plus sign(+) from the argument and assigns the result&nbsp;- as an integer&nbsp;- tothe variable <BCLASS="emphasis.bold">num</B>. This, in turn, is passed to the <EMCLASS="emphasis">getNdirs</EM>function.</P><PCLASS="para">The next two assignment statements set <BCLASS="emphasis.bold">newtop</B> to the <EMCLASS="emphasis">N</EM>thdirectory&nbsp;- i.e., the last directory in <BCLASS="emphasis.bold">$stackfront</B>&nbsp;- and delete that directory from <BCLASS="emphasis.bold">stackfront</B>. The final twolines in this part of <EMCLASS="emphasis">pushd</EM> put the stack back together againin the appropriate order and <BCLASS="emphasis.bold">cd</B> to the new top directory.</P><PCLASS="para">The <BCLASS="emphasis.bold">elif</B> clause tests for no argument, in which case <EMCLASS="emphasis">pushd</EM>should swap the top two directories on the stack. The first four linesof this clause assign the top two directories to <BCLASS="emphasis.bold">firstdir</B> and<BCLASS="emphasis.bold">seconddir</B>, and delete these from the stack. Then, as above,the code puts the stack back together in the new order and <BCLASS="emphasis.bold">cd</B>s tothe new top directory.  </P><PCLASS="para">The <BCLASS="emphasis.bold">else</B> clause corresponds to the usual case, where the usersupplies a directory name as argument.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10383"></A><EMCLASS="emphasis">popd</EM> works similarly. The <BCLASS="emphasis.bold">if</B> clause checks for the<BCLASS="emphasis.bold">+</B><EMCLASS="emphasis">N</EM> option, which in this case means delete the <EMCLASS="emphasis">N</EM>th directory. A <BCLASS="emphasis.bold">let</B> extracts the <EMCLASS="emphasis">N</EM> as an integer;the <EMCLASS="emphasis">getNdirs</EM> function puts the first <EMCLASS="emphasis">n</EM> directories into <BCLASS="emphasis.bold">stackfront</B>. Then the line <BCLASS="emphasis.bold">stackfront=${stackfront%&nbsp;*}</B>deletes the last directory (the <EMCLASS="emphasis">N</EM>th directory) from<BCLASS="emphasis.bold">stackfront</B>. Finally, the stack is put back together withthe <EMCLASS="emphasis">N</EM>th directory missing.</P><PCLASS="para">The <BCLASS="emphasis.bold">else</B> clause covers the usual case, where the user doesn'tsupply an argument.<ACLASS="indexterm"NAME="AUTOID-10401"></A><ACLASS="indexterm"NAME="AUTOID-10402"></A></P><PCLASS="para">Before we leave this subject, here are a few exercises that shouldtest your understanding of this code:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Add code to <EMCLASS="emphasis">pushd</EM> that exits with an error message ifthe user supplies no argument and the stack contains fewer than two directories.</P></LI><LICLASS="listitem"><PCLASS="para">Verify that when the user specifies <BCLASS="emphasis.bold">+</B><EMCLASS="emphasis">N</EM>and <EMCLASS="emphasis">N</EM> exceeds the number of directories in the stack, both<EMCLASS="emphasis">pushd</EM> and <EMCLASS="emphasis">popd</EM> use the last directory as the <EMCLASS="emphasis">N</EM>th directory.</P></LI><LICLASS="listitem"><PCLASS="para">Modify the <EMCLASS="emphasis">getNdirs</EM> function so that it checks for theabove condition and exits with an appropriate error message if true.</P></LI><LICLASS="listitem"><PCLASS="para">Change <EMCLASS="emphasis">getNdirs</EM> so that it uses <EMCLASS="emphasis">cut</EM> (withcommand substitution), instead of the <BCLASS="emphasis.bold">while</B> loop,to extract the first <EMCLASS="emphasis">N</EM> directories. This uses less codebut runs more slowly because of the extra processes generated.</P></LI></OL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10426"></A><ACLASS="indexterm"NAME="AUTOID-10427"></A></P></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_01.htm"TITLE="6.1 Command-line Options"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.1 Command-line Options"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_03.htm"TITLE="6.3 Arrays"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.3 Arrays"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">6.1 Command-line Options</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">6.3 Arrays</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>