<HTML><HEAD><TITLE>[Chapter 6] 6.3 Arrays</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:10:49Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch06_01.htm"TITLE="6. Command-line Options and Typed Variables"><LINKREL="prev"HREF="ch06_02.htm"TITLE="6.2 Integer Variables and Arithmetic"><LINKREL="next"HREF="ch07_01.htm"TITLE="7. Input/Output and Command-line Processing"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Integer Variables and Arithmetic"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.2 Integer Variables and Arithmetic"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 6<BR>Command-line Options and Typed Variables</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch07_01.htm"TITLE="7. Input/Output and Command-line Processing"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7. Input/Output and Command-line Processing"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-6-SECT-3">6.3 Arrays</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-ARRAYS"></A><ACLASS="indexterm"NAME="AUTOID-10433"></A>So far we have seen two types of variables: character strings and integers. The third type of variable the Korn shell supportsis an <EMCLASS="emphasis">array</EM>.  As you may know, an array is like a list of things; you can referto specific elements in an array with integer <EMCLASS="emphasis">indices</EM>, so that <EMCLASS="emphasis">a[i]</EM> refers to the <EMCLASS="emphasis">i</EM>th element of array <EMCLASS="emphasis">a</EM>.</P><PCLASS="para">The Korn shell provides an array facility that, while useful, ismuch more limited than analogous features in conventional programminglanguages. In particular, arrays can be only one-dimensional(i.e., no arrays of arrays), and they are limited to 1024elements. Indices can start at 0.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10444"></A>There are two ways to assign values to elements of an array.The first is the most intuitive: you can use the standard shell variable assignment syntax with the array index in brackets(<BCLASS="emphasis.bold">[]</B>).For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">nicknames[2]=bobnicknames[3]=ed</PRE></BLOCKQUOTE></P><PCLASS="para">puts the values <BCLASS="emphasis.bold">bob</B> and <BCLASS="emphasis.bold">ed</B> into the elements of the array <BCLASS="emphasis.bold">nicknames</B>with indices 2 and 3, respectively. As with regular shell variables,values assigned to array elements are treated as character stringsunless the assignment is preceded by <BCLASS="emphasis.bold">let</B>.</P><PCLASS="para">The second way to assign values to an array is with a variant ofthe <BCLASS="emphasis.bold">set</B> statement, which we saw in <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3, Customizing Your Environment</A>. Thestatement:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">set -A <EMCLASS="emphasis">aname val1 val2 val3</EM> ...</PRE></BLOCKQUOTE></P><PCLASS="para">creates the array <EMCLASS="emphasis">aname</EM> (if it doesn't already exist) andassigns<EMCLASS="emphasis">val1</EM> to <EMCLASS="emphasis">aname[0]</EM>, <EMCLASS="emphasis">val2</EM> to <EMCLASS="emphasis">aname[1]</EM>, etc.As you would guess, this is more convenient for loading up an arraywith an initial set of values.<ACLASS="indexterm"NAME="AUTOID-10467"></A><ACLASS="indexterm"NAME="AUTOID-10470"></A><ACLASS="indexterm"NAME="AUTOID-10473"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10477"></A>To extract a value from an array, use the syntax <BCLASS="emphasis.bold">${</B><EMCLASS="emphasis">aname</EM><BCLASS="emphasis.bold">[</B><EMCLASS="emphasis">i</EM><BCLASS="emphasis.bold">]}</B>.For example, <BCLASS="emphasis.bold">${nicknames[2]}</B> has the value &quot;bob&quot;.  The index <EMCLASS="emphasis">i</EM> can be an arithmetic expression-see above.  <ACLASS="indexterm"NAME="AUTOID-10487"></A><ACLASS="indexterm"NAME="AUTOID-10490"></A>If you use <CODECLASS="literal">*</CODE> in placeof the index, the value will be all elements, separated by spaces.Omitting the index is the same as specifying index 0.</P><PCLASS="para">Now we come to the somewhat unusual aspect of Korn shell arrays.Assume that the only values assigned to <BCLASS="emphasis.bold">nicknames</B> are the two we sawabove. If you type <BCLASS="emphasis.bold">print</B> <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">${nicknames[</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">]}&quot;</B>, you will see the output:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">bob ed</PRE></BLOCKQUOTE></P><PCLASS="para">In other words, <BCLASS="emphasis.bold">nicknames[0]</B> and <BCLASS="emphasis.bold">nicknames[1]</B> don't exist.Furthermore, if you were to type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">nicknames[9]=petenicknames[31]=ralph</PRE></BLOCKQUOTE></P><PCLASS="para">and then type <BCLASS="emphasis.bold">print</B> <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">${nicknames[</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">]}&quot;</B>, the output would look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">bob ed pete ralph</PRE></BLOCKQUOTE></P><PCLASS="para">This is why we said &quot;the elements of <BCLASS="emphasis.bold">nicknames</B> with indices 2 and 3&quot; earlier, instead of &quot;the 2nd and 3rd elements of <BCLASS="emphasis.bold">nicknames</B>&quot;.  Any array elements withunassigned values just don't exist; if you try to access their values,you will get null strings.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10520"></A><ACLASS="indexterm"NAME="AUTOID-10523"></A>You can preserve whatever whitespaceyou put in your array elements by using <CODECLASS="literal">&quot;</CODE> <BCLASS="emphasis.bold">$</B>{<EMCLASS="emphasis">aname</EM><BCLASS="emphasis.bold">[@]</B>}<CODECLASS="literal">&quot;</CODE> (with the double quotes) instead of <BCLASS="emphasis.bold">$</B>{<EMCLASS="emphasis">aname</EM><BCLASS="emphasis.bold">[</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">]</B>}<CODECLASS="literal">&quot;</CODE>, just as you can with<CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$@</B><CODECLASS="literal">&quot;</CODE> instead of<BCLASS="emphasis.bold">$</B><CODECLASS="literal">*</CODE>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10543"></A><ACLASS="indexterm"NAME="AUTOID-10546"></A>The shell provides an operator that tells you how many elements anarray has defined: <BCLASS="emphasis.bold">${#</B><EMCLASS="emphasis">aname</EM><BCLASS="emphasis.bold">[</B><CODECLASS="literal">*</CODE>]<BCLASS="emphasis.bold">}</B>. Thus <BCLASS="emphasis.bold">${#nicknames[</B><CODECLASS="literal">*</CODE>]<BCLASS="emphasis.bold">}</B>has the value 4.  Note that you need the <BCLASS="emphasis.bold">[</B><CODECLASS="literal">*</CODE><BCLASS="emphasis.bold">]</B> because the nameof the array alone is interpreted as the 0th element. This means, forexample, that <BCLASS="emphasis.bold">${#nicknames}</B> equals the length of <BCLASS="emphasis.bold">nicknames[0]</B> (see<ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A>). Since <BCLASS="emphasis.bold">nicknames[0]</B> doesn't exist, the value of<BCLASS="emphasis.bold">${#nicknames}</B> is 0, the length of the null string.</P><PCLASS="para">To be quite frank,we feel that the Korn shell's array facility is of little useto shell programmers. This is partially because it is so limited,but mainly because shell programming tasks are much more oftenoriented toward character strings and text than toward numbers.If you think of an array as a mapping from integers to values(i.e., put in a number, get out a value), then you can see why arrays are &quot;number-dominated&quot; data structures.</P><PCLASS="para">Nevertheless, we can find useful things to do with arrays.<ACLASS="indexterm"NAME="KSH-CH-6-IX-TERM"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-ENVIRONMENT-VARIABLES-TERM"></A>For example, here is a cleaner solution to Task 5-4,in which a user can select his or her terminal type (<BCLASS="emphasis.bold">TERM</B>environment variable) at login time.  <ACLASS="indexterm"NAME="KSH-CH-6-IX-SELECT"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-CASE"></A>Recall that the &quot;user-friendly&quot;version of this code used <BCLASS="emphasis.bold">select</B> and a <BCLASS="emphasis.bold">case</B> statement:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">print 'Select your terminal type:'PS3='terminal? 'select term in    'Givalt GL35a' \    'Tsoris T-2000' \    'Shande 531' \    'Vey VT99'do    case $REPLY in        1 ) TERM=gl35a ;;        2 ) TERM=t2000 ;;        3 ) TERM=s531 ;;        4 ) TERM=vt99 ;;        * ) print &quot;invalid.&quot; ;;    esac    if [[ -n $term ]]; then        print &quot;TERM is $TERM&quot;        break    fidone</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10582"></A><ACLASS="indexterm"NAME="AUTOID-10586"></A>We can eliminate the entire <BCLASS="emphasis.bold">case</B> constructby taking advantage of the fact that the <BCLASS="emphasis.bold">select</B> construct storesthe user's number choice in the variable <BCLASS="emphasis.bold">REPLY</B>.  We just need a line of code that stores allof the possibilities for <BCLASS="emphasis.bold">TERM</B> in an array, in an order thatcorresponds to the items in the <BCLASS="emphasis.bold">select</B> menu. Then we can use<BCLASS="emphasis.bold">$REPLY</B> to index the array. The resulting code is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">set -A termnames gl35a t2000 s531 vt99print 'Select your terminal type:'PS3='terminal? 'select term in    'Givalt GL35a' \    'Tsoris T-2000' \    'Shande 531' \    'Vey VT99'do    if [[ -n $term ]]; then        TERM=${termnames[REPLY-1]}        print &quot;TERM is $TERM&quot;        break    fidone</PRE></BLOCKQUOTE></P><PCLASS="para">This code sets up the array <BCLASS="emphasis.bold">termnames</B>so that <BCLASS="emphasis.bold">${termnames[0]}</B> is &quot;gl35a&quot;, <BCLASS="emphasis.bold">${termnames[1]}</B> is&quot;t2000&quot;, etc. The line <BCLASS="emphasis.bold">TERM=${termnames[REPLY-1]}</B> essentiallyreplaces the entire <BCLASS="emphasis.bold">case</B> construct by using <BCLASS="emphasis.bold">REPLY</B> toindex the array.  </P><PCLASS="para">Notice that the shell knows to interpret the text inan array index as an arithmetic expression, as if it were enclosed in <BCLASS="emphasis.bold">((</B> and <BCLASS="emphasis.bold">))</B>, which in turn means that variable need not bepreceded by a dollar sign (<BCLASS="emphasis.bold">$</B>).We have to subtract 1 from the value of <BCLASS="emphasis.bold">REPLY</B> becausearray indices start at 0, while <BCLASS="emphasis.bold">select</B> menu item numbers startat 1.<ACLASS="indexterm"NAME="AUTOID-10610"></A><ACLASS="indexterm"NAME="AUTOID-10611"></A><ACLASS="indexterm"NAME="AUTOID-10612"></A><ACLASS="indexterm"NAME="AUTOID-10613"></A><ACLASS="indexterm"NAME="AUTOID-10614"></A></P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-3.1">6.3.1 typeset</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-TYPESET"></A>The final Korn shell feature that relates to the kinds of valuesthat variables can hold is the <BCLASS="emphasis.bold">typeset</B> command.  If you are a programmer, you might guess that <BCLASS="emphasis.bold">typeset</B> is used to specify the <EMCLASS="emphasis">type</EM> of a variable (integer, string,etc.); you'd be partially right.</P><PCLASS="para"><BCLASS="emphasis.bold">typeset</B> is a rather <EMCLASS="emphasis">ad hoc</EM> collection of things thatyou can do to variables that restrict the kinds of values they can take.Operations are specified by options to <BCLASS="emphasis.bold">typeset</B>; the basic syntax is:<ACLASS="indexterm"NAME="AUTOID-10627"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">typeset <EMCLASS="emphasis">-o varname</EM>[=<EMCLASS="emphasis">value</EM>]</PRE></BLOCKQUOTE></P><PCLASS="para">Options can be combined; multiple <EMCLASS="emphasis">varname</EM>s can be used.If you leave out <EMCLASS="emphasis">varname</EM>, the shell prints a list of variablesfor which the given option is turned on.</P><PCLASS="para">The options available break down into two basic categories:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">String formatting operations, such as right- and left-justification,truncation, and letter case control.</P></LI><LICLASS="listitem"><PCLASS="para">Type and attribute functions that are of primary interest to advanced programmers.</P></LI></OL></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-3.2">6.3.2 Local Variables in Functions</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-TYPESET-MAKE-VARS-FUNCTIONS"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-FUNCTIONS-LOCAL-VARIABLES-IN"></A><ACLASS="indexterm"NAME="KSH-CH-6-IX-VARIABLES-LOCAL-IN-FUNCTIONS"></A><BCLASS="emphasis.bold">typeset</B> without options has an important meaning:if a <BCLASS="emphasis.bold">typeset</B> statementis inside a function definition, then the variables involvedall become <EMCLASS="emphasis">local</EM> to that function (in addition to anyproperties they may take on as a result of <BCLASS="emphasis.bold">typeset</B> options).The ability to definevariables that are local to &quot;subprogram&quot; units (procedures,functions, subroutines, etc.) is necessary for writinglarge programs, because it helps keep subprograms independent ofthe main program and of each other.</P><PCLASS="para">If you just want to declare a variable local to a function,use <BCLASS="emphasis.bold">typeset</B> without any options. For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function afunc {    typeset diffvar    samevar=funcvalue    diffvar=funcvalue    print &quot;samevar is $samevar&quot;    print &quot;diffvar is $diffvar&quot;}samevar=globvaluediffvar=globvalueprint &quot;samevar is $samevar&quot;print &quot;diffvar is $diffvar&quot;afuncprint &quot;samevar is $samevar&quot;print &quot;diffvar is $diffvar&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">This code will print the following:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">samevar is globvaluediffvar is globvaluesamevar is funcvaluediffvar is funcvaluesamevar is funcvaluediffvar is globvalue</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="xref"HREF="ch06_03.htm#KSH-CH-6-FIG-0"TITLE="Local variables in functions">Figure 6.1</A>shows this graphically.</P><H4CLASS="figure"><ACLASS="title"NAME="KSH-CH-6-FIG-0">Figure 6.1: Local variables in functions</A></H4><IMGCLASS="graphic"SRC="figs/korn0601.gif"ALT="Figure 6.1"><PCLASS="para">You will see several additional examples of local variableswithin functions in <ACLASS="xref"HREF="ch09_01.htm"TITLE="Debugging Shell Programs">Chapter 9</A>.<ACLASS="indexterm"NAME="AUTOID-10673"></A><ACLASS="indexterm"NAME="AUTOID-10674"></A><ACLASS="indexterm"NAME="AUTOID-10675"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-3.3">6.3.3 String Formatting Options</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-TYPESET-STR-FMT-OPTIONS"></A>Now let's look at the various options to <BCLASS="emphasis.bold">typeset</B>.<ACLASS="xref"HREF="ch06_03.htm#KSH-CH-6-TAB-4"TITLE="Typeset String Formatting Options">Table 6.5</A>lists the string formatting options;the first three take an optional numeric argument.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-6-TAB-4">Table 6.5: Typeset String Formatting Options</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Option</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operation</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-L</B><EMCLASS="emphasis">n</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Left-justify. Remove leading blanks; if <EMCLASS="emphasis">n</EM>is given, fill with blanks or truncate on right to length <EMCLASS="emphasis">n</EM>.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-R</B><EMCLASS="emphasis">n</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Right-justify. Remove trailing blanks; if <EMCLASS="emphasis">n</EM>is given, fill with blanks or truncate on left to length <EMCLASS="emphasis">n</EM>.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-Z</B><EMCLASS="emphasis">n</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Same as above, except add leading 0's instead ofblanks if needed.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-l</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Convert letters to lowercase.</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-u</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Convert letters to uppercase.</TD></TR></TBODY></TABLE><PCLASS="para">Here are a few simple examples. Assume that the variable <BCLASS="emphasis.bold">alpha</B>is assigned the letters of the alphabet, in alternating case, surroundedby three blanks on each side:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">alpha=&quot;   aBcDeFgHiJkLmNoPqRsTuVwXyZ   &quot;</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="xref"HREF="ch06_03.htm#KSH-CH-6-TAB-5"TITLE="Examples of typeset String Formatting Options">Table 6.6</A>shows some <BCLASS="emphasis.bold">typeset</B> statements and their resulting values(assuming that each of the statements are run &quot;independently&quot;).<ACLASS="indexterm"NAME="AUTOID-10729"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-6-TAB-5">Table 6.6: Examples of typeset String Formatting Options</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Statement</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Value of v</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">typeset -L</B> v=$alpha</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">&quot;aBcDeFgHiJkLmNoPqRsTuVwXyZ&nbsp;&nbsp;&nbsp;&quot;</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">typeset -L10</B> v=$alpha</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">&quot;aBcDeFgHiJ&quot;</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">typeset -R</B> v=$alpha</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">&quot;&nbsp;&nbsp;&nbsp;aBcDeFgHiJkLmNoPqRsTuVwXyZ&quot;</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">typeset -R16</B> v=$alpha</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">&quot;kLmNoPqRsTuVwXyZ&quot;</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">typeset -l</B> v=$alpha</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">&quot;&nbsp;&nbsp;&nbsp;abcdefghijklmnopqrstuvwxyz&quot;</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">typeset -uR5</B> v=$alpha</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">&quot;VWXYZ&quot;</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">typeset -Z8</B> v=<CODECLASS="literal">&quot;123.50&quot;</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">&quot;00123.50&quot;</CODE></TD></TR></TBODY></TABLE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10778"></A>When you run <BCLASS="emphasis.bold">typeset</B> on an existingvariable, its effect is <EMCLASS="emphasis">cumulative</EM> with whatever <BCLASS="emphasis.bold">typeset</B>smay have been used previously. This has the obvious exceptions:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">A <BCLASS="emphasis.bold">typeset -u</B> undoes a <BCLASS="emphasis.bold">typeset -l</B>, and vice versa.</P></LI><LICLASS="listitem"><PCLASS="para">A <BCLASS="emphasis.bold">typeset -R</B> undoes a <BCLASS="emphasis.bold">typeset -L</B>, and vice versa.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">typeset -Z</B> has no effect if <BCLASS="emphasis.bold">typeset -L</B> has been used.</P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10799"></A>You can turn off <BCLASS="emphasis.bold">typeset</B> options explicitly by typing<BCLASS="emphasis.bold">typeset +</B><EMCLASS="emphasis">o</EM>, where <EMCLASS="emphasis">o</EM> is the option you turned on before.Of course, it is hard to imagine scenarios where you would want toturn multiple <BCLASS="emphasis.bold">typeset</B> formatting options on and off over and over again; you usually set a <BCLASS="emphasis.bold">typeset</B>option on a given variable only once.  </P><PCLASS="para">An obvious application for the <BCLASS="emphasis.bold">-L</B> and <BCLASS="emphasis.bold">-R</B> optionsis one in which you need fixed-width output. The most ubiquitous sourceof fixed-width output in the UNIX system is reflected in the followingprogramming task.</P><DIVCLASS="task"><H4>Task 6.2</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">Pretend that <EMCLASS="emphasis">ls</EM> doesn't do multicolumn output;write a shell script that does it.</P></BLOCKQUOTE><ACLASS="indexterm"NAME="AUTOID-10815"></A><ACLASS="indexterm"NAME="AUTOID-10819"></A><PCLASS="para">For the sake of simplicity, we'll assume further that ourversion of UNIX is derived from AT&amp;T System V, in which filenamesare (<EMCLASS="emphasis">still!</EM>) limited to 14 characters.</P><PCLASS="para">Our solution to this task relies on many of the concepts wehave seen earlier in this chapter.  <ACLASS="indexterm"NAME="KSH-CH-6-IX-ARRAYS-2"></A><ACLASS="indexterm"NAME="AUTOID-10827"></A><ACLASS="indexterm"NAME="AUTOID-10830"></A><ACLASS="indexterm"NAME="AUTOID-10833"></A>It also relies on the factthat <BCLASS="emphasis.bold">set -A</B> (for constructing arrays) can be combinedwith command substitution in an interesting way: each word(separated by blanks, TABs, or NEWLINESs) becomes an element of the array.For example, if the file <EMCLASS="emphasis">bob</EM> contains 50 words, then after the statement:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">set -A fred $(&lt; bob)</PRE></BLOCKQUOTE></P><PCLASS="para">the array <BCLASS="emphasis.bold">fred</B> has 50 elements.</P><PCLASS="para">Our strategy is to get the names of all files in thegiven directory into an array variable.  <ACLASS="indexterm"NAME="AUTOID-10843"></A><ACLASS="indexterm"NAME="AUTOID-10845"></A>We use a <BCLASS="emphasis.bold">while</B> loopthat mimics a <BCLASS="emphasis.bold">for</B> loop, as we saw earlier in this chapter,to get each filename into a variable whose length has been setto 14. We print that variable in five-column format, with two spacesbetween each column (for a total of 80 columns), using a counterto keep track of columns. Here is the code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">set -A filenames $(ls $1)typeset -L14 fnamelet count=0let numcols=5while (( $count &lt; ${#filenames[*]} )); do    fname=${filenames[count]}    print -n &quot;$fname  &quot;    let count=&quot;count + 1&quot;    if (( count % numcols == 0 )); then        print		# NEWLINE    fidoneif (( count % numcols != 0 )); then    printfi</PRE></BLOCKQUOTE></P><PCLASS="para">The first line sets up the array <BCLASS="emphasis.bold">filenames</B> to containall files in the directory given by the first argument (the currentdirectory by default).  <ACLASS="indexterm"NAME="AUTOID-10853"></A><ACLASS="indexterm"NAME="AUTOID-10854"></A>The <BCLASS="emphasis.bold">typeset</B> statement sets up the variable <BCLASS="emphasis.bold">fname</B> tohave a fixed width of 14 characters.The next line initializes a counter that counts elements in the array.<BCLASS="emphasis.bold">numcols</B> is the number of columns per line.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10862"></A>The <BCLASS="emphasis.bold">while</B> loop iterates once for every element in <BCLASS="emphasis.bold">filenames</B>.In the body of the loop, the first line assigns the next array elementto the fixed-width variable.  <ACLASS="indexterm"NAME="AUTOID-10866"></A>The <BCLASS="emphasis.bold">print</B> statement prints thelatter followed by two spaces; the <BCLASS="emphasis.bold">-n</B> option suppresses <BCLASS="emphasis.bold">print</B>'s final NEWLINE.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10874"></A><ACLASS="indexterm"NAME="AUTOID-10876"></A>The <BCLASS="emphasis.bold">let</B> statements increments the counter. Then there is the<BCLASS="emphasis.bold">if</B> statement, which determines when to start the next line.<ACLASS="indexterm"NAME="AUTOID-10880"></A>It checks the <EMCLASS="emphasis">remainder</EM> of <BCLASS="emphasis.bold">$count</B> divided by <BCLASS="emphasis.bold">$numcols</B>-remember that dollar signs aren't necessary within a <BCLASS="emphasis.bold">$((</B>...<BCLASS="emphasis.bold">))</B>construct-and if the result is 0, it's time to output a NEWLINEvia a <BCLASS="emphasis.bold">print</B> statement without arguments. Notice that even though<BCLASS="emphasis.bold">$count</B> increases by 1 with every iteration of the loop, theremainder goes through a cycle of 1, 2, 3, 4, 0, 1, 2, 3, 4, 0,...</P><PCLASS="para">After the loop, an <BCLASS="emphasis.bold">if</B> construct outputs a final NEWLINE ifnecessary, i.e., if the <BCLASS="emphasis.bold">if</B> within the loop didn't just do it.</P><PCLASS="para">We can also use <BCLASS="emphasis.bold">typeset</B> options to clean up the code forour <EMCLASS="emphasis">dosmv</EM> function (Task 5-3), which translates filenamesin a given directory from MS-DOS to UNIX format. The code forthe function is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">dos_regexp='[^a-z]\{1,8\}\.[^a-z]\{0,3\}'for filename in ${1:+$1/}* ; do    if print &quot;$filename&quot; | grep $dos_regexp &gt; /dev/null; then        newfilename=$(print $filename | tr [A-Z] [a-z])        newfilename=${newfilename%.}        print &quot;$filename -&gt; $newfilename&quot;        mv $filename $newfilename    fidone</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10898"></A><ACLASS="indexterm"NAME="AUTOID-10900"></A>We can replace the call to <EMCLASS="emphasis">tr</EM> in the <BCLASS="emphasis.bold">for</B> loop with one to <BCLASS="emphasis.bold">typeset -l</B> before the loop:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">typeset -l newfilenamedos_regexp='[^a-z]\{1,8\}\.[^a-z]\{0,3\}'for filename in ${1:+$1/}* ; do    if print &quot;$filename&quot; | grep $dos_regexp &gt; /dev/null; then        newfilename=${filename%.}        print &quot;$filename -&gt; $newfilename&quot;        mv $filename $newfilename    fidone</PRE></BLOCKQUOTE></P><PCLASS="para">This way, the translation to lowercase letters is done automaticallyeach time a value is assigned to <BCLASS="emphasis.bold">newfilename</B>. Not only is thiscode cleaner, but it is also more efficient because the extra processes created by <EMCLASS="emphasis">tr</EM> and command substitution are eliminated.<ACLASS="indexterm"NAME="AUTOID-10912"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-3.4">6.3.4 Type and Attribute Options</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-TYPESET-TANDATTR-OPTIONS"></A>The other options to <BCLASS="emphasis.bold">typeset</B> are of more use to advanced shell programmers who are &quot;tweaking&quot; large scripts. These options are listed in <ACLASS="xref"HREF="ch06_03.htm#KSH-CH-6-TAB-6"TITLE="Typeset Type and Attribute Options">Table 6.7</A>.<ACLASS="indexterm"NAME="AUTOID-10921"></A><ACLASS="indexterm"NAME="AUTOID-10925"></A><ACLASS="indexterm"NAME="AUTOID-10929"></A><ACLASS="indexterm"NAME="AUTOID-10933"></A><ACLASS="indexterm"NAME="AUTOID-10935"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-6-TAB-6">Table 6.7: Typeset Type and Attribute Options</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Option</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operation</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-i</B><EMCLASS="emphasis">n</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Represent the variable internally as an integer;improvesefficiency of arithmetic. If <EMCLASS="emphasis">n</EM> is given, it is thebase used for output.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-r</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Make the variable read-only: forbid assignment to it and disallowit from being <BCLASS="emphasis.bold">unset</B>.[6]</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-x</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Export; same as <BCLASS="emphasis.bold">export</B> command.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-f</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Refer to function names only; see &quot;Function Options&quot; below.</P></TD></TR></TBODY></TABLE><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] The built-in command <BCLASS="emphasis.bold">readonly</B> does the same thing.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-10975"></A><ACLASS="indexterm"NAME="AUTOID-10977"></A><ACLASS="indexterm"NAME="AUTOID-10981"></A><BCLASS="emphasis.bold">-i</B> is the most useful of these. You can put it in a scriptwhen you are done writing and debugging it to make arithmeticrun a bit faster, though the speedup will be apparent only if your script does a <EMCLASS="emphasis">lot</EM> of arithmetic. The more readable<BCLASS="emphasis.bold">integer</B> is a built-in alias for <BCLASS="emphasis.bold">typeset -i</B>, so that<BCLASS="emphasis.bold">integer x=5</B> is the same as <BCLASS="emphasis.bold">typeset -i x=5</B>.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-TYPESET-TANDATTR-OPTIONS-R"></A><ACLASS="indexterm"NAME="AUTOID-10995"></A>The <BCLASS="emphasis.bold">-r</B> option is useful for setting up &quot;constants&quot; in shellscripts; constants are like variables except that you can't changetheir values once they have been initialized. Constants allow youto give names to values even if you don't want them changed;it is considered good programming practice to use constants inlarge programs.  </P><PCLASS="para">The solution to Task 6-2 contains a good candidate for<BCLASS="emphasis.bold">typeset -r</B>: the variable <BCLASS="emphasis.bold">numcols</B>, which specifiesthe number of columns in the output. Since <BCLASS="emphasis.bold">numcols</B> is aninteger, we could also use the <BCLASS="emphasis.bold">-i</B> option, i.e., replace<BCLASS="emphasis.bold">let numcols=5</B> with <BCLASS="emphasis.bold">typeset -ri numcols=5</B>. If we wereto try assigning another value to <BCLASS="emphasis.bold">numcols</B>, the shell wouldrespond with the error message <BCLASS="emphasis.bold">ksh: numcols: is read only</B>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11008"></A><BCLASS="emphasis.bold">-r</B> is also useful for system administrators who set up shellvariables in <EMCLASS="emphasis">/etc/profile</EM>, the system-wide Korn shellinitialization file.  <ACLASS="indexterm"NAME="AUTOID-11012"></A><ACLASS="indexterm"NAME="AUTOID-11014"></A>For example, if you wanted to tighten systemsecurity, one step you might take is to prevent the <BCLASS="emphasis.bold">PATH</B>environment variable from being changed. This helps prevent computercrackers from installing bogus executables. The statement<BCLASS="emphasis.bold">typeset -r PATH</B> does the trick.  <ACLASS="indexterm"NAME="AUTOID-11019"></A></P><PCLASS="para">These options are also useful without arguments,i.e., to see which variables exist that have those options turned on.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-6-SECT-3.5">6.3.5 Function Options</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-6-IX-TYPESET-TANDATTR-OPTIONS-F"></A>The <BCLASS="emphasis.bold">-f</B> option has various suboptions, all of which relate tofunctions. These are listed in <ACLASS="xref"HREF="ch06_03.htm#KSH-CH-6-TAB-7"TITLE="Typeset Function Options">Table 6.8</A>.<ACLASS="indexterm"NAME="AUTOID-11030"></A><ACLASS="indexterm"NAME="AUTOID-11033"></A><ACLASS="indexterm"NAME="AUTOID-11036"></A><ACLASS="indexterm"NAME="AUTOID-11039"></A><ACLASS="indexterm"NAME="AUTOID-11042"></A><ACLASS="indexterm"NAME="AUTOID-11046"></A><ACLASS="indexterm"NAME="AUTOID-11050"></A><ACLASS="indexterm"NAME="AUTOID-11054"></A><ACLASS="indexterm"NAME="AUTOID-11058"></A><ACLASS="indexterm"NAME="AUTOID-11062"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-6-TAB-7">Table 6.8: Typeset Function Options</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Option</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Operation</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-f</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">With no arguments, prints all function definitions.</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-f</B> <EMCLASS="emphasis">fname</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Prints the definition of function <EMCLASS="emphasis">fname</EM>.</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">+f</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Prints all function names.</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-ft</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Turns on trace mode for named function(s). (<ACLASS="xref"HREF="ch09_01.htm"TITLE="Debugging Shell Programs">Chapter 9</A>)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">+ft</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Turns off trace mode for named function(s). (<ACLASS="xref"HREF="ch09_01.htm"TITLE="Debugging Shell Programs">Chapter 9</A>)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-fu</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Defines given name(s) as autoloaded function(s). (<ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A>)</TD></TR></TBODY></TABLE><PCLASS="para">Two of these have built-in aliases that are more mnemonic:<BCLASS="emphasis.bold">functions</B> is an alias for <BCLASS="emphasis.bold">typeset -f</B> and<BCLASS="emphasis.bold">autoload</B> is an alias for <BCLASS="emphasis.bold">typeset -fu</B>.<ACLASS="indexterm"NAME="AUTOID-11108"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11110"></A><ACLASS="indexterm"NAME="AUTOID-11113"></A>Finally, if you type <BCLASS="emphasis.bold">typeset</B> without <EMCLASS="emphasis">any</EM> arguments, you will seea list of <EMCLASS="emphasis">all</EM> currently-defined variables (in no discernableorder), preceded byappropriate keywords if they have one or more <BCLASS="emphasis.bold">typeset</B> optionsturned on. For example, typing <BCLASS="emphasis.bold">typeset</B> in an uncustomizedshell gives you a listing of the shell's built-in variablesand their attributes that looks like this:[7]<ACLASS="indexterm"NAME="AUTOID-11124"></A><ACLASS="indexterm"NAME="AUTOID-11125"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] For some reason, this list excludes <BCLASS="emphasis.bold">PS1</B> and a few others.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">export HZexport PATHinteger ERRNOinteger OPTINDfunction LINENOexport LOGNAMEexport MAILfunction SECONDSinteger PPIDPS3PS2export TERMCAPOPTARGfunction RANDOMexport SHELLinteger TMOUTexport HOMEexport _FCEDITexport TERMexport PWDexport TZinteger MAILCHECK</PRE></BLOCKQUOTE></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Integer Variables and Arithmetic"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.2 Integer Variables and Arithmetic"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch07_01.htm"TITLE="7. Input/Output and Command-line Processing"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7. Input/Output and Command-line Processing"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">6.2 Integer Variables and Arithmetic</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">7. Input/Output and Command-line Processing</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>