<HTML><HEAD><TITLE>[Chapter 7] 7.2 String I/O</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:12:19Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch07_01.htm"TITLE="7. Input/Output and Command-line Processing"><LINKREL="prev"HREF="ch07_01.htm"TITLE="7.1 I/O Redirectors"><LINKREL="next"HREF="ch07_03.htm"TITLE="7.3 Command-line Processing"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_01.htm"TITLE="7.1 I/O Redirectors"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 7.1 I/O Redirectors"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 7<BR>Input/Output and Command-line Processing</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_03.htm"TITLE="7.3 Command-line Processing"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7.3 Command-line Processing"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-7-SECT-2">7.2 String I/O</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11616"></A><ACLASS="indexterm"NAME="AUTOID-11619"></A>Now we'll zoom back in to the string I/O level and examinethe <BCLASS="emphasis.bold">print</B> and <BCLASS="emphasis.bold">read</B> statements, which give the shellI/O capabilities that are more analogous to those of conventionalprogramming languages.  </P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-7-SECT-2.1">7.2.1 print</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-PRINT"></A>As we've seen countless times in this book, <BCLASS="emphasis.bold">print</B> simplyprints its arguments to standard output.  <ACLASS="indexterm"NAME="AUTOID-11631"></A>You should use itinstead of the <BCLASS="emphasis.bold">echo</B> command, whose functionality differs fromsystem to system.[3]Now we'll explore the command in greater detail.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[3] <ACLASS="indexterm"NAME="AUTOID-11636"></A>Specifically, there is a difference between System V and BSDversions.  <ACLASS="indexterm"NAME="AUTOID-11639"></A>The latter accepts options similar to those of<BCLASS="emphasis.bold">print</B>, while the former accepts C language-style escapesequences.</P></BLOCKQUOTE><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-7-SECT-2.1.1">7.2.1.1 print escape sequences</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-PRINT-ESCAPE-SEQUENCES"></A><BCLASS="emphasis.bold">print</B> accepts a number of options, as well as several<EMCLASS="emphasis">escape sequences</EM> that start with a backslash.[4]<ACLASS="indexterm"NAME="AUTOID-11653"></A>These are similar to the escape sequencesrecognized by <BCLASS="emphasis.bold">echo</B> and the C language; they are listedin <ACLASS="xref"HREF="ch07_02.htm#KSH-CH-7-TAB-1"TITLE="print Escape Sequences">Table 7.2</A>.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] You must use a double backslash if you don't surroundthe string that contains them with quotes; otherwise, theshell itself &quot;steals&quot; a backslash beforepassing the arguments to <BCLASS="emphasis.bold">print</B>.</P></BLOCKQUOTE><PCLASS="para">These sequences exhibit fairly predictable behavior, except for <BCLASS="emphasis.bold">\f</B>on some displays, it causes a screen clear, while on othersit causes a line feed. It ejects the page on most printers.<BCLASS="emphasis.bold">\v</B> is somewhat obsolete; it usually causes a line feed.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-7-TAB-1">Table 7.2: print Escape Sequences</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Sequence</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Character printed</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\a</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><SPANCLASS="acronym">ALERT</SPAN> or <KBDCLASS="keycap">[CTRL-G]</KBD></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\b</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><SPANCLASS="acronym">BACKSPACE</SPAN> or <KBDCLASS="keycap">[CTRL-H]</KBD></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\c</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Omit final <SPANCLASS="acronym">NEWLINE</SPAN></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\f</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><SPANCLASS="acronym">FORMFEED</SPAN> or <KBDCLASS="keycap">[CTRL-L]</KBD></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\n</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><SPANCLASS="acronym">NEWLINE</SPAN> (not at end of command) or <KBDCLASS="keycap">[CTRL-J]</KBD></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\r</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><SPANCLASS="acronym">RETURN</SPAN> (<SPANCLASS="acronym">ENTER</SPAN>) or <KBDCLASS="keycap">[CTRL-M]</KBD></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\t</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><SPANCLASS="acronym">TAB</SPAN> or <KBDCLASS="keycap">[CTRL-I]</KBD></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\v</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><SPANCLASS="acronym">VERTICAL TAB</SPAN> or <KBDCLASS="keycap">[CTRL-K]</KBD></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\0</B><EMCLASS="emphasis">n</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para"><SPANCLASS="acronym">ASCII</SPAN> character with octal (base-8) value <EMCLASS="emphasis">n</EM>, where <EMCLASS="emphasis">n</EM> is 1 to 3 digits</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">\\</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Single backslash</TD></TR></TBODY></TABLE><PCLASS="para">The \0<EMCLASS="emphasis">n</EM> sequence is even more device-dependent and canbe used for complex I/O, such as cursor control and specialgraphics characters.<ACLASS="indexterm"NAME="AUTOID-11731"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-7-SECT-2.1.2">7.2.1.2 Options to print</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-PRINT-OPTIONS"></A><BCLASS="emphasis.bold">print</B> also accepts a few dash options; we've already seen<BCLASS="emphasis.bold">-n</B> for omitting the final NEWLINE. The optionsare listed in <ACLASS="xref"HREF="ch07_02.htm#KSH-CH-7-TAB-2"TITLE="print Options">Table 7.3</A>.<ACLASS="indexterm"NAME="AUTOID-11741"></A><ACLASS="indexterm"NAME="AUTOID-11745"></A><ACLASS="indexterm"NAME="AUTOID-11749"></A><ACLASS="indexterm"NAME="KSH-CH-7-IX-PRINT-OPTIONS--S"></A><ACLASS="indexterm"NAME="AUTOID-11757"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-7-TAB-2">Table 7.3: print Options</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Option</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Function</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-n</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Omit the final newline (same as the \c escape sequence)</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-r</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Raw; ignore the escape sequences listed above</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-p</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Print on pipe to coroutine; see next chapter</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-s</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Print to command history file. See <ACLASS="xref"HREF="ch02_01.htm"TITLE="Command-line Editing">Chapter 2, Command-line Editing</A>.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-u</B><EMCLASS="emphasis">n</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Print to file descriptor <EMCLASS="emphasis">n</EM></P></TD></TR></TBODY></TABLE><PCLASS="para">Notice that some of these are redundant:<BCLASS="emphasis.bold">print -n</B> is the same as <BCLASS="emphasis.bold">print</B> with<BCLASS="emphasis.bold">c</B> at the end of a line; <BCLASS="emphasis.bold">print -u</B><EMCLASS="emphasis">n</EM><BCLASS="emphasis.bold"> ...</B> isequivalent to <BCLASS="emphasis.bold">print ... &gt;&amp;</B><EMCLASS="emphasis">n</EM> (though the former ismore efficient).</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-HISTORY-FILE-PRINTING-TO"></A>However, <BCLASS="emphasis.bold">print -s</B> is <EMCLASS="emphasis">not</EM> the same as <BCLASS="emphasis.bold">print ... &gt;&gt; $HISTFILE</B>.The latter command renders the <BCLASS="emphasis.bold">vi</B> and <BCLASS="emphasis.bold">emacs</B> editing modes temporarily inoperable; you must use <BCLASS="emphasis.bold">print -s</B> if youwant to print to your history file.  </P><PCLASS="para">Printing to your history file is useful if you want to edit somethingthat the shell expands when it processes a command line; for example,a complex environment variable such as <BCLASS="emphasis.bold">PATH</B>.  <ACLASS="indexterm"NAME="AUTOID-11818"></A><ACLASS="indexterm"NAME="AUTOID-11820"></A><ACLASS="indexterm"NAME="AUTOID-11822"></A><ACLASS="indexterm"NAME="AUTOID-11824"></A>If you enter the command <BCLASS="emphasis.bold">print -s PATH=$PATH</B> and then press <BCLASS="emphasis.bold"><KBDCLASS="keycap">[CTRL-P]</KBD></B> in emacs-mode (or <BCLASS="emphasis.bold">ESC k</B> in vi-mode), you will see somethinglike this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ PATH=/bin:/usr/bin:/etc:/usr/ucb:/usr/local/bin:/home/billr/bin</PRE></BLOCKQUOTE></P><PCLASS="para">That is, the shell expands the variable (and would expand anythingelse, like command substitutions, wildcards, etc.) before it writesthe line to the history file.Your cursor will be at the end of the line (or at the beginning of the line in vi-mode), and you can edit your <BCLASS="emphasis.bold">PATH</B> without havingto type in the whole thing again.<ACLASS="indexterm"NAME="AUTOID-11835"></A><ACLASS="indexterm"NAME="AUTOID-11836"></A><ACLASS="indexterm"NAME="AUTOID-11837"></A><ACLASS="indexterm"NAME="AUTOID-11838"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-7-SECT-2.2">7.2.2 read</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-READ"></A>The other half of the shell's string I/O facilities isthe <BCLASS="emphasis.bold">read</B> command, which allows you to read values <EMCLASS="emphasis">into</EM> shell variables.The basic syntax is:<ACLASS="indexterm"NAME="AUTOID-11846"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">read <EMCLASS="emphasis">var1 var2...</EM></PRE></BLOCKQUOTE></P><PCLASS="para">There are a few options, which we will cover in the section &quot;Options to read,&quot; below.<ACLASS="indexterm"NAME="AUTOID-11853"></A><ACLASS="indexterm"NAME="AUTOID-11856"></A>This statement takes a line from the standard input andbreaks it down into words delimited by any of the characters in thevalue of the environment variable <BCLASS="emphasis.bold">IFS</B> (see <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4, Basic Shell Programming</A>;these are usually a space, a TAB, and NEWLINE).  The words are assigned to variables<EMCLASS="emphasis">var1</EM>, <EMCLASS="emphasis">var2</EM>, etc. For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>read fred bob</B></CODE>dave pete$ <CODECLASS="userinput"><B>print &quot;$fred&quot;</B></CODE>dave$ <CODECLASS="userinput"><B>print &quot;$bob&quot;</B></CODE>pete</PRE></BLOCKQUOTE></P><PCLASS="para">If there are more words than variables,then excess words are assigned to the last variable.  <ACLASS="indexterm"NAME="AUTOID-11868"></A><ACLASS="indexterm"NAME="AUTOID-11872"></A>If youomit the variables altogether, the entire line of input is assignedto the variable <BCLASS="emphasis.bold">REPLY</B>.</P><PCLASS="para">You may have identified this as the &quot;missing ingredient&quot; inthe shell programming capabilities we have seen thus far.It resembles input statements in conventional languages, like itsnamesake in Pascal. So why did we wait this long to introduce it?</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11878"></A><ACLASS="indexterm"NAME="AUTOID-11880"></A><ACLASS="indexterm"NAME="AUTOID-11882"></A>Actually, <BCLASS="emphasis.bold">read</B> is sort of an &quot;escape hatch&quot; from traditional shellprogramming philosophy, which dictates that the most important unitof data to process is a <EMCLASS="emphasis">text file</EM>, and that UNIXutilities such as <EMCLASS="emphasis">cut</EM>, <EMCLASS="emphasis">grep</EM>, <EMCLASS="emphasis">sort</EM>,etc., should be used as building blocks for writing programs.</P><PCLASS="para"><BCLASS="emphasis.bold">read</B>, on the other hand, implies line-by-line processing.You could use it to write a shell script that does what a pipelineof utilities would normally do, but such a scriptwould inevitably look like:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">while (read a line) do    process the line    print the processed lineend</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11894"></A>This type of script is usually much slower than a pipeline; furthermore, it has the sameform as a program someone might write in C (or some similar language)that does the same thing much <EMCLASS="emphasis">much</EM> faster. In other words,if you are going to write it in this line-by-line way, there is no point inwriting a shell script.(The author has gone for years without writing a script with<BCLASS="emphasis.bold">read</B> in it.)</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-7-SECT-2.2.1">7.2.2.1 Reading lines from files</A></H4><PCLASS="para">Nevertheless, shell scripts with<BCLASS="emphasis.bold">read</B> are useful for certain kinds of tasks. One is whenyou are reading data from a filesmall enough so that efficiency isn't a concern(say a few hundred lines or less),and it's <EMCLASS="emphasis">really necessary</EM> to get bits of input into shell variables.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-TERM"></A><ACLASS="indexterm"NAME="KSH-CH-7-IX-ENVIRONMENT-VARIABLES-TERM"></A>One task that we have already seen fits this description: Task 5-4, the script that a system administrator could use to seta user's <BCLASS="emphasis.bold">TERM</B> environment variable according to which terminal linehe or she is using.  <ACLASS="indexterm"NAME="AUTOID-11910"></A>The code in <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5, Flow Control</A> used a <BCLASS="emphasis.bold">case</B> statementto select the correct value for <BCLASS="emphasis.bold">TERM</B>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11916"></A><ACLASS="indexterm"NAME="AUTOID-11918"></A>This code would presumably reside in <EMCLASS="emphasis">/etc/profile</EM>, thesystem-wide initialization file that the Korn shell runs before runninga user's <EMCLASS="emphasis">.profile</EM>. If the terminals on the system changeover time&nbsp;- as surely they must&nbsp;- then the code would have tobe changed. It would be better to store the information in a fileand change just the file instead.</P><PCLASS="para">Assume we put the information in a file whose format is typicalof such UNIX &quot;system configuration&quot; files: each line containsa device name, a TAB, and a <BCLASS="emphasis.bold">TERM</B> value.If the file, which we'll call<EMCLASS="emphasis">/etc/terms</EM>, contained the same data as the <BCLASS="emphasis.bold">case</B> statementin <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5</A>, <EMCLASS="emphasis">Flow Control</EM>, it would look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">console	s531tty01	gl35atty03	gl35atty04	gl35atty07	t2000tty08	s531</PRE></BLOCKQUOTE></P><PCLASS="para">We can use <BCLASS="emphasis.bold">read</B> to get the data from this file, but first weneed to know how to test for the end-of-file condition.<ACLASS="indexterm"NAME="AUTOID-11932"></A>Simple: <BCLASS="emphasis.bold">read</B>'s exit status is 1 (i.e., non-0) when there isnothing to read.  <ACLASS="indexterm"NAME="AUTOID-11936"></A>This leads to a clean <BCLASS="emphasis.bold">while</B> loop:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">TERM=vt99       # assume this as a defaultline=$(tty)while read dev termtype; do    if [[ $dev = $line ]]; then        TERM=$termtype        print &quot;TERM set to $TERM.&quot;        break    fidone</PRE></BLOCKQUOTE></P><PCLASS="para">The <BCLASS="emphasis.bold">while</B> loop reads each line of the input into the variables<BCLASS="emphasis.bold">dev</B> and <BCLASS="emphasis.bold">termtype</B>.  <ACLASS="indexterm"NAME="AUTOID-11945"></A>In each pass through the loop,the <BCLASS="emphasis.bold">if</B> looks for a match between <BCLASS="emphasis.bold">$dev</B> and the user'stty (<BCLASS="emphasis.bold">$line</B>, obtained by command substitution from the <EMCLASS="emphasis">tty</EM>command). If a match is found, <BCLASS="emphasis.bold">TERM</B> is set, a message is printed,and the loopexits; otherwise <BCLASS="emphasis.bold">TERM</B> remains at the default setting of <BCLASS="emphasis.bold">vt99</B>.<ACLASS="indexterm"NAME="AUTOID-11954"></A><ACLASS="indexterm"NAME="AUTOID-11955"></A></P><PCLASS="para">We're not quite done, though: this code reads from the standardinput, not from <EMCLASS="emphasis">/etc/terms</EM>! We need to know how to redirectinput to <EMCLASS="emphasis">multiple commands</EM>. It turns out that there area few ways of doing this.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-7-SECT-2.2.2">7.2.2.2 I/O Redirection and multiple commands</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-READ-FROM-FILES"></A>One way to solve the problem is witha <EMCLASS="emphasis">subshell</EM>, as we'll see in the next chapter.This involves creating a separate process to do the reading.However, it is usually more efficient to do it in the same process;the Korn shell gives us three ways of doing this.</P><PCLASS="para">The first, which we have seen already, is with a function:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function findterm {    TERM=vt99       # assume this as a default    line=$(tty)    while read dev termtype; do        if [[ $dev = $line ]]; then            TERM=$termtype            print &quot;TERM set to $TERM.&quot;            break;        fi    done}findterm &lt; /etc/terms</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11970"></A>A function acts like a script in that it has its own set ofstandard I/O descriptors, which can be redirected in the line of code thatcalls the function.In other words, you can think of this code as if <EMCLASS="emphasis">findterm</EM>were a script and you typed <BCLASS="emphasis.bold">findterm &lt; /etc/terms</B> on thecommand line. The <BCLASS="emphasis.bold">read</B> statement takes input from <EMCLASS="emphasis">/etc/terms</EM>a line at a time, and the function runs correctly.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11979"></A><ACLASS="indexterm"NAME="AUTOID-11983"></A>The second way is by putting the I/O redirector at the endof the loop, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">TERM=vt99       # assume this as a defaultline=$(tty)while read dev termtype; do    if [[ $dev = $line ]]; then        TERM=$termtype        print &quot;TERM set to $TERM.&quot;        break;    fidone &lt; /etc/terms</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11989"></A><ACLASS="indexterm"NAME="AUTOID-11992"></A><ACLASS="indexterm"NAME="AUTOID-11995"></A><ACLASS="indexterm"NAME="AUTOID-11998"></A>You can use this technique with any flow-control construct,including <BCLASS="emphasis.bold">if</B>...<BCLASS="emphasis.bold">fi</B>, <BCLASS="emphasis.bold">case</B>...<BCLASS="emphasis.bold">esac</B>,<BCLASS="emphasis.bold">select</B>...<BCLASS="emphasis.bold">done</B>, and <BCLASS="emphasis.bold">until</B>...<BCLASS="emphasis.bold">done</B>.<ACLASS="indexterm"NAME="AUTOID-12009"></A><ACLASS="indexterm"NAME="AUTOID-12011"></A>This makes sense because these are all <EMCLASS="emphasis">compoundstatements</EM> that the shell treats as single commandsfor these purposes.This technique works fine&nbsp;- the <BCLASS="emphasis.bold">read</B> command reads a line at a time&nbsp;- as longas all of the input is done within the compound statement.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-7-SECT-2.2.3">7.2.2.3 Code blocks</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-CODE-BLOCKS"></A>But if you want to redirect I/O to or from an arbitrary groupof commands without creating a separate process, you need touse a construct that we haven't seen yet.If you surround some code with <BCLASS="emphasis.bold">{</B> and <BCLASS="emphasis.bold">}</B>, the codewill behave like a function that has no name.This is another type of compound statement.<ACLASS="indexterm"NAME="AUTOID-12023"></A>In accordance with the equivalent concept in the Clanguage, we'll call this a <EMCLASS="emphasis">block</EM> of code.[5]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] LISP programmers may prefer to think of this as an <EMCLASS="emphasis">anonymousfunction</EM> or <EMCLASS="emphasis">lambda-function</EM>.</P></BLOCKQUOTE><PCLASS="para">What good is a block?<ACLASS="indexterm"NAME="AUTOID-12031"></A><ACLASS="indexterm"NAME="AUTOID-12034"></A>In this case, it means that the code within the curly brackets (<BCLASS="emphasis.bold">{}</B>) willtake standard I/O descriptors just as we described in the lastblock of code.This construct is appropriate for the current examplebecause the code needsto be called only once, and the entire script is not really largeenough to merit breaking down into functions. Here is howwe use a block in the example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">{    TERM=vt99       # assume this as a default    line=$(tty)    while read dev termtype; do        if [[ $dev = $line ]]; then            TERM=$termtype            print &quot;TERM set to $TERM.&quot;            break;        fi    done} &lt; /etc/terms</PRE></BLOCKQUOTE></P><PCLASS="para">To help you understand how this works, think ofthe curly brackets and the code inside them as if they were one command, i.e.:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">{ TERM=vt99; line=$(tty); while ... } &lt; /etc/terms</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12045"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12047"></A><ACLASS="indexterm"NAME="AUTOID-12049"></A>Configuration files for system administration taskslike this one are actually fairly common; a prominent example is<EMCLASS="emphasis">/etc/hosts</EM>, which lists machines that are accessiblein a TCP/IP network. We can make <EMCLASS="emphasis">/etc/terms</EM> more like thesestandard files by allowing comment lines inthe file that start with <BCLASS="emphasis.bold">#</B>, just as in shell scripts. This way<EMCLASS="emphasis">/etc/terms</EM> can look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">## System Console is a Shande 531sconsole	s531## Prof. Subramaniam's line has a Givalt GL35atty01	gl35a...</PRE></BLOCKQUOTE></P><PCLASS="para">We can handle comment lines in two ways. First, we could modify the <BCLASS="emphasis.bold">while</B>loop so that it ignores lines beginning with <BCLASS="emphasis.bold">#</B>.  <ACLASS="indexterm"NAME="AUTOID-12060"></A>We wouldtake advantage of the fact that the equal sign (<BCLASS="emphasis.bold">=</B>) under <BCLASS="emphasis.bold">[[</B>/<BCLASS="emphasis.bold">]]</B>does pattern matching, not just equality testing:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ $dev != \#* &amp;&amp; $dev = $line ]]; then    ...</PRE></BLOCKQUOTE></P><PCLASS="para">The pattern is <BCLASS="emphasis.bold">#</B><CODECLASS="literal">*</CODE>, which matches any string beginning with <BCLASS="emphasis.bold">#</B>.We must precede <BCLASS="emphasis.bold">#</B> with a backslash so that the shell doesn'ttreat the rest of the line as a comment.  <ACLASS="indexterm"NAME="AUTOID-12074"></A>Also, rememberfrom <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5</A> that the <BCLASS="emphasis.bold">&amp;&amp;</B> combines the twoconditions so that <EMCLASS="emphasis">both</EM> must be true for the entire conditionto be true.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12081"></A>This would certainly work, but the more usual way to filter outcomment lines is to use a pipeline with <EMCLASS="emphasis">grep</EM>. We give<EMCLASS="emphasis">grep</EM> the regular expression <BCLASS="emphasis.bold">^[^#]</B>, which matches anything exceptlines beginning with <BCLASS="emphasis.bold">#</B>.  Then we change the call to the blockso that it reads from the output of the pipeline instead of directlyfrom the file.[6]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] Unfortunately, using <BCLASS="emphasis.bold">read</B> with input from a pipe isoften very inefficient, because of issues in the design of theshell that aren't relevant here.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">grep &quot;^[^#]&quot; /etc/terms | {    TERM=vt99    ...}</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12093"></A>We can also use <BCLASS="emphasis.bold">read</B> to improve our solution to Task 6-2,in which we emulate the multicolumn output of <EMCLASS="emphasis">ls</EM>.<ACLASS="indexterm"NAME="AUTOID-12097"></A><ACLASS="indexterm"NAME="AUTOID-12101"></A>In the solution in the previous chapter, we assumed that (as in System V-derivedversions of UNIX) filenames are limited to 14 characters,and we used 14 as a fixed column width.<ACLASS="indexterm"NAME="AUTOID-12104"></A><ACLASS="indexterm"NAME="AUTOID-12108"></A>We'll improve the solution so that it allows <EMCLASS="emphasis">any</EM> filenamelength (as in BSD-derived UNIX versions) and uses the length of thelongest filename (plus 2) as the column width.</P><PCLASS="para">We will need to pass the output of <EMCLASS="emphasis">ls</EM> twicethrough the list of files wewant to display in multicolumn format. In the first pass, we will findthe longest filename and use that to set the number of columns aswell as their width; the second pass will do the actual output.Here is a block of code for the first pass:<ACLASS="indexterm"NAME="AUTOID-12114"></A><ACLASS="indexterm"NAME="AUTOID-12117"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">ls &quot;$@&quot; | {    let width=0    while read fname; do        if (( ${#fname} &gt; $width )); then            let width=${#fname}        fi    done    let width=&quot;$width + 2&quot;    let numcols=&quot;${COLUMNS:-80} / $width&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">This code looks a bit like an exercise from a first-semesterprogramming class.  <ACLASS="indexterm"NAME="AUTOID-12123"></A>The <BCLASS="emphasis.bold">while</B> loop goes through the input looking for fileswith names that are longer than the longest found so far;if a longer one is found, its length is saved as the new longest length.</P><PCLASS="para">After the loop finishes, we add 2 to the width to allow for spacebetween columns. Then we divide the width of the terminalby the column width to get the number of columns; the shell's integerdivision operator truncates remainders, which is just what we want.<ACLASS="indexterm"NAME="AUTOID-12127"></A><ACLASS="indexterm"NAME="AUTOID-12130"></A>Recall from <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A> that the built-in variable <BCLASS="emphasis.bold">COLUMNS</B>often contains the display width; the construct <BCLASS="emphasis.bold">${COLUMNS</B><CODECLASS="literal">:</CODE><BCLASS="emphasis.bold">-80}</B>gives a default of 80 if this variable is not set.</P><PCLASS="para">The results of the block are the variables <BCLASS="emphasis.bold">width</B> and <BCLASS="emphasis.bold">numcols</B>.These are global variables, so they are accessible by the rest ofthe code inside our (eventual) script. In particular, we need themin our second pass through the filenames. The code for this resemblesthe code to our original solution; all we need to do isreplace the fixed column width and number of columns with the variables:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">set -A filenames $(ls $@)typeset -L$width fnamelet count=0while (( $count &lt; ${#filenames[*]} )); do    fname=${filenames[$count]}    print &quot;$fname  \\&quot;    let count=&quot;count + 1&quot;    if [[ $((count % numcols)) = 0 ]]; then         print		# output a NEWLINE    fidoneif [[ $((count % numcols)) != 0 ]]; then    printfi</PRE></BLOCKQUOTE></P><PCLASS="para">The entire script consists of both pieces of code.<ACLASS="indexterm"NAME="AUTOID-12143"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-7-SECT-2.2.4">7.2.2.4 Reading User Input</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-READ-FROM-USER-INPUT"></A>The other type of task to which <BCLASS="emphasis.bold">read</B> is suited isprompting a user for input. Think about it: we have hardlyseen any such scripts so far in this book.  <ACLASS="indexterm"NAME="AUTOID-12151"></A>In fact, the onlyones were the modified solutions to Task 5-4, which involved<BCLASS="emphasis.bold">select</B>.</P><PCLASS="para">As you've probably figured out, <BCLASS="emphasis.bold">read</B> can be used to getuser input into shell variables.  <ACLASS="indexterm"NAME="AUTOID-12156"></A>We can use <BCLASS="emphasis.bold">print</B> to prompt the user, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">print -n 'terminal? 'read TERMprint &quot;TERM is $TERM&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">Here is what this looks like when it runs:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">terminal? <BCLASS="emphasis.bold">vt99</B> TERM is vt99</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12166"></A><ACLASS="indexterm"NAME="AUTOID-12170"></A>However, shell convention dictates that prompts should goto standard <EMCLASS="emphasis">error</EM>, not standard output.(Recall that <BCLASS="emphasis.bold">select</B> prompts to standard error.)We could just use file descriptor 2 with the outputredirector we saw earlier in this chapter:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">print -n 'terminal? ' &gt;&amp;2read TERMprint TERM is $TERM</PRE></BLOCKQUOTE></P><PCLASS="para">However, this has various disadvantages.The shell provides a better way of doing the same thing:<ACLASS="indexterm"NAME="AUTOID-12178"></A><ACLASS="indexterm"NAME="AUTOID-12182"></A>if you follow the first variable namein a <BCLASS="emphasis.bold">read</B> statement with a question mark (<CODECLASS="literal">?</CODE>) and a string,the shell will use that string as a prompt. In other words:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">read TERM?'terminal? 'print &quot;TERM is $TERM&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">does the same as the above. This looks a bit nicer;also, the shell knows not to generate the prompt if the inputis redirected to come from a file, and this scheme allowsyou to use vi- or emacs-mode on your input line.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12191"></A>We'll flesh out this simple example by showing how Task 5-4would be done if <BCLASS="emphasis.bold">select</B> didn't exist. Compare this withthe code in <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5</A>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">print 'Select your terminal type:'done=falsewhile [[ $done = false ]]; do    done=true		# assume user will make a valid choice    {        print '1) gl35a'        print '2) t2000'        print '3) s531'        print '4) vt99'    } &gt;&amp;2    read REPLY?'terminal? '    case $REPLY in        1 ) TERM=gl35a ;;        2 ) TERM=t2000 ;;        3 ) TERM=s531 ;;        4 ) TERM=vt99 ;;        * ) print 'invalid.'	          done=false ;;    esacdoneprint 'TERM is $TERM'</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12198"></A>The <BCLASS="emphasis.bold">while</B> loop is necessary so that the code repeats ifthe user makes an invalid choice.<ACLASS="indexterm"NAME="AUTOID-12201"></A></P><PCLASS="para">This is roughly twice as many lines of code as the first solution in<ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5</A>&nbsp;- but exactly as many as the later, more user-friendly version!This shows that <BCLASS="emphasis.bold">select</B> saves youcode only if you don't mind using the same strings to <EMCLASS="emphasis">display</EM>your menu choices as you use inside your script.</P><PCLASS="para">However, <BCLASS="emphasis.bold">select</B> has other advantages, including the abilityto construct multicolumn menus if there are many choices,and better handling of null user input.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-7-SECT-2.2.5">7.2.2.5 Options to read</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12211"></A><BCLASS="emphasis.bold">read</B> takes a set of options that are similar to thosefor <BCLASS="emphasis.bold">print</B>. <ACLASS="xref"HREF="ch07_02.htm#KSH-CH-7-TAB-3"TITLE="read Options">Table 7.4</A>lists them.<ACLASS="indexterm"NAME="KSH-CH-7-IX-READ-OPTIONS-R"></A><ACLASS="indexterm"NAME="AUTOID-12221"></A><ACLASS="indexterm"NAME="AUTOID-12225"></A><ACLASS="indexterm"NAME="AUTOID-12229"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-7-TAB-3">Table 7.4: read Options</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Option</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Function</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-r</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Raw; do not use <BCLASS="emphasis.bold">\\</B> as line continuation character.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-p</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Read from pipe to coroutine; see next chapter.</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-s</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Save input in command history file.  See <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A>.</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-u</B><EMCLASS="emphasis">n</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Read from file descriptor <EMCLASS="emphasis">n</EM>.</TD></TR></TBODY></TABLE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12264"></A><BCLASS="emphasis.bold">read</B> lets you input lines that are longer than the width ofyour display device by providing backslash (\) as a continuationcharacter, just as in shell scripts. The <BCLASS="emphasis.bold">-r</B> option to <BCLASS="emphasis.bold">read</B>overrides this, in case your script reads from a file that maycontain lines that happen to end in backslashes.  </P><PCLASS="para"><BCLASS="emphasis.bold">read -r</B> also preserves any other escape sequences the input might contain. For example, if the file <EMCLASS="emphasis">fred</EM>contains this line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">A line with a\n escape sequence</PRE></BLOCKQUOTE></P><PCLASS="para">Then <BCLASS="emphasis.bold">read -r fredline</B> will include the backslash in thevariable <BCLASS="emphasis.bold">fredline</B>, whereas without the <BCLASS="emphasis.bold">-r</B>, <BCLASS="emphasis.bold">read</B>will &quot;eat&quot; the backslash. As a result:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">read -r fredline &lt; fred</B> $ <BCLASS="emphasis.bold">print &quot;$fredline&quot;</B> A line with a escape sequence$</PRE></BLOCKQUOTE></P><PCLASS="para">However:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">read fredline &lt; fred</B> $ <BCLASS="emphasis.bold">print &quot;$fredline&quot;</B> A line with an escape sequence$</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12291"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12293"></A>The <BCLASS="emphasis.bold">-s</B> option helps you if you are writing a highly interactivescript and you want to provide the same command-historycapability as the shell itself has.  <ACLASS="indexterm"NAME="AUTOID-12298"></A>For example, say you are writing a new version of <EMCLASS="emphasis">mail</EM> as a shell script. Yourbasic command loop might look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">while read -s cmd; do    # process the commanddone</PRE></BLOCKQUOTE></P><PCLASS="para">Using <BCLASS="emphasis.bold">read -s</B> allows the user to retrieveprevious commands to <EMCLASS="emphasis">your program</EM> with the emacs-mode <KBDCLASS="keycap">[CTRL-P]</KBD> command or the vi-mode <SPANCLASS="acronym">ESC</SPAN> k command. The <EMCLASS="emphasis">kshdb</EM> debugger in <ACLASS="xref"HREF="ch09_01.htm"TITLE="Debugging Shell Programs">Chapter 9, Debugging Shell Programs</A>uses this feature.<ACLASS="indexterm"NAME="AUTOID-12310"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-I-O-REDIRECTION-FILE-DESCRIPTORS"></A><ACLASS="indexterm"NAME="KSH-CH-7-IX-READ-OPTIONS-U"></A>Finally, the <BCLASS="emphasis.bold">-u</B><EMCLASS="emphasis">N</EM> option is useful in scripts thatread from more than one file at the same time.Here's an example of this that also uses the <EMCLASS="emphasis">n</EM><BCLASS="emphasis.bold">&lt;</B> I/O redirector that we saw earlier in this chapter.</P><DIVCLASS="task"><H4>Task 7.4</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">Write a script that prints the contents of two filesside by side.</P></BLOCKQUOTE><PCLASS="para">We'll format the output so the two output columns are fixed at 30 characters wide.Here is the code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">typeset -L30 f1 f2while read -u3 f1 &amp;&amp; read -u4 f2; do    print &quot;$f1$f2&quot;done 3&lt;$1 4&lt;$2</PRE></BLOCKQUOTE></P><PCLASS="para"><BCLASS="emphasis.bold">read -u3</B> reads from file descriptor 3, and <BCLASS="emphasis.bold">3&lt;$1</B>directs the file given as first argument to be input onthat file descriptor; the same is true for the second argumentand file descriptor 4.<ACLASS="indexterm"NAME="AUTOID-12336"></A><ACLASS="indexterm"NAME="AUTOID-12337"></A>Remember that file descriptors 0, 1, and 2 are already usedfor standard I/O. We use file descriptors 3 and 4 forour two input files; it's best to start from 3 and workupwards to the shell's limit, which is 9.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12339"></A><ACLASS="indexterm"NAME="AUTOID-12343"></A>The <BCLASS="emphasis.bold">typeset</B> command and the quotes around the argumentto <BCLASS="emphasis.bold">print</B> ensure that the output columns are 30 characterswide and that all whitespace in the lines from the file ispreserved.  <ACLASS="indexterm"NAME="AUTOID-12347"></A>The <BCLASS="emphasis.bold">while</B> loop reads one line from eachfile until at least one of them runs out of input.</P><PCLASS="para">Assume the file <EMCLASS="emphasis">dave</EM> contains the following:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">DAVEHeight: 5'10&quot;Weight: 175 lbs.Hair: brownEyes: brown</PRE></BLOCKQUOTE></P><PCLASS="para">And the file <EMCLASS="emphasis">shirley</EM> contains this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">SHIRLEYHeight: 5'6&quot;Weight: 142 lbs.Hair: blondeEyes: blue</PRE></BLOCKQUOTE></P><PCLASS="para">If the script is called <EMCLASS="emphasis">twocols</EM>, then <BCLASS="emphasis.bold">twocols dave shirley</B>produces this output:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">DAVE                          SHIRLEYHeight: 5'10&quot;                 Height: 5'6&quot;                  Weight: 175 lbs.              Weight: 142 lbs.              Hair: brown                   Hair: blonde                  Eyes: brown                   Eyes: blue</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12364"></A></P></DIV></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_01.htm"TITLE="7.1 I/O Redirectors"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 7.1 I/O Redirectors"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_03.htm"TITLE="7.3 Command-line Processing"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7.3 Command-line Processing"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">7.1 I/O Redirectors</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">7.3 Command-line Processing</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>