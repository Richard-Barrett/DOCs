<HTML><HEAD><TITLE>[Chapter 7] 7.3 Command-line Processing</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:13:38Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch07_01.htm"TITLE="7. Input/Output and Command-line Processing"><LINKREL="prev"HREF="ch07_02.htm"TITLE="7.2 String I/O"><LINKREL="next"HREF="ch08_01.htm"TITLE="8. Process Handling"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_02.htm"TITLE="7.2 String I/O"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 7.2 String I/O"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 7<BR>Input/Output and Command-line Processing</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch08_01.htm"TITLE="8. Process Handling"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 8. Process Handling"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-7-SECT-3">7.3 Command-line Processing</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12368"></A><ACLASS="indexterm"NAME="AUTOID-12371"></A><ACLASS="indexterm"NAME="KSH-CH-7-IX-COMMAND-LINE-PROCESSING"></A>We've seen how the shell uses<BCLASS="emphasis.bold">read</B> to process input lines: it deals with singlequotes (<CODECLASS="literal">' '</CODE>), double quotes (<CODECLASS="literal">&quot; &quot;</CODE>), and backslashes(<CODECLASS="literal">\</CODE>); it separates lines intowords, according to delimiters in the environment variable <BCLASS="emphasis.bold">IFS</B>;and it assigns the words to shell variables. We can think of thisprocess as a subset of the things the shell does when processing<EMCLASS="emphasis">command lines</EM>.</P><PCLASS="para">We've touched upon command-line processing (see <ACLASS="xref"HREF="ch07_03.htm#KSH-CH-7-FIG-0"TITLE="Steps in Command-line Processing">Figure 7.1</A>) throughout this book; now is a goodtime to make the whole thing explicit.[7]<ACLASS="indexterm"NAME="AUTOID-12390"></A><ACLASS="indexterm"NAME="AUTOID-12392"></A>Each line that the shellreads from the standard input or a script is called a <EMCLASS="emphasis">pipeline</EM>;it contains one or more <EMCLASS="emphasis">commands</EM> separated by zero or more pipecharacters (<BCLASS="emphasis.bold">|</B>). For each pipeline it reads, the shell breaks it up into commands, sets up the I/O for thepipeline, then does the following for each command:<ACLASS="indexterm"NAME="AUTOID-12398"></A></P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] Even this explanation is slightly simplified to elide the most petty details,e.g., &quot;middles&quot; and &quot;ends&quot; of compound commands, special characters within <BCLASS="emphasis.bold">[[</B>...<BCLASS="emphasis.bold">]]</B> and <BCLASS="emphasis.bold">((</B>...<BCLASS="emphasis.bold">))</B> constructs, etc.The last word on this subject is the reference book, <EMCLASS="emphasis">The KornShell Command and Programming Language</EM>,by Morris Bolsky and David Korn, published by Prentice-Hall.</P></BLOCKQUOTE><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12404"></A><ACLASS="indexterm"NAME="AUTOID-12407"></A>Splits the command into <EMCLASS="emphasis">tokens</EM> that are separated bythe fixed set of <EMCLASS="emphasis">metacharacters</EM>: SPACE, <SPANCLASS="acronym">TAB</SPAN>, NEWLINE, <CODECLASS="literal">;</CODE>, <BCLASS="emphasis.bold">(</B><CODECLASS="literal">,</CODE> <BCLASS="emphasis.bold">)</B>,<BCLASS="emphasis.bold">&lt;</B>, <BCLASS="emphasis.bold">&gt;</B>, <BCLASS="emphasis.bold">|</B>, and <BCLASS="emphasis.bold">&amp;</B>. Types of tokens include <EMCLASS="emphasis">words</EM>, <EMCLASS="emphasis">keywords</EM>,I/O redirectors, and semicolons.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12424"></A>Checks the first token of each command to see if it is a <EMCLASS="emphasis">keyword</EM>with no quotes or backslashes. If it's an openingkeyword (<BCLASS="emphasis.bold">if</B> and other control-structure openers, <BCLASS="emphasis.bold">function</B>,<BCLASS="emphasis.bold">{</B>, <BCLASS="emphasis.bold">(</B>, <BCLASS="emphasis.bold">((</B>, or <BCLASS="emphasis.bold">[[</B>), then the command is actuallya <EMCLASS="emphasis">compound command</EM>. The shell sets things up internallyfor the compound command, reads the next command, and startsthe process again. If the keyword isn't a compound command opener(e.g., is a control-structure &quot;middle&quot; like <BCLASS="emphasis.bold">then</B>, <BCLASS="emphasis.bold">else</B>, or <BCLASS="emphasis.bold">do</B>,an &quot;end&quot; like <BCLASS="emphasis.bold">fi</B> or <BCLASS="emphasis.bold">done</B>, or a logical operator), the shellsignals a syntax error.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12442"></A>Checks the first word of each command against the list of <EMCLASS="emphasis">aliases</EM>.If a match is found, it substitutes the alias' definition and <EMCLASS="emphasis">goes back toStep 1</EM>; otherwise it goes on to Step 4.<ACLASS="indexterm"NAME="AUTOID-12447"></A>This scheme allows <EMCLASS="emphasis">recursive</EM> aliases; see <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A>.It also allows aliases for keywords to be defined, e.g.,<BCLASS="emphasis.bold">alias aslongas=while</B> or <BCLASS="emphasis.bold">alias procedure=function</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12456"></A><ACLASS="indexterm"NAME="AUTOID-12458"></A><ACLASS="indexterm"NAME="AUTOID-12460"></A><ACLASS="indexterm"NAME="AUTOID-12462"></A>Substitutes the user's home directory (<BCLASS="emphasis.bold">$HOME</B>) for <EMCLASS="emphasis">tilde</EM> ifit is at the beginning of a word.  Substitutes <EMCLASS="emphasis">user</EM>'s homedirectory for <CODECLASS="literal">~</CODE><EMCLASS="emphasis">user</EM><BCLASS="emphasis.bold"></B>.[8]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[8] <ACLASS="indexterm"NAME="AUTOID-12473"></A><ACLASS="indexterm"NAME="AUTOID-12475"></A><ACLASS="indexterm"NAME="AUTOID-12478"></A><ACLASS="indexterm"NAME="AUTOID-12481"></A><ACLASS="indexterm"NAME="AUTOID-12484"></A><ACLASS="indexterm"NAME="AUTOID-12487"></A><ACLASS="indexterm"NAME="AUTOID-12489"></A>Two obscure variations on this: the shell substitutes the current directory (<BCLASS="emphasis.bold">$PWD</B>) for <BCLASS="emphasis.bold">~+</B> and the previous directory(<BCLASS="emphasis.bold">$OLDPWD</B>) for <BCLASS="emphasis.bold">~-</B>.</P></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12497"></A>Performs <EMCLASS="emphasis">parameter (variable) substitution</EM> for any expression that starts with a dollar sign (<BCLASS="emphasis.bold">$</B>).</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12504"></A>Does <EMCLASS="emphasis">command substitution</EM> for any expression of the form<BCLASS="emphasis.bold">$(</B><EMCLASS="emphasis">string</EM><BCLASS="emphasis.bold">)</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12513"></A>Evaluates <EMCLASS="emphasis">arithmetic expressions</EM> of the form <BCLASS="emphasis.bold">$((</B><EMCLASS="emphasis">string</EM><BCLASS="emphasis.bold">))</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12522"></A><ACLASS="indexterm"NAME="AUTOID-12525"></A>Takes the parts of the line that resulted from parameter, command,and arithmetic substitution and splits theminto words again. This time it uses thecharacters in <BCLASS="emphasis.bold">$IFS</B> as delimiters insteadof the set of metacharacters in Step 1.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12532"></A>Performs <EMCLASS="emphasis">filename generation</EM>, a.k.a. <EMCLASS="emphasis">wildcard expansion</EM>,for any occurrences of <CODECLASS="literal">*</CODE>, <CODECLASS="literal">?</CODE>, and <BCLASS="emphasis.bold">[/]</B> pairs.  <ACLASS="indexterm"NAME="AUTOID-12540"></A>It also processes the regularexpression operators that we saw in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A>.<H4CLASS="figure"><ACLASS="title"NAME="KSH-CH-7-FIG-0">Figure 7.1: Steps in Command-line Processing</A></H4><IMGCLASS="graphic"SRC="figs/korn0701.gif"ALT="Figure 7.1">&#13;</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12549"></A><ACLASS="indexterm"NAME="AUTOID-12552"></A><ACLASS="indexterm"NAME="AUTOID-12555"></A><ACLASS="indexterm"NAME="AUTOID-12558"></A><ACLASS="indexterm"NAME="AUTOID-12562"></A><ACLASS="indexterm"NAME="AUTOID-12564"></A>Uses the first word as a command by looking up its source accordingto the rest of the list in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A>, i.e., as a <EMCLASS="emphasis">built-in</EM> command, then as a <EMCLASS="emphasis">function</EM>, thenas a file in any of the directories in <BCLASS="emphasis.bold">$PATH</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12573"></A>Runs the command after setting up I/O redirection and other such things.</P></LI></OL><PCLASS="para">That's a lot of steps&nbsp;- and it's not even the whole story!But before we go on, an example should make this process clearer.<ACLASS="indexterm"NAME="AUTOID-12578"></A>Assume that the following command has been run:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">alias ll=&quot;ls -l&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">Further assume that a file exists called <EMCLASS="emphasis">.hist537</EM>in user <BCLASS="emphasis.bold">fred</B>'s home directory, which is <EMCLASS="emphasis">/home/fred</EM>,and that there is a double-dollar-sign variable <BCLASS="emphasis.bold">$$</B> whose value is <BCLASS="emphasis.bold">2537</B> (we'll see what this special variable is in the next chapter).</P><PCLASS="para">Now let's see how the shell processes the following command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">ll $(whence cc) ~fred/.*$(($$%1000))</PRE></BLOCKQUOTE></P><PCLASS="para">Here is what happens to this line:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">ll $(whence cc) ~fred/.*$(($$%1000))</B></P><PCLASS="para">Splitting the input into words.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">ll</B> is not a keyword, so step 2 does nothing.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">ls -l $(whence cc) ~fred/.*$(($$%1000))</B></P><PCLASS="para">Substituting <BCLASS="emphasis.bold">ls -l</B> for its alias &quot;ll&quot;.  The shell then repeats steps1 through 3; step 2 splits the <BCLASS="emphasis.bold">ls -l</B> into two words.[9]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[9] Some of the shell's built-in aliases, however, seem to makeit through single quotes: <BCLASS="emphasis.bold">true</B>(an alias for <BCLASS="emphasis.bold">:</B>, a &quot;do-nothing&quot; command that always returnsexit status 0), <BCLASS="emphasis.bold">false</B>(an alias for <BCLASS="emphasis.bold">let 0</B>, which always returns exit status 1), and <BCLASS="emphasis.bold">stop</B> (an alias for <BCLASS="emphasis.bold">kill -STOP</B>).</P></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">ls -l $(whence cc) /home/fred/.*$(($$%1000))</B></P><PCLASS="para">Expanding <BCLASS="emphasis.bold">~fred</B> into <EMCLASS="emphasis">/home/fred</EM>.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">ls -l $(whence cc) /home/fred/.*$((2537%1000))</B></P><PCLASS="para">Substituting <BCLASS="emphasis.bold">2537</B> for <BCLASS="emphasis.bold">$$</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">ls -l /usr/bin/cc /home/fred/.*$((2537%1000))</B></P><PCLASS="para">Doing command substitution on &quot;whence cc&quot;.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">ls -l /usr/bin/cc /home/fred/.*537</B></P><PCLASS="para">Evaluating the arithmetic expression <BCLASS="emphasis.bold">2537%1000</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">ls -l /usr/bin/cc /home/fred/.*537</B></P><PCLASS="para">This step does nothing.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">ls -l /usr/bin/cc /home/fred/.hist537</B></P><PCLASS="para">Substituting the filename for the wildcard expression .*<BCLASS="emphasis.bold">537</B>.</P></LI><LICLASS="listitem"><PCLASS="para">The command <BCLASS="emphasis.bold">ls</B> is found in <EMCLASS="emphasis">/usr/bin</EM>.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">/usr/bin/ls</EM> is run with the option -l and the two arguments.</P></LI></OL><PCLASS="para">Although this list of steps is fairly straightforward, it is not the whole story. There are still two ways to <EMCLASS="emphasis">subvert</EM> the process:  by quoting and by using the advanced command <BCLASS="emphasis.bold">eval</B>.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-7-SECT-3.1">7.3.1 Quoting</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12658"></A><ACLASS="indexterm"NAME="AUTOID-12661"></A><ACLASS="indexterm"NAME="AUTOID-12664"></A>You can think of quoting as a way of getting the shell to skipsome of the 11 steps above. In particular:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">Single quotes</B> (<CODECLASS="literal"> '&nbsp; '</CODE>) bypass <EMCLASS="emphasis">everything</EM> through Step 9&nbsp;- including aliasing.[10]All characters inside a pair of single quotes are untouched.You can't have single quotes inside single quotes&nbsp;- not even if you precede them with backslashes.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[10] However, as we saw in <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A> <CODECLASS="literal">'\''</CODE> (i.e., single quote, backslash, single quote, single quote)acts pretty much like a single quote in the middle of asingle-quoted string; e.g., <CODECLASS="literal">'</CODE><BCLASS="emphasis.bold">abc</B><CODECLASS="literal">'\''</CODE><BCLASS="emphasis.bold">def</B><CODECLASS="literal">'</CODE> evaluates to <BCLASS="emphasis.bold">abc</B><CODECLASS="literal">'</CODE><BCLASS="emphasis.bold">def</B>.</P></BLOCKQUOTE></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">Double quotes</B> (<CODECLASS="literal">&quot; &quot;</CODE>) bypass steps 1 through 4, plus steps 8 and 9. That is, theyignore pipe characters, aliases, tilde substitution, wildcard expansion,and splitting into words via delimiters (e.g., blanks)inside the double quotes. Single quotes inside double quotes haveno effect. But double quotes do allow parameter substitution, command substitution, and arithmeticexpression evaluation. You can include a double quote inside adouble-quoted string by preceding it with a backslash(<CODECLASS="literal">\</CODE>). You mustalso backslash-escape <BCLASS="emphasis.bold">$</B>, <CODECLASS="literal">`</CODE> (the archaiccommand substitution delimiter), and <BCLASS="emphasis.bold">\</B> itself.</P></LI></UL><PCLASS="para"><ACLASS="xref"HREF="ch07_03.htm#KSH-CH-7-TAB-4"TITLE="Examples of Quoting Rules">Table 7.5</A>contains some simple examples that show how these work; they assume that the statement <BCLASS="emphasis.bold">dave=bob</B> was run and thatuser <BCLASS="emphasis.bold">fred</B>'s home directory is <EMCLASS="emphasis">/home/fred</EM>.  </P><PCLASS="para">If you are wondering whether to use single or double quotes in a particular shell programming situation, it is safest to use singlequotes unless you specifically need parameter, command, or arithmetic substitution.<ACLASS="indexterm"NAME="AUTOID-12699"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-7-TAB-4">Table 7.5: Examples of Quoting Rules</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Expression</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Value</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">$dave</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">bob</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">&quot;$dave&quot;</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">bob</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">\\$dave</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">$dave</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>$dave<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">$dave</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>$dave<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>bob<CODECLASS="literal">'</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">~fred</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">/home/fred</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">&quot;</CODE>~fred<CODECLASS="literal">&quot;</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">~fred</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">'</CODE>~fred<CODECLASS="literal">'</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">~fred</TD></TR></TBODY></TABLE><PCLASS="para">Here's a more advanced example of command-line processingthat should give you deeper insight into the overall process.<ACLASS="indexterm"NAME="KSH-CH-7-IX-PROMPTS-CUSTOM-CURRENT-DIRECTORY"></A></P><DIVCLASS="task"><H4>Task 7.5</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">Customize your primary prompt string so that it containsthe current directory with tilde (<BCLASS="emphasis.bold">~</B>) notation.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-PS1"></A><ACLASS="indexterm"NAME="KSH-CH-7-IX-ENVIRONMENT-VARIABLES-PS1"></A>Recall from <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A> that we found a simple way to set upthe prompt string <BCLASS="emphasis.bold">PS1</B> so that it always contains thecurrent directory:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PS1='($PWD)-&gt; '</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-TILDE-NOTATION"></A><ACLASS="indexterm"NAME="KSH-CH-7-IX-TILDE"></A>One problem with this setup is that the resulting prompt stringscan get very long. One way to shorten them is to substitute tildenotation for users' home directories.  This cannot be done with a simple string expression analogousto the above. The solution is somewhat complicated and takesadvantage of the command-line processing rules.</P><PCLASS="para">The basic idea is to create a &quot;wrapper&quot; around the <BCLASS="emphasis.bold">cd</B>command, as we did in <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5</A>,that installs the current directory with tilde notationas the prompt string. Because <BCLASS="emphasis.bold">cd</B> is a built-in command,the wrapper must be an alias in order to override it. But the code we need to insert tilde notation is too complicatedfor an alias, so we'll use a function and then alias the functionas <BCLASS="emphasis.bold">cd</B>.  </P><PCLASS="para">We'll start with a function that, given a pathnameas argument, prints its equivalent in tilde notation if possible:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function tildize {    if [[ $1 = $HOME* ]]; then        print &quot;\~/${1#$HOME}&quot;        return 0    fi    awk '{FS=&quot;:&quot;; print $1, $6}' /etc/passwd |         while read user homedir; do            if [[ $homedir != / &amp;&amp; $1 = ${homedir}?(/*) ]]; then                print &quot;\~$user/${1#$homedir}&quot;                return 0            fi        done    print &quot;$1&quot;    return 1}</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12777"></A>The first <BCLASS="emphasis.bold">if</B> clause checks if the given pathname is underthe user's home directory. If so, it substitutes tilde (<BCLASS="emphasis.bold">~</B>) forthe home directory in the pathname and returns.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12782"></A><ACLASS="indexterm"NAME="AUTOID-12784"></A><ACLASS="indexterm"NAME="AUTOID-12786"></A>If not, we use the <EMCLASS="emphasis">awk</EM> utility to extract thefirst and sixth fields of the file <EMCLASS="emphasis">/etc/passwd</EM>, which containusers IDs and home directories, respectively. In this case,<EMCLASS="emphasis">awk</EM> acts like <EMCLASS="emphasis">cut</EM>.  The <BCLASS="emphasis.bold">FS=</B><CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">:</B><CODECLASS="literal">&quot;</CODE> is analogous to<BCLASS="emphasis.bold">-d:</B>, which we saw in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A>, except that it prints thevalues on each line separated by blanks, not colons (<CODECLASS="literal">:</CODE>). </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12800"></A><EMCLASS="emphasis">awk</EM>'s output is fed into a <BCLASS="emphasis.bold">while</B> loop that checksthe pathname given as argument to see if it contains some user'shome directory. (The first part of the conditional expressioneliminates &quot;users&quot; like <BCLASS="emphasis.bold">daemon</B> and <BCLASS="emphasis.bold">root</B>, whose home directories are root and therefore are contained in everyfull pathname.The second part matches home directories by themselves orwith some other directory appended (the <BCLASS="emphasis.bold">?(/*)</B> part.)) If a user's home directory is found, then <BCLASS="emphasis.bold">~</B><EMCLASS="emphasis">user</EM><BCLASS="emphasis.bold"></B> is substituted for the full home directory in thegiven pathname, the result is printed, and the function exits.<ACLASS="indexterm"NAME="AUTOID-12810"></A><ACLASS="indexterm"NAME="AUTOID-12811"></A></P><PCLASS="para">Finally, if the <BCLASS="emphasis.bold">while</B> loop exhausts all users without findinga home directory that is a prefix of the given pathname, then<BCLASS="emphasis.bold">tildize</B> simply echoes back its input.</P><PCLASS="para">Now that we have this function, you might think we could useit in a command substitution expression like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PS1='$(tildize $PWD)'</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12819"></A>But this won't work, because the shell doesn't do commandsubstitution when it evaluates the prompt string after every command.That's why we have to incorporate it into analias that supersedes <BCLASS="emphasis.bold">cd</B>. The following code should gointo your <EMCLASS="emphasis">.profile</EM> or environment file, along with the definition of <BCLASS="emphasis.bold">tildize</B>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PS1=$(tildize $PWD)function _cd {    &quot;cd&quot; &quot;$@&quot;    es=$?    PS1=$(tildize $PWD)    return $es}alias cd=_cd</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12828"></A>When you log in, this code will set <BCLASS="emphasis.bold">PS1</B> to the initialcurrent directory (presumably your home directory).Then, whenever you enter a <BCLASS="emphasis.bold">cd</B> command, the aliasruns the function <BCLASS="emphasis.bold">_cd</B>, which looks a lot like the&quot;wrapper&quot; in <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5</A>.<ACLASS="indexterm"NAME="AUTOID-12834"></A><ACLASS="indexterm"NAME="AUTOID-12835"></A></P><PCLASS="para">The first line in <BCLASS="emphasis.bold">_cd</B> runs the &quot;real&quot; <BCLASS="emphasis.bold">cd</B> bysurrounding it in quotes&nbsp;- which makes the shell bypassalias expansion (Step 3 in the list).Then the shell resets the prompt stringto the new current directory, or the old one if the <BCLASS="emphasis.bold">cd</B>failed for some reason.</P><PCLASS="para">Of course, the function <BCLASS="emphasis.bold">tildize</B> can be any code thatformats the directory string. See the exercises at the endof this chapter for a couple of suggestions.<ACLASS="indexterm"NAME="AUTOID-12842"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-7-SECT-3.2">7.3.2 eval</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-EVAL"></A><ACLASS="indexterm"NAME="AUTOID-12848"></A><ACLASS="indexterm"NAME="AUTOID-12851"></A>We have seen that quoting lets you skip steps in command-line processing.  Then there's the eval command, which lets you go through the process again.Performing command-line processing twice may seem strange, but it's actually very powerful: it lets you write scripts that create command stringson the fly and then pass them to the shell for execution.   This means that you can give scripts &quot;intelligence&quot; to modify theirown behavior as they are running.</P><PCLASS="para">The <BCLASS="emphasis.bold">eval</B> statement tells the shell totake <BCLASS="emphasis.bold">eval</B>'s argumentsand run them through the command-line processing steps all over again.To help you understand the implications of <BCLASS="emphasis.bold">eval</B>,we'll start with a trivial example and work our way up to a situationin which we're constructing and running commands on the fly.</P><PCLASS="para"><BCLASS="emphasis.bold">eval ls</B> passes the string <BCLASS="emphasis.bold">ls</B> to the shell to execute;the shell prints list of files in the current directory.Very simple; there is nothing about the string <BCLASS="emphasis.bold">ls</B> that needs to be sent through the command-processing steps twice. But consider this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">listpage=&quot;ls | more&quot;$listpage</PRE></BLOCKQUOTE></P><PCLASS="para">Instead of producing a paginated file listing, the shell will treat <BCLASS="emphasis.bold">|</B> and <BCLASS="emphasis.bold">more</B> as arguments to <EMCLASS="emphasis">ls</EM>, and <EMCLASS="emphasis">ls</EM> willcomplain that no files of those names exist. Why? Becausethe pipe character &quot;appears&quot; in step 5 when the shell evaluates the variable, <EMCLASS="emphasis">after</EM> it has actually lookedfor pipe characters (in step 2). The variable's expansion isn't even parseduntil step 8. As a result, the shell will treat <BCLASS="emphasis.bold">|</B>and <BCLASS="emphasis.bold">more</B> as arguments to <EMCLASS="emphasis">ls</EM>, so that <EMCLASS="emphasis">ls</EM> will try to find files called <BCLASS="emphasis.bold">|</B> and <EMCLASS="emphasis">more</EM> in the current directory!</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-EVAL-FOR-CONSTRUCTING-PIPELINES"></A>Now consider <BCLASS="emphasis.bold">eval $listpage</B> instead of just <BCLASS="emphasis.bold">$listpage</B>.When the shell gets to the last step, it will run the command<BCLASS="emphasis.bold">eval</B> with arguments <BCLASS="emphasis.bold">ls</B>, <BCLASS="emphasis.bold">|</B>, and <BCLASS="emphasis.bold">more</B>.  This causes theshell to go back to Step 1 with a line that consists of these arguments.It finds <BCLASS="emphasis.bold">|</B> in Step 2and splits the line into two commands,<EMCLASS="emphasis">ls</EM> and <EMCLASS="emphasis">more</EM>. Each command is processed in the normal(and in both cases trivial) way. The result is a paginated listof the files in your current directory.</P><PCLASS="para">Now you may start to see how powerful <BCLASS="emphasis.bold">eval</B> can be.It is an advanced feature that requires considerable programmingcleverness to be used most effectively. It even has a bit of theflavor of artificial intelligence, in that it enables you towrite programs that can &quot;write&quot; and execute other programs.[11]You probably won't use <BCLASS="emphasis.bold">eval</B> for everyday shell programming,but it's worth taking the time to understand what it can do.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[11] <ACLASS="indexterm"NAME="AUTOID-12893"></A>You could actually do this without<BCLASS="emphasis.bold">eval</B>, by <BCLASS="emphasis.bold">print</B>ing commands to a temporary file and then&quot;sourcing&quot; that file with <BCLASS="emphasis.bold">.</B> <EMCLASS="emphasis">filename</EM>. But that is <EMCLASS="emphasis">much</EM>less efficient.</P></BLOCKQUOTE><PCLASS="para">As a more interesting example, we'll revisit Task 4-1, the very firsttask in the book. In it, we constructed a simple pipeline that sorts a fileand prints out the first <EMCLASS="emphasis">N</EM> lines, where <EMCLASS="emphasis">N</EM> defaults to10. The resulting pipeline was:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sort -nr $1 | head -${2:-10}</PRE></BLOCKQUOTE></P><PCLASS="para">The first argument specified the file to sort; <BCLASS="emphasis.bold">$2</B> is the numberof lines to print.</P><PCLASS="para">Now suppose we change the task just a bit so that the default is to printthe <EMCLASS="emphasis">entire file</EM> instead of 10 lines.  <ACLASS="indexterm"NAME="AUTOID-12911"></A>This means that we don'twant to use <EMCLASS="emphasis">head</EM> at all in the default case. We could do thisin the following way:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if [[ -n $2 ]]; then    sort -nr $1 | head -$2else    sort -nr $1fi</PRE></BLOCKQUOTE></P><PCLASS="para">In other words, we decide which pipeline to run according to whetheror not <BCLASS="emphasis.bold">$2</B> is null. But here is a more compact solution:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval sort -nr \$1 ${2:+&quot;| head -\$2&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">The last expression in this line evaluates to the string <BCLASS="emphasis.bold">| head -\$2</B> if <BCLASS="emphasis.bold">$2</B> exists (is not null); if <BCLASS="emphasis.bold">$2</B> is null, then the expressionis null too.  We backslash-escape dollar signs (<BCLASS="emphasis.bold">\$</B>) before variable names toprevent unpredictable results if the variables' values containspecial characters like <BCLASS="emphasis.bold">&gt;</B> or <BCLASS="emphasis.bold">|</B>. The backslash effectively puts off the variables' evaluation until the <BCLASS="emphasis.bold">eval</B> commanditself runs.So the entire line is either:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval sort -nr \$1 | head -\$2</PRE></BLOCKQUOTE></P><PCLASS="para">if <BCLASS="emphasis.bold">$2</B> is given or:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval sort -nr \$1</PRE></BLOCKQUOTE></P><PCLASS="para">if <BCLASS="emphasis.bold">$2</B> is null.  Once again, we can't just run this command without<BCLASS="emphasis.bold">eval</B> because the pipe is &quot;uncovered&quot; after the shell tries tobreak the line up into commands. <BCLASS="emphasis.bold">eval</B> causes the shell torun the correct pipeline when <BCLASS="emphasis.bold">$2</B> is given.<ACLASS="indexterm"NAME="AUTOID-12939"></A></P><PCLASS="para">Next, we'll revisit Task 7-3 from earlier in this chapter,the <EMCLASS="emphasis">start</EM> script that lets you start a command in the background andsave its standard output and standarderror in a logfile. Recall that the one-line solutionto this task had the restriction that the command could not containoutput redirectors or pipes. Although the former doesn't make sensewhen you think about it, you certainly would want the ability tostart a pipeline in this way.</P><PCLASS="para"><BCLASS="emphasis.bold">eval</B> is the obvious way to solve this problem:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval &quot;$@&quot; &gt; logfile 2&gt;&amp;1 &amp;</PRE></BLOCKQUOTE></P><PCLASS="para">The only restriction that this imposes on the user is that pipesand other such special characters be quoted (surrounded by quotesor preceded by backslashes).</P><PCLASS="para">Here's a way to apply <BCLASS="emphasis.bold">eval</B> in conjunctionwith various other interesting shell programming concepts.<ACLASS="indexterm"NAME="KSH-CH-7-IX-MAKE"></A></P><DIVCLASS="task"><H4>Task 7.6</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">Implement the guts of the <EMCLASS="emphasis">make(1)</EM> utility as ashell script.</P></BLOCKQUOTE><PCLASS="para"><EMCLASS="emphasis">make</EM> is known primarily as a programmer's tool,but it seems as though someone finds a new use for itevery day. Without going into too much extraneous detail,<EMCLASS="emphasis">make</EM> basically keeps track of multiple files in a particularproject, some of which depend on others (e.g., a documentdepends on its word processor input file(s)).It makes sure that when you change a file, all of the other files that depend on it are processed.</P><PCLASS="para">For example, assume you're using the <EMCLASS="emphasis">troff</EM> word processorto write a book. You have files for the book's chapterscalled <EMCLASS="emphasis">ch1.t</EM>, <EMCLASS="emphasis">ch2.t</EM>, and so on; the <EMCLASS="emphasis">troff</EM>output for these files are <EMCLASS="emphasis">ch1.out</EM>, <EMCLASS="emphasis">ch2.out</EM>, etc.You run commands like <BCLASS="emphasis.bold">troff ch</B><EMCLASS="emphasis">N</EM><BCLASS="emphasis.bold">.t &gt; ch</B><EMCLASS="emphasis">N</EM><BCLASS="emphasis.bold">.out</B>to do the processing. While you're working on the book,you tend to make changes to several files at a time.</P><PCLASS="para">In this situation, you can use <EMCLASS="emphasis">make</EM> to keep track of which files needto be reprocessed, so that all you need to do is type <BCLASS="emphasis.bold">make</B>,and it will figure out what needs to be done. You don't needto remember to reprocess the files that have changed.</P><PCLASS="para">How does <EMCLASS="emphasis">make</EM> do this?  <ACLASS="indexterm"NAME="AUTOID-12975"></A>Simple: it compares the<EMCLASS="emphasis">modification times</EM> of the input and output files(called <EMCLASS="emphasis">sources</EM> and <EMCLASS="emphasis">targets</EM> in <EMCLASS="emphasis">make</EM> terminology), and if the input file is newer, then <EMCLASS="emphasis">make</EM> reprocesses it.</P><PCLASS="para">You tell <EMCLASS="emphasis">make</EM> which files to check by building a file called<EMCLASS="emphasis">makefile</EM> that has constructs like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><EMCLASS="emphasis">target</EM><CODECLASS="literal"> :</CODE> <EMCLASS="emphasis">source1 source2 ...</EM>	<EMCLASS="emphasis">commands to make target</EM></PRE></BLOCKQUOTE></P><PCLASS="para">This essentially says, &quot;For <EMCLASS="emphasis">target</EM> to be up to date, it must benewer than all of the <EMCLASS="emphasis">source</EM>s. If it's not, runthe <EMCLASS="emphasis">commands</EM> to bring it up to date.&quot;The <EMCLASS="emphasis">commands</EM> are on one or more lines that must startwith TABs: e.g., to make <EMCLASS="emphasis">ch7.out</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">ch7.out : ch7.t	troff ch7.t &gt; ch7.out</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-13001"></A>Now suppose that we write a shell function called<BCLASS="emphasis.bold">makecmd</B> that reads and executes a single constructof this form. Assume that the <EMCLASS="emphasis">makefile</EM> is readfrom standard input. The function would look like the following code.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function makecmd {    read target colon sources    for src in $sources; do        if [[ $src -nt $target ]]; then            while read cmd &amp;&amp; [[ $cmd = \t* ]]; do                print &quot;$cmd&quot;                eval ${cmd#\t}            done            break        fi    done}</PRE></BLOCKQUOTE></P><PCLASS="para">This function reads the line with the target and sources;the variable <BCLASS="emphasis.bold">colon</B> is just a placeholder for the <BCLASS="emphasis.bold">:</B>.<ACLASS="indexterm"NAME="AUTOID-13009"></A>Then it checks each source to see if it's newer than the target,using the <BCLASS="emphasis.bold">-nt</B> file attribute test operator that we sawin <ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5</A>.If the source is newer, it reads, prints, and executes the commands until it finds a line that doesn't start with a TAB or it reaches end-of-file.(The real <EMCLASS="emphasis">make</EM> does more than this; see the exercisesat the end of this chapter.)After running the commands (which are stripped of the initial TAB), it breaks out of the <BCLASS="emphasis.bold">for</B> loop, so that it doesn't run the commands more than once.</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-7-SECT-3.2.1">7.3.2.1 The C Compiler as Pipeline</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-C-COMPILERS-AS-PIPELINES"></A>As a final example of <BCLASS="emphasis.bold">eval</B>, we'll revisit our old friend <EMCLASS="emphasis">occ</EM>, the C compiler from the previous three chapters. Recall that the compilerdoes its work by calling separate programs to do the actual <EMCLASS="emphasis">compile</EM> from C to object code (the <EMCLASS="emphasis">ccom</EM> program),<EMCLASS="emphasis">optimization</EM> of object code (<EMCLASS="emphasis">optimize</EM>),<EMCLASS="emphasis">assembly</EM> of assembler code files (<EMCLASS="emphasis">as</EM>),and final <EMCLASS="emphasis">linking</EM> of object code files into an executable program(<EMCLASS="emphasis">ld</EM>). These separate programs use temporary files to storetheir outputs.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-7-IX-EVAL-FOR-CONSTRUCTING-PIPELINES2"></A>Now we'll assume that these components (except the linker)pass information in a <EMCLASS="emphasis">pipeline</EM> to the final object code output.In other words, each component takes standard input and producesstandard output instead of taking filename arguments.We'll also change an earlier assumption:instead of compiling a C source file directly to object code, <EMCLASS="emphasis">occ</EM> compiles C to assembler code, which theassembler then assembles to object code. This lets us supposethat <EMCLASS="emphasis">occ</EM> works like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">ccom &lt; filename.c | as | optimize &gt; filename.o</PRE></BLOCKQUOTE></P><PCLASS="para">Or, if you prefer:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">cat <EMCLASS="emphasis">filename</EM><CODECLASS="literal">.c | ccom | as | optimize &gt; </CODE><EMCLASS="emphasis">filename</EM>.o</PRE></BLOCKQUOTE></P><PCLASS="para">To get this in the proper framework for <BCLASS="emphasis.bold">eval</B>, let's assume that the variables<BCLASS="emphasis.bold">srcname</B> and <BCLASS="emphasis.bold">objname</B> contain the names of the sourceand object files, respectively. Then our pipeline becomes:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">cat $srcname | ccom | as | optimize &gt; $objname</PRE></BLOCKQUOTE></P><PCLASS="para">As we've already seen, this is equivalent to:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval cat \$srcname | ccom | as | optimize &gt; \$objname</PRE></BLOCKQUOTE></P><PCLASS="para">Knowing what we do about <BCLASS="emphasis.bold">eval</B>, we can transform this into:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval cat \$srcname &quot; | ccom&quot; &quot; | as&quot; &quot; | optimize&quot; &gt; \$objname</PRE></BLOCKQUOTE></P><PCLASS="para">and from that into:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">compile=&quot; | ccom&quot;assemble=&quot; | as&quot;optimize=&quot; | optimize&quot;eval cat \$srcname \$compile \$assemble \$optimize &gt; \$objname</PRE></BLOCKQUOTE></P><PCLASS="para">Now, consider what happens if you don't wantto invoke the optimizer&nbsp;- which is the default case anyway.(Recall that the <BCLASS="emphasis.bold">-O</B> option invokes the optimizer.)We can do this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">optimize=&quot;&quot;if -O given then    optimize=&quot; | optimize&quot;fi</PRE></BLOCKQUOTE></P><PCLASS="para">In the default case, <BCLASS="emphasis.bold">$optimize</B> evaluates to the empty string,causing the final pipeline to &quot;collapse&quot; into:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval cat $srcname | ccom | as &gt; $objname</PRE></BLOCKQUOTE></P><PCLASS="para">Similarly, if you pass <BCLASS="emphasis.bold">occ</B> a file of assembler code (<EMCLASS="emphasis">filename.s</EM>), you can collapse the compile step:[12]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[12] Astute readers will notice that, according to this rationale,we would handle object-code input files (<EMCLASS="emphasis">filename.o</EM>)with the pipeline <BCLASS="emphasis.bold">eval cat $srcname &gt; $objname</B>, where thetwo names are the same. This will cause UNIX to destroy<EMCLASS="emphasis">filename.o</EM> by truncating it to zero length.We won't worry about this here.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">assemble=&quot;| as&quot;if $srcname ends in .s then    compile=&quot;&quot;fi</PRE></BLOCKQUOTE></P><PCLASS="para">That results in this pipeline:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval cat \$srcname | as &gt; \$objname</PRE></BLOCKQUOTE></P><PCLASS="para">Now we're ready to show the full &quot;pipeline&quot; version of <BCLASS="emphasis.bold">occ</B>.  It's similar to the previous version, except that for each input file, it constructs and runs a pipeline as above. It processesthe <BCLASS="emphasis.bold">-g</B> (debug) option and the link step in the same way asbefore. Here is the code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># initialize option-related variablesdo_link=truedebug=&quot;&quot;link_libs=&quot;-l c&quot;exefile=&quot;&quot;# initialize pipeline componentscompile=&quot; | ccom&quot;assemble=&quot; | as&quot;optimize=&quot;&quot;# process command-line optionswhile getopts &quot;:cgl:o:O&quot; opt; do    case $opt in         c )    do_link=false ;;        g )    debug=&quot;-g&quot; ;;        l )    link_libs=&quot;$link_libs -l $OPTARG&quot; ;;        o )    exefile=&quot;-o $OPTARG&quot; ;;        O )    optimize=&quot; | optimize&quot; ;;        \? )   print 'usage: occ [-cgO] [-l lib] [-o file] files...'               return 1 ;;    esacdoneshift $(($OPTIND - 1))# process the input filesfor filename in &quot;$@&quot;; do    case $filename in	*.c )	    objname=${filename%.c}.o ;;	*.s )	    objname=${filename%.s}.o	    compile=&quot;&quot; ;;	*.o )	    compile=&quot;&quot;	    assemble=&quot;&quot; ;;	*   )        print &quot;error: $filename is not a source or object file.&quot;        return 1 ;;    esac# run a pipeline for each input fileeval cat \$filename \$compile \$assemble \$optimize &gt; \$objname    objfiles=$objfiles&quot; &quot;$objnamedoneif [[ $do_link = true ]]; then    ld $exefile $link_libs $objfilesfi</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-13091"></A><ACLASS="indexterm"NAME="AUTOID-13092"></A><ACLASS="indexterm"NAME="AUTOID-13093"></A><ACLASS="indexterm"NAME="AUTOID-13094"></A>We could go on forever with increasingly complex examples of <BCLASS="emphasis.bold">eval</B>,but we'll settle for concluding the chapter with a few exercises.The last two are really more like items on the menu of food for thought;the very last one is particularly difficult.</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Here are a couple of ways to enhance <BCLASS="emphasis.bold">occ</B>, our C compiler:<OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Real-world C compilers accept the option <BCLASS="emphasis.bold">-S</B>,which tells the compiler to suppress the assembly step and leavethe output in files of assembler code whose names end in <EMCLASS="emphasis">.s</EM>.Modify <BCLASS="emphasis.bold">occ</B> so that it recognizes this option.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-13108"></A>The language C++ is an evolutionary successor to C; it includesadvanced features like operator overloading, function argumenttype checking, and class definitions. (Don't worryif you don't know what these are.) Some C++ compilers use Cas an &quot;assembly language&quot;, i.e., they compile C++ source filesto C code and then pass them to a C compiler for further processing.Assume that C++ source files have names ending in <EMCLASS="emphasis">.cc</EM>,and that <EMCLASS="emphasis">/lib/cfront</EM> is the C++ compiler &quot;front-end&quot; that producesC code on its standard output. Modify <EMCLASS="emphasis">occ</EM> so thatit accepts C++ as well as C, assembler, and object code files.</P></LI></OL></P></LI><LICLASS="listitem"><PCLASS="para">The possibilities for customizing your prompt string are practically endless.  Here are two enhancements to customization schemes that we've seen already:<OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Enhance the current-directory-in-the-prompt scheme bylimiting the prompt string's length to a number of charactersthat the user can define with an environment variable.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-13120"></A>On some UNIX systems, it's not possible to get a list of all usersby looking at <EMCLASS="emphasis">/etc/passwd</EM>.  <ACLASS="indexterm"NAME="AUTOID-13123"></A>For example, networks of Suns usethe Network Information Service (NIS, a.k.a. &quot;Yellow Pages&quot;),which stores a protected password file for the entire network on one server machine, instead of having separate <EMCLASS="emphasis">/etc/passwd</EM>files on each machine.</P><PCLASS="para">If such a machine is set up so that all login directories areunder a common directory (e.g., <EMCLASS="emphasis">/users</EM>),  you can geta list of all users by simply <EMCLASS="emphasis">ls</EM>-ing that directory.Modify the <BCLASS="emphasis.bold">tildize</B> function so that it uses this technique;pay particular attention to execution speed.</P></LI></OL></P></LI><LICLASS="listitem"><PCLASS="para">The function <BCLASS="emphasis.bold">makecmd</B> in the solution to Task 7-6 represents an oversimplification of the real <EMCLASS="emphasis">make</EM>'s functionality. <EMCLASS="emphasis">make</EM> actually checks file dependencies <EMCLASS="emphasis">recursively</EM>,meaning that a <EMCLASS="emphasis">source</EM> on one line in a <EMCLASS="emphasis">makefile</EM> can be a<EMCLASS="emphasis">target</EM> on another line. For example, the book chapters inthe examplecould themselves depend on some figures in separate filesthat were made with a graphics package.<OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Write a function called <BCLASS="emphasis.bold">readtargets</B> that goes through the<EMCLASS="emphasis">makefile</EM> and stores all of the targets in a variable or temp file.</P></LI><LICLASS="listitem"><PCLASS="para">Instead of reading the <EMCLASS="emphasis">makefile</EM> from standard input, read it intoan array variable called <BCLASS="emphasis.bold">lines</B>. Use the variable <BCLASS="emphasis.bold">curline</B>as the &quot;current line&quot; index. Modify <BCLASS="emphasis.bold">makecmd</B> so that it reads linesfrom the array starting with the current line.</P></LI><LICLASS="listitem"><PCLASS="para"><BCLASS="emphasis.bold">makecmd</B> merely checks to see if any of the sourcesare newer than the given target. It should really be a recursiveroutine that looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function makecmd {    target=$1    get sources for $target    for each source src; do        if $src is also a target in this makefile then            makecmd $src        fi        if [[ $src -nt $target ]]; then            run commands to make target            return        fi    done}</PRE></BLOCKQUOTE></P><PCLASS="para">Implement this. </P></LI><LICLASS="listitem"><PCLASS="para">Write the &quot;driver&quot; script that turns the <BCLASS="emphasis.bold">makecmd</B> function into a full<EMCLASS="emphasis">make</EM> program. This should make the target given as argument,or if none is given, the first target listed in the makefile.</P></LI><LICLASS="listitem"><PCLASS="para">The above <BCLASS="emphasis.bold">makecmd</B> still doesn't do one important thingthat the real <EMCLASS="emphasis">make</EM> does: allow for &quot;symbolic&quot; targets thataren't files. These give <EMCLASS="emphasis">make</EM> much of the power that makesit applicable to such an incredible variety of situations.Symbolic targets always have a modification time of 0, so that <EMCLASS="emphasis">make</EM> always runs the commands to make them.Modify <BCLASS="emphasis.bold">makecmd</B> so that it allows for symbolic targets.(Hint: the crux of this problem is to figure out how to get a file's modification time. This is quite difficult.)</P></LI></OL>&#13;</P></LI><LICLASS="listitem"><PCLASS="para">Finally, here are some problems that really test your knowledge of <BCLASS="emphasis.bold">eval</B> and the shell's command-line processing rules. Solve these and you're a true Korn shell hacker!<OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Advanced shell programmers sometimes use a little trick that includes<BCLASS="emphasis.bold">eval</B>: using the <EMCLASS="emphasis">value</EM> of a variableas the <EMCLASS="emphasis">name</EM> of another variable. In other words, you can givea shell script control over the <EMCLASS="emphasis">names</EM> of variables to which itassigns values. How would you do this?  (Hint: if <BCLASS="emphasis.bold">$fred</B> equals &quot;dave&quot;, and <BCLASS="emphasis.bold">$dave</B> is&quot;bob&quot;, then you might think that you could type <BCLASS="emphasis.bold">print $$fred</B>and get the response <BCLASS="emphasis.bold">bob</B>. Thisdoesn't actually work, but it's on the right track.)</P></LI><LICLASS="listitem"><PCLASS="para">You could use the above technique together with other <BCLASS="emphasis.bold">eval</B> tricksto implement new control structures for the shell.  <ACLASS="indexterm"NAME="AUTOID-13184"></A><ACLASS="indexterm"NAME="AUTOID-13186"></A>For example, see if you can write a script that emulates the behaviorof a <BCLASS="emphasis.bold">for</B> loop in a conventional language like C or Pascal, i.e.,a loop that iterates a fixed number of times, with a loop variablethat steps from 1 to the number of iterations (or, for C fans,0 to iterations-1). Call your script <BCLASS="emphasis.bold">loop</B> to avoid clashes with the keywords <BCLASS="emphasis.bold">for</B> and <BCLASS="emphasis.bold">do</B>.</P></LI></OL>&#13;</P></LI></OL></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_02.htm"TITLE="7.2 String I/O"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 7.2 String I/O"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch08_01.htm"TITLE="8. Process Handling"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 8. Process Handling"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">7.2 String I/O</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">8. Process Handling</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>