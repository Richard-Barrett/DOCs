<HTML><HEAD><TITLE>[Chapter 8] 8.4 trap</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:15:10Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch08_01.htm"TITLE="8. Process Handling"><LINKREL="prev"HREF="ch08_03.htm"TITLE="8.3 Signals"><LINKREL="next"HREF="ch08_05.htm"TITLE="8.5 Coroutines"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_03.htm"TITLE="8.3 Signals"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 8.3 Signals"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 8<BR>Process Handling</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_05.htm"TITLE="8.5 Coroutines"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 8.5 Coroutines"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-8-SECT-4">8.4 trap</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14095"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-TRAPS"></A>We've been discussing how signals affect the casual user; now let's talk a bit about how shell programmers can use them.We won't go into too much depth about this, because it's reallythe domain of systems programmers. </P><PCLASS="para">We mentioned above that programs in general can be set up to &quot;trap&quot;specific signals and process them in their own way.  <ACLASS="indexterm"NAME="KSH-CH-8-IX-TRAPS-TRAP-COMMAND"></A>The <BCLASS="emphasis.bold">trap</B>built-in command lets you do this from within a shell script.  <BCLASS="emphasis.bold">trap</B> is most important for &quot;bullet-proofing&quot; large shell programsso that they react appropriately to abnormal events-just as programsin any language should guard against invalid input. It's alsoimportant for certain systems programming tasks, as we'll see in thenext chapter.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14107"></A><ACLASS="indexterm"NAME="AUTOID-14110"></A>The syntax of <BCLASS="emphasis.bold">trap</B> is:</P><BLOCKQUOTECLASS="blockquote"><PCLASS="para"><BCLASS="emphasis.bold">trap</B> <CODECLASS="replaceable"><I>cmd sig1 sig2 ...</I></CODE> </P></BLOCKQUOTE><PCLASS="para">That is, when any of <EMCLASS="emphasis">sig1</EM>, <EMCLASS="emphasis">sig2</EM>, etc., are received,run <EMCLASS="emphasis">cmd</EM>, then resume execution.After <EMCLASS="emphasis">cmd</EM> finishes, the scriptresumes execution just after the command that was interrupted.[10]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[10] This is what <EMCLASS="emphasis">usually</EM> happens. Sometimes the commandcurrently running will abort (<EMCLASS="emphasis">sleep</EM> acts like this, as we'll see soon); other times it will finish running. Further details are beyond the scope of this book.</P></BLOCKQUOTE><PCLASS="para">Of course, <EMCLASS="emphasis">cmd</EM> can be a script or function. The <EMCLASS="emphasis">sig</EM>s can be specified by name or by number.<ACLASS="indexterm"NAME="AUTOID-14130"></A><ACLASS="indexterm"NAME="AUTOID-14131"></A>You can also invoke <BCLASS="emphasis.bold">trap</B> without arguments, in which casethe shell will print a list of any traps that have been set, usingsymbolic names for the signals.</P><PCLASS="para">Here's a simple example that shows how <BCLASS="emphasis.bold">trap</B> works.  Suppose we have a shell script called <BCLASS="emphasis.bold">loop</B> with this code:<ACLASS="indexterm"NAME="AUTOID-14138"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">while true; do    sleep 60done</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14143"></A>This will just pause for 60 seconds (the <EMCLASS="emphasis">sleep</EM>(1) command)and repeat indefinitely. <BCLASS="emphasis.bold">true</B> is a &quot;do-nothing&quot; command whose exit status is always 0.[11]<ACLASS="indexterm"NAME="AUTOID-14153"></A>Try typing in this script. Invoke it, let it run for a little while, then type <KBDCLASS="keycap">[CTRL-C]</KBD>(assuming that is your interrupt key). It should stop,and you should get your shell prompt back.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[11] <ACLASS="indexterm"NAME="AUTOID-14149"></A>Actually, it's a built-in alias for <CODECLASS="literal">:</CODE>, the real shell &quot;no-op.&quot;</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14157"></A>Now insert the following line at the beginning of the script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">trap 'print \'You hit control-C!\'' INT</PRE></BLOCKQUOTE></P><PCLASS="para">Invoke the script again. Now hit <SPANCLASS="acronym">CTRL-C</SPAN>. The odds are overwhelming that you are interrupting the <EMCLASS="emphasis">sleep</EM> command (as opposed to<BCLASS="emphasis.bold">true</B>). You should see the message&quot;You hit control-C!&quot;, and the script will not stop running;instead, the <EMCLASS="emphasis">sleep</EM> command will abort, andit will loop around and start another <EMCLASS="emphasis">sleep</EM>.Hit <SPANCLASS="acronym">CTRL-\</SPAN>&nbsp;to get it to stop.  <ACLASS="indexterm"NAME="AUTOID-14171"></A>Type <BCLASS="emphasis.bold">rm core</B> to get rid of the resulting core dump file.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14175"></A><ACLASS="indexterm"NAME="AUTOID-14177"></A><ACLASS="indexterm"NAME="AUTOID-14180"></A>Next, run the script in the background by typing <BCLASS="emphasis.bold">loop &amp;</B>.Type <BCLASS="emphasis.bold">kill %loop</B> (i.e., send it the TERM signal);the script will terminate. Add TERMto the <BCLASS="emphasis.bold">trap</B> command, so that it looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">trap 'print \'You hit control-C!\'' INT TERM</PRE></BLOCKQUOTE></P><PCLASS="para">Now repeat the process: run it in the background and type <BCLASS="emphasis.bold">kill %loop</B>.As before, you will see the message and the process will keepon running. Type <BCLASS="emphasis.bold">kill -KILL %loop</B> to stop it.</P><PCLASS="para">Notice that the message isn't really appropriate when you use <BCLASS="emphasis.bold">kill</B>. We'll change the script so it prints a better message inthe <BCLASS="emphasis.bold">kill</B> case:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">trap 'print \'You hit control-C!\'' INTtrap 'print \'You tried to kill me!\'' TERMwhile true; do    sleep 60done</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14198"></A><ACLASS="indexterm"NAME="AUTOID-14200"></A>Now try it both ways: in the foreground with <KBDCLASS="keycap">[CTRL-C]</KBD> and in the backgroundwith <BCLASS="emphasis.bold">kill</B>. You'll see different messages.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-4.1">8.4.1 Traps and Functions</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-TRAPS-WITHIN-FUNCTIONS"></A>The relationship between traps and shell functions is straightforward,but it has certain nuances that are worth discussing. The mostimportant thing to understand is that functions can have their ownlocal traps; these aren't known outside of the function. In particular,the surrounding script doesn't know about them. Consider this code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function settrap {    trap 'print \'You hit control-C!\'' INT}settrapwhile true; do    sleep 60done</PRE></BLOCKQUOTE></P><PCLASS="para">If you invoke this script and hit your interrupt key, it willjust exit. <ACLASS="indexterm"NAME="AUTOID-14213"></A>The trap on INT in the function is known only insidethat function. On the other hand:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function loop {    trap 'print \'How dare you!\'' INT    while true; do        sleep 60    done}trap 'print \'You hit control-C!\'' INTloop</PRE></BLOCKQUOTE></P><PCLASS="para">When you run this script and hit your interrupt key, it willprint &quot;How dare you!&quot;.  But how about this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function loop {    while true; do        sleep 60    done}trap 'print \'You hit control-C!\'' INTloopprint 'exiting...'</PRE></BLOCKQUOTE></P><PCLASS="para">This time the looping code is within a function, and the trapis set in the surrounding script. If you hit your interrupt key,it will print the message and then print &quot;exiting...&quot;.It will not repeat the loop as above.</P><PCLASS="para">Why? Remember that when the signal comes in,the shell aborts the current command, which in this case is a callto a function. The entire function aborts, and executionresumes at the next statement after the function call.</P><PCLASS="para">The advantage of traps that are local to functions is that theyallow you to control a function's behavior separately from thesurrounding code.  </P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-TRAPS-SETTING-GLOBAL-FUNCTIONS"></A>Yet you may want to define global traps inside functions.There is a rather kludgy way to do this; it depends on a featurethat we introduce in the next chapter, which we call a &quot;fake signal.&quot;Here is a way to set <EMCLASS="emphasis">trapcode</EM>as a global trap for signal <EMCLASS="emphasis">SIG</EM> inside a function:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">trap &quot;trap <EMCLASS="emphasis">trapcode SIG</EM>&quot; EXIT</PRE></BLOCKQUOTE></P><PCLASS="para">This sets up the command <BCLASS="emphasis.bold">trap</B> <EMCLASS="emphasis">trapcode SIG</EM> to runright after the function exits, at which time the surroundingshell script is in scope (i.e., is &quot;in charge&quot;). When that commandruns, <EMCLASS="emphasis">trapcode</EM> is set up to handle the <EMCLASS="emphasis">SIG</EM> signal.</P><PCLASS="para">For example, you may want to reset the trap on the signal you justreceived, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function trap_handler {    trap &quot;trap second_handler INT&quot; EXIT    print 'Interrupt: one more to abort.'}function second_handler {    print 'Aborted.'    exit }trap trap_handler INT</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14242"></A>This code acts like the UNIX <EMCLASS="emphasis">mail</EM>utility: when you are typing in a message, you must press yourinterrupt key twice to abort the process.  <ACLASS="indexterm"NAME="AUTOID-14245"></A><ACLASS="indexterm"NAME="AUTOID-14246"></A></P><PCLASS="para">Speaking of <EMCLASS="emphasis">mail</EM>, now we'll show a more practical example of traps.</P><DIVCLASS="task"><H4>Task 8.2</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">As part of an electronic mail system, write the shell code thatlets a user compose a message.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14253"></A>The basic idea is to use <EMCLASS="emphasis">cat</EM> to create the message in a temporaryfile and then hand the file's name off to a programthat actually sends the message to its destination.  The code to create the file is very simple:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">msgfile=/tmp/msg$$cat &gt; $msgfile</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14259"></A>Since <EMCLASS="emphasis">cat</EM> without an argument reads from the standard input, this will just wait for the user to type a message andend it with the end-of-text character <KBDCLASS="keycap">[CTRL-D]</KBD>.</P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-4.2">8.4.2 Process ID Variables and Temporary Files</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14266"></A><ACLASS="indexterm"NAME="AUTOID-14269"></A>The only thing new about this is <BCLASS="emphasis.bold">$$</B> in the filename expression.This is a special shell variable whose value is the process IDof the current shell. </P><PCLASS="para">To see how <BCLASS="emphasis.bold">$$</B> works, type <BCLASS="emphasis.bold">ps</B> and note the process ID of your shell process (<EMCLASS="emphasis">ksh</EM>).  Then type <BCLASS="emphasis.bold">print</B> <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$$</B><CODECLASS="literal">&quot;</CODE>;the shell will respond with thatsame number. Now type <BCLASS="emphasis.bold">ksh</B> tostart a subshell, and when you get a prompt, repeat the process.You should see a different number, probably slightly higher thanthe last one.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14283"></A><ACLASS="indexterm"NAME="AUTOID-14286"></A><ACLASS="indexterm"NAME="AUTOID-14289"></A>A related built-in shell variable is <BCLASS="emphasis.bold">!</B> (i.e., its value is<BCLASS="emphasis.bold">$!</B>), which contains the process ID of the most recentlyinvoked background job. To see how this works, invoke any jobin the background and note the process ID printed by the shellnext to <BCLASS="emphasis.bold">[1]</B>. Then type <BCLASS="emphasis.bold">print</B> <CODECLASS="literal">&quot;</CODE><BCLASS="emphasis.bold">$!</B><CODECLASS="literal">&quot;</CODE>; you should see the same number.  </P><PCLASS="para">The <BCLASS="emphasis.bold">!</B> variable is useful in shell programs that involvemultiple communicating processes, as we'll see later.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14302"></A><ACLASS="indexterm"NAME="AUTOID-14304"></A><ACLASS="indexterm"NAME="AUTOID-14307"></A><ACLASS="indexterm"NAME="AUTOID-14311"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-MAIL"></A>To return to our mail example:since all processes on the system musthave unique process IDs, <BCLASS="emphasis.bold">$$</B> is excellent for constructing namesof temporary files. We saw an example of this back in <ACLASS="xref"HREF="ch02_01.htm"TITLE="Command-line Editing">Chapter 2, Command-line Editing</A>:we used the expression <BCLASS="emphasis.bold">.hist$$</B> as a way of generatingunique names for command history files so that several can be openat once, allowing multiple shell windows on a workstation to have theirown history files. This expression generates names like <BCLASS="emphasis.bold">.hist234</B>.There are also examples of <BCLASS="emphasis.bold">$$</B> in <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7</A> and <ACLASS="xref"HREF="ch09_01.htm"TITLE="Debugging Shell Programs">Chapter 9, Debugging Shell Programs</A>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14325"></A><ACLASS="indexterm"NAME="AUTOID-14327"></A>The directory <EMCLASS="emphasis">/tmp</EM> is conventionally used for temporary files.Many systems also have another directory, <EMCLASS="emphasis">/usr/tmp</EM>, for the same purpose.All files in these directories are usually erased whenever the computer is rebooted.  </P><PCLASS="para">Nevertheless, a program should clean up such files before it exits,to avoid taking up unnecessary disk space. <ACLASS="indexterm"NAME="AUTOID-14332"></A>We could do this inour code very easily by adding the line <BCLASS="emphasis.bold">rm $msgfile</B> after the code that actually sends the message.<ACLASS="indexterm"NAME="AUTOID-14335"></A>But what if the program receives a signal during execution? For example, what if a user changes his or her mind about sendingthe message and hits <SPANCLASS="acronym">CTRL-C</SPAN> to stop the process? We would need toclean up before exiting. <ACLASS="indexterm"NAME="AUTOID-14339"></A>We'll emulate the actual UNIX <EMCLASS="emphasis">mail</EM> system by saving the message being written in a file called<EMCLASS="emphasis">dead.letter</EM> in the current directory.<ACLASS="indexterm"NAME="AUTOID-14344"></A>We can do this by using <BCLASS="emphasis.bold">trap</B> witha command string that includes an <BCLASS="emphasis.bold">exit</B> command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">trap 'mv $msgfile dead.letter; exit' INT TERMmsgfile=/tmp/msg$$cat &gt; $msgfile# send the contents of $msgfile to the specified mail address...rm $msgfile</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14351"></A><ACLASS="indexterm"NAME="AUTOID-14354"></A>When the script receives an INT or TERM signal, it will removethe temp file and then exit. Note that the command stringisn't <EMCLASS="emphasis">evaluated</EM> until it needs to be run, so <BCLASS="emphasis.bold">$msgfile</B> will contain the correct value; that's why we surround the stringin single quotes.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14360"></A>But what if the script receives a signal before <BCLASS="emphasis.bold">msgfile</B> iscreated-unlikely though that may be? Then <BCLASS="emphasis.bold">mv</B> will try torename a file that doesn't exist. To fix this, we need totest for the existence of thefile <BCLASS="emphasis.bold">$msgfile</B> before trying to delete it. The code for this isa bit unwieldy to put in a single command string, so we'll use afunction instead:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function cleanup {    if [[ -a $msgfile ]]; then	  mv $msgfile dead.letter    fi    exit}trap cleanup INT TERMmsgfile=/tmp/msg$$cat &gt; $msgfile# send the contents of $msgfile to the specified mail address...rm $msgfile</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14368"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-4.3">8.4.3 Ignoring Signals</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-TRAPS-FOR-IGNORING-SIGNALS"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-SIGNALS-IGNORING"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-TRAPS-COMNDNULL-STR-ARG-IGN-SIGS"></A>Sometimes a signal comes in that you don't want to do anything about.If you give the null string (&quot; &quot;  or <CODECLASS="literal">' '</CODE>) as the command argument to <BCLASS="emphasis.bold">trap</B>, then the shell will effectively ignore that signal.  <ACLASS="indexterm"NAME="KSH-CH-8-IX-SIGNALS-HUP"></A><ACLASS="indexterm"NAME="AUTOID-14386"></A>The classicexample of a signal you may want to ignore is HUP (hangup), the signal the shell sends to all of your background processes whenyou log out.</P><PCLASS="para">HUP has the usual default behavior: it will kill the process thatreceives it.But there are bound to be times when you don't want a background jobto terminate when you log out. For example, you may start a longcompile or word processing job; you want to log out and come back laterwhen you expect the job to be finished. Under normal circumstances,your background job will terminate when you log out. But if you run it in a shell environment where the HUP signal is ignored, thejob will finish.</P><PCLASS="para">To do this, you could write a simple function that looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function ignorehup {    trap &quot;&quot; HUP    eval &quot;$@&quot;}</PRE></BLOCKQUOTE></P><PCLASS="para">We write this as a function instead of a script for reasonsthat will become clearer when we look in detail at subshellsat the end of this chapter.<ACLASS="indexterm"NAME="AUTOID-14395"></A><ACLASS="indexterm"NAME="AUTOID-14396"></A><ACLASS="indexterm"NAME="AUTOID-14397"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-NOHUP"></A>Actually, there is a UNIX command called <EMCLASS="emphasis">nohup</EM>that does precisely this.The <BCLASS="emphasis.bold">start</B> script from the last chapter could include <BCLASS="emphasis.bold">nohup</B>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval nohup &quot;$@&quot; &gt; logfile 2&gt;&amp;1 &amp;</PRE></BLOCKQUOTE></P><PCLASS="para">This prevents HUP from terminating your command and saves itsstandard and error output in a file. Actually, the following is just as good:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">nohup &quot;$@&quot; &gt; logfile 2&gt;&amp;1 &amp;</PRE></BLOCKQUOTE></P><PCLASS="para">If you understand why <BCLASS="emphasis.bold">eval</B> is essentially redundant when you use<BCLASS="emphasis.bold">nohup</B> in this case,then you have a firm grasp on the material in the previous chapter.<ACLASS="indexterm"NAME="AUTOID-14412"></A><ACLASS="indexterm"NAME="AUTOID-14413"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-4.4">8.4.4 Resetting Traps</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-TRAPS-RESETTING-DEFAULTS"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-TRAP-COMMAND-RESET-DEFAULT"></A>Another &quot;special case&quot; of the <BCLASS="emphasis.bold">trap</B> command occurs when you givea dash (<BCLASS="emphasis.bold">-</B>) as the command argument. This resets the action taken when the signal is received to the default, which usually is termination of the process.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-MAIL-N"></A>As an example of this, let's return to Task 8-2, our mail program.  After theuser has finished sending the message, the temporary file is erased.At that point, since there is no longer any need to &quot;clean up,&quot; wecan reset the signal trap to its default state. The codefor this, apart from function definitions, is:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">trap abortmsg INTtrap cleanup TERMmsgfile=/tmp/msg$$cat &gt; $msgfile# send the contents of $msgfile to the specified mail address...rm $msgfiletrap - INT TERM</PRE></BLOCKQUOTE></P><PCLASS="para">The last line of this code resets the handlers for the INT and TERMsignals.<ACLASS="indexterm"NAME="AUTOID-14431"></A><ACLASS="indexterm"NAME="AUTOID-14432"></A></P><PCLASS="para">At this point you may be thinking that one could get seriouslycarried away with signal handling in a shell script. It is true that &quot;industrial strength&quot; programs devote considerableamounts of code to dealing with signals. But these programs are almostalways large enough so that the signal-handling code is a tiny fractionof the whole thing. For example, you can bet that the real UNIX<EMCLASS="emphasis">mail</EM> system is pretty darn bullet-proof.</P><PCLASS="para">However, you will probably never write a shell script thatis complex enough, and that needs to be robust enough, to merit lotsof signal handling. You may write a <EMCLASS="emphasis">prototype</EM> for a programas large as <EMCLASS="emphasis">mail</EM> in shell code, but prototypes by definitiondo not need to be bullet-proofed.  <ACLASS="indexterm"NAME="AUTOID-14438"></A></P><PCLASS="para">Therefore, you shouldn't worry aboutputting signal-handling code in every 20-line shell script you write.Our advice is to determine if there are any situations in which a signalcould cause your program to do something seriously bad and addcode to deal with those contingencies. What is &quot;seriously bad&quot;?Well, with respect to the above examples, we'd say that the casewhere HUP causes your job to terminate on logout <EMCLASS="emphasis">is</EM> seriously bad,while the temporary file situation in our mail program is not.</P><PCLASS="para">The Korn shell has several new options to <BCLASS="emphasis.bold">trap</B> (with respectto the same command in most Bourne shells) that make it usefulas an aid for debugging shell scripts. We'll cover these in the next chapter.<ACLASS="indexterm"NAME="AUTOID-14443"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_03.htm"TITLE="8.3 Signals"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 8.3 Signals"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_05.htm"TITLE="8.5 Coroutines"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 8.5 Coroutines"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">8.3 Signals</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">8.5 Coroutines</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>