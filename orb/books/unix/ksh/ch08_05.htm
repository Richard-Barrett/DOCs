<HTML><HEAD><TITLE>[Chapter 8] 8.5 Coroutines</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:15:32Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch08_01.htm"TITLE="8. Process Handling"><LINKREL="prev"HREF="ch08_04.htm"TITLE="8.4 trap"><LINKREL="next"HREF="ch08_06.htm"TITLE="8.6 Subshells"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_04.htm"TITLE="8.4 trap"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 8.4 trap"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 8<BR>Process Handling</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_06.htm"TITLE="8.6 Subshells"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 8.6 Subshells"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-8-SECT-5">8.5 Coroutines</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-COROUTINES"></A>We've spent the last several pages on almost microscopic detailsof process behavior. Rather than continue our descent into the murkydepths, we'll revert to a higher-level view of processes.</P><PCLASS="para">Earlier in this chapter, wecovered ways of controlling multiple simultaneous jobs within an interactive login session; now we'll consider multiple process controlwithin shell programs.  <ACLASS="indexterm"NAME="AUTOID-14450"></A>When two (or more) processes are explicitlyprogrammed to run simultaneously and possibly communicate with eachother, we call them <EMCLASS="emphasis">coroutines</EM>.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-COROUTINES-PIPELINES-AS-EXAMPLE"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-PIPELINES"></A>This is actually nothing new: a pipeline is an example of coroutines. The shell's pipeline construct encapsulates a fairly sophisticated set of rules about how processes interact with each other. If we take a closer look at these rules, we'll be better able to understand other ways of handling coroutines-most of which turn out to be simpler than pipelines.</P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-PIPELINES-SYSTEM-CALLS-USED-IN"></A><ACLASS="indexterm"NAME="AUTOID-14464"></A><ACLASS="indexterm"NAME="AUTOID-14466"></A>When you invoke a simple pipeline, say <BCLASS="emphasis.bold">ls | more</B>, the shell invokes a series of UNIX primitive operations, a.k.a. <EMCLASS="emphasis">system calls</EM>.In effect, the shell tells UNIX to do the following things;in case you're interested, we include in parenthesesthe actual system call used at each step:<ACLASS="indexterm"NAME="AUTOID-14470"></A><ACLASS="indexterm"NAME="AUTOID-14473"></A><ACLASS="indexterm"NAME="AUTOID-14476"></A><ACLASS="indexterm"NAME="AUTOID-14479"></A></P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Create two subprocesses, which we'll call P1 and P2 (the <EMCLASS="emphasis">fork</EM> system call).</P></LI><LICLASS="listitem"><PCLASS="para">Set up I/O between the processes so that P1's standard output feeds into P2's standard input (<EMCLASS="emphasis">pipe</EM>).</P></LI><LICLASS="listitem"><PCLASS="para">Start <EMCLASS="emphasis">/bin/ls</EM> in process P1 (<EMCLASS="emphasis">exec</EM>).</P></LI><LICLASS="listitem"><PCLASS="para">Start <EMCLASS="emphasis">/bin/more</EM> in process P2 (<EMCLASS="emphasis">exec</EM>).</P></LI><LICLASS="listitem"><PCLASS="para">Wait for both processes to finish (<EMCLASS="emphasis">wait</EM>).</P></LI></OL><PCLASS="para">You can probably imagine how the above steps change when the pipeline involves more than two processes.<ACLASS="indexterm"NAME="AUTOID-14501"></A><ACLASS="indexterm"NAME="AUTOID-14502"></A><ACLASS="indexterm"NAME="AUTOID-14503"></A></P><PCLASS="para">Now let's make things simpler. We'll see how to get multiple processes to run at the same time if the processes do not need to communicate. For example, we want the processes <BCLASS="emphasis.bold">dave</B> and <BCLASS="emphasis.bold">bob</B> to run as coroutines, without communication, in a shell script. Our initial solution would be this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">dave &amp;bob</PRE></BLOCKQUOTE></P><PCLASS="para">Assume for the moment that <BCLASS="emphasis.bold">bob</B> is the last command in the script.  The above will work-but only if <BCLASS="emphasis.bold">dave</B> finishes first.  <ACLASS="indexterm"NAME="AUTOID-14512"></A>If  <BCLASS="emphasis.bold">dave</B> is still running when the script finishes, then it becomes an <EMCLASS="emphasis">orphan</EM>, i.e., it enters one of the &quot;funny states&quot; we mentioned earlier in this chapter. Never mind the details of orphanhood; just believe that you don't want this to happen, and if it does, you mayneed to use the &quot;runaway process&quot; method of stopping it, discussedearlier in this chapter.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-5.1">8.5.1 wait</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-WAIT"></A>There is a way of making sure the script doesn't finish before <BCLASS="emphasis.bold">dave</B> does: the built-in command <BCLASS="emphasis.bold">wait</B>. Without arguments, <BCLASS="emphasis.bold">wait</B> simply waits until all background jobs have finished. So to make sure the above code behaves properly, we would add <BCLASS="emphasis.bold">wait</B>, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">dave &amp;bobwait</PRE></BLOCKQUOTE></P><PCLASS="para">Here, if <BCLASS="emphasis.bold">bob</B> finishes first, the parent shell will wait for <BCLASS="emphasis.bold">dave</B> to finish before finishing itself.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14532"></A>If your script has more than one background job and you need to wait for specific ones to finish, you can give <BCLASS="emphasis.bold">wait</B> the same type of job argument (with a percent sign) as you would use with <BCLASS="emphasis.bold">kill</B>, <BCLASS="emphasis.bold">fg</B>, or <BCLASS="emphasis.bold">bg</B>.  </P><PCLASS="para">However, you will probably find that <BCLASS="emphasis.bold">wait</B> without arguments suffices for all coroutines you will ever program.  Situations in which you would need to wait for specific background jobs are quite complex and beyond the scope of this book.<ACLASS="indexterm"NAME="AUTOID-14541"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-5.2">8.5.2 Advantages and Disadvantages of Coroutines</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-COROUTINES-PERFORMANCE-ISSUES"></A>In fact, you may be wondering why you would ever need to program coroutines that don't communicate with each other. For example, why not just run <BCLASS="emphasis.bold">bob</B> after <BCLASS="emphasis.bold">dave</B> in the usual way? What advantage is there in running the two jobs simultaneously?  </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14551"></A>If you are running on a computer with one processor (CPU), then there is a performanceadvantage-but only if you have the <BCLASS="emphasis.bold">bgnice</B> option turned off(see <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3, Customizing Your Environment</A>), and even then only in certain situations.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14557"></A>Roughly speaking, you cancharacterize a process in terms of how it uses system resources inthree ways: whether it is <EMCLASS="emphasis">CPU intensive</EM> (e.g., does lots ofnumber crunching), <EMCLASS="emphasis">I/O intensive</EM> (does a lot of reading orwriting to the disk), or <EMCLASS="emphasis">interactive</EM> (requires userintervention).  </P><PCLASS="para">We already know from <ACLASS="xref"HREF="ch01_01.htm"TITLE="Korn Shell Basics">Chapter 1</A> that it makes no sense to run aninteractive job in the background. But apart from that,the more two or more processes differ with respect to these threecriteria, the more advantage there is in running them simultaneously.  For example, a number-crunching statistical calculation would do wellwhen running at the same time as a long, I/O-intensive database query.</P><PCLASS="para">On the other hand, if two processes use resources in similar ways,it may even be less efficient to run them at the same timeas it would be to run them sequentially. Why? Basically, becauseunder such circumstances, the operating system often has to &quot;time-slice&quot; the resource(s) in contention.  </P><PCLASS="para">For example, if bothprocesses are &quot;disk hogs,&quot; the operating system may enter a modewhere it constantly switches control of the disk back and forth between thetwo competing processes; the system ends up spending at least asmuch time doing the switching as it does on the processes themselves.<ACLASS="indexterm"NAME="AUTOID-14567"></A>This phenomenon is known as <EMCLASS="emphasis">thrashing</EM>; at its most severe,it can cause a system to come to a virtual standstill.Thrashing is a common problem; system administrators and operating system designers both spend lots of time trying to minimize it.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-5.3">8.5.3 Parallelization</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-COROUTINES-MULTIPLE-CPUS"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-PARALLELIZING-SHELL-SCRIPTS"></A>But if you have a computer with multiple CPUs (such as a Pyramid, Sequent, or Sun MP), you should be less concerned about thrashing.Furthermore, coroutines can provide dramatic increases in speed on this type of machine, which is often called a<EMCLASS="emphasis">parallel</EM> computer; analogously,breaking up a process into coroutines is sometimes called <EMCLASS="emphasis">parallelizing</EM> the job.  </P><PCLASS="para">Normally, when you start a background job on a multiple-CPU machine,the computer will assign it to the next available processor. This means that the two jobs are actually-not just metaphorically-running at the same time.  </P><PCLASS="para">In this case, the running time of the coroutines is essentially equal to that of the longest-running job plus a bit of overhead, instead of the sum of the run times of all processes (although if the CPUs all sharea common disk drive, the possibility of I/O-related thrashing stillexists). In the best case-all jobs having the same run time and no I/O contention-you get aspeedup factor equal to the number of jobs.<ACLASS="indexterm"NAME="AUTOID-14583"></A></P><PCLASS="para">Parallelizing a program is often not easy; there are severalsubtle issues involved and there's plenty of room for error.Nevertheless,it's worthwhile to know how to parallelize a shell script whether ornot you have a parallel machine, especially since such machines arebecoming more and more common.</P><PCLASS="para">We'll show how to do this-and give you an idea of some of theproblems involved-by means of a simple task whose solution is amenable to parallelization.</P><DIVCLASS="task"><H4>Task 8.3</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para">Write a utility that allows you to make multiple copies ofa file at the same time.</P></BLOCKQUOTE><PCLASS="para">We'll call this script <EMCLASS="emphasis">mcp</EM>. The command <BCLASS="emphasis.bold">mcp</B> <EMCLASS="emphasis">filename dest1 dest2 ...</EM> should copy <EMCLASS="emphasis">filename</EM>to all of the destinations given. The code for this should be fairly obvious:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">file=$1shiftfor dest in &quot;$@&quot;; do    cp $file $destdone</PRE></BLOCKQUOTE></P><PCLASS="para">Now let's say we have a parallel computer and we want this commandto run as fast as possible.  <ACLASS="indexterm"NAME="AUTOID-14597"></A>To parallelize this script, it's a simplematter of firing off the <EMCLASS="emphasis">cp</EM> commands in the backgroundand adding a <BCLASS="emphasis.bold">wait</B> at the end:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">file=$1shiftfor dest in &quot;$@&quot;; do    cp $file $dest &amp;donewait</PRE></BLOCKQUOTE></P><PCLASS="para">Simple, right? Well, there is one little problem:what happens if the user specifies duplicate destinations?If you're lucky, the file just gets copied to the same place twice.  Otherwise, the identical <EMCLASS="emphasis">cp</EM> commands will interfere with each other, possibly resulting in a file that contains two interspersed copiesof the original file. In contrast, if you give the regular <EMCLASS="emphasis">cp</EM>command two arguments that point to the same file, it will print anerror message and do nothing.</P><PCLASS="para">To fix this problem, we would have to write code that checks theargument list for duplicates. Although this isn't too hard to do(see the exercises at the end of this chapter), the time it takesthat code to run might offset any gain in speed from parallelization;furthermore, the code that does the checking detracts from thesimple elegance of the script.</P><PCLASS="para">As you can see, even a seemingly trivial parallelization taskhas problems resulting from multiple processes having concurrentaccess to a given system resource (a file in this case).Such problems, known as <EMCLASS="emphasis">concurrency control</EM> issues, becomemuch more difficult as the complexity of the applicationincreases. Complex concurrent programs often have much morecode for handling the special cases than for the actual jobthe program is supposed to do!</P><PCLASS="para">Therefore it shouldn't surprise you that much research has beenand is being done on parallelization, the ultimate goal beingto devise a tool that parallelizes code automatically.  (Such tools do exist; they usually work in the confines of somenarrow subset of the problem.)Even if you don't have access to a multiple-CPU machine, parallelizing a shell script is an interesting exercise that should acquaint you with some of the issues that surround coroutines.<ACLASS="indexterm"NAME="AUTOID-14610"></A><ACLASS="indexterm"NAME="AUTOID-14611"></A></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-5.4">8.5.4 Coroutines with Two-way Pipes</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14615"></A><ACLASS="indexterm"NAME="AUTOID-14619"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-TWO-WAY-PIPES"></A>Now that we have seen how to program coroutines that don't communicatewith each other, we'll build on that foundation and discuss how toget them to communicate-in a more sophisticated way than with a pipeline. The Korn shell hasa set of features that allow programmers to set up two-way communication between coroutines.  <ACLASS="indexterm"NAME="AUTOID-14625"></A>These features aren't included in most Bourne shells.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14628"></A><ACLASS="indexterm"NAME="AUTOID-14631"></A><ACLASS="indexterm"NAME="AUTOID-14634"></A>If you start a background process by appending <BCLASS="emphasis.bold">|&amp;</B> to a commandinstead of <BCLASS="emphasis.bold">&amp;</B>, the Korn shell will set up a special two-way pipeline between the parent shell and the new background process.  <ACLASS="indexterm"NAME="AUTOID-14639"></A><ACLASS="indexterm"NAME="AUTOID-14643"></A><BCLASS="emphasis.bold">read -p</B> in the parent shell reads a line of the backgroundprocess' standard output; similarly, <BCLASS="emphasis.bold">print -p</B> in the parent shell feeds into the standard input of the background process. <ACLASS="xref"HREF="ch08_05.htm#KSH-CH-8-FIG-1"TITLE="Coroutine I/O">Figure 8.2</A> shows how this works.<ACLASS="indexterm"NAME="AUTOID-14650"></A></P><H4CLASS="figure"><ACLASS="title"NAME="KSH-CH-8-FIG-1">Figure 8.2: Coroutine I/O</A></H4><IMGCLASS="graphic"SRC="figs/korn0802.gif"ALT="Figure 8.2"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14657"></A>This scheme has some intriguing possibilities. Notice the following things: first, the parent shell communicates with the background process independently of its own standard input and output. Second, the background process need not have any idea that a shell script is communicating with it in this manner. This means that the background process can be any pre-existing program that uses its standard input and output in normal ways.</P><PCLASS="para">Here's a task that shows a simple example:</P><DIVCLASS="task"><H4>Task 8.4</H4><BLOCKQUOTECLASS="taskinfo"><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-DC"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-REVERSE-POLISH-NOTATION-RPN"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-ALGEBRAIC-NOTATION"></A>You would like to have an online calculator, but the existing UNIXutility <EMCLASS="emphasis">dc</EM>(1) uses Reverse Polish Notation (RPN), <EMCLASS="emphasis">a la</EM> Hewlett-Packard calculators. You'd rather have one that works like the $3.95 model you got with that magazine subscription. Write a calculator program that accepts standard algebraic notation.</P></BLOCKQUOTE><PCLASS="para">The objective here is to write the program without re-implementing the calculation engine that <EMCLASS="emphasis">dc</EM> already has-in other words, to write a program that translates algebraic notation to RPN and passes the translated line to <EMCLASS="emphasis">dc</EM> to do the actual calculation.[12]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[12] <ACLASS="indexterm"NAME="AUTOID-14677"></A>The utility <EMCLASS="emphasis">bc</EM>(1) actually provides similar functionality.</P></BLOCKQUOTE><PCLASS="para">We'll assume that the function <EMCLASS="emphasis">alg2rpn</EM>, which does the translation, already exists: given a line of algebraic notation asargument, it prints the RPN equivalent on the standard output. If we have this, then the calculator program (which we'll call <EMCLASS="emphasis">adc</EM>) is very simple:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">dc |&amp;while read line'?adc&gt; '; do    print -p &quot;$(alg2rpn $line)&quot;    read -p answer    print &quot;    = $answer&quot;done</PRE></BLOCKQUOTE></P><PCLASS="para">The first line of this code starts <EMCLASS="emphasis">dc</EM> as a coroutine with a two-way pipe. Then the <BCLASS="emphasis.bold">while</B> loop prompts the user for a lineand reads it until the user types <KBDCLASS="keycap">[CTRL-D]</KBD> for end-of-input.The loop body converts the line to RPN, passes it to <EMCLASS="emphasis">dc</EM> through the pipe, reads <EMCLASS="emphasis">dc</EM>'s answer, and prints it after an equal sign.  For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">adc</B>adc&gt; <BCLASS="emphasis.bold">2 + 3</B>    = 5adc&gt; <BCLASS="emphasis.bold">(7 * 8) + 54</B>    = 110adc&gt; <BCLASS="emphasis.bold">^D</B>$</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14698"></A><ACLASS="indexterm"NAME="AUTOID-14699"></A><ACLASS="indexterm"NAME="AUTOID-14700"></A>Actually-as you may have noticed-it's not entirely necessary to have a two-way pipe with <EMCLASS="emphasis">dc</EM>. You could do it with a standard pipe and let <EMCLASS="emphasis">dc</EM> do its own output, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">{ while read line'?adc&gt; '; do      print &quot;$(alg2rpn $line)&quot;  done } | dc</PRE></BLOCKQUOTE></P><PCLASS="para">The only difference from the above is the lack of equal sign before each answer is printed.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14707"></A><ACLASS="indexterm"NAME="AUTOID-14709"></A>But: what if you wanted to make a fancy graphical user interface (GUI), like the <EMCLASS="emphasis">xcalc</EM> program that comes with many X Window System installations? Then, clearly, <EMCLASS="emphasis">dc</EM>'s own output would not be satisfactory, and you would need full control of your own standard output in the parent process. The user interface would have to capture <EMCLASS="emphasis">dc</EM>'s output and display it in the window properly.  The two-way pipe is an excellent solution to this problem: just imagine that, instead of <BCLASS="emphasis.bold">print &quot;    = $answer</B>&quot;, there is a call to a routine that displays the answer in the &quot;readout&quot;section of the calculator window.<ACLASS="indexterm"NAME="AUTOID-14715"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14717"></A>All of this suggests that the two-way pipe scheme is great for writing shell scripts that interpose a software layer between the user (or some other program) and an existing program that uses standard input and output. In particular, it's great for writing new interfaces to old, standard UNIX programs that expect line-at-a-time, character-based user input and output. The new interfaces could be GUIs, or they could be network interface programs that talk to users over links to remote machines. In other words, the Korn shell's two-way pipe construct is designed to help develop very up-to-date software!</P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-5.5">8.5.5 Two-way Pipes Versus Standard Pipes</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-TWO-WAY-PIPES-COMP-STD-PIPES"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-PIPES-COMPARED-TO-TWO-WAY-PIPES"></A>Before we leave the subject of coroutines, we'll complete the circle by showing how the two-way pipe construct compares to regular pipelines.  <ACLASS="indexterm"NAME="AUTOID-14729"></A><ACLASS="indexterm"NAME="AUTOID-14732"></A>As you may have been able to figure out by now, it is possible to program a standard pipeline by using <BCLASS="emphasis.bold">|&amp;</B> with <BCLASS="emphasis.bold">print -p</B>.  </P><PCLASS="para">This has the advantage of reserving the parent shell's standard output for other use.  <ACLASS="indexterm"NAME="AUTOID-14739"></A>The disadvantage is that the child process' standard output is directed to the two-way pipe: if the parent process doesn't read it with <BCLASS="emphasis.bold">read -p</B>, then it's effectively lost.<ACLASS="indexterm"NAME="AUTOID-14744"></A><ACLASS="indexterm"NAME="AUTOID-14745"></A><ACLASS="indexterm"NAME="AUTOID-14746"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_04.htm"TITLE="8.4 trap"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 8.4 trap"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_06.htm"TITLE="8.6 Subshells"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 8.6 Subshells"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">8.4 trap</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">8.6 Subshells</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>