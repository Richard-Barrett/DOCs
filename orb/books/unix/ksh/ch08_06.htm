<HTML><HEAD><TITLE>[Chapter 8] 8.6 Subshells</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:15:46Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch08_01.htm"TITLE="8. Process Handling"><LINKREL="prev"HREF="ch08_05.htm"TITLE="8.5 Coroutines"><LINKREL="next"HREF="ch09_01.htm"TITLE="9. Debugging Shell Programs"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_05.htm"TITLE="8.5 Coroutines"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 8.5 Coroutines"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 8<BR>Process Handling</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch09_01.htm"TITLE="9. Debugging Shell Programs"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 9. Debugging Shell Programs"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-8-SECT-6">8.6 Subshells</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-SUBSHELLS"></A>Coroutines clearly represent the most complex relationship betweenprocesses that the Korn shell defines. To conclude this chapter, we will look at a much simpler type of interprocess relationship:that of a subshell with its parent shell.We saw in <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A> that whenever you run a shell script, you actuallyinvoke another copy of the shell that is a subprocessof the main, or <EMCLASS="emphasis">parent</EM>, shell process. Now let's look atsubshells in more detail.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-6.1">8.6.1 Subshell Inheritance</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-SSHS-INHER-PROPS-PARENT-SHELLS"></A>The most important things you need to know about subshells are whatcharacteristics they get, or <EMCLASS="emphasis">inherit</EM>, from their parents.These are as follows:<ACLASS="indexterm"NAME="AUTOID-14761"></A><ACLASS="indexterm"NAME="AUTOID-14764"></A><ACLASS="indexterm"NAME="AUTOID-14768"></A></P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">The current directory</P></LI><LICLASS="listitem"><PCLASS="para">Environment variables</P></LI><LICLASS="listitem"><PCLASS="para">Standard input, output, and error plus any other open file descriptors</P></LI><LICLASS="listitem"><PCLASS="para">Any characteristics defined in the environment file (see <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A>)</P></LI><LICLASS="listitem"><PCLASS="para">Signals that are ignored</P></LI></UL><PCLASS="para">The first three of these are inherited by all subprocesses, whilethe last is unique to subshells.Just as important are the things that a subshell does not inheritfrom its parent:<ACLASS="indexterm"NAME="AUTOID-14784"></A><ACLASS="indexterm"NAME="AUTOID-14787"></A></P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Shell variables, except environment variables and thosedefined in the environment file</P></LI><LICLASS="listitem"><PCLASS="para">Handling of signals that are not ignored</P></LI></UL><PCLASS="para">We covered some of this earlier (in <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A>), but these points are common sources of confusion, so they bear repeating.<ACLASS="indexterm"NAME="AUTOID-14797"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-8-SECT-6.2">8.6.2 Nested Subshells</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-SUBSHELLS-NESTED"></A>Subshells need not be in separate scripts;you can also start a subshell within the same script (or function)as the parent.  <ACLASS="indexterm"NAME="AUTOID-14804"></A>You do this in a manner very similar to the code blocks we saw in the last chapter.Just surround some shell code with parentheses (instead of curly brackets), and that code will run in a subshell.We'll call this a <EMCLASS="emphasis">nested</EM> subshell. </P><PCLASS="para">For example, here is the calculator program, from above,with a subshell instead of a code block:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">( while read line'?adc&gt; '; do      print &quot;$(alg2rpn $line)&quot;  done ) | dc</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-8-IX-CODE-BLOCKS-VS-NESTED-SUBSHELLS"></A><ACLASS="indexterm"NAME="KSH-CH-8-IX-SSHS-NEST-COMPAR-CODE-BLOCKS"></A>The code inside the parentheses will run as a separate process.This is usually less efficient than a code block.The differences in functionality between subshells and code blocksare very few; they primarily pertain to issues of scope, i.e.,the domains in which definitions of things like shell variables and signal traps are known. First, code inside a nested subshell obeysthe above rules of subshell inheritance, except that it knows about variables defined in the surrounding shell; in contrast, think of blocks as code units that inherit <EMCLASS="emphasis">everything</EM> from the outer shell.Second, variablesand traps defined inside a code block are known to the shellcode after the block, whereas those defined in a subshell are not.</P><PCLASS="para">For example, consider this code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">{    fred=bob    trap 'print \'You hit CTRL-C!\'' INT}while true; do    print &quot;\$fred is $fred&quot;    sleep 60done</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14824"></A><ACLASS="indexterm"NAME="AUTOID-14826"></A><ACLASS="indexterm"NAME="AUTOID-14828"></A>If you run this code, you will see the message <BCLASS="emphasis.bold">$fred is bob</B> every60 seconds, and if you type <SPANCLASS="acronym">CTRL-C</SPAN>, you will see the message, <BCLASS="emphasis.bold">You hitCTRL-C!</B>.  You will need to type <SPANCLASS="acronym">CTRL-\</SPAN>&nbsp;to stop it (don't forget toremove the <EMCLASS="emphasis">core</EM> file). Now let's change it to a nested subshell:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">(    fred=bob    trap 'print \'You hit CTRL-C!\'' INT)while true; do    print &quot;\$fred is $fred&quot;    sleep 60done</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14839"></A>If you run this, you will see the message <BCLASS="emphasis.bold">$fred is</B>; the outer shelldoesn't know about the subshell's definition of <BCLASS="emphasis.bold">fred</B> and thereforethinks it's null. Furthermore, the outer shell doesn't know aboutthe subshell's trap of the INT signal, so if you hit <SPANCLASS="acronym">CTRL-C</SPAN>, the scriptwill terminate.</P><PCLASS="para">If a language supports code nesting,then it's considered desirable that definitions inside a nested unit have a scope limited to that nested unit. In other words, nestedsubshells give you better control than code blocksover the scope of variables and signal traps.  Therefore we feel that you should usesubshells instead of code blocks if they are to contain variabledefinitions or signal traps-unless efficiency is a concern.<ACLASS="indexterm"NAME="AUTOID-14846"></A><ACLASS="indexterm"NAME="AUTOID-14847"></A><ACLASS="indexterm"NAME="AUTOID-14848"></A><ACLASS="indexterm"NAME="AUTOID-14849"></A></P><PCLASS="para">This has been a long chapter, and it has covered a lot of territory.  Here are some exercises that should help you make sure you have afirm grasp on the material. The last exercise is especiallydifficult for those without backgrounds in compilers, parsingtheory, or formal language theory.</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14854"></A><ACLASS="indexterm"NAME="AUTOID-14856"></A><ACLASS="indexterm"NAME="AUTOID-14858"></A><ACLASS="indexterm"NAME="AUTOID-14860"></A>Write a shell script called <EMCLASS="emphasis">pinfo</EM> that combines the <BCLASS="emphasis.bold">jobs</B>and <EMCLASS="emphasis">ps</EM> commands by printing a list of jobs with their job numbers,corresponding process IDs, running times, and full commands.</P></LI><LICLASS="listitem"><PCLASS="para">Take the latest version of our C compiler shell script-orsome other non-trivial shell script-and &quot;bullet-proof&quot; it with signal traps.</P></LI><LICLASS="listitem"><PCLASS="para">Take the <EMCLASS="emphasis">non-pipeline</EM> version of our C compiler-or some other non-trivial shell script-and parallelize it as much as possible. </P></LI><LICLASS="listitem"><PCLASS="para">Write the code that checks for duplicate arguments to the <EMCLASS="emphasis">mcp</EM>script. Bear in mind that different pathnames can pointto the same file. (Hint: if <BCLASS="emphasis.bold">$i</B> is &quot;1&quot;, then <BCLASS="emphasis.bold">eval </B><CODECLASS="literal">'</CODE><BCLASS="emphasis.bold">print \${$i}</B><CODECLASS="literal">'</CODE> prints the first command-line argument.Make sure you understand why.)</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14880"></A><ACLASS="indexterm"NAME="AUTOID-14883"></A>Redo the <EMCLASS="emphasis">findterms</EM> program in the last chapter using a nested subshell instead of a code block.</P></LI><LICLASS="listitem"><PCLASS="para">(The following doesn't have that much to do with the material in this chapter <EMCLASS="emphasis">per se</EM>, but it is a classic programming exercise:)<OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Write the function <EMCLASS="emphasis">alg2rpn</EM> used in <EMCLASS="emphasis">adc</EM>. Here's how to do this:<ACLASS="indexterm"NAME="AUTOID-14894"></A><ACLASS="indexterm"NAME="AUTOID-14896"></A><ACLASS="indexterm"NAME="AUTOID-14898"></A>Arithmetic expressions in algebraic notation have the form <EMCLASS="emphasis">expr op expr</EM>, where each <EMCLASS="emphasis">expr</EM> is either a number or anotherexpression (perhaps in parentheses), and <EMCLASS="emphasis">op</EM> is +, -, &#215;, /,or <BCLASS="emphasis.bold">%</B> (remainder).In RPN, expressions have the form <EMCLASS="emphasis">expr expr op</EM>. For example:the algebraic expression <BCLASS="emphasis.bold">2</B>+<BCLASS="emphasis.bold">3</B> is <BCLASS="emphasis.bold">2 3 +</B> in RPN; the RPN equivalent of <BCLASS="emphasis.bold">(2+3) &#215;  (9-5)</B> is <BCLASS="emphasis.bold">2 3 +</B> 9 5 - &#215;.<ACLASS="indexterm"NAME="AUTOID-14910"></A>The main advantage of RPN is that it obviates the need for parentheses and operator precedence rules (e.g., &#215; is evaluated before +).The <EMCLASS="emphasis">dc</EM> program accepts standard RPN, but each expression shouldhave &quot;p&quot; appended to it: this tells <EMCLASS="emphasis">dc</EM> to print its result, e.g., the first example above should be given to <EMCLASS="emphasis">dc</EM> as <BCLASS="emphasis.bold">2 3 + p</B>.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14918"></A>You need to write a routine that converts algebraic notation to RPN.  This should be (or include) a function that calls itself(known as a <EMCLASS="emphasis">recursive</EM> function) whenever it encounters a subexpression. It is especially important that this function keeptrack of where it is in the input string and how much of the string it &quot;eats up&quot; during its processing. (Hint: make use of the pattern matching operators discussed in <ACLASS="xref"HREF="ch04_01.htm"TITLE="Basic Shell Programming">Chapter 4</A> to ease the task of parsing input strings.)  </P><PCLASS="para">To make your life easier, don't worry about operator precedence for now;just convert to RPN from left to right.e.g., treat <BCLASS="emphasis.bold">3+4&#215;5</B> as <BCLASS="emphasis.bold">(3+4)&#215;5</B> and <BCLASS="emphasis.bold">3&#215;4+5</B> as <BCLASS="emphasis.bold">(3&#215;4)+5</B>.  This makes it possible for you to convert the input string on the fly, i.e., without having to read in the whole thing before doing any processing.</P></LI><LICLASS="listitem"><PCLASS="para">Enhance your solution to the previous exercise so that it supportsoperator precedence in the &quot;usual&quot; order: &#215;, /, % (remainder) +, -.e.g., treat <BCLASS="emphasis.bold">3+4&#215;5</B> as <BCLASS="emphasis.bold">3+(4&#215;5)</B> and <BCLASS="emphasis.bold">3&#215;4+5</B> as <BCLASS="emphasis.bold">(3&#215;4)+5</B>.</P></LI></OL>&#13;</P></LI></OL></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_05.htm"TITLE="8.5 Coroutines"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 8.5 Coroutines"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch09_01.htm"TITLE="9. Debugging Shell Programs"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 9. Debugging Shell Programs"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">8.5 Coroutines</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">9. Debugging Shell Programs</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>