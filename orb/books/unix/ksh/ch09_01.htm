<HTML><HEAD><TITLE>[Chapter 9] Debugging Shell Programs</TITLE><METANAME="DC.title"CONTENT="Learning the Korn Shell"><METANAME="DC.creator"CONTENT="Bill Rosenblatt"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T21:16:12Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-054-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="index.htm"TITLE="Learning the Korn Shell"><LINKREL="prev"HREF="ch08_06.htm"TITLE="8.6 Subshells"><LINKREL="next"HREF="ch09_02.htm"TITLE="9.2 A Korn Shell Debugger"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the Korn Shell"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,66"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/ksrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_06.htm"TITLE="8.6 Subshells"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 8.6 Subshells"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 9</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch09_02.htm"TITLE="9.2 A Korn Shell Debugger"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 9.2 A Korn Shell Debugger"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="CHAPTER"><H1CLASS="chapter"><ACLASS="title"NAME="KSH-CH9-DEBUGSH">9. Debugging Shell Programs</A></H1><DIVCLASS="htmltoc"><P><B>Contents:</B><BR><ACLASS="sect1"HREF="#KSH-CH-9-SECT-1"TITLE="9.1 Basic Debugging Aids">Basic Debugging Aids</A><BR><ACLASS="sect1"HREF="ch09_02.htm"TITLE="9.2 A Korn Shell Debugger">A Korn Shell Debugger</A></P><P></P></DIV><PCLASS="para">We hope that we have convinced you thatthe Korn shell can be used as a serious UNIX programming environment.It certainly has enough features, control structures, etc.But another essential part of a programming environment is a setof powerful, integrated <EMCLASS="emphasis">support tools</EM>.  <ACLASS="indexterm"NAME="AUTOID-14938"></A><ACLASS="indexterm"NAME="AUTOID-14940"></A>For example,there is a wide assortment of screen editors, compilers,debuggers, profilers, cross-referencers, etc., for languages likeC and C++.  <ACLASS="indexterm"NAME="AUTOID-14942"></A><ACLASS="indexterm"NAME="AUTOID-14944"></A><ACLASS="indexterm"NAME="KSH-CH-9-IX-DEBUGGERS"></A>If you program in one of these languages,you probably take such tools for granted, and you wouldundoubtedly cringe at the thought of having to develop code with, say,the <EMCLASS="emphasis">ed</EM> editor and the <EMCLASS="emphasis">adb</EM> machine-language debugger.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14951"></A><ACLASS="indexterm"NAME="AUTOID-14953"></A>But what about programming support tools for the Korn shell? Ofcourse, you can use any editor you like, including <EMCLASS="emphasis">vi</EM> and<EMCLASS="emphasis">emacs</EM>. And because the shell is an interpreted language,you don't need a compiler.[1]But there are no other tools available. The most serious problemis the lack of a debugger.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] <ACLASS="indexterm"NAME="AUTOID-14959"></A>Actually, if you are really concerned about efficiency, thereare shell code compilers on the market; they convert shellscripts to C code that often runs quite a bit faster.</P></BLOCKQUOTE><PCLASS="para">This chapter addresses that lack. The shell does have a few features that help in debugging shell scripts; we'll see these in thefirst part of the chapter.  <ACLASS="indexterm"NAME="AUTOID-14962"></A>The Korn shell also has a couple ofnew features, not present in most Bourne shells, that make itpossible to implement a full-blown debugging tool.  <ACLASS="indexterm"NAME="AUTOID-14964"></A>We'll show these features; more importantly, we will present <EMCLASS="emphasis">kshdb</EM>,a Korn shell debugger that uses them. <EMCLASS="emphasis">kshdb</EM> is basic yetquite useable, and its implementation serves as an extended example ofvarious shell programming techniques from throughout this book.  </P><DIVCLASS="sect1"><H2CLASS="sect1"><ACLASS="title"NAME="KSH-CH-9-SECT-1">9.1 Basic Debugging Aids</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-9-IX-DEBUGGING-SHELL-CODE"></A><ACLASS="indexterm"NAME="AUTOID-14974"></A>What sort of functionality do you need to debug a program?At the most empirical level, you need a way of determining <EMCLASS="emphasis">what</EM>is causing your program to behave badly, and <EMCLASS="emphasis">where</EM> theproblem is in the code. You usually start with an obvious <EMCLASS="emphasis">what</EM>(such as an error message, inappropriate output, infinite loop, etc.),try to work backwards until you find a <EMCLASS="emphasis">what</EM> that is closer to the actual problem (e.g., a variable with a bad value, a bad optionto a command), and eventually arrive at the exact <EMCLASS="emphasis">where</EM> in yourprogram. Then you can worry about <EMCLASS="emphasis">how</EM> to fix it.</P><PCLASS="para">Notice that these steps represent a process of starting with obviousinformation and ending up with often obscure facts gleaned throughdeduction and intuition. Debugging aids make it easier to deduce andintuit by providing relevant information easily or even automatically,preferably without modifying your code.<ACLASS="indexterm"NAME="AUTOID-14985"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14987"></A><ACLASS="indexterm"NAME="AUTOID-14990"></A>The simplest debugging aid (for any language)is the output statement, <BCLASS="emphasis.bold">print</B> in the shell's case. Indeed, old-timer programmers debugged theirFORTRAN code by inserting <BCLASS="emphasis.bold">WRITE</B> cards into their decks.You can debug by puttinglots of <BCLASS="emphasis.bold">print</B> statements in your code(and removing them later), but you willhave to spend lots of time narrowing down not only <EMCLASS="emphasis">what</EM> exact information you want but also <EMCLASS="emphasis">where</EM> you need to see it.You will also probably have to wade through lots and lots ofoutput to find the information you really want.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-9-SECT-1.1">9.1.1 Set Options</A></H3><PCLASS="para">Luckily, the shell has a few basic features that give youdebugging functionality beyond that of <BCLASS="emphasis.bold">print</B>.The most basic of these are options to the <BCLASS="emphasis.bold">set -o</B> command(as covered in <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3, Customizing Your Environment</A>). These options can also beused on the command line when running a script, as <ACLASS="xref"HREF="ch09_01.htm#KSH-CH-9-TAB-0"TITLE="Debugging Options">Table 9.1</A> shows.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15007"></A><ACLASS="indexterm"NAME="AUTOID-15010"></A><ACLASS="indexterm"NAME="KSH-CH-9-IX-OPTIONS-VERBOSE"></A><ACLASS="indexterm"NAME="AUTOID-15018"></A><ACLASS="indexterm"NAME="AUTOID-15021"></A>The <BCLASS="emphasis.bold">verbose</B> option simply echoes (to standard error)whatever input the shell gets. Itis useful for finding the exact point atwhich a script is bombing. For example, assume your script lookslike this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">fredbobdavepeteedralph</PRE></BLOCKQUOTE></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-9-TAB-0">Table 9.1: Debugging Options</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">set -o Option</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Command-line Option</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Action</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">noexec</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-n</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Don't run commands; check for syntax errors only</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">verbose</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-v</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Echo commands before running them</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">xtrace</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BCLASS="emphasis.bold">-x</B></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Echo commands after command-line processing</P></TD></TR></TBODY></TABLE><PCLASS="para">None of these commands are standard UNIX programs, and they alldo their work silently. Say the scriptcrashes with a cryptic message like &quot;segmentation violation.&quot;  This tells you nothing about which command caused the error.If you type <BCLASS="emphasis.bold">ksh -v</B> <EMCLASS="emphasis">scriptname</EM>, you might see this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">fredbob davesegmentation violationpeteedralph</PRE></BLOCKQUOTE></P><PCLASS="para">Now you know that <BCLASS="emphasis.bold">dave</B> is the probable culprit-though it is alsopossible that <BCLASS="emphasis.bold">dave</B> bombed because of something it expected<BCLASS="emphasis.bold">fred</B> or <BCLASS="emphasis.bold">bob</B> to do (e.g., create an input file) thatthey did incorrectly.<ACLASS="indexterm"NAME="AUTOID-15067"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-9-IX-OPTIONS-XTRACE"></A><ACLASS="indexterm"NAME="AUTOID-15072"></A>The <BCLASS="emphasis.bold">xtrace</B> option is more powerful: it echoes command linesafter they have been through parameter substitution, command substitution,and the other steps of command-line processing (as listed in Chapter <ACLASS="xref"HREF="ch07_01.htm"TITLE="Input/Output and Command-line Processing">Chapter 7, Input/Output and Command-line Processing</A>). For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">set -o xtrace</B> $ <BCLASS="emphasis.bold">fred=bob</B> + fred=bob$ <BCLASS="emphasis.bold">print &quot;$fred&quot;</B> + print bobbob$ <BCLASS="emphasis.bold">ls -l $(whence emacs)</B> + whence emacs+ ls -l /usr/share/bin/emacs-rwxr-xr-x  1 root      1593344 Apr  8  1991 /usr/share/bin/emacs$</PRE></BLOCKQUOTE></P><PCLASS="para">As you can see, <BCLASS="emphasis.bold">xtrace</B> starts each line it prints with <BCLASS="emphasis.bold">+</B>.<ACLASS="indexterm"NAME="KSH-CH-9-IX-BUILT-IN-VARIABLES-PS4"></A><ACLASS="indexterm"NAME="KSH-CH-9-IX-OPTIONS-XTRACE-PS4-PROMPT"></A><ACLASS="indexterm"NAME="KSH-CH-9-IX-PS4"></A>This is actually customizable: it's the value of the built-in shell variable<BCLASS="emphasis.bold">PS4</B>. So if you set <BCLASS="emphasis.bold">PS4</B>to &quot;<BCLASS="emphasis.bold">xtrace</B><BCLASS="emphasis.bold">-&gt;</B> &quot;(e.g., in your <EMCLASS="emphasis">.profile</EM> or environment file), then you'll get<BCLASS="emphasis.bold">xtrace</B> listings that look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">ls -l $(whence emacs)</B> xtrace-&gt; whence emacsxtrace-&gt; ls -l /usr/share/bin/emacs-rwxr-xr-x  1 root      1593344 Apr  8  1991 /usr/share/bin/emacs$</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15105"></A><ACLASS="indexterm"NAME="AUTOID-15108"></A>An even better way of customizing <BCLASS="emphasis.bold">PS4</B> is to use abuilt-in variable we haven't seen yet: <BCLASS="emphasis.bold">LINENO</B>, whichholds the number of the currently running line in a shell script.Put this line in your <EMCLASS="emphasis">.profile</EM> or environment file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PS4='line $LINENO: '</PRE></BLOCKQUOTE></P><PCLASS="para">We use the same technique as we did with <BCLASS="emphasis.bold">PS1</B> in<ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A>: using single quotes to postponethe evaluation of the string until each time the shell prints the prompt.This will print messages of the form <BCLASS="emphasis.bold">line</B> <EMCLASS="emphasis">N</EM><BCLASS="emphasis.bold">:</B> in yourtrace output.  <ACLASS="indexterm"NAME="AUTOID-15121"></A>You could even include the name of the shellscript you're debugging in this prompt by using the positional parameter <BCLASS="emphasis.bold">$0</B>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">PS4='$0 line $LINENO: '</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15127"></A><ACLASS="indexterm"NAME="AUTOID-15128"></A><ACLASS="indexterm"NAME="AUTOID-15129"></A>As another example, say you are trying to track down a bugin a script called <BCLASS="emphasis.bold">fred</B> that contains this code:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">dbfmq=$1.fmq...fndrs=$(cut -f3 -d' ' $dfbmq)</PRE></BLOCKQUOTE></P><PCLASS="para">You type <BCLASS="emphasis.bold">fred bob</B> to run it in the normal way, and it hangs.Then you type <BCLASS="emphasis.bold">ksh -x fred bob</B>, and you see this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">+ dbfmq=bob.fmq...+ + cut -f3 -d</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15139"></A>It hangs again at this point. You notice that <EMCLASS="emphasis">cut</EM> doesn'thave a filename argument, which means that there must be somethingwrong with the variable <BCLASS="emphasis.bold">dbfmq</B>. But it has executed the assignmentstatement <BCLASS="emphasis.bold">dbfmq=bob.fmq</B> properly... ah-<EMCLASS="emphasis">hah</EM>!You made a typo in the variable name inside the command substitutionconstruct.  [2]You fix it, and the script works properly.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] We should admit that if you turned on the <BCLASS="emphasis.bold">nounset</B> optionat the top of this script, the shell would have flagged this error.</P></BLOCKQUOTE><PCLASS="para">If the code you are trying to debug calls functions that are definedelsewhere (e.g., in your <EMCLASS="emphasis">.profile</EM> or environment file), you cantrace through these in the same way with an option to the <BCLASS="emphasis.bold">typeset</B>command.  <ACLASS="indexterm"NAME="AUTOID-15151"></A><ACLASS="indexterm"NAME="AUTOID-15155"></A><ACLASS="indexterm"NAME="AUTOID-15159"></A>Just enter the command <BCLASS="emphasis.bold">typeset -ft</B> <EMCLASS="emphasis">functname</EM>,and the named function will be traced whenever it runs. Type<BCLASS="emphasis.bold">typeset +ft</B> <EMCLASS="emphasis">functname</EM> to turn tracing off.<ACLASS="indexterm"NAME="AUTOID-15166"></A></P><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-9-IX-OPTIONS-NOEXEC"></A>The last option is <BCLASS="emphasis.bold">noexec</B>, which reads in the shell script,checks for syntax errors, but doesn't execute anything. It's worth usingif your script is syntactically complex (lots of loops,code blocks, string operators, etc.) and the bughas side effects (like creating a large fileor hanging up the system).</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15173"></A><ACLASS="indexterm"NAME="AUTOID-15176"></A><ACLASS="indexterm"NAME="AUTOID-15179"></A><ACLASS="indexterm"NAME="AUTOID-15182"></A>You can turn on these options with <BCLASS="emphasis.bold">set -o</B> in your shell scripts,and, as explained in <ACLASS="xref"HREF="ch03_01.htm"TITLE="Customizing Your Environment">Chapter 3</A>, turn them off with <BCLASS="emphasis.bold">set +o</B> <EMCLASS="emphasis">option</EM>. For example, if you're debugging ascript with a nasty side effect, and you have localized it to a certain chunk of code, you can precede that chunk with<BCLASS="emphasis.bold">set -o noexec</B> (and, perhaps, close it with<BCLASS="emphasis.bold">set +o noexec</B>) to avoid the side effect.<ACLASS="indexterm"NAME="AUTOID-15192"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="KSH-CH-9-SECT-1.2">9.1.2 Fake Signals</A></H3><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-9-IX-FAKE-SIGNALS"></A><ACLASS="indexterm"NAME="AUTOID-15198"></A><ACLASS="indexterm"NAME="AUTOID-15202"></A><ACLASS="indexterm"NAME="AUTOID-15206"></A><ACLASS="indexterm"NAME="AUTOID-15210"></A><ACLASS="indexterm"NAME="KSH-CH-9-IX-TRAPS-TRAPPING-FAKE-SIGNALS"></A>A more sophisticated set of debugging aids is the shell's three&quot;fake signals,&quot; which can be used in <BCLASS="emphasis.bold">trap</B> statements toget the shell to act under certain conditions. Recall from the previous chapter that <BCLASS="emphasis.bold">trap</B> allows you to install somecode that runs when a particular signal is sent to your script.</P><PCLASS="para">Fake signals act like real ones, but they are generated bythe shell (as opposed to real signals, which the underlying operatingsystem generates). They represent runtime events that are likely tobe interesting to debuggers-both human ones and software tools-andcan be treated just like real signals within shell scripts.The three fake signals and their meanings are listed in <ACLASS="xref"HREF="ch09_01.htm#KSH-CH-9-TAB-1"TITLE="Fake Signals">Table 9.2</A>.<ACLASS="indexterm"NAME="KSH-CH-9-IX-FAKE-SIGNALS-EXIT"></A><ACLASS="indexterm"NAME="AUTOID-15224"></A><ACLASS="indexterm"NAME="AUTOID-15227"></A></P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="KSH-CH-9-TAB-1">Table 9.2: Fake Signals</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Fake Signal</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">When Sent</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">EXIT</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">The shell exits from a function or script</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">ERR</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">A command returns a non-0 exit status</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">DEBUG</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">After every statement</P></TD></TR></TBODY></TABLE><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-9-SECT-1.2.1">9.1.2.1 EXIT</A></H4><PCLASS="para">The EXIT trap, when set, will run its code when the function orscript within which it was set exits.  Here's a simple example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function func {    print 'start of the function'    trap 'print /'exiting from the function/'' EXIT}print 'start of the script'trap 'print /'exiting from the script/'' EXITfunc</PRE></BLOCKQUOTE></P><PCLASS="para">If you run this script, you will see this output:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">start of the scriptstart of the functionexiting from the functionexiting from the script</PRE></BLOCKQUOTE></P><PCLASS="para">In other words, the script starts by printing a message. Thenit sets the trap for its own exit, then calls the function.The function does the same-prints a message and sets a trap forits exit. (Remember that functions can have their own localtraps that supersede any traps set by the surrounding script.)</P><PCLASS="para">The function then exits, which causes the shell to sendit the fake signal EXIT, which in turn runs the code <BCLASS="emphasis.bold">print</B> <CODECLASS="literal">'</CODE>exiting from the function<CODECLASS="literal">'</CODE>. Then the script exits, and its ownEXIT trap code is run.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15264"></A><ACLASS="indexterm"NAME="AUTOID-15267"></A>An EXIT trap occurs no matter how the script or function exits-whethernormally (by finishing the last statement),by an explicit <BCLASS="emphasis.bold">exit</B> or <BCLASS="emphasis.bold">return</B> statement, or by receiving a &quot;real&quot;signal such as INT or TERM. Consider the following inane number-guessingprogram:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">trap 'print /'Thank you for playing!/'' EXITmagicnum=$(($RANDOM%10+1))print 'Guess a number between 1 and 10:'while read guess'?number&gt; '; do    sleep 10    if (( $guess == $magicnum )); then        print 'Right!'        exit    fi    print 'Wrong!'done</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-15275"></A><ACLASS="indexterm"NAME="AUTOID-15277"></A>This program picks a number between 1 and 10 by getting a randomnumber (the built-in variable <BCLASS="emphasis.bold">RANDOM</B>), extracting the lastdigit (the remainder when divided by 10), and adding 1. Thenit prompts you for a guess, andafter 10 seconds, it will tell you if you guessed right.</P><PCLASS="para">If you did, the program will exit with the message, &quot;Thankyou for playing!&quot;, i.e., it will run the EXIT trap code.If you were wrong, it will prompt youagain and repeat the process until you get it right.<ACLASS="indexterm"NAME="AUTOID-15282"></A>If you get bored with this little gameand hit <BCLASS="emphasis.bold"><KBDCLASS="keycap">[CTRL-C]</KBD></B> while waiting for it to tell youwhether you were right, you will also see the message.<ACLASS="indexterm"NAME="AUTOID-15286"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-9-SECT-1.2.2">9.1.2.2 ERR</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-9-IX-FAKE-SIGNALS-ERR"></A><ACLASS="indexterm"NAME="KSH-CH-9-IX-EXIT-STATUS-TRAPPING-WHEN-NON-0"></A>The fake signal ERR enables you to run code whenever a commandin the surrounding script or function exits with non-zero status.<ACLASS="indexterm"NAME="AUTOID-15296"></A><ACLASS="indexterm"NAME="AUTOID-15299"></A>Trap code for ERR can take advantage of the built-invariable <CODECLASS="literal">?</CODE>, which holds the exit status of the previous command.It &quot;survives&quot; the trap and is accessible at the beginning of thetrap-handling code.</P><PCLASS="para">A simple but effective use of this is to put the following codeinto a script you want to debug:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function errtrap {    es=$?    print &quot;ERROR: Command exited with status $es.&quot;}trap errtrap ERR</PRE></BLOCKQUOTE></P><PCLASS="para">The first line saves the non-zero exit status in the variable <BCLASS="emphasis.bold">es</B>.This code enables you to see which command in your scriptexits with error status and what the status is.  </P><PCLASS="para">For example, if the shell can't find a command, it returns status 1.If you put the code in a script with a line of gibberish(like &quot;lskdjfafd&quot;), the shell will respond with:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="replaceable"><I>scriptname</I></CODE>[<CODECLASS="replaceable"><I>N</I></CODE>]: lskdjfafd:  not foundERROR: command exited with status 1.</PRE></BLOCKQUOTE></P><PCLASS="para"><EMCLASS="emphasis">N</EM> is the number of the line in the script that containsthe bad command. In this case, the shell prints the line numberas part of its own error-reporting mechanism, since the errorwas a command that the shell could not find. But if the non-0exit status comes from another program, the shell won't reportthe line number. For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function errtrap {    es=$?    print &quot;ERROR: Command exited with status $es.&quot;}trap errtrap ERRfunction bad {    return 17}bad</PRE></BLOCKQUOTE></P><PCLASS="para">This will only print, <BCLASS="emphasis.bold">ERROR: Command exited with status 17.</B></P><PCLASS="para">It would obviously be an improvement to include the line numberin this error message.  <ACLASS="indexterm"NAME="AUTOID-15320"></A><ACLASS="indexterm"NAME="AUTOID-15322"></A>The built-in variable LINENO exists,  but if you use it inside a function,it evaluates to the line number in the function, not in the overallfile. In other words, if you used <BCLASS="emphasis.bold">$LINENO</B> in the <BCLASS="emphasis.bold">print</B> statementin the <BCLASS="emphasis.bold">errtrap</B> routine, it would always evaluate to 2.</P><PCLASS="para">To get around this problem, we simply pass <BCLASS="emphasis.bold">$LINENO</B> as anargument to the trap handler, surrounding it in single quotesso that it doesn't get evaluated until the fake signal actuallycomes in:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function errtrap {    es=$?    print &quot;ERROR line $1: Command exited with status $es.&quot;}trap 'errtrap $LINENO' ERR...</PRE></BLOCKQUOTE></P><PCLASS="para">If you use this with the above example, the result is the message,<BCLASS="emphasis.bold">ERROR line 12: Command exited with status 17.</B> This is much more useful. We'll see a variation on this technique shortly.</P><PCLASS="para">This simple code is actually not a bad all-purpose debuggingmechanism. It takes into account that a non-0 exit statusdoes not necessarily indicate an undesirable condition or event:remember that every control construct with a conditional(<BCLASS="emphasis.bold">if</B>, <BCLASS="emphasis.bold">while</B>, etc.) uses a non-0 exit status tomean &quot;false&quot;.  Accordingly, the shell doesn't generate ERR trapswhen statements or expressions in the &quot;condition&quot; parts of control structures produce non-0 exit statuses.</P><PCLASS="para">But a disadvantage is that exit statuses are not as uniform(or even as meaningful) as they should be-as we explained in<ACLASS="xref"HREF="ch05_01.htm"TITLE="Flow Control">Chapter 5, Flow Control</A>. A particular exit status need not say anything about the nature of the error or eventhat there was an error.  <ACLASS="indexterm"NAME="AUTOID-15339"></A><ACLASS="indexterm"NAME="AUTOID-15340"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="KSH-CH-9-SECT-1.2.3">9.1.2.3 DEBUG</A></H4><PCLASS="para"><ACLASS="indexterm"NAME="KSH-CH-9-IX-FAKE-SIGNALS-DEBUG"></A><ACLASS="indexterm"NAME="KSH-CH-9-IX-TRAPS-AFTER-EVERY-STATEMENT"></A>The final fake signal, DEBUG, causes the trap code to be run afterevery statement in the surrounding function or script.This has two possible uses. First is the use for humans, as asort of a &quot;brute force&quot; method of tracking a certain element ofa program's state that you notice is going awry.</P><PCLASS="para">For example, you notice that the value of a particular variableis running amok. The naive approach would be to put in lots of<EMCLASS="emphasis">print</EM> statements to check the variable's value at severalpoints. The DEBUG trap makes this easier by letting you dothis:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">function dbgtrap {    print &quot;<EMCLASS="emphasis">badvar</EM>  is $<EMCLASS="emphasis">badvar</EM> &quot;}trap dbgtrap DEBUG...<EMCLASS="emphasis">section of code in which problem occurs...</EM> trap - DEBUG		# turn off DEBUG trap&#13;</PRE></BLOCKQUOTE></P><PCLASS="para">This code will print the value of the wayward variable after everystatement between the two <BCLASS="emphasis.bold">trap</B>s.</P><PCLASS="para">The second and far more important use of the DEBUG trap is asa primitive for implementing Korn shell debuggers. In fact, it wouldbe fair to say that the DEBUG trap reduces the task of implementinga useful shell debugger from a large-scale software development project to a manageable exercise. Read on.<ACLASS="indexterm"NAME="AUTOID-15360"></A><ACLASS="indexterm"NAME="AUTOID-15361"></A><ACLASS="indexterm"NAME="AUTOID-15362"></A><ACLASS="indexterm"NAME="AUTOID-15363"></A></P></DIV></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch08_06.htm"TITLE="8.6 Subshells"><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 8.6 Subshells"BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the Korn Shell"><IMGSRC="../gifs/txthome.gif"ALT="Learning the Korn Shell"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch09_02.htm"TITLE="9.2 A Korn Shell Debugger"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 9.2 A Korn Shell Debugger"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">8.6 Subshells</TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">9.2 A Korn Shell Debugger</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>