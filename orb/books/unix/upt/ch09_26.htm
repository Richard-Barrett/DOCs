<HTML><HEAD><TITLE>[Chapter 9] 9.26 Expect </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:35:36Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch09_01.htm"TITLE="9. Saving Time on the Command Line"><LINKREL="prev"HREF="ch09_25.htm"TITLE="9.25 The C Shell repeat Command "><LINKREL="next"HREF="ch10_01.htm"TITLE="10. Aliases"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch09_25.htm"TITLE="9.25 The C Shell repeat Command "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 9.25 The C Shell repeat Command "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 9<BR>Saving Time on the Command Line</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch10_01.htm"TITLE="10. Aliases"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 10. Aliases"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-9912">9.26 Expect </A></H2><TABLECLASS="para.programreference"BORDER="1"><TR><THVALIGN="TOP"><ACLASS="programreference"HREF="examples/index.htm"TITLE="expect">expect</A><BR></TH><TDVALIGN="TOP"><ACLASS="indexterm"NAME="AUTOID-11484"></A>Expect is a program to control interactive applications such as<SPANCLASS="link"><EMCLASS="emphasis">telnet</EM> (<ACLASS="linkend"HREF="ch01_33.htm"TITLE="UNIX Networking and Communications ">1.33</A>)</SPAN>and <EMCLASS="emphasis">passwd</EM>.These and many other applications interactively prompt andexpect a user to enter keystrokes in response.But you can write simple Expect scripts to automate theseinteractions.Then the Expect program can run the &quot;interactive&quot; programnon-interactively.Expect can also be used to automate only parts of a dialogue, sincecontrol can be passed from the script to the keyboard and vice versa.This allows a script to do the drudgery and a user to do the fun stuff.</TD></TR></TABLE><TABLECLASS="para.programreference"BORDER="1"><TR><THVALIGN="TOP"><ACLASS="programreference"HREF="examples/index.htm"TITLE="tcl">tcl</A><BR><ACLASS="programreference"HREF="examples/index.htm"TITLE="tk">tk</A><BR></TH><TDVALIGN="TOP">Expect programs can be written in any language, but are almost alwayswritten using Tcl.Tcl is an interpreted language that is widely usedin many other applications.<ACLASS="indexterm"NAME="AUTOID-11492"></A>If you already use a Tcl-based application, you won't have to learn anew language for Expect.</TD></TR></TABLE><PCLASS="para">Tcl is a very typical-looking shell-like language.There are commands to set variables (<EMCLASS="emphasis">set</EM>), control flow(<EMCLASS="emphasis">if</EM>, <EMCLASS="emphasis">while</EM>, <EMCLASS="emphasis">foreach</EM>, etc.),and perform the usual math and string operations.Of course, UNIX programs can be called, too.</P><PCLASS="para">Expect is integrated on top of Tcl and provides additional commandsfor interacting with programs.Expect is named after the specific command that waits for output from aprogram.The <EMCLASS="emphasis">expect</EM> command is the heart of the Expect program.The <EMCLASS="emphasis">expect</EM> command describes a list of patterns to watch for.Each pattern is followed by an action.If the pattern is found, the action is executed.</P><PCLASS="para">For example, the following fragment is from a script thatinvolves a login.When executed, the script waits for the strings <CODECLASS="literal">welcome</CODE>,<CODECLASS="literal">failed</CODE>, or <CODECLASS="literal">busy</CODE>, and then it evaluates[(executes)-<EMCLASS="emphasis">JP</EM>&nbsp;]one of the corresponding actions.The action associated with busy shows how multiple commandscan be evaluated.<ACLASS="indexterm"NAME="AUTOID-11507"></A>The timeout keyword is a special pattern thatmatches if no other patterns match in a certain amount of time.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">expect {   &quot;welcome&quot; break   &quot;failed&quot;  abort   timeout   abort   &quot;busy&quot;    {        puts &quot;I'll wait - the system is busy!&quot;        continue    }}</PRE></BLOCKQUOTE></P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-9912-SECT-1.1">9.26.1 Dialback </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11514"></A>It is surprising how little scripting is necessary to producesomething useful.Below is a script that dials a phone.It is used to reverse the charges so that long-distance phone calls arecharged to the computer.It is invoked with the phone number as its argument.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">spawn tip modemexpect &quot;connected&quot;send &quot;ATD$argv\r&quot;# modem takes a while to connectset timeout 60expect &quot;CONNECT&quot;</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11519"></A>The first line runs the <EMCLASS="emphasis">tip</EM> program so that the output of a modem canbe read by <EMCLASS="emphasis">expect</EM> and its input written by <EMCLASS="emphasis">send</EM>.Once <EMCLASS="emphasis">tip</EM> says it is connected, the modem is told to dial using thecommand <CODECLASS="literal">ATD</CODE> followed by the phone number.The phone number is retrieved from <EMCLASS="emphasis">argv</EM>, which is a variable predefinedto contain the original argument with which the script was called.</P><PCLASS="para">The fourth line is just a comment noting that the variable being setin the next line controls how long <EMCLASS="emphasis">expect</EM> will wait before giving up.At this point, the script waits for the call to complete.No matter what happens, <EMCLASS="emphasis">expect</EM> terminates.If the call succeeds, the system detects that a user is connected andprompts with <CODECLASS="literal">login:</CODE>.</P><PCLASS="para">Actual scripts do more error checking, of course.For example, the script could retry if the call fails.But the point here is that it does not take much code to produce usefulscripts.This six-line script replaced a 60Kb executable (written in C) that didthe same thing!</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-9912-SECT-1.2">9.26.2 Automating /bin/passwd </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="UPT-ART-9912-IX-AUTOMATIC-PASSWD-COMMAND-USE"></A><ACLASS="indexterm"NAME="UPT-ART-9912-IX-PASSWD-COMMAND"></A>Earlier I mentioned some programs that cannot be automated with theshell.It is difficult to imagine why you might even want to embedsome of these programs in shell scripts.Certainly the original authors of the programs did not conceive of thisneed.As an example, consider <EMCLASS="emphasis">passwd</EM>.</P><PCLASS="para"><EMCLASS="emphasis">passwd</EM> is the command to change a password.The <EMCLASS="emphasis">passwd</EM> program does not take the new password from the command line.Instead, it interactively prompts for it&nbsp;- twice.Here is what it looks like when run by a system administrator.(When run by users, the interaction is slightly more complex becausethey are prompted for their old passwords as well.)</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"># <CODECLASS="userinput"><B>passwd libes</B></CODE>Changing password for libes on thunder.New password:Retype new password:</PRE></BLOCKQUOTE></P><PCLASS="para">This is fine for a single password.But suppose you have accounts of your own on a number of unrelatedcomputers and you would like them all to have the same password.Or suppose you are a system administrator establishing 1000 accounts atthe beginning of each semester.All of a sudden, an automated <EMCLASS="emphasis">passwd</EM> makes a lot of sense.Here is an Expect script to do just that:automate <EMCLASS="emphasis">passwd</EM> so that it can be called from a shell script.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">spawn passwd [lindex $argv 0]set password [lindex $argv 1]expect &quot;password:&quot;send &quot;$password\r&quot;expect &quot;password:&quot;send &quot;$password\r&quot;expect eof</PRE></BLOCKQUOTE></P><PCLASS="para">The first line starts the <EMCLASS="emphasis">passwd</EM> program with the username passed asan argument.The next line saves the password in a variable for convenience.As in shell scripts, variables do not have to be declared in advance.</P><PCLASS="para">In the third line, the <EMCLASS="emphasis">expect</EM> command looks for the pattern<CODECLASS="literal">password:</CODE>.<EMCLASS="emphasis">expect</EM> waits until the pattern is found before continuing.</P><PCLASS="para">After receiving the prompt, the next line sends a password to thecurrent process.The <EMCLASS="emphasis">\r</EM> indicates a carriage-return.(Most of the usual C string conventions are supported.)There are two <EMCLASS="emphasis">expect</EM>-<EMCLASS="emphasis">send</EM> sequences because<EMCLASS="emphasis">passwd</EM> asks the password tobe typed twice as a spelling verification.There is no point to this in a non-interactive <EMCLASS="emphasis">passwd</EM>,but the script has to do it because <EMCLASS="emphasis">passwd</EM> assumes it isinteracting with a human who does not type consistently.</P><PCLASS="para">The final command <CODECLASS="literal">expect&nbsp;eof</CODE> causes the script to wait for theend-of-file in the output of <EMCLASS="emphasis">passwd</EM>.Similar to <EMCLASS="emphasis">timeout</EM>, <EMCLASS="emphasis">eof</EM> is another keyword pattern.This final <EMCLASS="emphasis">expect</EM> effectively waits for <EMCLASS="emphasis">passwd</EM> tocomplete execution before returning control to the script.</P><PCLASS="para">Take a step back for a moment.Consider that this problem could be solved in a different way.You could edit the source to <EMCLASS="emphasis">passwd</EM> (should you be so lucky as tohave it) and modify it so that given an optional flag, it reads itsarguments from the command line just the way that the Expectscript does.If you lack the source and have to write <EMCLASS="emphasis">passwd</EM> from scratch, ofcourse, then you will have to worry about how to encrypt passwords,lock and write the password database, etc.In fact, even if you only modify the existing code, you may find itsurprisingly complicated code to look at.The <EMCLASS="emphasis">passwd</EM> program does some very tricky things.If you do get it to work, pray that nothingchanges when your system is upgraded.If the vendor adds NIS, Kerberos, shadow passwords, a differentencryption function, or some other new feature, you will have torevisit the code.</P><PCLASS="para">Expect comes with many example scripts that demonstrate how you cando many things that are impossible with traditional shells.For example, the <EMCLASS="emphasis">passmass</EM> script lets you update your password onmany unrelated machines simultaneously.The <EMCLASS="emphasis">rftp</EM> script provides your regular <EMCLASS="emphasis">ftp</EM> client withadditional commands to do recursive FTP in either direction.The <EMCLASS="emphasis">cryptdir</EM> script encrypts all the files in a directory.And an amusing script is provided that lets two <EMCLASS="emphasis">chess</EM>processes play each other.Expect has no limit to the number of interactive programs it can driveat the same time.[The UNIX system may limit Expect, though, by controlling themaximum number of processes or other system resources available. -<EMCLASS="emphasis">JP</EM>&nbsp;]<ACLASS="indexterm"NAME="AUTOID-11583"></A><ACLASS="indexterm"NAME="AUTOID-11584"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-9912-SECT-1.3">9.26.3 Testing: A Story </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-11588"></A>Many people use Expect for testing.You can test interactive programs as easily as you can automate them.And hardware lends itself to testing with Expect, too.For example, we solved a thorny problem when we had to deal with anunreliable bank of modems.We were receiving dozens of calls each week reporting &quot;the modem is hung.&quot;No indication of which modem, of course.And it was always too late for us to ask the user to try somethingto investigate the problem.The connection was gone by then.Our solution was an Expect script that hourly connected to each modemand exercised it.Any problems were recorded so that we had a clear and full history ofeach modem's behavior.As soon as a defective or hung modem was encountered, theExpect script would send email to the system administrator.With this script in place, reports of modem problems from our usersdropped to zero.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-9912-SECT-1.4">9.26.4 Other Problems </A></H3><PCLASS="para">These are just a few of the problems that can be solved with Expect.And as with all Expect solutions, recompilation of the originalprograms is unnecessary.You don't even need the source code!Expect handles many other problems as well.For example, Expect can wrap existing interactive tools with GUI wrappers.This means you can wrap interactive programs with Motif-like frontendsto control applications by buttons, scrollbars, and other graphicelements.And Expect scripts work great as CGI scripts or from<SPANCLASS="link"><EMCLASS="emphasis">cron</EM> (<ACLASS="linkend"HREF="ch40_12.htm"TITLE="Periodic Program Execution: The cron Facility ">40.12</A>)</SPAN>or <EMCLASS="emphasis">inetd</EM>[the daemon that controls Internet services provided by asystem-<EMCLASS="emphasis">JP</EM>&nbsp;].Finally, learning Expect may be easier than you think.Expect can watch you interact and then produce an Expect script for you.Interaction automation can't get much easier than this!</P><PCLASS="para">More information on Expect is available in <EMCLASS="emphasis">Exploring Expect</EM>, byDon Libes, from O'Reilly &amp; Associates.</P></DIV><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">DL</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch09_25.htm"TITLE="9.25 The C Shell repeat Command "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 9.25 The C Shell repeat Command "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch10_01.htm"TITLE="10. Aliases"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 10. Aliases"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">9.25 The C Shell repeat Command </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">10. Aliases</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>