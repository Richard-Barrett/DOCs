<HTML><HEAD><TITLE>[Chapter 11] 11.7 History Substitutions </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:36:07Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch11_01.htm"TITLE="11. The Lessons of History"><LINKREL="prev"HREF="ch11_06.htm"TITLE="11.6 Using !$ for Safety with Wildcards "><LINKREL="next"HREF="ch11_08.htm"TITLE="11.8 Repeating a Cycle of Commands "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_06.htm"TITLE="11.6 Using !$ for Safety with Wildcards "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 11.6 Using !$ for Safety with Wildcards "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 11<BR>The Lessons of History</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_08.htm"TITLE="11.8 Repeating a Cycle of Commands "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 11.8 Repeating a Cycle of Commands "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-0237">11.7 History Substitutions </A></H2><PCLASS="para">[Although most of the examples here use <ICLASS="filename">echo</I> to demonstrateclearly just what is going on,you'll normally use history with other UNIX commands. -JP]</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12562"></A>The exclamation point (<CODECLASS="literal">!</CODE>) is the C shell's<SPANCLASS="link">default (<ACLASS="linkend"HREF="ch11_15.htm"TITLE="Changing C Shell History Characters with histchars ">11.15</A>)</SPAN>history substitutioncharacter.(It's used in <EMCLASS="emphasis">bash</EM>, too.)This allows you to recall previously entered commands and re-executethem without retyping.The number of commands saved is up to you.To set this number, put a line in your<SPANCLASS="link">shell setup file (<ACLASS="linkend"HREF="ch02_02.htm"TITLE="Shell Setup Files-Which, Where, and Why ">2.2</A>)</SPAN>like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">set history=40   <ICLASS="lineannotation">...C shell</I>HISTSIZE=40   <ICLASS="lineannotation">...bash, ksh</I></PRE></BLOCKQUOTE></P><PCLASS="para">This means that the C shell will save the last 40 commands.To list out these 40 commands use:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>history</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12579"></A><ACLASS="indexterm"NAME="AUTOID-12583"></A><ACLASS="indexterm"NAME="AUTOID-12587"></A>To see just the last ten commands in <EMCLASS="emphasis">csh</EM> or <EMCLASS="emphasis">bash</EM>,use <CODECLASS="literal">history&nbsp;10</CODE>.In the C shell, you can also list out the commands in reverse with<CODECLASS="literal">history&nbsp;-r</CODE>.</P><PCLASS="para">To use the <CODECLASS="literal">!</CODE> in a command line, you have several choices.Some of the following examples are more of a headache than they may beworth.But they are used mostly to<SPANCLASS="link">select arguments from the command line in aliases (<ACLASS="linkend"HREF="ch10_03.htm"TITLE="C Shell Aliases with Command-Line Arguments ">10.3</A>)</SPAN>.Here they are:<ACLASS="indexterm"NAME="UPT-ART-237-IX-EXCLAMATION-POINT-HISTORY-SUBSTITUTION-COMMANDS"></A></P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!!</B></CODE> repeats the last command.</P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!:</B></CODE> repeats the last command.This form is used if you want to add a <SPANCLASS="link">modifier (<ACLASS="linkend"HREF="ch09_06.htm"TITLE="String Editing (Colon) Operators ">9.6</A>)</SPAN>like:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo xy</B></CODE>xy% <CODECLASS="userinput"><B>!:s/xy/yx</B></CODE>echo yxyx</PRE></BLOCKQUOTE></P><PCLASS="para">The second <CODECLASS="literal">!</CODE> was left out.</P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!so</B></CODE> repeats the last command that starts with <CODECLASS="literal">so</CODE>.</P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!?fn?</B></CODE> repeats the last command that has <CODECLASS="literal">fn</CODE> anywhere in it.The string could be found in an argument or in the command name.This is opposed to <CODECLASS="literal">!fn</CODE>, in which <CODECLASS="literal">!fn</CODE> must be in a command name.(The last <CODECLASS="literal">?</CODE> need not be there.Thus <CODECLASS="literal">!?fn</CODE> means the same thing.)</P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!34</B></CODE> executes command number 34.You can find the appropriate history number when you list your history usingthe <EMCLASS="emphasis">history</EM> command, or by<SPANCLASS="link"> putting the history number in your prompt . (<ACLASS="linkend"HREF="ch07_02.htm"TITLE="Basics of Setting the Prompt ">7.2</A>)</SPAN></P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!! &amp;</B></CODE> adds an ampersand (<CODECLASS="literal">&amp;</CODE>) to the end of the last command,which executes it and places it into the background.You can add anything to the end of a previous command. For example: &#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cat -v foo</B></CODE>       ...% <CODECLASS="userinput"><B>!! | more</B></CODE>cat -v foo | more       ...</PRE></BLOCKQUOTE></P><PCLASS="para">In this case the shell will repeat the command to be executed and run it, addingthe pipe through the<SPANCLASS="link"><EMCLASS="emphasis">more</EM> (<ACLASS="linkend"HREF="ch25_03.htm"TITLE="Using more to Page Through Files ">25.3</A>)</SPAN>pager.Another common usage is:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cat -v foo</B></CODE>       ...% <CODECLASS="userinput"><B>!! &gt; out</B></CODE>cat -v foo &gt; out</PRE></BLOCKQUOTE></P><PCLASS="para">which returns the command but redirects the output into a file.</P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!:0</B></CODE> selects only the command name; rather than the entire command line.&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>/usr/bin/grep Ah fn1</B></CODE>       ...% <CODECLASS="userinput"><B>!:0 Bh fn2</B></CODE>/usr/bin/grep Bh fn2</PRE></BLOCKQUOTE></P><PCLASS="para">Note that as an <SPANCLASS="link">operator (<ACLASS="linkend"HREF="ch09_06.htm"TITLE="String Editing (Colon) Operators ">9.6</A>)</SPAN><CODECLASS="literal">:0</CODE> can be appended to these history substitutions as well.For example, <CODECLASS="literal">!!:0</CODE> will give the last command name, anda colon followed by any number will give the corresponding argument.For example:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cat fn fn1 fn2</B></CODE>       ...% <CODECLASS="userinput"><B>more !:3</B></CODE>more fn2       ...</PRE></BLOCKQUOTE></P><PCLASS="para">gives the third argument.</P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!:2-4</B></CODE>gives the second through the fourth argument, or any numbers you choose:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo 1 2 3 4 5</B></CODE>1 2 3 4 5% <CODECLASS="userinput"><B>echo !:2-4</B></CODE>echo 2 3 42 3 4</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!:-3</B></CODE> gives zero through the third argument, or any number you wish:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo 1 2 3 4</B></CODE>1 2 3 4% <CODECLASS="userinput"><B>echo !:-3</B></CODE>echo echo 1 2 3echo 1 2 3</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!^</B></CODE> gives the first argument of the previous command.This is the same as <CODECLASS="literal">!:1</CODE>.Remember that, just as the <CODECLASS="literal">^</CODE> (caret) is the beginning-of-lineanchor in<SPANCLASS="link">regular expressions (<ACLASS="linkend"HREF="ch26_04.htm"TITLE="Using Metacharacters in Regular Expressions ">26.4</A>)</SPAN>,<CODECLASS="literal">!^</CODE> gives the beginning history argument.&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cat fn fn1 fn2</B></CODE>       ...% <CODECLASS="userinput"><B>more !^</B></CODE>more fn       ...</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12694"></A><CODECLASS="userinput"><B>!$</B></CODE> gives the last argument of the last command.In the same way that <CODECLASS="literal">$</CODE> (dollar sign) is the end-of-line anchor inregular expressions,<CODECLASS="literal">!$</CODE> gives the ending history argument.Thus:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cat fn</B></CODE>       ...% <CODECLASS="userinput"><B>more !$</B></CODE>more fn       ...</PRE></BLOCKQUOTE></P><PCLASS="para">The new command (<CODECLASS="literal">more</CODE>) is given the last argument of the previouscommand.</P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!*</B></CODE> is shorthand for the first through the last argument.This is used a lot in aliases:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo 1 2 3 4 5</B></CODE>1 2 3 4 5% <CODECLASS="userinput"><B>echo !*</B></CODE>echo 1 2 3 4 51 2 3 4 5</PRE></BLOCKQUOTE></P><PCLASS="para">In an alias:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">alias vcat 'cat -v \!* | more'</PRE></BLOCKQUOTE></P><PCLASS="para">&#13;will pipe the output of<SPANCLASS="link"><EMCLASS="emphasis">cat -v</EM> (<ACLASS="linkend"HREF="ch25_07.htm"TITLE="Show Non-Printing Characters with cat -v or od -c ">25.7</A>)</SPAN>command through <EMCLASS="emphasis">more</EM>.The backslash (<CODECLASS="literal">\</CODE>) has to be there to hide the history character,<CODECLASS="literal">!</CODE>,until the alias is used-see article<ACLASS="xref"HREF="ch10_03.htm"TITLE="C Shell Aliases with Command-Line Arguments ">10.3</A>for more information.</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12726"></A><CODECLASS="userinput"><B>!:2*</B></CODE> gives the second through the last arguments:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo 1 2 3 4 5</B></CODE>1 2 3 4 5% <CODECLASS="userinput"><B>echo !:2*</B></CODE>echo 2 3 4 52 3 4 5</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!:2-</B></CODE> like <CODECLASS="literal">2*</CODE> but the last argument is dropped:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo 1 2 3 4 5</B></CODE>1 2 3 4 5% <CODECLASS="userinput"><B>echo !:2-</B></CODE>echo 2 3 42 3 4</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!?fn?%</B></CODE> gives the first word found that has <CODECLASS="literal">fn</CODE> in it:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>sort fn1 fn2 fn3</B></CODE>       ...% <CODECLASS="userinput"><B>echo !?fn?%</B></CODE>echo fn1fn1</PRE></BLOCKQUOTE></P><PCLASS="para">That found the <CODECLASS="literal">fn</CODE> in <CODECLASS="literal">fn1</CODE>.You can get wilder with:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo 1 2 3 4 5</B></CODE>1 2 3 4 5% <CODECLASS="userinput"><B>echo !?ec?^</B></CODE>echo 11</PRE></BLOCKQUOTE></P><PCLASS="para">That selected the command that had <CODECLASS="literal">ec</CODE> in it, and the caret (<CODECLASS="literal">^</CODE>)said to give the first argument of that command.You can also do something like:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo fn fn1 fn2</B></CODE>fn fn1 fn2% <CODECLASS="userinput"><B>echo !?fn1?^ !$</B></CODE>echo fn fn2fn fn2</PRE></BLOCKQUOTE></P><PCLASS="para">That cryptic command told the shell to look for a command that had<CODECLASS="literal">fn1</CODE> in it (<CODECLASS="literal">!?fn1?</CODE>), and gave the first argument of thatcommand (<CODECLASS="literal">^</CODE>).Then it gave the last argument (<CODECLASS="literal">!$</CODE>).</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-12775"></A><CODECLASS="userinput"><B>^xy^yx</B></CODE> is the<SPANCLASS="link">shorthand substitution (<ACLASS="linkend"HREF="ch11_03.htm"TITLE="My Favorite Is !$ ">11.3</A>, <ACLASS="linkend"HREF="ch11_05.htm"TITLE="My Favorite Is ^^ ">11.5</A>)</SPAN>command.In the case of:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo xxyyzzxx</B></CODE>xxyyzzxx% <CODECLASS="userinput"><B>^xx^ab</B></CODE>echo abyyzzxxabyyzzxx</PRE></BLOCKQUOTE></P><PCLASS="para">it replaced the characters <CODECLASS="literal">xx</CODE> with <CODECLASS="literal">ab</CODE>.This makes editing the previous command much easier.</P></LI><LICLASS="listitem"><PCLASS="para"><CODECLASS="userinput"><B>!!:s/xx/ab/</B></CODE>is doing the same thing as the previous example, but it is using thesubstitute command instead of the <CODECLASS="literal">^</CODE>.This works for any previous command, as in:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>more afile bfile</B></CODE>       ...% <CODECLASS="userinput"><B>echo xy</B></CODE>xy% <CODECLASS="userinput"><B>!m:s/b/c/</B></CODE>more afile cfile</PRE></BLOCKQUOTE></P><PCLASS="para">You do not have to use the slashes (<CODECLASS="literal">/</CODE>); any character can act as a delimiter.&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>!!:s:xy:yx</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">There we used the colons (<CODECLASS="literal">:</CODE>) [good when the word you're trying to edit contains a slash-<EMCLASS="emphasis">JP</EM> ].If you want to add more to the replacement, use <CODECLASS="literal">&amp;</CODE> to &quot;replay it&quot; and then addon whatever you like:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo xy</B></CODE>xy% <CODECLASS="userinput"><B>!!:s/xy/&amp;yx</B></CODE>echo xyyxxyyx</PRE></BLOCKQUOTE></P><PCLASS="para">The <CODECLASS="literal">&amp;</CODE> in the replacement part said to give what the searchpart found, which was the <CODECLASS="literal">xy</CODE> characters.</P><PCLASS="para">The search part, or left side, cannot include<SPANCLASS="link">metacharacters (<ACLASS="linkend"HREF="ch26_03.htm"TITLE="Understanding Expressions ">26.3</A>)</SPAN>.You must type the actual string you are looking for.</P><PCLASS="para">Also, the example above only replaces the first occurrence of <CODECLASS="literal">xy</CODE>.<ACLASS="indexterm"NAME="AUTOID-12816"></A>To replace them all, use <EMCLASS="emphasis">g</EM>:&#13;</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo xy xy xy xy</B></CODE>xy xy xy xy% <CODECLASS="userinput"><B>!!:s/xy/yx/</B></CODE>echo yx xy xy xyyx xy xy xy% <CODECLASS="userinput"><B>!!:gs/xy/yx/</B></CODE>echo yx yx yx yxyx yx yx yx</PRE></BLOCKQUOTE></P><PCLASS="para">The <EMCLASS="emphasis">g</EM> command in this case meant do all the <CODECLASS="literal">xy</CODE>s.And oddly enough, the <EMCLASS="emphasis">g</EM> has to come before the <EMCLASS="emphasis">s</EM> command.</P><PCLASS="para">Or you could have done:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo xy xy xy xy</B></CODE>xy xy xy xy% <CODECLASS="userinput"><B>!!:s/xy/yx/</B></CODE>echo yx xy xy xyyx xy xy xy% <CODECLASS="userinput"><B>!!:g&amp;</B></CODE>echo yx yx yx yxyx yx yx yx</PRE></BLOCKQUOTE></P><PCLASS="para">&#13;In that case, we told the shell to globally (<CODECLASS="literal">:g</CODE>) replace everymatched string from the last command with thelast substitution (<CODECLASS="literal">&amp;</CODE>).Without the <EMCLASS="emphasis">g</EM> command, the shells would have replaced just one more <CODECLASS="literal">xy</CODE> with <CODECLASS="literal">yx</CODE>.</P><PCLASS="para">[A &quot;global&quot; substitution works just once per word:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo xyzzy</B></CODE>xyzzy% <CODECLASS="userinput"><B>!!:gs/y/p/</B></CODE>echo xpzzyxpzzy</PRE></BLOCKQUOTE></P><PCLASS="para">The substitution above changed only the first <CODECLASS="literal">y</CODE>. <EMCLASS="emphasis">-TC</EM> ]</P></LI></UL><ACLASS="indexterm"NAME="AUTOID-12849"></A><ACLASS="indexterm"NAME="AUTOID-12850"></A><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">DR</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_06.htm"TITLE="11.6 Using !$ for Safety with Wildcards "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 11.6 Using !$ for Safety with Wildcards "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch11_08.htm"TITLE="11.8 Repeating a Cycle of Commands "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 11.8 Repeating a Cycle of Commands "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">11.6 Using !$ for Safety with Wildcards </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">11.8 Repeating a Cycle of Commands </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>