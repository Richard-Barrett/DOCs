<HTML><HEAD><TITLE>[Chapter 13] Redirecting Input and Output</TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:36:37Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="part02.htm"TITLE="II. Let the Computer Do the Dirty Work "><LINKREL="prev"HREF="ch12_09.htm"TITLE="12.9 Running Multiple Shell Sessions with screen "><LINKREL="next"HREF="ch13_02.htm"TITLE="13.2 One Argument with a cat Isn't Enough "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch12_09.htm"TITLE="12.9 Running Multiple Shell Sessions with screen "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 12.9 Running Multiple Shell Sessions with screen "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 13</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch13_02.htm"TITLE="13.2 One Argument with a cat Isn't Enough "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 13.2 One Argument with a cat Isn't Enough "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="CHAPTER"><H1CLASS="chapter"><ACLASS="title"NAME="UPT-CHP-13">13. Redirecting Input and Output</A></H1><DIVCLASS="htmltoc"><P><B>Contents:</B><BR><ACLASS="sect1"HREF="#UPT-ART-1023"TITLE="13.1 Using Standard Input and Output">Using Standard Input and Output</A><BR><ACLASS="sect1"HREF="ch13_02.htm"TITLE="13.2 One Argument with a cat Isn't Enough ">One Argument with a cat Isn't Enough </A><BR><ACLASS="sect1"HREF="ch13_03.htm"TITLE="13.3 Send (only) Standard Error Down a Pipe ">Send (only) Standard Error Down a Pipe </A><BR><ACLASS="sect1"HREF="ch13_04.htm"TITLE="13.4 Problems Piping to a Pager ">Problems Piping to a Pager </A><BR><ACLASS="sect1"HREF="ch13_05.htm"TITLE="13.5 Redirection in C Shell: Capture Errors, Too? ">Redirection in C Shell: Capture Errors, Too? </A><BR><ACLASS="sect1"HREF="ch13_06.htm"TITLE="13.6 Safe I/O Redirection with noclobber ">Safe I/O Redirection with noclobber </A><BR><ACLASS="sect1"HREF="ch13_07.htm"TITLE="13.7 The () Subshell Operators ">The () Subshell Operators </A><BR><ACLASS="sect1"HREF="ch13_08.htm"TITLE="13.8 Using {list} to Group Bourne Shell Commands ">Using {list} to Group Bourne Shell Commands </A><BR><ACLASS="sect1"HREF="ch13_09.htm"TITLE="13.9 Send Output Two or More Places with tee ">Send Output Two or More Places with tee </A><BR><ACLASS="sect1"HREF="ch13_10.htm"TITLE="13.10 How to tee Several Commands Into One File ">How to tee Several Commands Into One File </A><BR><ACLASS="sect1"HREF="ch13_11.htm"TITLE="13.11 tpipe-Redirecting stdout to More than One Place ">tpipe-Redirecting stdout to More than One Place </A><BR><ACLASS="sect1"HREF="ch13_12.htm"TITLE="13.12 Writing to Multiple Terminals for Demonstrations ">Writing to Multiple Terminals for Demonstrations </A><BR><ACLASS="sect1"HREF="ch13_13.htm"TITLE='13.13 The "Filename&quot; - '>The &quot;Filename&quot; - </A><BR><ACLASS="sect1"HREF="ch13_14.htm"TITLE="13.14 What Can You Do with an Empty File? ">What Can You Do with an Empty File? </A><BR><ACLASS="sect1"HREF="ch13_15.htm"TITLE="13.15 What to Do with a Full Bit Bucket :-) ">What to Do with a Full Bit Bucket <CODECLASS="literal">:-)</CODE> </A><BR><ACLASS="sect1"HREF="ch13_16.htm"TITLE="13.16 Store and Show Errors with logerrs ">Store and Show Errors with logerrs </A></P><P></P></DIV><DIVCLASS="sect1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-1023">13.1 Using Standard Input and Output</A></H2><PCLASS="para">There is absolutelyno difference between reading datafrom a file and reading data from a terminal.[1]Likewise, if aprogram's output consists entirely of alphanumeric characters andpunctuation, there is no difference between writing to a file, writingto a terminal, and writing to the input of another program (as in apipe).</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] If a program'sinput consists entirely of alphanumeric characters and punctuation (i.e., ASCII data or international (non-English) characters).</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-13926"></A><ACLASS="indexterm"NAME="AUTOID-13928"></A>The <EMCLASS="emphasis">standard I/O</EM> facility provides some simple defaults formanaging Input/Output. There are three default I/O streams: standard input,standard output, and standard error. By convention, standard output(abbreviated <EMCLASS="emphasis">stdout</EM>)consists of all &quot;normal&quot; output from your program, while standard error(<EMCLASS="emphasis">stderr</EM>) consists of error messages. It is often a convenience to beable to handle error messages and standard output separately.If you don't do anything special, programs will read standard inputfrom your keyboard, and they will send standard output and standarderror to your terminal's display.</P><PCLASS="para"><ACLASS="indexterm"NAME="UPT-ART-1023-IX-STDIN-STANDARD-INPUT"></A><ACLASS="indexterm"NAME="UPT-ART-1023-IX-INPUT-STDIN"></A>Standard input (<EMCLASS="emphasis">stdin</EM>) normally comes from your keyboard.Many programs ignore <EMCLASS="emphasis">stdin</EM>; you name files directlyon their command line&nbsp;- for instance, the command <EMCLASS="emphasis">cat&nbsp;file1&nbsp;file2</EM>never reads its standard input; it reads the files directly.But, without filenames on the command line, UNIX commands that need inputwill usually read <EMCLASS="emphasis">stdin</EM>.Standard input normally comes from your keyboard, but the shell canredirect <EMCLASS="emphasis">stdin</EM> from a file.This is handy for UNIX commands that can't open files directly&nbsp;- for instance,<SPANCLASS="link"><EMCLASS="emphasis">mail</EM> (<ACLASS="linkend"HREF="ch01_33.htm"TITLE="UNIX Networking and Communications ">1.33</A>)</SPAN>.To mail a file to <EMCLASS="emphasis">joan</EM>, use <CODECLASS="literal">&lt;&nbsp;</CODE><CODECLASS="replaceable"><I>filename</I></CODE>-to tell theshell to attach the file, instead of your keyboard, to <EMCLASS="emphasis">mail</EM>'s standardinput:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>mail joan &lt; myfile</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-13955"></A><ACLASS="indexterm"NAME="AUTOID-13958"></A>The real virtue of standard I/O is that it allows you to<EMCLASS="emphasis">redirect</EM> input or output away from your terminal to a file.As we said, UNIX is<SPANCLASS="link">file-based (<ACLASS="linkend"HREF="ch01_29.htm"TITLE="When Is a File Not a File? ">1.29</A>)</SPAN>.Because terminals and other I/Odevices are treated as files, a program doesn't care or even know[2]if it is sending its output to a terminal or to a file. For example, ifyou want to run the command <EMCLASS="emphasis">cat&nbsp;file1&nbsp;file2</EM>, but you want toplace the output in <EMCLASS="emphasis">file3</EM> rather than sending it to yourterminal, give the command:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] A program can find out.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cat file1 file2 &gt; file3</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">This is called <EMCLASS="emphasis">redirecting</EM> standard output to <EMCLASS="emphasis">file3</EM>. Ifyou give this command and look at <EMCLASS="emphasis">file3</EM> afterward,you will find the contents of <EMCLASS="emphasis">file1</EM>, followed by<EMCLASS="emphasis">file2</EM>-exactly what you would have seen on your screen if youomitted the <CODECLASS="literal">&gt;&nbsp;file3</CODE> modifier. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-13978"></A>One of the best-known forms of redirection in UNIX is the <EMCLASS="emphasis">pipe</EM>.The shell's vertical bar (<CODECLASS="literal">|</CODE>) operator makes a pipe.For example, to send both <EMCLASS="emphasis">file1</EM> and <EMCLASS="emphasis">file2</EM> together in a mailmessage for <EMCLASS="emphasis">joan</EM>, type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>cat file1 file2 | mail joan</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">The pipe says &quot;connect the standard output of the process at the left(<CODECLASS="literal">cat</CODE>) to the standard input of the process at the right(<CODECLASS="literal">mail</CODE>).&quot;</P><PCLASS="para">Article<ACLASS="xref"HREF="ch45_20.htm"TITLE="Overview: Open Files and File Descriptors ">45.20</A>has diagrams and more information about standard I/O and redirection.<ACLASS="xref"HREF="ch13_01.htm#UPT-ART-1023-TAB-0"TITLE="Common Standard I/O Redirections">Table 13.1</A>shows the mostcommon ways of redirecting standard I/O, for both the C shell and theBourne shell.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="UPT-ART-1023-TAB-0">Table 13.1: Common Standard I/O Redirections</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Function</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">csh</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">sh</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Send <EMCLASS="emphasis">stdout</EM> to <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &gt; <CODECLASS="replaceable"><I>file</I></CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &gt; <CODECLASS="replaceable"><I>file</I></CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Send <EMCLASS="emphasis">stderr</EM> to <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog 2&gt; <CODECLASS="replaceable"><I>file</I></CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Send <EMCLASS="emphasis">stdout</EM> and <EMCLASS="emphasis">stderr</EM> to <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &gt;&amp; <CODECLASS="replaceable"><I>file</I></CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &gt; <CODECLASS="replaceable"><I>file</I></CODE> 2&gt;&amp;1</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Take <EMCLASS="emphasis">stdin</EM> from <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &lt; <CODECLASS="replaceable"><I>file</I></CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &lt; <CODECLASS="replaceable"><I>file</I></CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Send <EMCLASS="emphasis">stdout</EM> to end of <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &gt;&gt; <CODECLASS="replaceable"><I>file</I></CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &gt;&gt; <CODECLASS="replaceable"><I>file</I></CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Send <EMCLASS="emphasis">stderr</EM> to end of <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog 2&gt;&gt; <CODECLASS="replaceable"><I>file</I></CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Send <EMCLASS="emphasis">stdout</EM> and <EMCLASS="emphasis">stderr</EM> to end of <EMCLASS="emphasis">file</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &gt;&gt;&amp; <CODECLASS="replaceable"><I>file</I></CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &gt;&gt; <CODECLASS="replaceable"><I>file</I></CODE> 2&gt;&amp;1</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Read <EMCLASS="emphasis">stdin</EM> from keyboard until <EMCLASS="emphasis">c</EM> (seearticle <ACLASS="xref"HREF="ch08_18.htm"TITLE="Here Documents ">8.18</A>)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &lt;&lt;<CODECLASS="replaceable"><I>c</I></CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog &lt;&lt;<CODECLASS="replaceable"><I>c</I></CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Pipe <EMCLASS="emphasis">stdout</EM> to <EMCLASS="emphasis">prog2</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog | prog2</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog | prog2</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Pipe <EMCLASS="emphasis">stdout</EM> and <EMCLASS="emphasis">stderr</EM> to <EMCLASS="emphasis">prog2</EM></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog |&amp; prog2</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">prog 2&gt;&amp;1 | prog2</TD></TR></TBODY></TABLE><PCLASS="para">Be aware that:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14086"></A>While standard I/O is a basic feature of UNIX, the syntax used toredirect standard I/O depends on the shell you are using. Bourneshell syntax and C shell syntax differ, particularly when you get intothe less commonly used features. The Korn shell and <EMCLASS="emphasis">bash</EM> arethe same as the Bourne shell, but with a few twists of their own.&#13;</P></LI><LICLASS="listitem"><PCLASS="para">You can redirect standard input and standard output in the same command line.For example, to read from the file <EMCLASS="emphasis">input</EM> and write to the file<EMCLASS="emphasis">output</EM>, give the command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>prog &lt; input &gt; output</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">The Bourne shell will let you go further and write <EMCLASS="emphasis">stderr</EM> to a third file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>prog &lt; input &gt; output 2&gt; errors</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14105"></A>The C shell doesn't give you an easy way to redirectstandard output without redirecting standard error. A simple trickwill help you do this. To put standard output and standard error indifferent files, give a command like:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>( prog &gt; output ) &gt;&amp; errors</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">We'll discuss commands like this in articles<ACLASS="xref"HREF="ch13_03.htm"TITLE="Send (only) Standard Error Down a Pipe ">13.3</A>and<ACLASS="xref"HREF="ch13_05.htm"TITLE="Redirection in C Shell: Capture Errors, Too? ">13.5</A>.</P></LI><LICLASS="listitem"><PCLASS="para">Many implementations of both shells don't care what order theredirections appear in, or even where they appear on the command line.For example, SunOS lets you type <CODECLASS="literal">&lt;</CODE>&nbsp;<CODECLASS="literal">input</CODE>&nbsp;<CODECLASS="literal">&gt;</CODE>&nbsp;<CODECLASS="literal">output</CODE>&nbsp;<CODECLASS="literal">prog</CODE>.However, clarity is always a virtue that computer users have neverappreciated enough. It will be easiest to understandwhat you are doing if you type the command name first&nbsp;- then redirect standardinput, followed by standard output, followed by standard error.</P></LI></UL><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14122"></A><SPANCLASS="link"> There are some more complex forms of standard I/O redirection,particularly for the Bourne shell . (<ACLASS="linkend"HREF="ch45_21.htm"TITLE="n&gt;&amp;m: Swap Standard Output and Standard Error ">45.21</A>, <ACLASS="linkend"HREF="ch45_22.htm"TITLE="Handling Files Line-by-Line ">45.22</A>, <ACLASS="linkend"HREF="ch45_23.htm"TITLE="The Ins and Outs of Redirected I/O Loops ">45.23</A>)</SPAN></P><PCLASS="para">Of course, programs aren't restricted to standard I/O. They can openother files, define their own special-purpose pipes, and writedirectly to the terminal. But standard I/O is the glue that allowsyou to make big programs out of smaller ones, and is therefore acrucial part of the operating system. Most UNIX utilities read their data from standard input and write their output to standardoutput, allowing you to combine them easily. A program that createsits own special-purpose pipe may be very useful, but it cannot beused in combination with standard utilities.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-14128"></A>Some UNIX systems, and utilities such as<SPANCLASS="link"><EMCLASS="emphasis">gawk</EM> (<ACLASS="linkend"HREF="ch33_12.htm"TITLE="Versions of awk ">33.12</A>)</SPAN>,support special filenames like <EMCLASS="emphasis">/dev/stdin</EM>, <EMCLASS="emphasis">/dev/stdout</EM>, and<EMCLASS="emphasis">/dev/stderr</EM>.You can use these just as you'd use other files.For instance, to have any ordinary command read from the file <EMCLASS="emphasis">afile</EM>,then standard input (from the keyboard, for example), then the file<EMCLASS="emphasis">bfile</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="replaceable"><I>somecmd</I></CODE><CODECLASS="userinput"><B> afile /dev/stdin bfile</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">In the same way, a process can write to its standard output through<EMCLASS="emphasis">/dev/stdout</EM> and the standard error via <EMCLASS="emphasis">/dev/stderr</EM>.<ACLASS="indexterm"NAME="AUTOID-14144"></A><ACLASS="indexterm"NAME="AUTOID-14145"></A></P><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">ML</SPAN>, <SPANCLASS="authorinitials">JP</SPAN></P></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch12_09.htm"TITLE="12.9 Running Multiple Shell Sessions with screen "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 12.9 Running Multiple Shell Sessions with screen "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch13_02.htm"TITLE="13.2 One Argument with a cat Isn't Enough "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 13.2 One Argument with a cat Isn't Enough "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">12.9 Running Multiple Shell Sessions with screen </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">13.2 One Argument with a cat Isn't Enough </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>