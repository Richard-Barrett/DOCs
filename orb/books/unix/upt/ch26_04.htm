<HTML><HEAD><TITLE>[Chapter 26] 26.4 Using Metacharacters in Regular Expressions </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:44:01Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch26_01.htm"TITLE="26. Regular Expressions (Pattern Matching)"><LINKREL="prev"HREF="ch26_03.htm"TITLE="26.3 Understanding Expressions "><LINKREL="next"HREF="ch26_05.htm"TITLE="26.5 Getting Regular Expressions Right "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch26_03.htm"TITLE="26.3 Understanding Expressions "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 26.3 Understanding Expressions "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 26<BR>Regular Expressions (Pattern Matching)</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch26_05.htm"TITLE="26.5 Getting Regular Expressions Right "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 26.5 Getting Regular Expressions Right "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-0427">26.4 Using Metacharacters in Regular Expressions </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="UPT-ART-427-IX-REGULAR-EXPRESSIONS-METACHARACTERS-IN"></A>There are three important parts to a regular expression: </P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Anchors</EM><ACLASS="indexterm"NAME="AUTOID-28439"></A>are used to specify the position of the pattern in relation to a line oftext.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Character sets</EM><ACLASS="indexterm"NAME="AUTOID-28444"></A>match one or more characters in a single position.</P></LI><LICLASS="listitem"><PCLASS="para"><EMCLASS="emphasis">Modifiers</EM><ACLASS="indexterm"NAME="AUTOID-28449"></A>specify how many times the previous character set is repeated.</P></LI></OL><PCLASS="para">A simple example that demonstrates all three parts is the regularexpression: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">^#*</PRE></BLOCKQUOTE></P><PCLASS="para">The caret (<CODECLASS="literal">^</CODE>) is an anchor that indicates the beginning of the line. The hash mark is a simple character set that matches thesingle character<CODECLASS="literal">#</CODE>.The asterisk (<CODECLASS="literal">*</CODE>) is a modifier.In a regular expression it specifies that the previous character setcan appear any number of times, including zero.As you will see shortly, this is a useless regular expression(except for demonstrating the syntax!).</P><PCLASS="para">There are two main types of regular expressions: <EMCLASS="emphasis">simple</EM>regular expressions and <EMCLASS="emphasis">extended</EM>regular expressions.(As we'll see later in the article, the boundaries between the twotypes have become blurred as regular expressions have evolved.)A few utilities like<EMCLASS="emphasis">awk</EM>and<EMCLASS="emphasis">egrep</EM>use the extended regular expression.Most use the simpleregular expression.From now on, if I talk about a &quot;regular expression&quot; (without specifying simple or extended),I am describing a feature common to both types.</P><PCLASS="para">The commands that understand just simple regular expressions are:<EMCLASS="emphasis">vi</EM>, <EMCLASS="emphasis">sed</EM>, <EMCLASS="emphasis">grep</EM>, <EMCLASS="emphasis">csplit</EM>, <EMCLASS="emphasis">dbx</EM>,<EMCLASS="emphasis">more</EM>, <EMCLASS="emphasis">ed</EM>, <EMCLASS="emphasis">expr</EM>, <EMCLASS="emphasis">lex</EM>, and <EMCLASS="emphasis">pg</EM>.The utilities <EMCLASS="emphasis">awk</EM>, <EMCLASS="emphasis">nawk</EM>, and <EMCLASS="emphasis">egrep</EM>understand extended regular expressions.</P><PCLASS="para">[The situation is complicated by the fact that simple regularexpressions have evolved over time, and so there are versions of&quot;simple regular expressions&quot; that support extensions missing fromextended regular expressions!Bruce explains the incompatibility atthe end of his article. -<EMCLASS="emphasis">TOR</EM>&nbsp;]</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.1">26.4.1 The Anchor Characters: ^ and $ </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28482"></A><ACLASS="indexterm"NAME="AUTOID-28485"></A><ACLASS="indexterm"NAME="AUTOID-28488"></A>Most UNIX text facilities are line-oriented. Searching for patternsthat span several lines is not easy to do.You see, the end-of-line character is not included in the block oftext that is searched.It is a separator.Regular expressions examine the text between the separators.If you want to search for a pattern that is at one end or the other,you use<EMCLASS="emphasis">anchors</EM>.The caret (<CODECLASS="literal">^</CODE>)is the starting anchor, and the dollar sign (<CODECLASS="literal">$</CODE>)is the end anchor.The regular expression <CODECLASS="literal">^A</CODE>will match all lines that start with an uppercase A.The expression<CODECLASS="literal">A$</CODE>will match all lines that end with uppercase A.If the anchor characters are not used at the proper end of thepattern, then they no longer act as anchors.That is, the <CODECLASS="literal">^</CODE>is only an anchor if it is the first character in a regularexpression.The<CODECLASS="literal">$</CODE>is only an anchor if it is the last character.The expression<CODECLASS="literal">$1</CODE>does not have an anchor.Neither does<CODECLASS="literal">1^</CODE>.If you need to match a<CODECLASS="literal">^</CODE>at the beginning of the line or a<CODECLASS="literal">$</CODE>at the end of a line, you must <EMCLASS="emphasis">escape</EM>the special character by typing a backslash (<CODECLASS="literal">\</CODE>) before it.<ACLASS="xref"HREF="ch26_04.htm#UPT-ART-427-TAB-0"TITLE="Regular Expression Anchor Character Examples">Table 26.1</A>has a summary.</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="UPT-ART-427-TAB-0">Table 26.1: Regular Expression Anchor Character Examples</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Pattern</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Matches</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">^A</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">An A at the beginning of a line</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">A$</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">An A at the end of a line</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">A</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">An A anywhere on a line</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">$A</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">A <CODECLASS="literal">$A</CODE> anywhere on a line</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^\^</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">A <CODECLASS="literal">^</CODE> at the beginning of a line</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^^</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Same as <CODECLASS="literal">^\^</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">\$$</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">A <CODECLASS="literal">$</CODE> at the end of a line</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">$$</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Same as <CODECLASS="literal">\$$</CODE></TD></TR></TBODY></TABLE><PCLASS="para">The use of<CODECLASS="literal">^</CODE>and<CODECLASS="literal">$</CODE>as indicators of the beginning or end of a line is a conventionother utilities use.The<EMCLASS="emphasis">vi</EM>editor uses these two characters as commands to go to the beginning orend of a line.The C shell uses<CODECLASS="literal">!^</CODE>to specify the first argument of the previous line, and<CODECLASS="literal">!$</CODE>is the last argument on the previous line(article<ACLASS="xref"HREF="ch11_07.htm"TITLE="History Substitutions ">11.7</A>explains).</P><PCLASS="para">It is one of those choices that other utilities go along with tomaintain consistency.For instance,<CODECLASS="literal">$</CODE>can refer to the last line of a file when using<EMCLASS="emphasis">ed</EM>and<EMCLASS="emphasis">sed</EM>.<SPANCLASS="link"><EMCLASS="emphasis">cat -v -e</EM> (<ACLASS="linkend"HREF="ch25_06.htm"TITLE="What's in That White Space? ">25.6</A>, <ACLASS="linkend"HREF="ch25_07.htm"TITLE="Show Non-Printing Characters with cat -v or od -c ">25.7</A>)</SPAN>marks ends of lines with a<CODECLASS="literal">$</CODE>.You might see it in other programs as well.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.2">26.4.2 Matching a Character with a Character Set </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28562"></A><ACLASS="indexterm"NAME="AUTOID-28564"></A>The simplest character set is a character.The regular expression<CODECLASS="literal">the</CODE>contains three character sets:<CODECLASS="literal">t</CODE>,<CODECLASS="literal">h</CODE>,and <CODECLASS="literal">e</CODE>.It will match any line that contains the string<CODECLASS="literal">the</CODE>,including the word<CODECLASS="literal">other</CODE>.To prevent this, put spaces (<IMGSRC="../chars/squ.gif"ALT=" ">) before and after the pattern:<IMGSRC="../chars/squ.gif"ALT=" "><CODECLASS="literal">the</CODE><IMGSRC="../chars/squ.gif"ALT=" ">.You can combine the string with an anchor.The pattern<CODECLASS="literal">^From:</CODE><IMGSRC="../chars/squ.gif"ALT=" ">will match the lines of a<SPANCLASS="link">mail message (<ACLASS="linkend"HREF="ch01_33.htm"TITLE="UNIX Networking and Communications ">1.33</A>)</SPAN>that identify the sender.Use this pattern with <EMCLASS="emphasis">grep</EM> to print every address in your incoming mailbox:</P><PCLASS="para"><TABLECLASS="screen.co"BORDER="1"><TR><THVALIGN="TOP"><PRECLASS="calloutlist"><ACLASS="co"HREF="ch06_03.htm"TITLE="6.3 Predefined Environment Variables ">$USER</A> </PRE></TH><TDVALIGN="TOP"><PRECLASS="screen">% <CODECLASS="userinput"><B>grep '^From: ' /usr/spool/mail/$USER</B></CODE></PRE></TD></TR></TABLE></P><PCLASS="para">Some characters have a special meaning in regular expressions.If you want to search for such a character as itself, escape it with abackslash (<CODECLASS="literal">\</CODE>).</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.3">26.4.3 Match any Character with . (Dot) </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28586"></A>The dot (<CODECLASS="literal">.</CODE>)is one of those special metacharacters. By itself it will match any character, except the end-of-linecharacter.The pattern that will match a line with any single character is: <CODECLASS="literal">^.$</CODE>.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.4">26.4.4 Specifying a Range of Characters with [...] </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28594"></A>If you want to match specific characters, you can use square brackets, <CODECLASS="literal">[]</CODE>, to identify the exact characters you are searching for.The pattern that will match any line of text that contains exactly onedigit is: <CODECLASS="literal">^[0123456789]$</CODE>.This is longer than it has to be.You can use the hyphen between two characters to specify a range:<CODECLASS="literal">^[0-9]$</CODE>.You can intermix explicit characters with character ranges.This pattern will match a single character that is a letter, digit,or underscore:<CODECLASS="literal">[A-Za-z0-9_]</CODE>.Character sets can be combined by placing them next to one another.If you wanted to search for a word that:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">started with an uppercase T,</P></LI><LICLASS="listitem"><PCLASS="para">was the first word on a line,</P></LI><LICLASS="listitem"><PCLASS="para">the second letter was a lowercase letter,</P></LI><LICLASS="listitem"><PCLASS="para">was three letters long (followed by a space character (<IMGSRC="../chars/squ.gif"ALT=" ">)), and</P></LI><LICLASS="listitem"><PCLASS="para">the third letter was a lowercase vowel,</P></LI></UL><PCLASS="para">the regular expression would be: <CODECLASS="literal">^T[a-z][aeiou]</CODE><IMGSRC="../chars/squ.gif"ALT=" ">.</P><PCLASS="para">[To be specific:A range is a contiguous series of characters, from low to high, in the<SPANCLASS="link">ASCII chart (<ACLASS="linkend"HREF="ch51_03.htm"TITLE="ASCII Characters: Listing and Getting Values ">51.3</A>)</SPAN>.For example, <CODECLASS="literal">[z-a]</CODE> is <EMCLASS="emphasis">not</EM> a range because it's backwards.The range <CODECLASS="literal">[A-z]</CODE> does match both uppercase and lowercase letters,but it also matches the six characters that fall between uppercaseand lowercase letters in the ASCII chart:<CODECLASS="literal">[</CODE>, <CODECLASS="literal">\</CODE>, <CODECLASS="literal">]</CODE>, <CODECLASS="literal">^</CODE>, <CODECLASS="literal">_</CODE>, and <CODECLASS="literal">`</CODE>.<EMCLASS="emphasis">-JP</EM>&nbsp;]</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.5">26.4.5 Exceptions in a Character Set </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28629"></A><ACLASS="indexterm"NAME="AUTOID-28632"></A>You can easily search for all characters except those in squarebrackets by putting acaret (<CODECLASS="literal">^</CODE>)as the first character after the left square bracket (<CODECLASS="literal">[</CODE>).To match all characters except lowercase vowels use: <CODECLASS="literal">[^aeiou]</CODE>.</P><PCLASS="para">Like the anchors in places that can't be considered an anchor, theright square bracket (<CODECLASS="literal">]</CODE>)anddash (<CODECLASS="literal">-</CODE>)do not have a special meaning if they directly follow a&nbsp;<CODECLASS="literal">[</CODE>.<ACLASS="xref"HREF="ch26_04.htm#UPT-ART-427-TAB-1"TITLE="Regular Expression Character Set Examples">Table 26.2</A>has some examples.&#13;</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="UPT-ART-427-TAB-1">Table 26.2: Regular Expression Character Set Examples</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Regular Expression</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Matches</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[0-9]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any digit</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[^0-9]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any character other than a digit</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[-0-9]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any digit or a <CODECLASS="literal">-</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[0-9-]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any digit or a <CODECLASS="literal">-</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[^-0-9]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any character except a digit or a <CODECLASS="literal">-</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[]0-9]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any digit or a <CODECLASS="literal">]</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[0-9]]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any digit followed by a <CODECLASS="literal">]</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[0-99-z]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Any digit or any character <SPANCLASS="link">between 9 and z (<ACLASS="linkend"HREF="ch51_03.htm"TITLE="ASCII Characters: Listing and Getting Values ">51.3</A>)</SPAN></P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">[]0-9-]</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any digit, a <CODECLASS="literal">-</CODE>, or a <CODECLASS="literal">]</CODE></TD></TR></TBODY></TABLE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.6">26.4.6 Repeating Character Sets with <CODECLASS="literal">*</CODE> </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28691"></A>The third part of a regular expression is the modifier.It is used to specify how many times you expect to see the previouscharacter set. The special character <CODECLASS="literal">*</CODE>&nbsp;(asterisk)matches<EMCLASS="emphasis">zero or more</EM>copies.That is, the regular expression<CODECLASS="literal">0*</CODE>matches zero or more zeros,while the expression<CODECLASS="literal">[0-9]*</CODE>matches zero or more digits.</P><PCLASS="para">This explains why the pattern<CODECLASS="literal">^#*</CODE>is useless, as it matches any number of <CODECLASS="literal">#</CODE>'sat the beginning of the line, including <EMCLASS="emphasis">zero</EM>.Therefore, this will match every line, because every line starts withzero or more <CODECLASS="literal">#</CODE>'s.</P><PCLASS="para">At first glance, it might seem that starting the count at zero isstupid.Not so.Looking for an unknown number of characters is very important.Suppose you wanted to look for a digit at the beginning of a line,and there may or may not be spaces before the digit.Just use <CODECLASS="literal">^</CODE><IMGSRC="../chars/squ.gif"ALT=" "><CODECLASS="literal">*</CODE>to match zero or more spaces at the beginning of the line.If you need to match one or more, just repeat the character set.That is, <CODECLASS="literal">[0-9]*</CODE>matches zero or more digits and<CODECLASS="literal">[0-9][0-9]*</CODE>matches one or more digits.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.7">26.4.7 Matching a Specific Number of Sets with \&nbsp;{ and \&nbsp;} </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28711"></A><ACLASS="indexterm"NAME="AUTOID-28714"></A>You cannot specify a maximum number of setswith the<CODECLASS="literal">*</CODE>modifier.However, <SPANCLASS="link">some programs (<ACLASS="linkend"HREF="ch26_09.htm"TITLE="Valid Metacharacters for Different UNIX Programs ">26.9</A>)</SPAN>recognize a special pattern you can use to specify theminimum and maximum number of repeats. This is done by putting those two numbers between <CODECLASS="literal">\{</CODE>and<CODECLASS="literal">\}</CODE>.</P><PCLASS="para">Having convinced you that <CODECLASS="literal">\{</CODE>isn't a plot to confuse you, an example is in order. The regularexpression to match four, five, six, seven, or eight lowercase letters is:<CODECLASS="literal">[a-z]\{4,8\}</CODE>.Any numbers between 0 and 255 can be used.The second number may be omitted, which removes the upper limit.If the comma and the second number are omitted, the pattern must beduplicated the exact number of times specified by the first number.</P><BLOCKQUOTECLASS="caution"><PCLASS="para"><STRONG>CAUTION:</STRONG> The backslashes deserve a special discussion.Normally a backslash <EMCLASS="emphasis">turns off</EM>the special meaning for a character.For example, a literal period is matched by <CODECLASS="literal">\.</CODE>and a literal asterisk is matched by<CODECLASS="literal">\*</CODE>.However, if a backslash is placed before a<CODECLASS="literal">&lt;</CODE>,<CODECLASS="literal">&gt;</CODE>,<CODECLASS="literal">{</CODE>,<CODECLASS="literal">}</CODE>,<CODECLASS="literal">(</CODE>, or<CODECLASS="literal">)</CODE>or before a digit, the backslash<EMCLASS="emphasis">turns on</EM>a special meaning.This was done because these special functions were added late in thelife of regular expressions. Changing the meaning of <CODECLASS="literal">{</CODE>, <CODECLASS="literal">}</CODE>,<CODECLASS="literal">(</CODE>, <CODECLASS="literal">)</CODE>,<CODECLASS="literal">&lt;</CODE>, and <CODECLASS="literal">&gt;</CODE>would have broken old expressions. (This is a horrible crime punishableby a year of hard labor writing COBOL programs.)Instead, adding a backslash added functionality without breaking oldprograms. Rather than complain about the change, view it as evolution.&#13;</P></BLOCKQUOTE><PCLASS="para">You must remember that modifiers like<CODECLASS="literal">*</CODE>and<CODECLASS="literal">\{1,5\}</CODE>only act as modifiers if they follow a character set.If they were at the beginning of a pattern, they would not be modifiers.<ACLASS="xref"HREF="ch26_04.htm#UPT-ART-427-TAB-2"TITLE="Regular Expression Pattern Repetition Examples">Table 26.3</A>is a list of examples, and the exceptions.&#13;</P><TABLECLASS="table"><CAPTIONCLASS="table"><ACLASS="title"NAME="UPT-ART-427-TAB-2">Table 26.3: Regular Expression Pattern Repetition Examples</A></CAPTION><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Regular Expression</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Matches</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line with a <CODECLASS="literal">*</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">\*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line with a <CODECLASS="literal">*</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">\\</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line with a <CODECLASS="literal">\</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line starting with a <CODECLASS="literal">*</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^A*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^A\*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line starting with an A<CODECLASS="literal">*</CODE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^AA*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line starting with one A</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^AA*B</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Any line starting with one or more A's followedby a B</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^A\{4,8\}B</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Any line starting with four, five, six, seven, or eight A's followed by a B</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^A\{4,\}B</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Any line starting with four or more A's followedby a B</P></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^A\{4\}B</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line starting with an AAAAB</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">\{4,8\}</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line with a {4,8}</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">A{4,8}</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Any line with an A{4,8}</TD></TR></TBODY></TABLE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.8">26.4.8 Matching Words with \&nbsp;&lt; and \&nbsp;&gt; </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28804"></A><ACLASS="indexterm"NAME="AUTOID-28807"></A>Searching for a word isn't quite as simple as it at first appears.The string<CODECLASS="literal">the</CODE>will match the word <CODECLASS="literal">other</CODE>.You can put spaces before and after the letters and use this regularexpression:<IMGSRC="../chars/squ.gif"ALT=" "><CODECLASS="literal">the</CODE><IMGSRC="../chars/squ.gif"ALT=" ">.However, this does not match words at the beginning or the end of the line.And it does not match the case where there is a punctuation markafter the word. </P><PCLASS="para">There is an easy solution&nbsp;- at least in many versions of <EMCLASS="emphasis">ed</EM>, <EMCLASS="emphasis">ex</EM>, and<EMCLASS="emphasis">vi</EM>.The characters <CODECLASS="literal">\&lt;</CODE>and<CODECLASS="literal">\&gt;</CODE>are similar to the<CODECLASS="literal">^</CODE>and<CODECLASS="literal">$</CODE>anchors,as they don't occupy a position of a character.They do <EMCLASS="emphasis">anchor</EM>the expression between to match only if it is on a word boundary.The pattern to search for the words<CODECLASS="literal">the</CODE> and <CODECLASS="literal">The</CODE>would be:<CODECLASS="literal">\&lt;[tT]he\&gt;</CODE>.</P><PCLASS="para">Let's define a &quot;word boundary.&quot;The character before the<CODECLASS="literal">t</CODE> or <CODECLASS="literal">T</CODE>must be either a newline character or anything except a letter,digit, or underscore (&nbsp;<CODECLASS="literal">_</CODE>&nbsp;).The character after the<CODECLASS="literal">e</CODE>mustalso be a character other than a digit, letter, or underscore,or it could be the end-of-line character.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.9">26.4.9 Remembering Patterns with \&nbsp;(, \&nbsp;), and \1 </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28833"></A><ACLASS="indexterm"NAME="AUTOID-28836"></A><ACLASS="indexterm"NAME="AUTOID-28839"></A>Another pattern that requires a special mechanism is searching forrepeated words.The expression<CODECLASS="literal">[a-z][a-z]</CODE>will match any two lowercase letters.If you wanted to search for lines that had two adjoining identicalletters, the above pattern wouldn't help.You need a way to remember what you found and see if the same pattern occurs again.In some programs, you can mark part of a pattern using<CODECLASS="literal">\(</CODE>and<CODECLASS="literal">\)</CODE>.You can recall the remembered pattern with<CODECLASS="literal">\</CODE> followed by a single digit.Therefore, to search for two identical letters, use:<CODECLASS="literal">\([a-z]\)\1</CODE>.You can have nine different remembered patterns. Each occurrence of <CODECLASS="literal">\(</CODE>starts a new pattern.The regular expression to match a five-letter palindrome (e.g., &quot;radar&quot;) is:<CODECLASS="literal">\([a-z]\)\([a-z]\)[a-z]\2\1</CODE>.[Some versions of some programs can't handle <CODECLASS="literal">\(&nbsp;\)</CODE> in the sameregular expression as <CODECLASS="literal">\</CODE><CODECLASS="replaceable"><I>1</I></CODE>, etc.In all versions of <EMCLASS="emphasis">sed</EM>, you're safe if you use<SPANCLASS="link"> <CODECLASS="literal">/( /)</CODE> on the pattern side of an <EMCLASS="emphasis">s</EM> command-and<CODECLASS="literal">/</CODE><CODECLASS="replaceable"><I>1</I></CODE>, etc., on the replacement side . (<ACLASS="linkend"HREF="ch34_10.htm"TITLE="Referencing Portions of a Search String ">34.10</A>)</SPAN><EMCLASS="emphasis">-JP</EM> ]</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.10">26.4.10 Potential Problems </A></H3><PCLASS="para">That completes a discussion of simple regular expressions.Before I discuss the extensions that extended expressions offer, Iwant to mention two potential problem areas.</P><PCLASS="para">The <CODECLASS="literal">/&lt;</CODE>and<CODECLASS="literal">/&gt;</CODE>characters were introduced in the<EMCLASS="emphasis">vi</EM>editor. The other programs didn't have this ability at that time.Also, the<CODECLASS="literal">/{</CODE><CODECLASS="replaceable"><I>min</I></CODE><CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>max</I></CODE><CODECLASS="literal">/}</CODE>modifier is new, and earlier utilities didn't have this ability.This makes it difficult for the novice user of regular expressions,because it seems as if each utility has a different convention.Sun has retrofitted the newest regular expression library to all oftheir programs, so they all have the same ability.If you try to use these newer features on other vendors' machines, youmight find they don't work the same way.</P><PCLASS="para">The other potential point of confusion is the <SPANCLASS="link">extent of the pattern matches (<ACLASS="linkend"HREF="ch26_06.htm"TITLE="Just What Does a Regular Expression Match? ">26.6</A>)</SPAN>.Regular expressions match the longest possible pattern.That is, the regular expression<CODECLASS="literal">A.*B</CODE>matches <CODECLASS="literal">AAB</CODE>as well as <CODECLASS="literal">AAAABBBBABCCCCBBBAAAB</CODE>.This doesn't cause many problems using<EMCLASS="emphasis">grep</EM>,because an oversight in a regular expression will just match morelines than desired.If you use <EMCLASS="emphasis">sed</EM>,and your patterns get carried away, you may end up deleting orchanging more than you want to.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-427-SECT-1.11">26.4.11 Extended Regular Expressions </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28881"></A><ACLASS="indexterm"NAME="AUTOID-28883"></A><ACLASS="indexterm"NAME="AUTOID-28886"></A><ACLASS="indexterm"NAME="AUTOID-28888"></A><ACLASS="indexterm"NAME="AUTOID-28891"></A>Two programs use extended regular expressions:<EMCLASS="emphasis">egrep</EM>and <EMCLASS="emphasis">awk</EM>.[<EMCLASS="emphasis">perl</EM> uses expressions that are even more extended. <EMCLASS="emphasis">-JP</EM> ]With these extensions, those special characters preceded by a backslashno longer have special meaning:<CODECLASS="literal">/{</CODE>,<CODECLASS="literal">/}</CODE>,<CODECLASS="literal">/&lt;</CODE>,<CODECLASS="literal">/&gt;</CODE>,<CODECLASS="literal">/(</CODE>,<CODECLASS="literal">/)</CODE>,as well as <CODECLASS="literal">/</CODE><CODECLASS="replaceable"><I>digit</I></CODE>.There is a very good reason for this, which I willdelay explaining to build up suspense.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-28906"></A>The question mark (<CODECLASS="literal">?</CODE>) matches zero or one instances of the character set before it, and the<ACLASS="indexterm"NAME="AUTOID-28910"></A>plus sign (<CODECLASS="literal">+</CODE>)matches one or more copies of the character set.You can't use <CODECLASS="literal">/{</CODE> and <CODECLASS="literal">/}</CODE> in extended regular expressions,but if you could, you might consider<CODECLASS="literal">?</CODE>to be the same as<CODECLASS="literal">/{0,1/}</CODE>and <CODECLASS="literal">+</CODE>to be the same as<CODECLASS="literal">/{1,/}</CODE>.</P><PCLASS="para">By now, you are wondering why the extended regular expressions are even worth using. Except for two abbreviations, there seem to be noadvantages and a lot of disadvantages.Therefore, examples would be useful.</P><PCLASS="para">The three important characters in the expanded regular expressions are<CODECLASS="literal">(</CODE>,<CODECLASS="literal">|</CODE>,and <CODECLASS="literal">)</CODE>.<ACLASS="indexterm"NAME="AUTOID-28925"></A><ACLASS="indexterm"NAME="AUTOID-28928"></A>Parentheses are used to group expressions; the vertical bar acts anan OR operator.Together, they let you match a<EMCLASS="emphasis">choice</EM>of patterns.As an example, you can use <EMCLASS="emphasis">egrep</EM>to print all <CODECLASS="literal">From:</CODE> and <CODECLASS="literal">Subject:</CODE>lines from your incoming mail:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>egrep '^(From|Subject): ' /usr/spool/mail/$USER</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">All lines starting with <CODECLASS="literal">From:</CODE>or<CODECLASS="literal">Subject:</CODE>will be printed. There is no easy way to do this with simpleregular expressions. You could try something like<CODECLASS="literal">^[FS][ru][ob][mj]e*c*t*:</CODE>and hope you don't have any lines that start with<CODECLASS="literal">Sromeet:</CODE>.Extended expressions don't havethe <CODECLASS="literal">/&lt;</CODE>and<CODECLASS="literal">/&gt;</CODE>characters.You can compensate by using the alternation mechanism.Matching the word&quot;the&quot;in the beginning, middle, or end of a sentence or at the end of a line can bedone with the extended regular expression:<CODECLASS="literal">(^| )the([^a-z]|$)</CODE>.There are two choices before the word: a space or the beginning of aline.Following the word, there must be something besides a lowercase letter orelse the end of the line.One extra bonus with extended regular expressions is the ability touse the<CODECLASS="literal">*</CODE>,<CODECLASS="literal">+</CODE>,and <CODECLASS="literal">?</CODE>modifiers after a <CODECLASS="literal">(...)</CODE>grouping.Here are two ways to match&quot;a simple problem&quot;,&quot;an easy problem&quot;,as well as&quot;a problem&quot;;the second expression is more exact:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>egrep &quot;a[n]? (simple|easy)? ?problem&quot; data</B></CODE>% <CODECLASS="userinput"><B>egrep &quot;a[n]? ((simple|easy) )?problem&quot; data</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">I promised to explain why the backslash characters don't work inextended regular expressions.Well, perhaps the<CODECLASS="literal">/{.../}</CODE>and<ACLASS="indexterm"NAME="AUTOID-28956"></A><ACLASS="indexterm"NAME="AUTOID-28959"></A><ACLASS="indexterm"NAME="AUTOID-28962"></A><ACLASS="indexterm"NAME="AUTOID-28965"></A><CODECLASS="literal">/&lt;.../&gt;</CODE>could be added to the extended expressions, but it might confuse people if those characters are added and the<CODECLASS="literal">/(.../)</CODE>are not. And there is no way to add that functionality to the extendedexpressions without changing the current usage. Do you see why?It's quite simple. If<CODECLASS="literal">(</CODE>has a special meaning, then <CODECLASS="literal">/(</CODE>must be the ordinary character.This is the opposite of the simple regular expressions,where<CODECLASS="literal">(</CODE>is ordinary and<CODECLASS="literal">/(</CODE>is special.The usage of the parentheses is incompatible, and any change couldbreak old programs.</P><PCLASS="para">If the extended expression used <CODECLASS="literal">(...|...)</CODE>as regular characters, and<CODECLASS="literal">/(.../|.../)</CODE>for specifying alternate patterns, then it is possible to have one setof regular expressions that has full functionality.This is exactlywhat<SPANCLASS="link">GNU Emacs (<ACLASS="linkend"HREF="ch32_01.htm#UPT-ART-5540"TITLE="Emacs: The Other Editor ">32.1</A>)</SPAN>does, by the way-it combinesall of the features of regular andextended expressions with one syntax.<ACLASS="indexterm"NAME="AUTOID-28978"></A></P></DIV><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">BB</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch26_03.htm"TITLE="26.3 Understanding Expressions "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 26.3 Understanding Expressions "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch26_05.htm"TITLE="26.5 Getting Regular Expressions Right "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 26.5 Getting Regular Expressions Right "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">26.3 Understanding Expressions </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">26.5 Getting Regular Expressions Right </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>