<HTML><HEAD><TITLE>[Chapter 33] 33.11 Quick Reference: awk </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:46:58Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch33_01.htm"TITLE="33. Batch Editing"><LINKREL="prev"HREF="ch33_10.htm"TITLE="33.10 Quick Globals from the Command Line with qsubst "><LINKREL="next"HREF="ch33_12.htm"TITLE="33.12 Versions of awk "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch33_10.htm"TITLE="33.10 Quick Globals from the Command Line with qsubst "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 33.10 Quick Globals from the Command Line with qsubst "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 33<BR>Batch Editing</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch33_12.htm"TITLE="33.12 Versions of awk "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 33.12 Versions of awk "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-2860">33.11 Quick Reference: awk </A></H2><PCLASS="para">This article also covers<SPANCLASS="link"><EMCLASS="emphasis">nawk</EM> and <EMCLASS="emphasis">gawk</EM> (<ACLASS="linkend"HREF="ch33_12.htm"TITLE="Versions of awk ">33.12</A>)</SPAN>.<ACLASS="indexterm"NAME="UPT-ART-2860-IX-AWK-UTILITY"></A><ACLASS="indexterm"NAME="AUTOID-37087"></A><ACLASS="indexterm"NAME="AUTOID-37091"></A><ACLASS="indexterm"NAME="UPT-ART-2860-IX-NAWK-UTILITY"></A><ACLASS="indexterm"NAME="UPT-ART-2860-IX-GAWK-UTILITY"></A>With the exception of array subscripts, values in<CODECLASS="literal">[</CODE>brackets<CODECLASS="literal">]</CODE> are optional; don't type the<CODECLASS="literal">[</CODE> or <CODECLASS="literal">]</CODE>.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.1">33.11.1 Command-line Syntax </A></H3><PCLASS="para"><EMCLASS="emphasis">awk</EM> can be invoked in two ways:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">awk [<CODECLASS="replaceable"><I>options</I></CODE>] '<CODECLASS="replaceable"><I>script</I></CODE>' [<CODECLASS="replaceable"><I>var</I></CODE>=<CODECLASS="replaceable"><I>value</I></CODE>] [<CODECLASS="replaceable"><I>file(s)</I></CODE>]awk [<CODECLASS="replaceable"><I>options</I></CODE>] -f <CODECLASS="replaceable"><I>scriptfile </I></CODE>[<CODECLASS="replaceable"><I>var</I></CODE>=<CODECLASS="replaceable"><I>value</I></CODE>] [<CODECLASS="replaceable"><I>file(s)</I></CODE>]</PRE></BLOCKQUOTE><PCLASS="para">You can specify a <CODECLASS="replaceable"><I>script</I></CODE> directly on the command line, oryou can store a script in a <CODECLASS="replaceable"><I>scriptfile</I></CODE> and specify it with <EMCLASS="emphasis">-f</EM>.In most versions, the <EMCLASS="emphasis">-f</EM> option can be used multiple times.The variable <CODECLASS="replaceable"><I>var</I></CODE> can be assigned a value on the command line. The value can be aliteral, a shell variable (<CODECLASS="literal">$</CODE><CODECLASS="replaceable"><I>name</I></CODE>), or a command substitution (<CODECLASS="literal">`</CODE><CODECLASS="replaceable"><I>cmd</I></CODE><CODECLASS="literal">`</CODE>), but the value isavailable only after a line of input is read (i.e., after the BEGINstatement). <EMCLASS="emphasis">awk</EM> operates on one or more <CODECLASS="replaceable"><I>file(s)</I></CODE>.If none are specified (or if <CODECLASS="literal">-</CODE> is specified), <EMCLASS="emphasis">awk</EM> reads from the<SPANCLASS="link">standard input (<ACLASS="linkend"HREF="ch13_01.htm#UPT-ART-1023"TITLE="Using Standard Input and Output">13.1</A>)</SPAN>.</P><PCLASS="para">The other recognized <CODECLASS="replaceable"><I>options</I></CODE> are:</P><DLCLASS="variablelist"><DTCLASS="term"><CODECLASS="literal">-F</CODE><CODECLASS="replaceable"><I>c</I></CODE></DT><DDCLASS="listitem"><PCLASS="para">Set the field separator to character <CODECLASS="replaceable"><I>c</I></CODE>.This is the same as setting the system variable <EMCLASS="emphasis">FS</EM>.<EMCLASS="emphasis">nawk</EM> allows <CODECLASS="replaceable"><I>c</I></CODE> to be a<SPANCLASS="link">regular expression (<ACLASS="linkend"HREF="ch26_04.htm"TITLE="Using Metacharacters in Regular Expressions ">26.4</A>)</SPAN>.Each record (by default, one input line) is divided into fields bywhite space (blanks or tabs) or by some other user-definable fieldseparator. Fields are referred to by the variables <CODECLASS="literal">$1</CODE>, <CODECLASS="literal">$2</CODE>,...<CODECLASS="literal">$</CODE><CODECLASS="replaceable"><I>n</I></CODE>. <CODECLASS="literal">$0</CODE> refers to the entire record.For example, toprint the first three (colon-separated) fields on separate lines:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">    % <CODECLASS="userinput"><B>awk -F: '{print $1; print $2; print $3}' /etc/passwd</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para"></P></DD><DTCLASS="term"><CODECLASS="literal">-v </CODE><CODECLASS="replaceable"><I>var</I></CODE><CODECLASS="literal">=</CODE><CODECLASS="replaceable"><I>value</I></CODE></DT><DDCLASS="listitem"><PCLASS="para">Assign a <CODECLASS="replaceable"><I>value</I></CODE> to variable <CODECLASS="replaceable"><I>var</I></CODE>.This allows assignment before the script begins execution.(Available in <EMCLASS="emphasis">nawk</EM> only.)&#13;</P></DD></DL></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.2">33.11.2 Patterns and Procedures </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-37171"></A><ACLASS="indexterm"NAME="AUTOID-37174"></A><EMCLASS="emphasis">awk</EM> scripts consist of patterns and procedures:</P><BLOCKQUOTECLASS="blockquote"><PCLASS="para"><CODECLASS="replaceable"><I>pattern </I></CODE><CODECLASS="literal">{</CODE><CODECLASS="replaceable"><I>procedure</I></CODE><CODECLASS="literal">}</CODE></P></BLOCKQUOTE><PCLASS="para">Both are optional. If <CODECLASS="replaceable"><I>pattern</I></CODE> is missing, <CODECLASS="literal">{</CODE><CODECLASS="replaceable"><I>procedure</I></CODE><CODECLASS="literal">}</CODE> is applied to all records.If <CODECLASS="literal">{</CODE><CODECLASS="replaceable"><I>procedure</I></CODE><CODECLASS="literal">}</CODE> is missing, the matched recordis written to the standard output.&#13;</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.2.1">33.11.2.1 Patterns </A></H4><PCLASS="para"><CODECLASS="replaceable"><I>pattern</I></CODE> can be any of the following:</P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/<CODECLASS="replaceable"><I>regular expression</I></CODE>/<CODECLASS="replaceable"><I>relational expression</I></CODE><CODECLASS="replaceable"><I>pattern-matching expression</I></CODE>BEGINEND</PRE></BLOCKQUOTE><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Expressions can be composed of quoted strings, numbers, operators,functions, defined variables, or any of the predefined variables described later under the section &quot;awk System Variables.&quot;</P></LI><LICLASS="listitem"><PCLASS="para">Regular expressions use the extended set of metacharacters as described in article<ACLASS="xref"HREF="ch26_04.htm"TITLE="Using Metacharacters in Regular Expressions ">26.4</A>.In addition,<CODECLASS="literal">^</CODE> and <CODECLASS="literal">$</CODE> can be used to refer to the beginning and end of a field, respectively, rather than the beginning and end of a record (line).</P></LI><LICLASS="listitem"><PCLASS="para">Relational expressions use the relational operators listed under the section&quot;Operators&quot; later in this article.Comparisons can be either string or numeric.For example, <CODECLASS="literal">$2</CODE>&nbsp;<CODECLASS="literal">&gt;</CODE>&nbsp;<CODECLASS="literal">$1</CODE> selects records forwhich the second field is greater than the first.</P></LI><LICLASS="listitem"><PCLASS="para">Pattern-matching expressions use the operators <CODECLASS="literal">~</CODE> (match)and <CODECLASS="literal">!~</CODE> (don't match). See the section &quot;Operators&quot; later in this article.</P></LI><LICLASS="listitem"><PCLASS="para">The BEGIN pattern lets you specify procedures that will takeplace <EMCLASS="emphasis">before</EM> the first input record is processed. (Generally, youset global variables here.)</P></LI><LICLASS="listitem"><PCLASS="para">The END pattern lets you specify procedures thatwill take place <EMCLASS="emphasis">after</EM> the last input record is read.</P></LI></UL><PCLASS="para">Except for BEGIN and END,patterns can be combined with the Boolean operators <CODECLASS="literal">||</CODE> (OR), <CODECLASS="literal">&amp;&amp;</CODE> (AND), and <CODECLASS="literal">!</CODE> (NOT). A range of lines can also be specified using comma-separated patterns:</P><BLOCKQUOTECLASS="blockquote"><PCLASS="para"><CODECLASS="replaceable"><I>pattern</I></CODE><CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>pattern</I></CODE></P></BLOCKQUOTE></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.2.2">33.11.2.2 Procedures </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-37235"></A><CODECLASS="replaceable"><I>procedure</I></CODE> can consist of one or more commands, functions, or variableassignments, separated by newlines or semicolons (<CODECLASS="literal">;</CODE>), and contained withincurly braces (<CODECLASS="literal">{}</CODE>). Commands fall into four groups:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Variable or array assignments</P></LI><LICLASS="listitem"><PCLASS="para">Printing commands&#13;</P></LI><LICLASS="listitem"><PCLASS="para">Built-in functions</P></LI><LICLASS="listitem"><PCLASS="para">Control-flow commands</P></LI></UL></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.2.3">33.11.2.3 Simple Pattern-Procedure Examples </A></H4><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Print first field of each line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">{ print $1 }</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Print all lines that contain <CODECLASS="literal">pattern</CODE>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/pattern/</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Print first field of lines that contain <CODECLASS="literal">pattern</CODE>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/pattern/{ print $1 }</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Print records containing more than two fields:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">NF &gt; 2</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Interpret input records as a group of lines up toa blank line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">BEGIN { FS = &quot;\n&quot;; RS = &quot;&quot; }{ <CODECLASS="replaceable"><I>...process records...</I></CODE> }</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Print fields 2 and 3 in switched order, but only on lineswhose first field matches the string <CODECLASS="literal">URGENT</CODE>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$1 ~ /URGENT/ { print $3, $2 }</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Count and print the number of <CODECLASS="literal">pattern</CODE> found:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/pattern/ { ++x }END { print x }</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Add numbers in second column and print total:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">{total += $2 }; END { print &quot;column total is&quot;, total}</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Print lines that contain less than 20 characters:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">length($0) &lt; 20</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Print each line that begins with <CODECLASS="literal">Name:</CODE> and that contains exactly seven fields:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">NF == 7 &amp;&amp; /^Name:/</PRE></BLOCKQUOTE></P></LI></OL></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.3">33.11.3 awk System Variables </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-37311"></A><ACLASS="indexterm"NAME="AUTOID-37314"></A><EMCLASS="emphasis">nawk</EM> supports all <EMCLASS="emphasis">awk</EM> variables.<EMCLASS="emphasis">gawk</EM> supports both <EMCLASS="emphasis">nawk</EM> and <EMCLASS="emphasis">awk</EM>.<TABLECLASS="informaltable"><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Version</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Variable</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Description</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">awk</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">FILENAME</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Current filename</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">FS</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Field separator (default is whitespace)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">NF</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Number of fields in current record</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">NR</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Number of the current record</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">OFMT</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Output format for numbers (default is <CODECLASS="literal">%.6g</CODE>)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">OFS</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Output field separator (default is a blank)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">ORS</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Output record separator (default is a newline)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">RS</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Record separator (default is a newline)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">$0</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Entire input record</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">$</CODE><CODECLASS="replaceable"><I>n</I></CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="replaceable"><I>n</I></CODE>th field in current record;fields are separated by <EMCLASS="emphasis">FS</EM></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">nawk</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">ARGC</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Number of arguments on command line</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">ARGV</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">An array containing the command-line arguments</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">ENVIRON</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">An associative array of environment variables</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">FNR</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Like <EMCLASS="emphasis">NR</EM>, but relative to the current file</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">RSTART</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">First position in the string matched by <EMCLASS="emphasis">match</EM> function</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">RLENGTH</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Length of the string matched by <EMCLASS="emphasis">match</EM> function</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">SUBSEP</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Separator character for array subscripts (default is <CODECLASS="literal">\034</CODE>)</TD></TR></TBODY></TABLE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.4">33.11.4 Operators </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-37411"></A><ACLASS="indexterm"NAME="AUTOID-37414"></A>The table below lists the operators,in order of increasing precedence, that are available in <EMCLASS="emphasis">awk</EM>:<TABLECLASS="informaltable"><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Symbol</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Meaning</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">= += -= *= /= %= ^=</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Assignment (<CODECLASS="literal">^=</CODE> only in <EMCLASS="emphasis">nawk</EM> and <EMCLASS="emphasis">gawk</EM>)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">?:</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">C conditional expression (<EMCLASS="emphasis">nawk</EM> and <EMCLASS="emphasis">gawk</EM>)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">||</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Logical OR</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">&amp;&amp;</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Logical AND</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">~  !~</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Match regular expression and negation</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">&lt; &lt;= &gt; &gt;= != ==</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Relational operators</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">(blank)</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Concatenation</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">+ -</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Addition, subtraction</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">* / %</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Multiplication, division, and modulus</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">+ - !</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Unary plus and minus, and logical negation</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">^</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Exponentiation (<EMCLASS="emphasis">nawk</EM> and <EMCLASS="emphasis">gawk</EM>)</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">++ -- </TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Increment and decrement, either prefix or postfix</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">$</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">Field reference</TD></TR></TBODY></TABLE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.5">33.11.5 Variables and Array Assignments </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-37474"></A><ACLASS="indexterm"NAME="AUTOID-37477"></A><ACLASS="indexterm"NAME="AUTOID-37480"></A>Variables can be assigned a value with an equal sign (<CODECLASS="literal">=</CODE>). For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">FS = &quot;,&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">Expressions using the operators <CODECLASS="literal">+</CODE>, <CODECLASS="literal">-</CODE>, <CODECLASS="literal">*</CODE>,<CODECLASS="literal">/</CODE>, and <CODECLASS="literal">%</CODE> (modulo) can be assigned to variables.</P><PCLASS="para">Arrays can be created with the <EMCLASS="emphasis">split</EM> function (see below), or they can simply be named in an assignment statement.Array elements can be subscripted with numbers (<CODECLASS="replaceable"><I>array</I></CODE><CODECLASS="literal">[1]</CODE>,...<CODECLASS="replaceable"><I>array</I></CODE><CODECLASS="literal">[</CODE><CODECLASS="replaceable"><I>n</I></CODE><CODECLASS="literal">]</CODE>)or with names. For example, to count the number of occurrences of apattern, you could use the following script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/<CODECLASS="replaceable"><I>pattern</I></CODE>/ { <CODECLASS="replaceable"><I>array</I></CODE>[&quot;<CODECLASS="replaceable"><I>pattern</I></CODE>&quot;]++ }END { print <CODECLASS="replaceable"><I>array</I></CODE>[&quot;<CODECLASS="replaceable"><I>pattern</I></CODE>&quot;] }</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.6">33.11.6 Group Listing of awk Commands </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="UPT-ART-2860-IX-COMMANDS-AWK-UTILITY"></A><ACLASS="indexterm"NAME="UPT-ART-2860-IX-AWK-UTILITY-COMMANDS-LIST-OF"></A><EMCLASS="emphasis">awk</EM> commands may be classified as follows:<TABLECLASS="informaltable"><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Arithmetic</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">String</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Control Flow</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Input/Output</TH></TR><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Functions</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Functions</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Statements</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Processing</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">atan2*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">gsub*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">break</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">close*</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">cos*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">index</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">continue</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">delete*</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">exp</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">length</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">do/while*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">getline*</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">int</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">match*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">exit</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">next</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">log</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">split</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">for</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">print</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">rand*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">sub*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">if</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">printf</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">sin*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">substr</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">return*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">sprintf</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">sqrt</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">tolower*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">while</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">system*</TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">srand*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1">toupper*</TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD></TR></TBODY></TABLE>*Not in original <EMCLASS="emphasis">awk</EM>&#13;</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-2860-SECT-1.7">33.11.7 Alphabetical Summary of Commands </A></H3><PCLASS="para">The following alphabetical list of statements and functionsincludes all that are available in <EMCLASS="emphasis">awk</EM>, <EMCLASS="emphasis">nawk</EM>, or <EMCLASS="emphasis">gawk</EM>.Unless otherwise mentioned, the statement or function is foundin all versions. New statements and functions introducedwith <EMCLASS="emphasis">nawk</EM> are also found in <EMCLASS="emphasis">gawk</EM>.</P><DLCLASS="variablelist"><DTCLASS="term"><CODECLASS="literal">atan2</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">atan2(</CODE><CODECLASS="replaceable"><I>y</I></CODE><CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>x</I></CODE><CODECLASS="literal">)</CODE> <ACLASS="indexterm"NAME="AUTOID-37596"></A>Returns the arctangent of <CODECLASS="replaceable"><I>y</I></CODE>/<CODECLASS="replaceable"><I>x</I></CODE> in radians. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">break</CODE></DT><DDCLASS="listitem"><PCLASS="para">Exit from a <EMCLASS="emphasis">while</EM>, <EMCLASS="emphasis">for</EM>, or <EMCLASS="emphasis">do</EM> loop.<ACLASS="indexterm"NAME="AUTOID-37609"></A>&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">close</CODE></DT><DDCLASS="listitem"><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="literal">close(</CODE><CODECLASS="replaceable"><I>filename-expr</I></CODE><CODECLASS="literal">)</CODE><CODECLASS="literal">close(</CODE><CODECLASS="replaceable"><I>command-expr</I></CODE><CODECLASS="literal">)</CODE></PRE></BLOCKQUOTE>In some implementations of <EMCLASS="emphasis">awk</EM>, you can have only ten files open<ACLASS="indexterm"NAME="AUTOID-37624"></A>simultaneously and one pipe; modern versions allow more than one pipe open.Therefore, <EMCLASS="emphasis">nawk</EM> provides a <EMCLASS="emphasis">close</EM>statement that allows you to close a file or a pipe. <EMCLASS="emphasis">close</EM> takesas an argument the same expression that opened the pipeor file. (<EMCLASS="emphasis">nawk</EM>)</P></DD><DTCLASS="term"><CODECLASS="literal">continue</CODE></DT><DDCLASS="listitem"><PCLASS="para">Begin next iteration of <EMCLASS="emphasis">while</EM>, <EMCLASS="emphasis">for</EM>, or <EMCLASS="emphasis">do</EM> loop immediately.<ACLASS="indexterm"NAME="AUTOID-37638"></A>&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">cos</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">cos(</CODE><CODECLASS="replaceable"><I>x</I></CODE><CODECLASS="literal">)</CODE>Return cosine of <CODECLASS="replaceable"><I>x</I></CODE> (in radians).<ACLASS="indexterm"NAME="AUTOID-37649"></A>(<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">delete</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">delete </CODE><CODECLASS="replaceable"><I>array</I></CODE>[<CODECLASS="replaceable"><I>element</I></CODE>]<CODECLASS="literal"> </CODE>Delete <CODECLASS="replaceable"><I>element</I></CODE> of <CODECLASS="replaceable"><I>array</I></CODE>. (<EMCLASS="emphasis">nawk</EM>)<ACLASS="indexterm"NAME="AUTOID-37664"></A>&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">do</CODE></DT><DDCLASS="listitem"><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="literal">do</CODE>     <CODECLASS="replaceable"><I>body</I></CODE><CODECLASS="literal">while (</CODE><CODECLASS="replaceable"><I>expr</I></CODE><CODECLASS="literal">)</CODE></PRE></BLOCKQUOTE>Looping statement.<ACLASS="indexterm"NAME="AUTOID-37677"></A>Execute statements in <CODECLASS="replaceable"><I>body</I></CODE>, then evaluate <CODECLASS="replaceable"><I>expr</I></CODE>.If <CODECLASS="replaceable"><I>expr</I></CODE> is true, execute <CODECLASS="replaceable"><I>body</I></CODE> again.More than one <CODECLASS="replaceable"><I>command</I></CODE> must be put inside braces (<CODECLASS="literal">{}</CODE>).(<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">exit</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">exit</CODE>[<CODECLASS="replaceable"><I>expr</I></CODE>]Do not execute remaining instructions and do not read new input.<ACLASS="indexterm"NAME="AUTOID-37693"></A>ENDprocedure, if any, will be executed.The <CODECLASS="literal">expr</CODE>, if any, becomes <EMCLASS="emphasis">awk</EM>'s <SPANCLASS="link">exit status (<ACLASS="linkend"HREF="ch44_07.htm"TITLE="Exit Status of UNIX Processes ">44.7</A>)</SPAN>.&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">exp</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">exp(</CODE><CODECLASS="replaceable"><I>arg</I></CODE><CODECLASS="literal">)&#13;</CODE>Return the natural exponent of <CODECLASS="replaceable"><I>arg</I></CODE>.<ACLASS="indexterm"NAME="AUTOID-37707"></A>&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">for</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">for (</CODE>[<CODECLASS="replaceable"><I>init-expr</I></CODE>]<CODECLASS="literal">; </CODE>[<CODECLASS="replaceable"><I>test-expr</I></CODE>]<CODECLASS="literal">; </CODE>[<CODECLASS="replaceable"><I>incr-expr</I></CODE>]<CODECLASS="literal">)</CODE>    <CODECLASS="replaceable"><I>command</I></CODE>C-language-style looping construct.<ACLASS="indexterm"NAME="AUTOID-37722"></A>Typically, <CODECLASS="replaceable"><I>init-expr</I></CODE> assigns the initial value of a countervariable.<CODECLASS="replaceable"><I>test-expr</I></CODE> is a relational expression that is evaluated each timebefore executing the <CODECLASS="replaceable"><I>command</I></CODE>.When <CODECLASS="replaceable"><I>test-expr</I></CODE> is false, the loop is exited.<CODECLASS="replaceable"><I>incr-expr</I></CODE> is used to increment the counter variable after each pass.A series of <CODECLASS="replaceable"><I>command</I></CODE>smust be put within braces (<CODECLASS="literal">{}</CODE>).Example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for (i = 1; i &lt;= 10; i++)     printf &quot;Element %d is %s.\n&quot;, i, array[i]</PRE></BLOCKQUOTE></P><PCLASS="para"></P></DD><DTCLASS="term"><CODECLASS="literal">for</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">for (</CODE><CODECLASS="replaceable"><I>item </I></CODE><CODECLASS="literal">in </CODE><CODECLASS="replaceable"><I>array</I></CODE><CODECLASS="literal">)</CODE>     <CODECLASS="replaceable"><I>command</I></CODE>For each <CODECLASS="replaceable"><I>item</I></CODE> in an associative <CODECLASS="replaceable"><I>array</I></CODE>, do<CODECLASS="replaceable"><I>command</I></CODE>.More than one <CODECLASS="replaceable"><I>command</I></CODE> must be put inside braces (<CODECLASS="literal">{}</CODE>).Refer to each element of the array as <CODECLASS="replaceable"><I>array</I></CODE><CODECLASS="literal">[</CODE><CODECLASS="replaceable"><I>item</I></CODE><CODECLASS="literal">]</CODE>.&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">getline</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">getline </CODE>[<CODECLASS="replaceable"><I>var</I></CODE>][<CODECLASS="literal">&lt;</CODE><CODECLASS="replaceable"><I>file</I></CODE>]        or<CODECLASS="replaceable"><I>command </I></CODE><CODECLASS="literal">| getline </CODE>[<CODECLASS="replaceable"><I>var</I></CODE>]Read next line of input.Original <EMCLASS="emphasis">awk</EM> does not support the syntaxto open multiple input streams.The first form reads input from <CODECLASS="replaceable"><I>file</I></CODE>,and the second form reads the standard output of a UNIX <CODECLASS="replaceable"><I>command</I></CODE>.Both forms read one line at a time, and each timethe statement is executed it gets the next lineof input.The line of input is assigned to <CODECLASS="literal">$0</CODE>,and it is parsed into fields, setting <EMCLASS="emphasis">NF</EM>,<EMCLASS="emphasis">NR</EM>, and <EMCLASS="emphasis">FNR</EM>.If <CODECLASS="replaceable"><I>var</I></CODE> is specified, the result is assignedto <CODECLASS="replaceable"><I>var</I></CODE> and the <CODECLASS="literal">$0</CODE> is not changed.Thus, ifthe result is assigned to a variable, thecurrent line does not change.<EMCLASS="emphasis">getline</EM> is actually a function and it returns 1 if itreads a record successfully, 0 if end-of-file isencountered, and -1 if for some reason it isotherwise unsuccessful. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">gsub</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">gsub(</CODE><CODECLASS="replaceable"><I>r</I></CODE><CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>s</I></CODE>[<CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>t</I></CODE>]<CODECLASS="literal">)</CODE>Globally substitute <CODECLASS="replaceable"><I>s</I></CODE> for each match of the<ACLASS="indexterm"NAME="AUTOID-37791"></A>regular expression <CODECLASS="replaceable"><I>r</I></CODE> in the string <CODECLASS="replaceable"><I>t</I></CODE>.Returnthe number of substitutions.If <CODECLASS="replaceable"><I>t</I></CODE> is not supplied,defaults to <CODECLASS="literal">$0</CODE>. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">if</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">if (</CODE><CODECLASS="replaceable"><I>condition</I></CODE><CODECLASS="literal">)</CODE></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">      <CODECLASS="replaceable"><I>command</I></CODE>[<CODECLASS="literal">else</CODE>      <CODECLASS="replaceable"><I>command</I></CODE>]</PRE></BLOCKQUOTE></P><PCLASS="para">If <CODECLASS="replaceable"><I>condition</I></CODE> is true, do <CODECLASS="replaceable"><I>command(s)</I></CODE>, otherwise do<ACLASS="indexterm"NAME="AUTOID-37814"></A><CODECLASS="replaceable"><I>command(s)</I></CODE> in <EMCLASS="emphasis">else</EM> clause (if any).<CODECLASS="replaceable"><I>condition</I></CODE> can be an expression that uses any of the relational operators <CODECLASS="literal">&lt;</CODE>, <CODECLASS="literal">&lt;=</CODE>, <CODECLASS="literal">==</CODE>, <CODECLASS="literal">!=</CODE>, <CODECLASS="literal">&gt;=</CODE>, or <CODECLASS="literal">&gt;</CODE>, as well asthe pattern-matching operators <CODECLASS="literal">~</CODE> or <CODECLASS="literal">!~</CODE>(e.g., <CODECLASS="literal">if&nbsp;($1&nbsp;~&nbsp;/[Aa].*[Zz]/)</CODE>).A series of <CODECLASS="replaceable"><I>command</I></CODE>s must be put within braces (<CODECLASS="literal">{}</CODE>).</P></DD><DTCLASS="term"><CODECLASS="literal">index</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">index(</CODE><CODECLASS="replaceable"><I>str</I></CODE><CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>substr</I></CODE><CODECLASS="literal">)</CODE>Return position of first substring <CODECLASS="replaceable"><I>substr</I></CODE> in string <CODECLASS="replaceable"><I>str</I></CODE><ACLASS="indexterm"NAME="AUTOID-37842"></A>or 0 if not found.&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">int</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">int(</CODE><CODECLASS="replaceable"><I>arg</I></CODE><CODECLASS="literal">)</CODE>Return integer value of <CODECLASS="replaceable"><I>arg</I></CODE>.<ACLASS="indexterm"NAME="AUTOID-37853"></A>&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">length</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">length(</CODE><CODECLASS="replaceable"><I>arg</I></CODE><CODECLASS="literal">)</CODE>Return the length of <CODECLASS="replaceable"><I>arg</I></CODE>.<ACLASS="indexterm"NAME="AUTOID-37864"></A>&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">log</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">log(</CODE><CODECLASS="replaceable"><I>arg</I></CODE><CODECLASS="literal">)</CODE>Return the natural logarithm of <CODECLASS="replaceable"><I>arg</I></CODE>.<ACLASS="indexterm"NAME="AUTOID-37875"></A>&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">match</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">match(</CODE><CODECLASS="replaceable"><I>s</I></CODE><CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>r</I></CODE><CODECLASS="literal">)</CODE>Function that matches the pattern, specified by the regular expression<ACLASS="indexterm"NAME="AUTOID-37887"></A><CODECLASS="replaceable"><I>r</I></CODE>, in the string <CODECLASS="replaceable"><I>s</I></CODE> and returns either the position in<CODECLASS="replaceable"><I>s</I></CODE> where the match begins or 0 if no occurrences are found.Sets the values of <EMCLASS="emphasis">RSTART</EM> and <EMCLASS="emphasis">RLENGTH</EM>. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">next</CODE></DT><DDCLASS="listitem"><PCLASS="para">Read next input line and start new cycle through pattern/proceduresstatements.<ACLASS="indexterm"NAME="AUTOID-37900"></A>&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">print</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">print </CODE>[<CODECLASS="replaceable"><I>args</I></CODE>] [<CODECLASS="replaceable"><I>destination</I></CODE>]Print <CODECLASS="replaceable"><I>args</I></CODE> on output, followed by a newline.<ACLASS="indexterm"NAME="AUTOID-37911"></A><CODECLASS="replaceable"><I>args</I></CODE> is usually one or more fields,but may also be one or more of the predefined variables&nbsp;- orarbitrary expressions.If no <CODECLASS="replaceable"><I>args</I></CODE> are given, prints <CODECLASS="literal">$0</CODE> (the current input line).Literalstrings must be quoted.Fields areprinted in the order they are listed.If separated by commas (<CODECLASS="literal">,</CODE>) in theargument list, they are separated in the output by the <EMCLASS="emphasis">OFS</EM> character.If separated by spaces, they areconcatenated in the output.<CODECLASS="replaceable"><I>destination</I></CODE> is a UNIX redirection orpipe expression (e.g., <CODECLASS="literal">&gt;&nbsp;</CODE><CODECLASS="replaceable"><I>file</I></CODE>) that redirects the default standard output.&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">printf</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="replaceable"><I>format </I></CODE>[<CODECLASS="literal">, </CODE><CODECLASS="replaceable"><I>expression(s)</I></CODE>] [<CODECLASS="replaceable"><I>destination</I></CODE>]Formatted print statement.<ACLASS="indexterm"NAME="AUTOID-37930"></A>Fields or variables can beformatted according to instructions in the <CODECLASS="replaceable"><I>format</I></CODE> argument.The number of <CODECLASS="replaceable"><I>expression</I></CODE>s must correspond to the number specified in theformat sections.<CODECLASS="replaceable"><I>format</I></CODE> follows the conventions of the C-language <EMCLASS="emphasis">printf</EM>statement.Here are a few of the most common formats:&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">%s</CODE></DT><DDCLASS="listitem"><PCLASS="para">A string.</P></DD><DTCLASS="term"><CODECLASS="literal">%d</CODE></DT><DDCLASS="listitem"><PCLASS="para">A decimal number.</P></DD><DTCLASS="term"><CODECLASS="literal">%</CODE><CODECLASS="replaceable"><I>n</I></CODE><CODECLASS="literal">.</CODE><CODECLASS="replaceable"><I>m</I></CODE><CODECLASS="literal">f</CODE></DT><DDCLASS="listitem"><PCLASS="para">A floating-point number, where <CODECLASS="replaceable"><I>n</I></CODE> is the total number of digitsand <CODECLASS="replaceable"><I>m</I></CODE> is the number of digits after the decimal point.</P></DD><DTCLASS="term"><CODECLASS="literal">%</CODE>[<CODECLASS="literal">-</CODE>]<CODECLASS="replaceable"><I>nc</I></CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="replaceable"><I>n</I></CODE> specifies minimum field length for format type <CODECLASS="replaceable"><I>c</I></CODE>, while<CODECLASS="literal">-</CODE> left justifies value in field; otherwise value is right justified.<CODECLASS="replaceable"><I>format</I></CODE> can also contain embedded escape sequences:<CODECLASS="literal">\n</CODE> (newline) or <CODECLASS="literal">\t</CODE>&nbsp;(tab)are the most common.<CODECLASS="replaceable"><I>destination</I></CODE> is a UNIX redirection orpipe expression (e.g., <CODECLASS="literal">&gt;&nbsp;</CODE><CODECLASS="replaceable"><I>file</I></CODE>) that redirects the default standard output.Example:Using the script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">{printf &quot;The sum on line %s is %d.\n&quot;, NR, $1+$2}</PRE></BLOCKQUOTE></P><PCLASS="para">The following input line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">5   5</PRE></BLOCKQUOTE></P><PCLASS="para">produces this output, followed by a newline:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">The sum on line 1 is 10.</PRE></BLOCKQUOTE></P><PCLASS="para">&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">rand</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">rand()</CODE>Generate a random number between 0 and 1.<ACLASS="indexterm"NAME="AUTOID-37988"></A>This function returns thesame series of numbers each time the script is executed, unless the randomnumber generator is seeded using the <EMCLASS="emphasis">srand(&nbsp;)</EM> function. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">return</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">return </CODE>[<CODECLASS="replaceable"><I>expr</I></CODE>]Used at end of user-defined functions to exit the function,<ACLASS="indexterm"NAME="AUTOID-37999"></A>returning value of expression <CODECLASS="replaceable"><I>expr</I></CODE>, if any. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">sin</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">sin(</CODE><CODECLASS="replaceable"><I>x</I></CODE><CODECLASS="literal">)</CODE><ACLASS="indexterm"NAME="AUTOID-38011"></A>Return sine of <CODECLASS="replaceable"><I>x</I></CODE> (in radians).(<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">split</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">split(</CODE><CODECLASS="replaceable"><I>string</I></CODE><CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>array</I></CODE>[<CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>sep</I></CODE>]<CODECLASS="literal">)</CODE>Split <CODECLASS="replaceable"><I>string</I></CODE> into elements of <CODECLASS="replaceable"><I>array</I></CODE><ACLASS="indexterm"NAME="AUTOID-38029"></A><CODECLASS="literal">array[1],...array[</CODE><CODECLASS="replaceable"><I>n</I></CODE><CODECLASS="literal">]</CODE>.<CODECLASS="replaceable"><I>string</I></CODE>is split at each occurrence of separator <CODECLASS="replaceable"><I>sep</I></CODE>.(In <EMCLASS="emphasis">nawk</EM>, the separator may be a regular expression.)If <CODECLASS="replaceable"><I>sep</I></CODE> isnot specified, <EMCLASS="emphasis">FS</EM> is used.The number of array elements created isreturned.&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">sprintf</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">sprintf (</CODE><CODECLASS="replaceable"><I>format </I></CODE>[<CODECLASS="literal">, </CODE><CODECLASS="replaceable"><I>expression(s)</I></CODE>]<CODECLASS="literal">)</CODE>Return the value of <CODECLASS="replaceable"><I>expression(s)</I></CODE>, using the specified <CODECLASS="replaceable"><I>format</I></CODE><ACLASS="indexterm"NAME="AUTOID-38051"></A>(see <EMCLASS="emphasis">printf</EM>).Data is formatted but not printed.&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">sqrt</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">sqrt(</CODE><CODECLASS="replaceable"><I>arg</I></CODE><CODECLASS="literal">)</CODE>Return square root of <CODECLASS="replaceable"><I>arg</I></CODE>.<ACLASS="indexterm"NAME="AUTOID-38063"></A>&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">srand</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">srand(</CODE><CODECLASS="replaceable"><I>expr</I></CODE><CODECLASS="literal">)</CODE><ACLASS="indexterm"NAME="AUTOID-38073"></A>Use <CODECLASS="replaceable"><I>expr</I></CODE> to set a new seed for random number generator.Default is time of day.Returns the old seed.(<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">sub</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">sub(</CODE><CODECLASS="replaceable"><I>r</I></CODE><CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>s</I></CODE>[<CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>t</I></CODE>]<CODECLASS="literal">)</CODE>Substitute <CODECLASS="replaceable"><I>s</I></CODE> for first match of the<ACLASS="indexterm"NAME="AUTOID-38090"></A>regular expression <CODECLASS="replaceable"><I>r</I></CODE> in the string <CODECLASS="replaceable"><I>t</I></CODE>.Return1 if successful; 0 otherwise.If <CODECLASS="replaceable"><I>t</I></CODE> is not supplied,defaults to <CODECLASS="literal">$0</CODE>. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">substr</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">substr(</CODE><CODECLASS="replaceable"><I>string</I></CODE><CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>m</I></CODE>[<CODECLASS="literal">,</CODE><CODECLASS="replaceable"><I>n</I></CODE>]<CODECLASS="literal">)</CODE>Return substring of <CODECLASS="replaceable"><I>string</I></CODE> beginning at character position<ACLASS="indexterm"NAME="AUTOID-38110"></A><CODECLASS="replaceable"><I>m</I></CODE> and consisting of the next <CODECLASS="replaceable"><I>n</I></CODE> characters.If <CODECLASS="replaceable"><I>n</I></CODE> isomitted, include all characters to the end of string.&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">system</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">system(</CODE><CODECLASS="replaceable"><I>command</I></CODE><CODECLASS="literal">)</CODE>Function that executes the specified UNIX <CODECLASS="replaceable"><I>command</I></CODE> and returns its<ACLASS="indexterm"NAME="AUTOID-38124"></A><SPANCLASS="link">status (<ACLASS="linkend"HREF="ch44_07.htm"TITLE="Exit Status of UNIX Processes ">44.7</A>)</SPAN>.The status of the command that is executed typicallyindicates its success (0) or failure (non-zero).The output of the command is not available for processingwithin the <EMCLASS="emphasis">nawk</EM> script.Use <CODECLASS="replaceable"><I>command</I></CODE>&nbsp;<CODECLASS="literal">|</CODE>&nbsp;<CODECLASS="literal">getline</CODE> toread the output of the command into the script. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">tolower</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">tolower(</CODE><CODECLASS="replaceable"><I>str</I></CODE><CODECLASS="literal">)</CODE>Translate all uppercase characters<ACLASS="indexterm"NAME="AUTOID-38140"></A>in <CODECLASS="replaceable"><I>str</I></CODE> to lowercase and return the new string. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">toupper</CODE></DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">toupper(</CODE><CODECLASS="replaceable"><I>str</I></CODE><CODECLASS="literal">)</CODE>Translate all lowercase characters<ACLASS="indexterm"NAME="AUTOID-38152"></A>in <CODECLASS="replaceable"><I>str</I></CODE> to uppercase and return the new string. (<EMCLASS="emphasis">nawk</EM>)&#13;</P></DD><DTCLASS="term"><CODECLASS="literal">while</CODE></DT><DDCLASS="listitem"><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="literal">while (</CODE><CODECLASS="replaceable"><I>condition</I></CODE><CODECLASS="literal">)</CODE>      <CODECLASS="replaceable"><I>command</I></CODE></PRE></BLOCKQUOTE>Do <CODECLASS="replaceable"><I>command</I></CODE> while <CODECLASS="replaceable"><I>condition</I></CODE> is true (see <CODECLASS="literal">if</CODE> for a<ACLASS="indexterm"NAME="AUTOID-38169"></A>description of allowable conditions).A series of commands must be put within braces (<CODECLASS="literal">{}</CODE>).</P></DD></DL><ACLASS="indexterm"NAME="AUTOID-38172"></A><ACLASS="indexterm"NAME="AUTOID-38173"></A><ACLASS="indexterm"NAME="AUTOID-38174"></A><ACLASS="indexterm"NAME="AUTOID-38175"></A><ACLASS="indexterm"NAME="AUTOID-38176"></A></DIV><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">DG</SPAN> <SPANCLASS="bibliomisc">from O'Reilly &amp; Associates' <CITECLASS="citetitle">UNIX in a Nutshell (SVR4/Solaris)</CITE></SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch33_10.htm"TITLE="33.10 Quick Globals from the Command Line with qsubst "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 33.10 Quick Globals from the Command Line with qsubst "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch33_12.htm"TITLE="33.12 Versions of awk "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 33.12 Versions of awk "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">33.10 Quick Globals from the Command Line with qsubst </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">33.12 Versions of awk </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>