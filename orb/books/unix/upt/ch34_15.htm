<HTML><HEAD><TITLE>[Chapter 34] 34.15 Making Edits Across Line Boundaries </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:47:23Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch34_01.htm"TITLE="34. The sed Stream Editor"><LINKREL="prev"HREF="ch34_14.htm"TITLE="34.14 Transforming Part of a Line "><LINKREL="next"HREF="ch34_16.htm"TITLE="34.16 The Deliberate Scrivener "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch34_14.htm"TITLE="34.14 Transforming Part of a Line "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 34.14 Transforming Part of a Line "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 34<BR>The sed Stream Editor</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch34_16.htm"TITLE="34.16 The Deliberate Scrivener "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 34.16 The Deliberate Scrivener "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-0089">34.15 Making Edits Across Line Boundaries </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="UPT-ART-89-IX-SED-PATTERN-SPACE"></A><ACLASS="indexterm"NAME="AUTOID-38964"></A>Most programs that use<SPANCLASS="link">regular expressions (<ACLASS="linkend"HREF="ch26_04.htm"TITLE="Using Metacharacters in Regular Expressions ">26.4</A>)</SPAN>are ableto match a pattern only on a single line of input. This makesit difficult to find or change a phrase, for instance, because it can startnear the end of one line and finish near the beginning of the nextline. Other patterns might be significant only when repeatedon multiple lines.</P><PCLASS="para"><EMCLASS="emphasis">sed</EM> has the ability to load more than one line into the patternspace.This allows you to match (and change) patterns that extend over multiple lines.In this article, we show how tocreate a multiline pattern space and manipulateits contents. </P><PCLASS="para">The multiline Next command, <EMCLASS="emphasis">N</EM>, creates a multiline pattern spaceby reading a new line of input and appending it to thecontents of the pattern space.The original contents of the pattern space and the new input lineare separated by a newline.The embedded newline character can be matched in patternsby the escape sequence <CODECLASS="literal">\n</CODE>.In a multiline pattern space, only the metacharacter <CODECLASS="literal">^</CODE> matches the newline at the beginning of the pattern spaceand <CODECLASS="literal">$</CODE> matches the newline at the end. After the Next command is executed, control is then passed to subsequent commands in the script.</P><PCLASS="para">The Next command differs from the next command, <EMCLASS="emphasis">n</EM>,which outputs the contents of the pattern spaceand then reads a new line of input. The next command doesnot create a multiline pattern space. </P><PCLASS="para">For our first example, let's suppose that we wanted tochange &quot;Owner and Operator Guide&quot; to &quot;Installation Guide&quot;but we found that it appears in the file on two lines,splitting between <CODECLASS="literal">Operator</CODE> and <CODECLASS="literal">Guide</CODE>.For instance, here are a few lines of sample text:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Consult Section 3.1 in the Owner and OperatorGuide for a description of the tape drivesavailable on your system.</PRE></BLOCKQUOTE></P><PCLASS="para">The following script looks for <CODECLASS="literal">Operator</CODE> at the end of a line, reads the next line of input, and then makesthe replacement:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/Operator$/{    N    s/Owner and Operator\nGuide/Installation Guide/}</PRE></BLOCKQUOTE></P><PCLASS="para">&#13;In this example, we know where the two lines split and where to specify the embedded newline.When the script is run on the sample file, it producesthe two lines of output, one of which combinesthe first and second lines and is too longto show here.This happens because the substitute command matchesthe embedded newline but does not replace it. Unfortunately, you cannot use <CODECLASS="literal">\n</CODE> to insert a newlinein the replacement string.You must either use the backslashto escape the newline, as follows:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">s/Owner and Operator\nGuide /Installation Guide\/</PRE></BLOCKQUOTE></P><PCLASS="para">or use the<SPANCLASS="link"><CODECLASS="literal">\(</CODE>..<CODECLASS="literal">\)</CODE> operators (<ACLASS="linkend"HREF="ch34_10.htm"TITLE="Referencing Portions of a Search String ">34.10</A>)</SPAN>to keep the newline:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">s/Owner and Operator\(\n\)Guide /Installation Guide\1/</PRE></BLOCKQUOTE></P><PCLASS="para">This command restores the newline after <CODECLASS="literal">Installation Guide</CODE>.It is also necessary to match a blank space following <CODECLASS="literal">Guide</CODE>so the new line won't begin with a space. Now we can show the output: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Consult Section 3.1 in the Installation Guide for a description of the tape drivesavailable on your system.</PRE></BLOCKQUOTE></P><PCLASS="para">Remember, you don't have to replace the newline, but if youdon't, it can make for some long lines.</P><PCLASS="para">What if there are other occurrences of &quot;Owner and Operator Guide&quot; that break overmultiple lines in different places? You could change the address to match <CODECLASS="literal">Owner</CODE>, the firstword in the pattern instead of the last, and then modify the regular expression to look for a space or a newlinebetween words, as shown below:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">/Owner/{Ns/Owner *\n*and *\n*Operator *\n*Guide/Installation Guide/}</PRE></BLOCKQUOTE></P><PCLASS="para">The asterisk (<CODECLASS="literal">*</CODE>) indicates that the space or newline is optional.This seems like hard work though, and indeed there is a moregeneral way. We can read the newlineinto the pattern space and thenuse a substitute command to remove the embedded newline, whereverit is: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">s/Owner and Operator Guide/Installation Guide//Owner/{Ns/ *\n/ /s/Owner and Operator Guide */Installation Guide\/}</PRE></BLOCKQUOTE></P><PCLASS="para">The first line of the script matches <CODECLASS="literal">Owner and Operator Guide</CODE> when it appearson a line by itself. (See the discussion at the end of the article aboutwhy this is necessary.)If we match the string<CODECLASS="literal">Owner</CODE>, we read the next line into the pattern space and replace theembedded newline with a space. Then we attempt to match the wholepattern and make the replacement followed by a newline.This script will match <CODECLASS="literal">Owner and OperatorGuide</CODE> regardlessof how it is broken across two lines.Here's our expanded test file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Consult Section 3.1 in the Owner and OperatorGuide for a description of the tape drivesavailable on your system.Look in the Owner and Operator Guide shipped with your system.Two manuals are provided, including the Owner andOperator Guide and the User Guide.The Owner and Operator Guide is shipped with your system.</PRE></BLOCKQUOTE></P><PCLASS="para">Running the above script on the sample file producesthe following result:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>sed -f sedscr sample</B></CODE>Consult Section 3.1 in the Installation Guidefor a description of the tape drivesavailable on your system.Look in the Installation Guide shipped with your system.Two manuals are provided, including the Installation Guideand the User Guide.The Installation Guide is shipped with your system.</PRE></BLOCKQUOTE></P><PCLASS="para">&#13;In this sample script, itmight seem redundant to have two substitute commands thatmatch the pattern. The first command matches it when thepattern is found already on one line, and the second matchesthe pattern after two lines have been read into the pattern space. Why the first command is necessary is perhaps best demonstratedby removing that command from the script and running it onthe sample file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>sed -f sedscr2 sample</B></CODE>Consult Section 3.1 in the Installation Guidefor a description of the tape drivesavailable on your system.Look in the Installation Guideshipped with your system.Two manuals are provided, including the Installation Guideand the User Guide.</PRE></BLOCKQUOTE></P><PCLASS="para">Do you see the two problems?The most obvious problem is that the last linedid not print. The last line matches <CODECLASS="literal">Owner</CODE>, andwhen <EMCLASS="emphasis">N</EM> is executed, there is not another inputline to read, so <EMCLASS="emphasis">sed</EM> quits.It does not even output the line.If this is the normalbehavior,the Next command should be used as followsto be safe: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$!N</PRE></BLOCKQUOTE></P><PCLASS="para">It excludes the last line (<CODECLASS="literal">$</CODE>) from the Next command.As it is in our script, by matching <CODECLASS="literal">Owner and OperatorGuide</CODE> on the last line, we avoid matching <CODECLASS="literal">Owner</CODE>and applying the <EMCLASS="emphasis">N</EM> command. However, if the word <CODECLASS="literal">Owner</CODE>appeared on the last line we'd have the same problemunless we implement the <CODECLASS="literal">$!N</CODE> syntax. </P><PCLASS="para">The second problem is a little less conspicuous. It hasto do with the occurrence of <CODECLASS="literal">Owner and OperatorGuide</CODE> in the second paragraph. In the input file,it is found on a line by itself: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Look in the Owner and Operator Guide shipped with your system.</PRE></BLOCKQUOTE></P><PCLASS="para">In the output shown above, the blank line following<CODECLASS="literal">shipped with your system</CODE> is missing. The reason forthis is that this line matches <CODECLASS="literal">Owner</CODE> and the nextline, a blank line, is appended to the pattern space.The substitute command removes the embedded newline, andthe blank line has in effect vanished. (If the linewere not blank, the newline would still be removedbut the text would  appear on the same line with<CODECLASS="literal">shipped with your system</CODE>.) The bestsolution seems to be to avoid reading the next linewhen the pattern can be matched on one line.So, that is why the first instruction attempts to match the casewhere the string appears all on one line.<ACLASS="indexterm"NAME="AUTOID-39045"></A></P><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">DD</SPAN> <SPANCLASS="bibliomisc">from O'Reilly &amp; Associates' <CITECLASS="citetitle">sed &amp; awk</CITE>, Chapter 6</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch34_14.htm"TITLE="34.14 Transforming Part of a Line "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 34.14 Transforming Part of a Line "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch34_16.htm"TITLE="34.16 The Deliberate Scrivener "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 34.16 The Deliberate Scrivener "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">34.14 Transforming Part of a Line </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">34.16 The Deliberate Scrivener </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>