<HTML><HEAD><TITLE>[Chapter 37] 37.4 Why Learn Perl? #2 </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:48:53Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch37_01.htm"TITLE="37. Perl, a Pathologically Eclectic Rubbish Lister"><LINKREL="prev"HREF="ch37_03.htm"TITLE="37.3 Three Great Virtues of a Programmer "><LINKREL="next"HREF="ch37_05.htm"TITLE="37.5 And Now, Perl 5 "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch37_03.htm"TITLE="37.3 Three Great Virtues of a Programmer "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 37.3 Three Great Virtues of a Programmer "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 37<BR>Perl, a Pathologically Eclectic Rubbish Lister</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch37_05.htm"TITLE="37.5 And Now, Perl 5 "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 37.5 And Now, Perl 5 "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-5562">37.4 Why Learn Perl? #2 </A></H2><PCLASS="para">Donning my vestments as devil's advocate, let me start by saying thatjust because you learn something new, you shouldn't entirely forgetthe old.  UNIX is a pluralistic environment in which many pathscan lead to the solution, some more circuitously than others.Different problems can call for different solutions.  If you forceyourself to program in nothing but Perl, you may be short-changingyourself and taking the more tortuous route for some problems.</P><PCLASS="para">Now, that being said, I shall now reveal my true colors as Perldisciple and perhaps not infrequent evangelist.  Perl is withoutquestion the greatest single program to appear in the UNIXcommunity (although it runs elsewhere, too) in the last ten years.[Tom wrote this in 1992 or so, but I'd bet his opinion hasn't changedsince then. <CODECLASS="literal">;-)</CODE> <EMCLASS="emphasis">-JP</EM>&nbsp;] It makes programming fun again.It's simple enough to get a quick start on, but rich enough for somevery complex tasks.  I frequently learn new things about it despitehaving used it nearly daily since Larry Wall first released it to thegeneral public around 1991.  Heck, sometimes even Larry learnssomething new about Perl! The Artist is not always aware of thebreadth and depth of his own work.</P><PCLASS="para">It is indeed the case that Perl is a strict superset of <EMCLASS="emphasis">sed</EM> and<EMCLASS="emphasis">awk</EM>, so much so that <EMCLASS="emphasis">s2p</EM> and <EMCLASS="emphasis">a2p</EM> translators existfor these utilities.  You can do anything in Perl that you can do inthe shell, although Perl is, strictly speaking, not a commandinterpreter.  It's more of a programming language.</P><PCLASS="para">Most of us have written, or at least seen, shell scripts from hell.While often touted as one of UNIX's strengths because they'reconglomerations of small, single-purpose tools, these shell scriptsquickly grow so complex that they're cumbersome and hard tounderstand, modify, and maintain.  After a certain point ofcomplexity, the strength of the UNIX philosophy of having manyprograms that each does one thing well becomes its weakness.</P><PCLASS="para">The big problem with piping tools together is that there is only onepipe.  This means that several different data streams have to getmultiplexed into a single data stream, then demuxed on the other endof the pipe.  This wastes processor time as well as human brain power.</P><PCLASS="para">For example, you might be shuffling a list of filenames through apipe, but you also want to indicate that certain files have aparticular attribute, and others don't.  (For example, certain filesare more than ten days old.)  Typically, this information is encodedin the data stream by appending or prepending some special markerstring to the filename.  This means that both the pipe feeder and thepipe reader need to know about it.  Not a pretty sight.</P><PCLASS="para">Because <EMCLASS="emphasis">perl</EM> is one program rather than a dozen others(<EMCLASS="emphasis">sh</EM>, <EMCLASS="emphasis">awk</EM>, <EMCLASS="emphasis">sed</EM>, <EMCLASS="emphasis">tr</EM>, <EMCLASS="emphasis">wc</EM>, <EMCLASS="emphasis">sort</EM>,<EMCLASS="emphasis">grep</EM>, and so on), it is usually clearer to express yourself in<EMCLASS="emphasis">perl</EM> than in <EMCLASS="emphasis">sh</EM> and allies, and often more efficient aswell.  You don't need as many pipes, temporary files, or separateprocesses to do the job.  You don't need to go shoving your datastream out to <EMCLASS="emphasis">tr</EM> and back, and to <EMCLASS="emphasis">sed</EM> and back, and to<EMCLASS="emphasis">awk</EM> and back, and to <EMCLASS="emphasis">sort</EM> and back, and then back to<EMCLASS="emphasis">sed</EM>, and back again.  Doing so can often be slow, awkward,and/or confusing.</P><PCLASS="para">Anyone who's ever tried to pass command-line arguments into a<EMCLASS="emphasis">sed</EM> script of moderate complexity or above can attest to thefact that getting the quoting right is not a pleasant task.  In fact,quoting in general in the shell is just not a pleasant thing to codeor to read.</P><PCLASS="para">In a heterogeneous computing environment, the available versions ofmany tools vary too much from one system to the next to be utterlyreliable.  Does your <EMCLASS="emphasis">sh</EM> understand functions on all yourmachines?  What about your <EMCLASS="emphasis">awk</EM>?  What about local variables?It is very difficult to do complex programming without being able tobreak a problem up into subproblems of lesser complexity.  You'reforced to resort to using the shell to call other shell scripts andallow UNIX's power of<SPANCLASS="link">spawning processes (<ACLASS="linkend"HREF="ch38_02.htm"TITLE="fork and exec ">38.2</A>)</SPAN>to serve as your subroutine mechanism, which is inefficient at best.That means your script will require several separate scripts to run,and getting all these installed, working, and maintained on all thedifferent machines in your local configuration is painful.  With<EMCLASS="emphasis">perl</EM>, all you need to do is get it installed on thesystem&nbsp;- which is really pretty easy thanks to Larry's <EMCLASS="emphasis">Configure</EM>program&nbsp;- and after that you're home free.</P><PCLASS="para">Perl is even beginning to be included by some software and hardwarevendors' standard software distributions.  I predict we'll see a lotmore of this in the next couple of years.</P><PCLASS="para">Besides being faster, <EMCLASS="emphasis">perl</EM> is a more powerful tool than<EMCLASS="emphasis">sh</EM>, <EMCLASS="emphasis">sed</EM>, or <EMCLASS="emphasis">awk</EM>.  I realize these are fighting wordsin some camps, but so be it.  There exists a substantial niche betweenshell programming and C programming that <EMCLASS="emphasis">perl</EM> convenientlyfills.  Tasks of this nature seem to arise with extreme frequency inthe realm of system administration.  Since system administratorsalmost invariably have far too much to do to devote a week to codingup every task before them in C, <EMCLASS="emphasis">perl</EM> is especially useful forthem.  Larry Wall, Perl's author, has been known to call it &quot;a shellfor C programmers.&quot;  I like to think of it as a &quot;BASIC forUNIX.&quot;  I realize that this carries both good and badconnotations.</P><PCLASS="para">In what ways is <EMCLASS="emphasis">perl</EM> more powerful than the individual tools?This list is pretty long, so what follows is not necessarily anexhaustive list.  To begin with, you don't have to worry aboutarbitrary and annoying restrictions on string length, input linelength, or number of elements in an array.  These are all virtuallyunlimited; i.e., limited to your system's address space and virtualmemory size.</P><PCLASS="para">Perl's<SPANCLASS="link">regular expression (<ACLASS="linkend"HREF="ch26_04.htm"TITLE="Using Metacharacters in Regular Expressions ">26.4</A>)</SPAN>handling is far and above the best I've ever seen.  For one thing, youdon't have to remember which tool wants which particular flavor ofregular expressions, or lament the fact that one tool doesn't allow<CODECLASS="literal">(..|..)</CODE> constructs or <CODECLASS="literal">+</CODE>'s <CODECLASS="literal">\b</CODE>'s or whatever.With Perl, it's all the same&nbsp;- and, as far as I can tell, a propersuperset of all the others.</P><PCLASS="para">Perl has a fully functional symbolic debugger (written, of course, inPerl) that is an indispensable aid in debugging complex programs.Neither the shell nor <EMCLASS="emphasis">sed</EM>/<EMCLASS="emphasis">awk</EM>/<EMCLASS="emphasis">sort</EM>/<EMCLASS="emphasis">tr</EM>/... havesuch a thing.</P><PCLASS="para">Perl has a loop control mechanism that's more powerful even than C's.You can do the equivalent of a <EMCLASS="emphasis">break</EM> or <EMCLASS="emphasis">continue</EM>(<EMCLASS="emphasis">last</EM> and <EMCLASS="emphasis">next</EM> in Perl) of any arbitrary loop, not merelythe nearest enclosing one.  You can even do a kind of <EMCLASS="emphasis">continue</EM>that doesn't trigger the re-initialization part of a loop, somethingyou may, from time to time, want to do.</P><PCLASS="para">Perl's data types and operators are richer than the shells' or<EMCLASS="emphasis">awk</EM>'s, because you have scalars, numerically-indexed arrays(lists), and string-indexed (hashed) arrays.  Each of these holdsarbitrary data values, including floating-point numbers, for whichmathematic built-in subroutines and power operators are available.  Itcan handle binary data of arbitrary size.</P><PCLASS="para">Speaking of LISP, you can generate strings, perhaps with<EMCLASS="emphasis">sprintf</EM>&nbsp;(&nbsp;), and then <EMCLASS="emphasis">eval</EM> them.  That way you cangenerate code on the fly.  You can even do lambda-type functions thatreturn newly created functions that you can call later. The scoping ofvariables is dynamic; fully recursive subroutines are supported; andyou can pass or return any type of data into or out of yoursubroutines.</P><PCLASS="para">You have a built-in automatic formatter for generating pretty printedforms with automatic pagination and headers and center-justified andtext-filled fields like <CODECLASS="literal">%(|fmt)s</CODE>, if you can imagine what thatwould actually be were it legal.</P><PCLASS="para">There's a mechanism for writing<SPANCLASS="link">SUID (<ACLASS="linkend"HREF="ch01_23.htm"TITLE="File Access Permissions ">1.23</A>)</SPAN>programs that can be made more secure than even C programs, thanks toan elaborate data-tracing mechanism that understands the &quot;taintedness&quot;of data derived from external sources.  It won't let you do anythingreally stupid that you might not have thought of.</P><PCLASS="para">You have access to just about any system-related function or systemcall, like <EMCLASS="emphasis">ioctl</EM>s, <EMCLASS="emphasis">fcntl</EM>, <EMCLASS="emphasis">select</EM>, <EMCLASS="emphasis">pipe</EM> and<EMCLASS="emphasis">fork</EM>, <EMCLASS="emphasis">getc</EM>, <EMCLASS="emphasis">socket</EM> and <EMCLASS="emphasis">bind</EM>, and <EMCLASS="emphasis">connect</EM>and <EMCLASS="emphasis">attach</EM>, and indirect <EMCLASS="emphasis">syscall</EM> invocation, as well asthings like <EMCLASS="emphasis">getpwuid</EM>, <EMCLASS="emphasis">gethostbyname</EM>, etc.  You canread in binary data laid out by a C program or system call usingstructure-conversion templates.</P><PCLASS="para">At the same time you can get at the high-level shell-type operationslike the<SPANCLASS="link"><EMCLASS="emphasis">-r</EM> or <EMCLASS="emphasis">-w</EM> tests (<ACLASS="linkend"HREF="ch44_20.htm"TITLE="test: Testing Files and Strings ">44.20</A>)</SPAN>on files or<SPANCLASS="link"><CODECLASS="literal">`backquote`</CODE> (<ACLASS="linkend"HREF="ch09_16.htm"TITLE="Command Substitution ">9.16</A>)</SPAN>command interpolation.  You can do file-globbing with the<SPANCLASS="link"><CODECLASS="literal">&lt;*.[</CODE><CODECLASS="replaceable"><I>ch</I></CODE><CODECLASS="literal">]&gt;</CODE> (<ACLASS="linkend"HREF="ch15_01.htm#UPT-ART-1480"TITLE="File Naming Wildcards ">15.1</A>)</SPAN>notation or do low-level <EMCLASS="emphasis">readdir</EM>s as suits your fancy.</P><PCLASS="para">DBM files can be accessed using simple array notation.  This is reallynice for dealing with system databases (aliases, news, ...), efficientaccess mechanisms over large data sets, and for keeping persistentdata.</P><PCLASS="para">Don't be dismayed by the apparent complexity of what I've justdiscussed.  Perl is actually very easy to learn because so much of itderives from existing tools.  It's like interpreter C with <EMCLASS="emphasis">sh</EM>,<EMCLASS="emphasis">sed</EM>, <EMCLASS="emphasis">awk</EM>, and a lot more built into it.  And, finally,there's a lot of code out there already written in Perl, includinglibraries to handle things you don't feel like re-implementing.<ACLASS="indexterm"NAME="AUTOID-42056"></A></P><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">TC</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch37_03.htm"TITLE="37.3 Three Great Virtues of a Programmer "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 37.3 Three Great Virtues of a Programmer "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch37_05.htm"TITLE="37.5 And Now, Perl 5 "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 37.5 And Now, Perl 5 "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">37.3 Three Great Virtues of a Programmer </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">37.5 And Now, Perl 5 </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>