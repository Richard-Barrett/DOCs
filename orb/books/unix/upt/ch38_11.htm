<HTML><HEAD><TITLE>[Chapter 38] 38.11 Printer Queue Watcher: A Restartable Daemon Shell Script</TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:49:47Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch38_01.htm"TITLE="38. Starting, Stopping, and Killing Processes"><LINKREL="prev"HREF="ch38_10.htm"TITLE="38.10 Destroying Processes with kill "><LINKREL="next"HREF="ch38_12.htm"TITLE="38.12 Killing All Your Processes "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch38_10.htm"TITLE="38.10 Destroying Processes with kill "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 38.10 Destroying Processes with kill "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 38<BR>Starting, Stopping, and Killing Processes</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch38_12.htm"TITLE="38.12 Killing All Your Processes "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 38.12 Killing All Your Processes "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-0212">38.11 Printer Queue Watcher: A Restartable Daemon Shell Script</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43076"></A>[This article may not appear to have a lot to do with the subject of thischapter, but it illustrates the other side of signal handling&nbsp;- what aprogram or shell script can do when it receives a signal.Jerry's script uses the <SPANCLASS="link"><EMCLASS="emphasis">trap</EM> (<ACLASS="linkend"HREF="ch44_12.htm"TITLE="Trapping Exits Caused by Interrupts ">44.12</A>)</SPAN>command to catch several different signals, and act differentlydepending on whether the signal is a &quot;hangup&quot; (<ICLASS="filename">HUP</I>, or signal 1)or a <ICLASS="filename">TERM</I> (signal 15). -TOR&nbsp;]</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43084"></A>UNIX systems run &quot;daemon&quot; programs like <EMCLASS="emphasis">cron</EM>(8) and <EMCLASS="emphasis">syslogd</EM>(8)that wait in the background, looking for work to do.Many daemons read configuration files when they start up.System administrators sometimes change the configuration files and wantthe daemon to re-read the file.One way to do that is by terminating and restarting the program&nbsp;- butthat's ugly and also means the daemon won't be running for a few secondsuntil it's restarted.So, many daemons are designed to re-read their configuration filesand/or restart themselves when they get a signal (usually, the HUPsignal, signal 1).System administrators do this by getting the daemon's process ID numberand sending the signal with the <EMCLASS="emphasis">kill</EM> command.Because the daemon &quot;catches&quot; the signal, the daemon isn't actually killed.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43091"></A><ACLASS="indexterm"NAME="AUTOID-43094"></A><ACLASS="indexterm"NAME="AUTOID-43096"></A>You can run a shell script as a daemon by putting it in thebackground.[4]Here's a simple example, a shell script named <EMCLASS="emphasis">watchq</EM>.It reads a file full of printer queue names and stores it in a shell variable.Every 30 seconds, it runs<SPANCLASS="link"><EMCLASS="emphasis">lpq</EM> (<ACLASS="linkend"HREF="ch43_02.htm"TITLE="Introduction to Printing on UNIX ">43.2</A>)</SPAN>on all printer queues listed.If any queues have an error, the script echoes a message and the outputof <EMCLASS="emphasis">lpq</EM> to a particular user with the<SPANCLASS="link"><EMCLASS="emphasis">write</EM> (<ACLASS="linkend"HREF="ch01_33.htm"TITLE="UNIX Networking and Communications ">1.33</A>)</SPAN>command.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] It's usually also a good idea to be sure that<SPANCLASS="link">the input and outputs are redirected (<ACLASS="linkend"HREF="ch13_01.htm#UPT-ART-1023"TITLE="Using Standard Input and Output">13.1</A>, <ACLASS="linkend"HREF="ch45_21.htm"TITLE="n&gt;&amp;m: Swap Standard Output and Standard Error ">45.21</A>)</SPAN>away from the terminal, maybe to the system console instead.On systems and shells that kill background jobs when you log out, use<SPANCLASS="link"><EMCLASS="emphasis">nohup</EM> (<ACLASS="linkend"HREF="ch38_18.htm"TITLE="nohup ">38.18</A>)</SPAN>.</P></BLOCKQUOTE><PCLASS="para">After the script has run for a while, the printer named <EMCLASS="emphasis">office</EM> goes down.I edit the <EMCLASS="emphasis">watchqs</EM> file and remove that printer so the poor user<EMCLASS="emphasis">lisa</EM> won't keep getting complaints about it.Then I send a signal to have the file re-read:</P><PCLASS="para"><TABLECLASS="screen.co"BORDER="1"><TR><THVALIGN="TOP"><PRECLASS="calloutlist">&#13;<ACLASS="co"HREF="ch13_14.htm"TITLE="13.14 What Can You Do with an Empty File? ">/dev/null</A> <ACLASS="co"HREF="ch13_13.htm"TITLE='13.13 The "Filename&quot; - '>-</A> <ACLASS="co"HREF="ch38_10.htm"TITLE="38.10 Destroying Processes with kill ">kill</A> &#13;</PRE></TH><TDVALIGN="TOP"><PRECLASS="screen">&#13;% <CODECLASS="userinput"><B>cat watchq</B></CODE>#! /bin/sh# watchq - &quot;daemon&quot; script that watches printer queue(s) for errorstemp=/tmp/WATCHQ$$             # Holds output of lpqwatch=/usr/local/lib/watchqs   # Queue names to watchwriteto=lisa                   # User who gets notices about printerqueues=&quot;`cat $watch`&quot;          # Put list of queue names in $queuestrap 'queues=&quot;`cat $watch`&quot;' 1 # Reset $queues if we get a SIGHUPtrap 'rm -f $temp; exit' 0 15  # Clean up temp file when killed# Loop forever (until someone kills script):while :do    for queue in $queues    do        lpq -P$queue &gt;$temp        if egrep '(out of paper|error|warning)' $temp &gt;/dev/null        then echo &quot;PRINTER QUEUE $queue:&quot; | cat - $temp | write $writeto        fi    done    sleep 30done% <CODECLASS="userinput"><B>echo office main lobby &gt; /usr/local/lib/watchqs</B></CODE>% <CODECLASS="userinput"><B>watchq &amp;</B></CODE>[1] 4363   ...% <CODECLASS="userinput"><B>echo main lobby &gt; /usr/local/lib/watchqs</B></CODE>%<CODECLASS="userinput"><B> kill -1 4363</B></CODE>   ...% <CODECLASS="userinput"><B>kill 4363</B></CODE>[1]    Exit -48             watchq</PRE></TD></TR></TABLE></P><PCLASS="para">In real life, the <EMCLASS="emphasis">watchq</EM> script might be started from a system filelike <EMCLASS="emphasis">/etc/rc.local</EM> when the system reboots.Lisa would probably edit the <EMCLASS="emphasis">watchqs</EM> file herself.The username that's notified by <EMCLASS="emphasis">write</EM> might also be resettable with a<EMCLASS="emphasis">kill -1</EM>.</P><PCLASS="para">This isn't foolproof and you can run into subtle problems.For instance, the <EMCLASS="emphasis">write</EM> command may not work on some UNIXes ifit's running from a daemon without a<SPANCLASS="link">controlling tty (<ACLASS="linkend"HREF="ch38_06.htm"TITLE="The Controlling Terminal ">38.6</A>)</SPAN>.Also, the error messages that<SPANCLASS="link"><EMCLASS="emphasis">egrep</EM> (<ACLASS="linkend"HREF="ch27_05.htm"TITLE="Extended Searching for Text with egrep ">27.5</A>)</SPAN>searches for may not catch allproblems and are system-dependent.But this script is just a demonstration&nbsp;- to show a great way to write aquick-and-dirty daemon.</P><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">JP</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch38_10.htm"TITLE="38.10 Destroying Processes with kill "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 38.10 Destroying Processes with kill "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch38_12.htm"TITLE="38.12 Killing All Your Processes "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 38.12 Killing All Your Processes "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">38.10 Destroying Processes with kill </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">38.12 Killing All Your Processes </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>