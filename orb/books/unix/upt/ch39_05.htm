<HTML><HEAD><TITLE>[Chapter 39] 39.5 Why Is the System So Slow? </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:50:13Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch39_01.htm"TITLE="39. Time and Performance"><LINKREL="prev"HREF="ch39_04.htm"TITLE="39.4 Average Command Runtimes with runtime "><LINKREL="next"HREF="ch39_06.htm"TITLE="39.6 lastcomm: What Commands Are Running and How Long Do They Take?"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch39_04.htm"TITLE="39.4 Average Command Runtimes with runtime "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 39.4 Average Command Runtimes with runtime "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 39<BR>Time and Performance</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch39_06.htm"TITLE="39.6 lastcomm: What Commands Are Running and How Long Do They Take?"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 39.6 lastcomm: What Commands Are Running and How Long Do They Take?"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-0066">39.5 Why Is the System So Slow? </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43763"></A>To a user, performance means: &quot;How much time does it take to runmy job?&quot; For a system manager, this question is much too simple: auser's job may take a long time to execute because it is badlywritten or because it doesn't really use the computer appropriately.Furthermore, a system manager must optimize performance for all system users&nbsp;- which is much more complicated than optimizingperformance for a single user.Here are some of the things that affect performance.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43767"></A>The UNIX utility<SPANCLASS="link"><EMCLASS="emphasis">/bin/time</EM> (<ACLASS="linkend"HREF="ch39_02.htm"TITLE="Timing Programs ">39.2</A>)</SPAN>reports the amount of timerequired to execute a program, breaking down the total time into several important components. For example, considerthe report below:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>/bin/time application</B></CODE><CODECLASS="literal">  4.8 real      0.5 user      0.7 sys</CODE></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43777"></A><ACLASS="indexterm"NAME="AUTOID-43779"></A><ACLASS="indexterm"NAME="AUTOID-43781"></A><ACLASS="indexterm"NAME="AUTOID-43783"></A><ACLASS="indexterm"NAME="AUTOID-43786"></A>This report shows that the program ran in roughly 4.8 seconds. Thisis the <EMCLASS="emphasis">elapsed</EM> or <EMCLASS="emphasis">wallclock</EM> time: it is the actualtime that the program runs as it would be measured by a user sittingat the terminal with a stopwatch. The amount of time that the systemspent working on your program is much smaller. It spent0.5&nbsp;seconds of <EMCLASS="emphasis">user time</EM>, which is time spent executing code in theuser state, and about 0.7 seconds of <EMCLASS="emphasis">system time</EM>, which is timespent in the system state (i.e., time spent executing UNIX system code) onbehalf of the user. The total amount of CPU time (actualexecution time on the main processor) was only 1.2 seconds, or onlyone-quarter of the elapsed time.  [1] </P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] Note that BSD and System V versions of <EMCLASS="emphasis">/bin/time</EM> have differentoutput formats but provide the same information. <EMCLASS="emphasis">/bin/time</EM> alsodiffers from the<SPANCLASS="link"> C shell's <EMCLASS="emphasis">time</EM> command , (<ACLASS="linkend"HREF="ch39_03.htm"TITLE="The csh time variable ">39.3</A>)</SPAN>which provides a more elaborate report.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43799"></A> Where did the rest of the time go? Some time was spent performing I/O(text input/output) operations, which <EMCLASS="emphasis">/bin/time</EM> doesn't report. Handling I/O requires some computation, which is attributed to system time.But time that is spent by disk drives, network interfaces, terminal controllers, or other hardware isn't accounted for;most of the time was spent running jobs on behalf of other users. This entails its own performance overhead (context-switch time,swapping time, etc.). </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43803"></A> Many differentcomponents contribute to a program's total running time. When you understand the roles these components play, you will understand theproblem. Here is a summary of the different components:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43809"></A> <BCLASS="emphasis.bold">User-state CPU time.</B>  The actual amount of time the CPU spendsrunning your program in the user state. It includes time spent executing library functions but excludes time spent executing systemcalls (i.e., time spent in the UNIX kernel on behalf of the process).Programmers can control user-state time by knowing which library routines are efficient and which aren't, and theyshould know how to run profilers on the program to find out where it's spending its time.</P></LI><LICLASS="listitem"><PCLASS="para"> <ACLASS="indexterm"NAME="AUTOID-43814"></A><ACLASS="indexterm"NAME="AUTOID-43817"></A> <BCLASS="emphasis.bold">System-state CPU time.</B>  The amount of time the CPU spendsin the system state (i.e., the amount of time spent executing kernel code) on behalf of the program. This includes time spent executingsystem calls and performing administrative functions on the program's behalf.The distinction between time spent in simple library routines and time spent in system services is important and often confused. A call to<EMCLASS="emphasis">strcpy</EM>, which copies a character string, executes entirely in the user state because it doesn't require any special handling by thekernel. Calls to <EMCLASS="emphasis">printf</EM>, <EMCLASS="emphasis">fork</EM>, and many other routines are much more complex. These functions do require services from the UNIXkernel so they spend part of their time, if not most of it, in the system state. All I/O routines require the kernel's services.</P><PCLASS="para">System-state CPU time is partially under the programmer's control. Although programmers cannot change the amount of time it takes to service any systemcall, they can rewrite the program to issue system calls more efficiently (for example, to make I/O transfers in larger blocks).</P></LI><LICLASS="listitem"><PCLASS="para"> <ACLASS="indexterm"NAME="AUTOID-43827"></A><BCLASS="emphasis.bold">I/O time.</B>  The amount of time the I/O subsystem spends servicing the I/O requests that the job issues. Under UNIX, I/O time isdifficult to measure; however, there are some tools for determining whether the I/O system is overloaded and some configurationconsiderations that can help alleviate load problems. </P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43832"></A> <BCLASS="emphasis.bold">Network time.</B>  The amount of time that the I/O subsystem spendsservicing network requests that the job issues. This is really a subcategory of I/O time and depends critically on configuration andusage issues. </P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43837"></A> <BCLASS="emphasis.bold">Time spent running other programs.</B>  As system load increases, theCPU spends less time working on any given job, thus increasing the elapsed time required to run the job. This is an annoyance, but barring someproblem with I/O or virtual memory performance, there is little you can do about it.</P></LI><LICLASS="listitem"><PCLASS="para"> <ACLASS="indexterm"NAME="AUTOID-43843"></A><ACLASS="indexterm"NAME="AUTOID-43845"></A> <BCLASS="emphasis.bold">Virtual memory performance.</B>  This is by far the most complex aspect ofsystem performance. Ideally, all active jobs would remain in the system's physical memory at all times. But when physical memory is fullyoccupied, the operating system starts moving parts of jobs to disk, thus freeing memory for the job it wants to run. This takes time. It also takestime when these disk-bound jobs need to run again and therefore need to be moved back into memory. When running jobs with extremely large memoryrequirements, system performance can degrade significantly. </P></LI></UL><PCLASS="para"> If you spend most of your time running standard utilities andcommercial applications, you can't do much about user-state or system-state time. To make a significant dent in these, you have torewrite the program. But you can do a lot to improve your memory and I/O performance, and you can do a lot to run your big applicationsmore efficiently. </P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-43851"></A> <ACLASS="indexterm"NAME="AUTOID-43853"></A>Keyboard response is an extremely important issue to users, although it really doesn't contribute to a program's execution time. If thereis a noticeable gap between the time when a user types a character and the time when the system echoes that character,the user will think performance is bad, regardless of how much time it takes to run a job. In order to prevent terminal buffers from overflowing and losing characters, most UNIX systems give <SPANCLASS="link">terminal drivers (<ACLASS="linkend"HREF="ch42_01.htm#UPT-ART-1142"TITLE="Making Sense Out of the Terminal Mess ">42.1</A>)</SPAN>very high priority. As a side effect, the high priority of terminals means that keyboard response should be bad only under exceptionally high loads. If youare accessing a remote system across a network, however, network delays can cause poor keyboard response. Network performance is anextremely complex issue. </P><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">ML</SPAN> <SPANCLASS="bibliomisc">from O'Reilly &amp; Associates' <CITECLASS="citetitle">System Performance Tuning</CITE>, Chapter 1</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch39_04.htm"TITLE="39.4 Average Command Runtimes with runtime "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 39.4 Average Command Runtimes with runtime "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch39_06.htm"TITLE="39.6 lastcomm: What Commands Are Running and How Long Do They Take?"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 39.6 lastcomm: What Commands Are Running and How Long Do They Take?"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">39.4 Average Command Runtimes with runtime </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">39.6 lastcomm: What Commands Are Running and How Long Do They Take?</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>