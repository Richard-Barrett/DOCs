<HTML><HEAD><TITLE>[Chapter 39] 39.12 What Makes Your Computer Slow? How Do You Fix It?</TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:50:25Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch39_01.htm"TITLE="39. Time and Performance"><LINKREL="prev"HREF="ch39_11.htm"TITLE="39.11 Changing a Job's Priority Under BSD UNIX "><LINKREL="next"HREF="ch40_01.htm"TITLE="40. Delayed Execution"></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch39_11.htm"TITLE="39.11 Changing a Job's Priority Under BSD UNIX "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 39.11 Changing a Job's Priority Under BSD UNIX "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 39<BR>Time and Performance</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch40_01.htm"TITLE="40. Delayed Execution"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 40. Delayed Execution"BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-0067">39.12 What Makes Your Computer Slow? How Do You Fix It?</A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-44273"></A><ACLASS="indexterm"NAME="AUTOID-44276"></A><ACLASS="indexterm"NAME="AUTOID-44279"></A>Article<ACLASS="xref"HREF="ch39_05.htm"TITLE="Why Is the System So Slow? ">39.5</A>discussed the various components that make up a user'sperception of system performance. There is another equally importantapproach to this issue: the computer's view of performance.All system performance issues are basically resource contention issues.In any computer system, there are three fundamental resources: the CPU,memory, and the I/O subsystem (e.g., disks and networks). From thisstandpoint, performance tuning means ensuring that every user getsa fair share of available resources.</P><PCLASS="para">Each resource has its own particular set of problems. Resourceproblems are complicated because all resources interact with oneanother. Your best approach is to consider carefully what each systemresource does: CPU, I/O, and memory. To get you started, here's aquick summary of each system resource and the problems it can have.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-67-SECT-1.1">39.12.1 The CPU </A></H3><PCLASS="para">On any time-sharing system, even single-user time-sharing systems(such as UNIX on a personal computer), many programs want touse the CPU at the same time. Under most circumstances the UNIXkernel is able to allocate the CPU fairly; however, each process (orprogram) requires a certain number of CPU cycles to execute and thereare only so many cycles in a day. At some point the CPU just can't getall the work done.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-44288"></A><ACLASS="indexterm"NAME="AUTOID-44291"></A><ACLASS="indexterm"NAME="AUTOID-44294"></A>There are a few ways to measure CPU contention. The simplest is theUNIX load average, reported by the BSD<SPANCLASS="link"><EMCLASS="emphasis">uptime</EM> (<ACLASS="linkend"HREF="ch39_07.htm"TITLE="Checking System Load: uptime ">39.7</A>)</SPAN>command.  Under System V, <EMCLASS="emphasis">sar -q</EM> provides the same sort ofinformation. The load average tries to measure the number of activeprocesses at any time (a <EMCLASS="emphasis">process</EM> is a single stream ofinstructions). As a measure of CPU utilization, the load average issimplistic, poorly defined, but far from useless.</P><PCLASS="para">Before you blame the CPU for your performance problems, think a bitabout what we <EMCLASS="emphasis">don't</EM> mean by CPU contention. We don't mean thatthe system is short of memory or that it can't do I/O fastenough. Either of these situations can make your system appear veryslow. But the CPU may be spending most of its time idle; therefore,you can't just look at the load average and decide that you need afaster processor.  Your programs won't run a bit faster.  Before youunderstand your system, you also need to find out what your memory andI/O subsystems are doing.  Users often point their fingers at the CPU,but I would be willing to bet that in most situations memory and I/Oare equally (if not more) to blame.</P><PCLASS="para">Given that you are short of CPU cycles, you have three basicalternatives:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">You can get users to run jobs at night or at other low-usage times -suring the computer is doing useful work 24 hours a day)with<SPANCLASS="link"><EMCLASS="emphasis">batch</EM> or <EMCLASS="emphasis">at</EM> (<ACLASS="linkend"HREF="ch40_01.htm#UPT-ART-2313"TITLE="Off-Peak Job Submission ">40.1</A>)</SPAN>.</P></LI><LICLASS="listitem"><PCLASS="para">You can prevent your system from doing unnecessary work.</P></LI><LICLASS="listitem"><PCLASS="para">You can get users to<SPANCLASS="link">run their big jobs at lower priority (<ACLASS="linkend"HREF="ch39_09.htm"TITLE='Know When to Be "nice&quot; to OTher Users...and WhenNot to'>39.9</A>)</SPAN>.</P></LI></UL><PCLASS="para">If none of these options is viable, you may need to upgrade your system.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-67-SECT-1.2">39.12.2 The Memory Subsystem </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-44318"></A><ACLASS="indexterm"NAME="AUTOID-44321"></A><ACLASS="indexterm"NAME="AUTOID-44324"></A><ACLASS="indexterm"NAME="AUTOID-44326"></A><ACLASS="indexterm"NAME="AUTOID-44328"></A><ACLASS="indexterm"NAME="AUTOID-44330"></A><ACLASS="indexterm"NAME="AUTOID-44332"></A><ACLASS="indexterm"NAME="AUTOID-44334"></A>Memory contention arises when the memory requirements of the activeprocesses exceed the physical memory available on the system; at thispoint, the system is out of memory.  To handle this lack of memorywithout crashing the system or killing processes, the system starts<EMCLASS="emphasis">paging</EM>: moving portions of active processes to disk in orderto reclaim physical memory. At this point, performance decreasesdramatically. Paging is distinguished from <EMCLASS="emphasis">swapping</EM>, which meansmoving entire processes to disk and reclaiming their space. Paging andswapping indicate that the system can't provide enough memory for theprocesses that are currently running, although under somecircumstances swapping can be a part of normal housekeeping. Under BSDUNIX, tools such as <EMCLASS="emphasis">vmstat</EM> and <EMCLASS="emphasis">pstat</EM> show whetherthe system is paging; <EMCLASS="emphasis">ps</EM> can report the memory requirementsof each process. The System V utility <EMCLASS="emphasis">sar</EM> provides informationabout virtually all aspects of memory performance.</P><PCLASS="para">To prevent paging, you must either make more memory available ordecrease the extent to which jobs compete. To do this, you cantune system parameters, which is beyond the scope of this book(see O'Reilly &amp; Associates' <EMCLASS="emphasis">System Performance Tuning</EM> by Mike Loukidesfor help).You can also<SPANCLASS="link">terminate (<ACLASS="linkend"HREF="ch38_10.htm"TITLE="Destroying Processes with kill ">38.10</A>)</SPAN>the jobs with the largest memory requirements.If your system has a lot of memory, the kernel's memory requirements will berelatively small; the typicalantagonists are very large application programs.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-67-SECT-1.3">39.12.3 The I/O Subsystem </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-44348"></A><ACLASS="indexterm"NAME="AUTOID-44350"></A><ACLASS="indexterm"NAME="AUTOID-44353"></A><ACLASS="indexterm"NAME="AUTOID-44355"></A><ACLASS="indexterm"NAME="AUTOID-44358"></A><ACLASS="indexterm"NAME="AUTOID-44361"></A><ACLASS="indexterm"NAME="AUTOID-44363"></A><ACLASS="indexterm"NAME="AUTOID-44365"></A>The I/O subsystem is a common source of resource contention problems.A finite amount of I/O bandwidth must be shared by all the programs(including the UNIX kernel) that currently run. The system'sI/O buses can transfer only so many megabytes per second; individualdevices are even more limited. Each kind of device has its ownpeculiarities and, therefore, its own problems. Unfortunately, UNIX has poor tools for analyzing the I/O subsystem.Under BSD UNIX, <EMCLASS="emphasis">iostat</EM> can give you information about thetransfer rates for each disk drive; <EMCLASS="emphasis">ps</EM> and <EMCLASS="emphasis">vmstat</EM> can give some informationabout how many processes are blocked waiting for I/O; and<EMCLASS="emphasis">netstat</EM> and <EMCLASS="emphasis">nfsstat</EM> report various network statistics.Under System V, <EMCLASS="emphasis">sar</EM> can provide voluminous information about I/Oefficiency, and <EMCLASS="emphasis">sadp</EM> (V.4) can give detailed information aboutdisk access patterns. However, there is no standard tool to measurethe I/O subsystem's response to a heavy load.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-44375"></A><ACLASS="indexterm"NAME="AUTOID-44378"></A><ACLASS="indexterm"NAME="AUTOID-44380"></A>The disk and network subsystems are particularly important to overallperformance. Disk bandwidth issues have two general forms:maximizing per-processtransfer rates and maximizing aggregate transfer rates. Theper-process transfer rate is the rate at which a single program canread or write data. The aggregate transfer rate is the maximum totalbandwidth that the system can provide to all programs that run.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-44383"></A>Network I/O problems have two basic forms: a network can beoverloaded or a network can lose data integrity. When a network isoverloaded, the amount of data that needs to be transferred across thenetwork is greater than the network's capacity; therefore, the actualtransfer rate for any task is relatively slow. Network load problemscan usually be solved by changing the network's configuration.Integrity problems occur when the network is faulty andintermittently transfers data incorrectly. In order to delivercorrect data to the applications using the network, the networkprotocols may have to transmit each block of data many times.Consequently, programs using the network will run veryslowly. The only way to solve a data integrity problem is to isolatethe faulty part of the network and replace it.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-67-SECT-1.4">39.12.4 User Communities </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-44388"></A><ACLASS="indexterm"NAME="AUTOID-44391"></A>So far we have discussed the different factors that contribute tooverall system performance. But we have ignored one of the mostimportant factors: the users who submit the jobs.</P><PCLASS="para">In talking about the relationship between users and performance, it iseasy to start seeing users as problems: the creatures who keep yoursystem from running the way it ought to. Nothing is further from thetruth.Computers are tools: they exist to help usersdo their work and not vice versa.</P><PCLASS="para">Limitations on memory requirements, file size, jobpriorities, etc., are effective only when everyone cooperates.Likewise, you can't force people to submit their jobs to a<SPANCLASS="link">batch queue (<ACLASS="linkend"HREF="ch40_06.htm"TITLE="System V.4 Batch Queues ">40.6</A>)</SPAN>.Most people will cooperate when they understand a problem and whatthey can do to solve it. Most people will resist a solutionthat is imposed from above, that they don't understand, or thatseems to get in the way of their work.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-44398"></A>The nature of your system's users has a big effect on yoursystem's performance.We can divide users into several classes:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Users who run a large number of relatively small jobs: for example,users who spend most of their time editing or running UNIX utilities.</P></LI><LICLASS="listitem"><PCLASS="para">Users who run a small number of relatively large jobs: for example,users who run large simulation programs with huge data files.</P></LI><LICLASS="listitem"><PCLASS="para">Users who run a small number of CPU-intensive jobs that don't requirea lot of I/O but do require a lot of memory and CPU time.  Programdevelopers fall into this category. Compilers tend to be largeprograms that build large data structures and can be a source ofmemory contention problems.</P></LI></UL><PCLASS="para">All three groups can cause problems. Several dozen users running<EMCLASS="emphasis">grep</EM> and accessing remote filesystems can be as bad for overallperformance as a few users accessing gigabyte files. However, thetypes of problems these groups cause are not the same. For example,setting up a &quot;striped filesystem&quot; will help disk performance forlarge, I/O-bound jobs but won't help (and may hurt) users who run manysmall jobs. Setting up batch queues will help reduce contention amonglarge jobs, which can often be run overnight, but it won't help thesystem if its problems arise from users typing at their text editors and reading their mail.</P><PCLASS="para">Modern systems with<SPANCLASS="link">network facilities (<ACLASS="linkend"HREF="ch01_33.htm"TITLE="UNIX Networking and Communications ">1.33</A>)</SPAN>complicate the picture even more.  In addition to knowing what kindsof work users do, you also need to know what kind of equipment theyuse: a standard terminal over an RS-232 line, an X terminal overEthernet, ora diskless workstation? The X Window System requires a lot of memoryand puts a heavy load on the network. Likewise, diskless workstationsplace a load on the network. Similarly, do users access local files orremote files via NFS or RFS?</P></DIV><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">ML</SPAN> <SPANCLASS="bibliomisc">from O'Reilly &amp; Associates' <CITECLASS="citetitle">System Performance Tuning</CITE>, Chapter 1</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch39_11.htm"TITLE="39.11 Changing a Job's Priority Under BSD UNIX "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 39.11 Changing a Job's Priority Under BSD UNIX "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch40_01.htm"TITLE="40. Delayed Execution"><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 40. Delayed Execution"BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">39.11 Changing a Job's Priority Under BSD UNIX </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">40. Delayed Execution</TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>