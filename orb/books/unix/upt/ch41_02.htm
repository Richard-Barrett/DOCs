<HTML><HEAD><TITLE>[Chapter 41] 41.2 stty and All That Stuff </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:51:49Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch41_01.htm"TITLE="41. Terminal and Serial Line Settings"><LINKREL="prev"HREF="ch41_01.htm"TITLE="41.1 Delving a Little Deeper "><LINKREL="next"HREF="ch41_03.htm"TITLE="41.3 Find Out Terminal Settings with stty "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch41_01.htm"TITLE="41.1 Delving a Little Deeper "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 41.1 Delving a Little Deeper "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 41<BR>Terminal and Serial Line Settings</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch41_03.htm"TITLE="41.3 Find Out Terminal Settings with stty "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 41.3 Find Out Terminal Settings with stty "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-1140">41.2 stty and All That Stuff </A></H2><PCLASS="para">[...all that <ICLASS="filename">useful</I> stuff!This article has a lot of good background for understanding howcommunications works between the UNIX host and your terminal or window.Chris has been in the business since way back; there's lots ofinteresting history in here, too.You might want a copy of your system's <ICLASS="filename">stty</I> manual page close bywhile you read this article. -JP]</P><DIVCLASS="msgset"><DIVCLASS="msgentry"><DIVCLASS="msg"><DIVCLASS="msgtext"><PCLASS="para"><BCLASS="msgentry.role">Q:</B>  What is <EMCLASS="emphasis">stty</EM> all about? Why does it have so many options?</P></DIV></DIV></DIV><DIVCLASS="msgentry"><DIVCLASS="msg"><DIVCLASS="msgtext"><PCLASS="para"><BCLASS="msgentry.role">A:</B>  Serial ports&nbsp;- indeed, computer communications in general&nbsp;- are atangled and complicated area. The demands made for serialport communication, and hence the support for it in UNIX systems, begansimply, but then grew in raging, uncontrolled bursts.</P></DIV></DIV></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-1140-SECT-1.1">41.2.1 How We Made It This Far (Back?) </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45390"></A><ACLASS="indexterm"NAME="AUTOID-45392"></A><ACLASS="indexterm"NAME="AUTOID-45394"></A><ACLASS="indexterm"NAME="AUTOID-45396"></A><ACLASS="indexterm"NAME="AUTOID-45398"></A>Originally, UNIX ran on a small machine that talked only to<EMCLASS="emphasis">teletypes</EM>, or <EMCLASS="emphasis">ttys</EM> for short. The UNIX kernel had tocollect up input lines, allowing minor corrections&nbsp;- erasingthe previous character and killing (erasing wholly) the inputline&nbsp;- and translating a few &quot;special&quot; characters for controllingprograms. Teletypes were printers, incapable of erasing, sothe erase and kill characters were just ordinary printingcharacters, namely <CODECLASS="literal">#</CODE> and <CODECLASS="literal">@</CODE>. The original special characterswere CTRL-d (for end-of-file), DEL (to interrupt), and CTRL-\ (toquit). The kernel also mapped input RETURN codes to the newlinecharacter, so that users could push the big RETURN key, on teletypesthat had those.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45405"></A><ACLASS="indexterm"NAME="AUTOID-45408"></A><ACLASS="indexterm"NAME="AUTOID-45410"></A><ACLASS="indexterm"NAME="AUTOID-45413"></A><ACLASS="indexterm"NAME="AUTOID-45415"></A>These teletypes had some peculiarities. In particular, they used amoving print head (or <EMCLASS="emphasis">carriage</EM>), and this print head took anoticeable amount of time to return from the right margin to the left. If sent continuous printing text, a teletype could smearcharacters all over the paper during a carriage return.[1]The UNIXkernel therefore had to allow for a delay after a carriage return. Atthe same time, the kernel did &quot;output processing&quot; by changingnewlines to the teletype's carriage return and linefeed codes, ifnecessary.[2]A few teletypes allowed only uppercase characters, andUNIX grew support for these as well. UNIX did get away withoutsomething common to other operating systems, however: UNIX systemsassumed that all teletypes were &quot;full duplex&quot; and used &quot;remoteecho.&quot; This meant, in essence, that both the teletype and the UNIXsystem could send to each other at the same time; and the teletypewould not print what you typed until told to do so by the UNIX host.[3]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] This is an exaggeration. Printing during a carriage return wasoccasionally used as a diagnostic for checking the motor speed. Thecharacter printed during the return was supposed to appear exactlyhalfway along the line.</P><PCLASS="para">[2] Some teletypes really processed a newline as a &quot;new line,&quot; i.e., acarriage return and linefeed, but most left this up to the hostcomputer.</P><PCLASS="para">[3] <ACLASS="indexterm"NAME="AUTOID-45425"></A><ACLASS="indexterm"NAME="AUTOID-45427"></A>Full duplex/remote echo and half duplex/local echo tended to gotogether. In particular, a half duplex system&nbsp;- which was not thesame as a simplex system&nbsp;- had to have local echo to avoid beingannoying to use. Fortunately, this is irrelevant today. The conceptof &quot;duplex&quot; has fallen by the wayside, and everything is fullduplex, or at least simulates it internally.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45430"></A>UNIX also had to provide a way for special applications, such as<SPANCLASS="link">UUCP (<ACLASS="linkend"HREF="ch01_33.htm"TITLE="UNIX Networking and Communications ">1.33</A>)</SPAN>,to get input characters without any processing. This was the so-calledraw mode. The kernel service was all-or-nothing: in raw mode,every input and output character was left alone, and passed directly&nbsp;- and immediately&nbsp;- to the application. In &quot;cooked&quot; mode, thekernel did input and output translations and delays.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45434"></A><ACLASS="indexterm"NAME="AUTOID-45436"></A><ACLASS="indexterm"NAME="AUTOID-45438"></A><ACLASS="indexterm"NAME="AUTOID-45440"></A>Along with the ability to set raw or cooked mode, the kernel allowedchanging each of the<SPANCLASS="link">special characters (<ACLASS="linkend"HREF="ch05_09.htm"TITLE="Setting Your Erase, Kill, and Interrupt Characters ">5.9</A>)</SPAN>and allowed control of some ofthe simpler aspects of the serial port interface, such as parity andbaud rate.[4]The baud rate, perhaps better called the bit rate, of theoriginal teletype was 110 bits per second (bps), or 11 characters persecond. (The machines really did print exactly 11 times each second,with one possibility being quietly to print nothing.) Early computermodems ran at 110 and 300 baud, and there were a standard set of serialport speeds: 50, 75, 110, 134.5, 150, 200, 300, 600, 1200, 1800, 2400,4800, and even 9600 bps, which was considered terribly fast. UNIXsystems used serial cards with two additional &quot;external control&quot;<ACLASS="indexterm"NAME="AUTOID-45446"></A>rates labeled A and B; these became <EMCLASS="emphasis">exta</EM> and <EMCLASS="emphasis">extb</EM>. Some UNIXsystems still support exactly (and only) these rates, and tie <EMCLASS="emphasis">exta</EM>to 19200 bps and <EMCLASS="emphasis">extb</EM> to 38400 bps.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[4] Parity is used for error checking. Parity is simply the numberof &quot;1&quot; bits. If you have the value 1001001, and even parity, theparity bit should be 1, because 1001001 has three 1 bits&nbsp;- an oddnumber&nbsp;- and adding another 1 makes this even. If the parity bitfails to match, at least one bit is wrong. It could, of course, bethe parity bit itself. Moreover, with a <EMCLASS="emphasis">tty</EM> port, there may not beanything you can do to fix the error&nbsp;- most UNIX kernels just dropthe bad input character&nbsp;- but the check is available.</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45453"></A><ACLASS="indexterm"NAME="AUTOID-45455"></A>Eventually, teletype printers began to be displaced. First there cameso-called glass ttys-CRT displays that tried to act just like ateletype&nbsp;- and then smarter terminals, ones that could (gasp) move acursor around the screen, and edit the display in place. These usedspecial control and escape codes to do the editing. They also providedthe opportunity to write full-screen editors. UNIX had to evolve toadapt to these new constraints. Unfortunately, by this time there weretwo main branches of UNIX. One would eventually become 4BSD, orBerkeley UNIX; the other was to become System V.</P><PCLASS="para">The goals for both systems were similar, and thus both wound up withcomparable approaches. Berkeley UNIX, however, attempted both toretain backwards compatibility and to provide a nice user interface,while the original System V system discarded compatibility in favor ofefficiency and a &quot;complete&quot; interface&nbsp;- one that allowed doingeverything a serial port could do.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45460"></A><ACLASS="indexterm"NAME="AUTOID-45462"></A><ACLASS="indexterm"NAME="AUTOID-45464"></A>Berkeley UNIX thus acquired <EMCLASS="emphasis">three</EM> terminal modes. It retained theoriginal <EMCLASS="emphasis">raw</EM> and <EMCLASS="emphasis">cooked</EM> modes, and added a new one called<EMCLASS="emphasis">cbreak.</EM>[5]In cbreak mode, some input processing was done, butmost characters were sent on to the application as they arrived. Sincethe kernel was not collecting lines, the erase and line-kill characterswere unneeded; these were sent on unchanged. Most of the processcontrol characters&nbsp;- interrupt, quit, and a new <EMCLASS="emphasis">stop</EM> or <EMCLASS="emphasis">suspend</EM>code&nbsp;- were still interpreted. To allow users to type these codes, anew &quot;literal next&quot; or &quot;quote&quot; character was introduced. BerkeleyUNIX also added more output processing, including a special translationoption for certain Hazeltine Corporation displays and features such asproper tab handling, output flush, and word erase.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[5] <ACLASS="indexterm"NAME="AUTOID-45472"></A>This <EMCLASS="emphasis">cbreak</EM> mode has sometimes been referred to as &quot;half-baked.&quot;</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45479"></A><ACLASS="indexterm"NAME="AUTOID-45481"></A><ACLASS="indexterm"NAME="AUTOID-45483"></A><ACLASS="indexterm"NAME="AUTOID-45485"></A><ACLASS="indexterm"NAME="AUTOID-45487"></A><ACLASS="indexterm"NAME="AUTOID-45489"></A><ACLASS="indexterm"NAME="AUTOID-45491"></A>The System V base, on the other hand, dropped the idea of raw modeentirely. Instead, this system provided an individual control for eachoption. The <EMCLASS="emphasis">icanon</EM> option, for instance, controlled whether inputlines were to be collected or &quot;canonicalized.&quot; The <EMCLASS="emphasis">isig</EM> optioncontrolled signals: when off, the <EMCLASS="emphasis">interrupt</EM> (DEL, or in modern systems,CTRL-c) and <EMCLASS="emphasis">quit</EM> characters were just ordinary characters. The<EMCLASS="emphasis">inpchk</EM> option controlled input parity checking, and so forth.Similarly, output processing had individual flags: <EMCLASS="emphasis">ocrnl</EM> forcarriage return-newline control, <EMCLASS="emphasis">opost</EM> for output processing ingeneral. By turning everything off individually, an application couldget the same effect as the old system's raw mode. The kernel alsoallowed control over the number of data bits in each serial frame, thenumber of stop bits, and so forth.[6]Thus, while Berkeley UNIX had niceline editing, it was incapable of attaching to five-bit Baudot systems.System V lacked the user interface features, but could talk to almostanything.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[6] Different systems use anything from five to nine bits in aserial-port &quot;byte.&quot; Most people, however, do not need to careabout all this. Most systems just use eight bits, either as sevendata bits and a parity check, or as eight data bits without parity.Thus, most people can ignore these options, and stick with either&quot;seven bits, even parity&quot; or &quot;eight bits, no parity.&quot;</P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45503"></A><ACLASS="indexterm"NAME="AUTOID-45505"></A><ACLASS="indexterm"NAME="AUTOID-45507"></A>Since then, the world has become simpler in one way&nbsp;- those oldprinting teletypes are gone nearly everywhere, for instance&nbsp;- but more complicated in another. These days, many computers usebitmapped displays rather than individual remote terminals. UNIXsystems support networking, and use windowing systems such as the<SPANCLASS="link">X Window System (<ACLASS="linkend"HREF="ch01_31.htm"TITLE="The X Window System ">1.31</A>)</SPAN>.These in turn bring a myriad of options, windowmanagers, look-and-feel, and so on. But they all have one thing incommon: to run old applications, each window or network login mustprovide a <EMCLASS="emphasis">virtual terminal</EM> interface. UNIX systems generally do thiswith <EMCLASS="emphasis">pseudo teletypes</EM> or<SPANCLASS="link"><EMCLASS="emphasis">pty</EM>s (<ACLASS="linkend"HREF="ch41_08.htm"TITLE="ptys and Window Systems ">41.8</A>)</SPAN>.Each <EMCLASS="emphasis">pty</EM> exists to emulate adisplay terminal, which in turn is mainly pretending to be a teletypeprinter. (Sometimes one has to wonder where the progress lies.)</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45516"></A>A POSIX standardization committee has settled on a standardinterface, both at the UNIX kernel level and for the <EMCLASS="emphasis">stty</EM>command.  Most UNIX systems, including Berkeley UNIX,have moved to embrace this standard. While it leaves a few looseends&nbsp;- mainly for reasons involving backwards compatibility for SystemV-it allows systems both the flexibility of the System V interfaceand the features of the Berkeley approach. This means that whilewindows and networks may be emulating ancient teletypes, at leastthey are all doing it in the same way.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-1140-SECT-1.2">41.2.2 Handling Most Characters </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45522"></A><ACLASS="indexterm"NAME="AUTOID-45525"></A>With all that as background, let's take a look at what happens to aninput character, from the time you type it until anapplication can react. The details may vary&nbsp;- often wildly&nbsp;- dependingon your system and whether you are using a window, a terminal, anetwork, or some combination of all three, but the overall idea is thesame. For simplicity, we will assume you have an ordinary terminal.We will call this &quot;the terminal&quot; and the kernel's idea of it &quot;thetty.&quot;</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45529"></A><ACLASS="indexterm"NAME="AUTOID-45531"></A><ACLASS="indexterm"NAME="AUTOID-45533"></A><ACLASS="indexterm"NAME="AUTOID-45535"></A>Suppose you type the letter <EMCLASS="emphasis">x</EM>. The terminal sends the<SPANCLASS="link">ASCII code (<ACLASS="linkend"HREF="ch51_03.htm"TITLE="ASCII Characters: Listing and Getting Values ">51.3</A>)</SPAN>for a lowercase X (120) to the UNIX kernel's tty. The kernel thenlooks at the <EMCLASS="emphasis">tty</EM> state. Assume for the sake of discussion that the ttyis in cooked or icanon mode, and that none of the specialcharacters has been set to <EMCLASS="emphasis">x</EM>. Then the letter <CODECLASS="literal">x</CODE> is placed inan input buffer and echoed back to the terminal, causing an <CODECLASS="literal">x</CODE> to bedisplayed on your screen. But if you really wanted to type a <EMCLASS="emphasis">c</EM>,you would now type your<SPANCLASS="link">erase character (<ACLASS="linkend"HREF="ch05_09.htm"TITLE="Setting Your Erase, Kill, and Interrupt Characters ">5.9</A>)</SPAN>(usually CTRL-h, BACKSPACE,or DELETE, which may or may not all be the same or all different,depending on your particular terminal or keyboard). The code for thischaracter will also be sent to the tty; this time it will match yourerase character. The kernel will then remove the last character fromthe input buffer. Since this&nbsp;- a lowercase X&nbsp;- is an ordinary printingcharacter, the kernel will send a single backspace, or the sequence&quot;backspace space backspace,&quot; to the terminal. This will generally backthe cursor up over the character and then erase it from the screen.(On a POSIX system, you get the latter by setting <EMCLASS="emphasis">echoe</EM> mode.) Finally, when you type RETURN orENTER, your terminal sends an ASCII code 13. Since <EMCLASS="emphasis">icrnl</EM> is set, thekernel changes this to 10 (newline), which it then echoes to theterminal. Since <EMCLASS="emphasis">onlcr</EM> is set, this sends both a code 13 (carriagereturn) and a 10 (linefeed) to the terminal. The kernel sees that 10is a newline, wraps up the collected buffer, and passes it on towhatever application is currently reading from the tty.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45549"></A>If you turn off <EMCLASS="emphasis">icanon</EM> (or turn on <EMCLASS="emphasis">cbreak</EM>), the kernel takes anypartially collected buffer and passes those characters to theapplication, then passes on each ordinary input character as it comesin. The kernel still echoes input back to the terminal. If you turnoff the <EMCLASS="emphasis">echo</EM> flag in the tty, the kernel will stop doing echoing.This is how a full-screen editor like <EMCLASS="emphasis">vi</EM> works: it turns off<EMCLASS="emphasis">icanon</EM>, turns off <EMCLASS="emphasis">echo</EM>, and turns off some, but not all, of thespecialcharacters. The <EMCLASS="emphasis">vi</EM> program can then do its own echoing, so that whenyou type <CODECLASS="literal">i</CODE> to go into insert mode, no <CODECLASS="literal">i</CODE> appears on yourterminal.</P><PCLASS="para">One of several difficult areas involves turning <EMCLASS="emphasis">icanon</EM> back on. Inparticular, there may be some characters you typed at the terminalwhile <EMCLASS="emphasis">icanon</EM> was off. These reached the tty, which packaged them upand sent them off to an application. The application may not have readthem yet, but as far as the <EMCLASS="emphasis">tty</EM> is concerned, they are gone. Thus, youmay not be able to recover them for your current input line. OlderBerkeley UNIX systems are able to handle this case, but System Vsystems that use the STREAMS interface are not. As long as your systemis fast enough, though, you will never notice, because applicationswill always turn <EMCLASS="emphasis">icanon</EM> on before you can type anything at theterminal.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-1140-SECT-1.3">41.2.3 What About TABs? </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45568"></A><ACLASS="indexterm"NAME="AUTOID-45570"></A>Tabs are another difficult issue. The history here predates computing;typewriter tabs are sometimes used as the &quot;right&quot; model.Nonetheless, different terminals behave differently, and differentpeople make different assumptions about how tabs should work. TheASCII code for TAB, code 9, is intended to move the cursor right to thenext tabstop. But where <EMCLASS="emphasis">is</EM> that? Moreover, once the cursor hasgone there, how does the kernel move it back if you decided to erasethe tab?</P><PCLASS="para">Many UNIX kernels can be told to expand tabs. When they do this, theyset the tabstops at every eight characters. This is where they thinktabstops belong. That is, if you print a newline, two ordinaryletters, and a tab, the tab will turn into six spaces. If a <EMCLASS="emphasis">tty</EM> is inicanon/cooked mode, and is expanding tabs, it can &quot;unexpand&quot; themto backspace over the tab. Berkeley kernels will do this, and itworks fairly well. They can get it wrong, however, under certainconditions. For instance, if you set the <EMCLASS="emphasis">tty</EM> to pass tabs unmodified,and if the terminal itself puts tabstops at every tencharacters&nbsp;- this would be the proper setting for dealing with aDEC-10, for instance&nbsp;- the kernel <EMCLASS="emphasis">tty</EM> code will put out fewerbackspaces than needed.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45579"></A><ACLASS="indexterm"NAME="AUTOID-45582"></A><ACLASS="indexterm"NAME="AUTOID-45585"></A>Even if the terminal sets its tabstops at eight, the kernel's <EMCLASS="emphasis">tty</EM> codeand the terminal can get different ideas of the current cursor column.Most Berkeley kernels count control codes as &quot;ordinary&quot; outputcharacters, for instance, even though those characters are likely tohave no effect on the cursor, or might even move it to an arbitraryposition. To help prevent <EMCLASS="emphasis">input</EM> control characters from goofing upbackspacing, Berkeley kernels can echo them as two-charactersequences. For instance, CTRL-g will normally echo as <CODECLASS="literal">^G</CODE>. Erasingsuch a control character works properly: the <EMCLASS="emphasis">tty</EM> code puts out <EMCLASS="emphasis">two</EM>backspaces, <EMCLASS="emphasis">two</EM> spaces, and two more backspaces. Erasing morecharacters, possibly including a TAB, then still works. This &quot;controlecho&quot; can be switched on and off individually as well.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45594"></A>In addition to carriage return delays, which exist to allow timefor the teletype's print carriage to move left, some UNIX systemsalso support tab delays, for more or less the same reason. Likereturn-delays, these are pretty much outmoded and useless. ThePOSIX standard leaves room for both kinds of delay, but does notmandate either one. You may see them in <EMCLASS="emphasis">stty</EM> output, as <EMCLASS="emphasis">cr2</EM>,<EMCLASS="emphasis">cr3</EM>, <EMCLASS="emphasis">tab1</EM>, and the like, but your system's default is probably&quot;no delay,&quot; and few people are likely to change this deliberately.</P><PCLASS="para">Article<ACLASS="xref"HREF="ch41_04.htm"TITLE="How UNIX Handles TAB Characters ">41.4</A>has some higher-level information about TABs.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-1140-SECT-1.4">41.2.4 Flow Control (We Hope) </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45605"></A><ACLASS="indexterm"NAME="AUTOID-45607"></A><ACLASS="indexterm"NAME="AUTOID-45609"></A><ACLASS="indexterm"NAME="AUTOID-45611"></A><ACLASS="indexterm"NAME="AUTOID-45613"></A><ACLASS="indexterm"NAME="AUTOID-45615"></A>Finally, flow control&nbsp;- avoiding lost input and output characters&nbsp;- isperhaps the dirtiest swamp of all. Most of the terminals built in the1980s support, and at higher speeds require, something called\h'-1p'<EMCLASS="emphasis">XON/XOFF</EM> flow control. Here, when the terminal falls behind inprinting characters, it shouts &quot;stop!&quot; by sending an XOFFcharacter&nbsp;- ASCII code 19, or CTRL-s&nbsp;- to the UNIX system. If theUNIX machine does not stop soon enough, some text will be lost. Whenthe terminal is ready for more, it sends a &quot;go&quot; character&nbsp;- an XON,ASCII code 17, or CTRL-q. These were never intended as a generalflow control mechanism&nbsp;- on some of the original teletypes, they turnedthe paper tape punch off and on&nbsp;- but they have that meaning now.Unfortunately, most terminals also allow users to type CTRL-s andCTRL-q, but they provide no way to distinguish between the terminalyelling &quot;stop&quot; and the user pushing CTRL-s. The result is aconstant battle between people who want to use CTRL-s and computersystems that want to take it for themselves.</P><PCLASS="para">Other systems, notably HP-based systems, use something called <EMCLASS="emphasis">ENQ/ACK</EM>flow control. Here the terminal and the host system must agree up-front on a minimum buffer size. Then either system is allowed to sendthat many characters to the other, after which it must stop and waitfor a &quot;go-ahead&quot; signal. Each system requests such a signal bysending an &quot;enquire&quot;: ASCII code 5, or CTRL-e. When the listeningsystem encounters the ENQ, and is ready for more, it sends anacknowledgement: ASCII code 6, or CTRL-f. This system is superiorto the XON/XOFF system in one way, as it never has problems with abusy system failing to stop immediately on command, but it still doesnot prevent users from typing CTRL-e and CTRL-f. Moreover, itis not implemented on most UNIX systems.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45621"></A><ACLASS="indexterm"NAME="AUTOID-45623"></A><ACLASS="indexterm"NAME="AUTOID-45626"></A>A third method of flow control, and the most reliable where it isavailable, is the so-called <EMCLASS="emphasis">out of band</EM> approach. &quot;Out of band&quot;simply means that users cannot accidentally simulate it by typingcontrol characters. Out of band control can be done in software,using something similar to HP's ENQ/ACK and some encoding tricks,but in practice, most UNIX machines that support any kind of outof band flow control use something called either &quot;hardware flowcontrol&quot; or &quot;<EMCLASS="emphasis">RTS/CTS</EM> flow control.&quot; (This can be implementedwith no special hardware at all on many systems, so the latter nameis better.)</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-45631"></A><ACLASS="indexterm"NAME="AUTOID-45633"></A>With RTS/CTS flow control, two existing serial-cable wires, RTS andCTS, are &quot;taken over.&quot; (RTS and CTS-which stand for Request toSend and Clear to Send respectively&nbsp;- were originally intended for usewith half duplex modems. Since half duplex modems are today merelymuseum pieces, this is a sensible approach, but it does violate theRS232 standard.) RTS at the terminal is cross-connected to CTS at thehost computer, and vice versa. The terminal and the computer bothassert RTS whenever they are ready to receive data, and wait for CTSbefore sending. Unfortunately, not enough systems implement this, andof those that do, many get it wrong.[7]Thus, while RTS/CTS flowcontrol offers the possibility of working perfectly, you cannot counton it. Still, it is worth looking for an <EMCLASS="emphasis">rts/cts</EM> option in yourUNIX's <EMCLASS="emphasis">stty</EM>.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[7] For instance, on Sun workstations, RTS/CTS is supported inhardware, but the particular Zilog chip that does this also usesthe DCD (Data Carrier Detect) line to control the receiver. Thus,if you set <EMCLASS="emphasis">stty crtscts</EM>, you cannot tell a modem to dial out,because DCD is off. It is possible to work around this, but onlywith control over both the hardware and the UNIX kernel.</P></BLOCKQUOTE></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-1140-SECT-1.5">41.2.5 Then What? </A></H3><PCLASS="para">If you think this is complicated, just hope you never have to deal withsynchronous transmission, RS422, DIN connectors, lightning strikeprotection, and many of the other hardware and electrical aspects thatsurround computer communications. Getting two arbitrary computers totalk to each other can be excessively difficult. Here again, standardscome to the rescue. If everything you have is proper RS232-<SPANCLASS="link">modulo (<ACLASS="linkend"HREF="glossary.htm#UPT-ART-1010"TITLE="Glossary">52.9</A>)</SPAN>,perhaps, RTS/CTS flow control&nbsp;- and POSIX, things should usually gosmoothly.</P></DIV><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">CT</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch41_01.htm"TITLE="41.1 Delving a Little Deeper "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 41.1 Delving a Little Deeper "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch41_03.htm"TITLE="41.3 Find Out Terminal Settings with stty "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 41.3 Find Out Terminal Settings with stty "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">41.1 Delving a Little Deeper </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">41.3 Find Out Terminal Settings with stty </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>