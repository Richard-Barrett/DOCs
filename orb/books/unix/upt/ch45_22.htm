<HTML><HEAD><TITLE>[Chapter 45] 45.22 Handling Files Line-by-Line </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:54:49Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch45_01.htm"TITLE="45. Shell Programming for the Initiated"><LINKREL="prev"HREF="ch45_21.htm"TITLE="45.21 n&gt;&amp;m: Swap Standard Output and Standard Error "><LINKREL="next"HREF="ch45_23.htm"TITLE="45.23 The Ins and Outs of Redirected I/O Loops "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch45_21.htm"TITLE="45.21 n&gt;&amp;m: Swap Standard Output and Standard Error "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 45.21 n&gt;&amp;m: Swap Standard Output and Standard Error "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 45<BR>Shell Programming for the Initiated</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch45_23.htm"TITLE="45.23 The Ins and Outs of Redirected I/O Loops "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 45.23 The Ins and Outs of Redirected I/O Loops "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-7923">45.22 Handling Files Line-by-Line </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="UPT-ART-7923-IX-FILES-READING-LINE-BY-LINE"></A><ACLASS="indexterm"NAME="UPT-ART-7923-IX-SHELL-SCRIPTS-READING-FILES-LINE-BY-LINE"></A><ACLASS="indexterm"NAME="AUTOID-53840"></A>It isn't easy to see how to read a file line-by-line in a shell script.And while youcan write a file line-by-line by using the file-appending operator<CODECLASS="literal">&gt;&gt;</CODE> (two right angle brackets) with each command that should addto the file, there's a more efficient way to do that as well.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-53845"></A><ACLASS="indexterm"NAME="AUTOID-53847"></A><ACLASS="indexterm"NAME="AUTOID-53850"></A><ACLASS="indexterm"NAME="AUTOID-53853"></A><ACLASS="indexterm"NAME="AUTOID-53856"></A>The trick is to open the file and associate a file descriptornumber (3, 4, ..., 9) with it.UNIX keeps a <EMCLASS="emphasis">file pointer</EM>, like a bookmark in a book, that tells itwhere the next read or write should be in each open file.For example, if you open a file for reading and read the first line, the filepointer will stay at the start of the second line.The next read from that same open file will move the pointer to thestart of the third line.This trick only works with files that stay open; each time you open a file,the file pointer is set to the start of the file.[1]The Bourne shell<SPANCLASS="link"><EMCLASS="emphasis">exec</EM> command (<ACLASS="linkend"HREF="ch45_07.htm"TITLE="The exec Command ">45.7</A>)</SPAN>can open a file and associate a file descriptor with it.For example, this <EMCLASS="emphasis">exec</EM> command makes the standard input of allfollowing commands come from the file <EMCLASS="emphasis">formfile</EM>:</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] The file-appending operator <CODECLASS="literal">&gt;&gt;</CODE> sets the pointer to the end ofthe file before the first write.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><ICLASS="lineannotation">...all commands read their stdin from default place</I>exec &lt; formfile   <ICLASS="lineannotation">...all commands will read their stdin from formfile</I></PRE></BLOCKQUOTE></P><PCLASS="para">There's another way to rearrange file descriptors: by doing it at the lastline of <EMCLASS="emphasis">while</EM> loops, <EMCLASS="emphasis">if</EM> and <EMCLASS="emphasis">case</EM> statements.For example, all commands in the <EMCLASS="emphasis">while</EM> loop below will take theirstandard inputs from the file <EMCLASS="emphasis">formfile</EM>.The standard input outside the <EMCLASS="emphasis">while</EM> loop isn't changed:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><ICLASS="lineannotation">...all commands read their stdin from default place</I>while ...do   <ICLASS="lineannotation">...all commands will read their stdin from formfile</I>done &lt; formfile   <ICLASS="lineannotation">...all commands read their stdin from default place</I></PRE></BLOCKQUOTE></P><PCLASS="para">I call those &quot;redirected-I/O loops.&quot;Those and other Bourne shell structures<SPANCLASS="link">have some problems (<ACLASS="linkend"HREF="ch45_23.htm"TITLE="The Ins and Outs of Redirected I/O Loops ">45.23</A>)</SPAN>,but they're usually worth the work to solve.</P><PCLASS="para"><ACLASS="indexterm"NAME="UPT-ART-7923-IX-FORMPROG-SCRIPT-EXAMPLES"></A><ACLASS="indexterm"NAME="UPT-ART-7923-IX-FORMPROG-SCRIPT-DESCRIBED"></A>We'll use all that to make a shell script for filling in forms.The script, <EMCLASS="emphasis">formprog</EM>, reads an empty form file like this one, lineby line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><ACLASS="indexterm"NAME="UPT-ART-7923-IX-FORMS-SCRIPT-FOR-FILING"></A>Name:Address:City:State/Province:Phone:FAX: Project: Corporate DecisionComments:</PRE></BLOCKQUOTE></P><PCLASS="para">If a line has just a label, like <CODECLASS="literal">Name:</CODE>, the script will promptyou to fill it in.If you do, the script will add the completed line to an output file; otherwise,no output line is written.If a form line is already completed, like:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Project: Corporate Decision</PRE></BLOCKQUOTE></P><PCLASS="para">the script doesn't prompt you; it just writes the lineto the output file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>formprog formfile completed</B></CODE>Name: <CODECLASS="userinput"><B>Jerry Peek</B></CODE>Address: <CODECLASS="userinput"><B>123 Craigie St.</B></CODE>City: <CODECLASS="userinput"><B>Cambridge</B></CODE>State/Province: <CODECLASS="userinput"><B>MA</B></CODE>Phone: <CODECLASS="userinput"><B>(617)456-7890</B></CODE>FAX: Project: Corporate DecisionComments: % <CODECLASS="userinput"><B>cat completed</B></CODE>Name: Jerry PeekAddress: 123 Craigie St.City: CambridgeState/Province: MAPhone: (617)456-7890Project: Corporate Decision</PRE></BLOCKQUOTE></P><PCLASS="para">Here's the <EMCLASS="emphasis">formprog</EM> script.The line numbers are for reference only; don't type them into the file.There's more explanation after the script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><ACLASS="indexterm"NAME="AUTOID-53915"></A><ACLASS="indexterm"NAME="AUTOID-53918"></A> 1  #!/bin/sh 2  # formprog - fill in template form from $1, leave completed form in $2 3  # TABSTOPS ARE SET AT 4 IN THIS SCRIPT 4   5  template=&quot;$1&quot;   completed=&quot;$2&quot;   errors=/tmp/formprog$$ 6  myname=`basename $0`    # BASENAME OF THIS SCRIPT (NO LEADING PATH) 7  trap 'rm -f $errors; exit' 0 1 2 15 8  <ACLASS="indexterm"NAME="AUTOID-53921"></A> 9  # READ $template LINE-BY-LINE, WRITE COMPLETED LINES TO $completed:10  exec 4&lt;&amp;0   # SAVE ORIGINAL stdin (USUALLY TTY) AS FD 411  while read label text12  do<ACLASS="indexterm"NAME="AUTOID-53924"></A>13      case &quot;$label&quot; in14      ?*:) # FIRST WORD ENDS WITH A COLON; LINE IS OKAY15          case &quot;$text&quot; in16          ?*) # SHOW LINE ON SCREEN AND PUT INTO completed FILE:17              echo &quot;$label $text&quot;18              echo &quot;$label $text&quot; 1&gt;&amp;319              ;;20          *)  # FILL IT IN OURSELVES:21              echo -n &quot;$label &quot;22              exec 5&lt;&amp;0   # SAVE template FILE FD; DO NOT CLOSE!23              exec 0&lt;&amp;4   # RESTORE ORIGINAL stdin TO READ ans24              read ans25              exec 0&lt;&amp;5   # RECONNECT template FILE TO stdin26              case &quot;$ans&quot; in27              &quot;&quot;) ;;      # EMPTY; DO NOTHING28              *)  echo &quot;$label $ans&quot; 1&gt;&amp;3 ;;29              esac30              ;;31          esac32          ;;33      *)  echo &quot;$myname: bad $1 line:   '$label $text'&quot; 1&gt;&amp;2; break;;34      esac35  done &lt;&quot;$template&quot; 2&gt;$errors 3&gt;&quot;$completed&quot;36  37  if [ -s $errors ]; then38      /bin/cat $errors 1&gt;&amp;239      echo &quot;$myname: should you remove '$completed' file?&quot; 1&gt;&amp;240  fi</PRE></BLOCKQUOTE></P><PCLASS="para"><BCLASS="emphasis.bold">Line&nbsp;10</B> uses the<SPANCLASS="link"><CODECLASS="literal">4&lt;&amp;0</CODE> operator (<ACLASS="linkend"HREF="ch45_21.htm"TITLE="n&gt;&amp;m: Swap Standard Output and Standard Error ">45.21</A>)</SPAN>to save the location of the original standard input&nbsp;- usually yourterminal, but not always&nbsp;- as file descriptor 4.[2](We'll need to read that original <EMCLASS="emphasis">stdin</EM> in line 24.)</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] We can't assume that standard input is coming from a terminal.If we do, it prevents you from running <EMCLASS="emphasis">formprog</EM> this way:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="replaceable"><I>command-generator-program</I></CODE> <CODECLASS="userinput"><B>| formprog</B></CODE>% <CODECLASS="userinput"><B>formprog &lt; </B></CODE><CODECLASS="replaceable"><I>command-file</I></CODE></PRE></BLOCKQUOTE></P><PCLASS="para"></P></BLOCKQUOTE><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-53944"></A><ACLASS="indexterm"NAME="AUTOID-53947"></A><ACLASS="indexterm"NAME="AUTOID-53950"></A><ACLASS="indexterm"NAME="AUTOID-53953"></A>During <BCLASS="emphasis.bold">lines&nbsp;11-35</B> of the redirected-I/O <EMCLASS="emphasis">while</EM> loop:all commands' standard input comes from the file named in <CODECLASS="literal">$template</CODE>,all standard error goes to the <CODECLASS="literal">$errors</CODE> file,and anything written to file descriptor 3 is added to the <CODECLASS="literal">$completed</CODE>file.UNIX keeps file pointers for all those open files&nbsp;- so each read andwrite is done just past the end of the previous one.</P><PCLASS="para">Here's what happens each time the loop is executed:</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">The<SPANCLASS="link"><EMCLASS="emphasis">read</EM> command (<ACLASS="linkend"HREF="ch44_13.htm"TITLE="read: Reading from the Keyboard ">44.13</A>)</SPAN>in <BCLASS="emphasis.bold">line 11</B> reads the next line from its standard input&nbsp;- that's the open<CODECLASS="literal">$template</CODE> file.</P></LI><LICLASS="listitem"><PCLASS="para">The<SPANCLASS="link"><EMCLASS="emphasis">case</EM> (<ACLASS="linkend"HREF="ch44_05.htm"TITLE="Test String Values with Bourne Shell case ">44.5</A>)</SPAN>in lines&nbsp;15-31 checks the text from the<CODECLASS="literal">$template</CODE> file:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">If the text has both a label -ding with a colon (<CODECLASS="literal">:</CODE>)) and someother text (stored in <CODECLASS="literal">$text</CODE>), the complete line is written two places.<BCLASS="emphasis.bold">Line&nbsp;17</B> writes the line to the standard output&nbsp;- which is probablyyour screen (it's not redirected by the script, anyway).<BCLASS="emphasis.bold">Line&nbsp;18</B> writes the line to file descriptor 3, the open<CODECLASS="literal">$completed</CODE> file.</P></LI><LICLASS="listitem"><PCLASS="para">If the text has just a label, <BCLASS="emphasis.bold">line&nbsp;21</B> writes the label tostandard output (usually your terminal) without a newline.We want to read the answer, at <BCLASS="emphasis.bold">line&nbsp;24</B>, but there's a problem:on some Bourne shells, the <EMCLASS="emphasis">read</EM> command can only read from filedescriptor 0 and won't let you use operators like <CODECLASS="literal">&lt;&amp;4</CODE> on itscommand line.</P><PCLASS="para">So, in <BCLASS="emphasis.bold">line&nbsp;22</B>, we save a copy of the open <CODECLASS="literal">$template</CODE>file descriptor <EMCLASS="emphasis">and the location of the open file pointer</EM> in filedescriptor 5.<BCLASS="emphasis.bold">Line&nbsp;23</B> changes standard input so the <EMCLASS="emphasis">read</EM> in line&nbsp;24 willread from the right place (usually the terminal).<BCLASS="emphasis.bold">Line&nbsp;25</B> adjusts standard input so the next <EMCLASS="emphasis">read</EM> at the top ofthe loop (line&nbsp;11) will come from the <CODECLASS="literal">$template</CODE> file.</P><PCLASS="para">If line&nbsp;24 doesn't read an answer, <BCLASS="emphasis.bold">line&nbsp;27</B> does not write a line.Otherwise, <BCLASS="emphasis.bold">line&nbsp;28</B> writes the line to file descriptor 3, the open<CODECLASS="literal">$completed</CODE> file.</P></LI><LICLASS="listitem"><PCLASS="para">If the template label doesn't end with a colon, <BCLASS="emphasis.bold">line&nbsp;33</B> writesa message to <EMCLASS="emphasis">stderr</EM> (file descriptor 2).These messages, together with messages to <EMCLASS="emphasis">stderr</EM> from any othercommand in the loop, are redirected into the <CODECLASS="literal">$errors</CODE> file.After the loop, if the<SPANCLASS="link">test (<ACLASS="linkend"HREF="ch44_20.htm"TITLE="test: Testing Files and Strings ">44.20</A>)</SPAN>in <BCLASS="emphasis.bold">line&nbsp;37</B> sees any text in the file,the text is displayed in <BCLASS="emphasis.bold">line&nbsp;38</B> and the script prints awarning.</P></LI></UL></LI></OL><PCLASS="para">The loop keeps reading and writing line by line until the <EMCLASS="emphasis">read</EM>at the top of the loop reaches the end-of-file of <CODECLASS="literal">$template</CODE>.<ACLASS="indexterm"NAME="AUTOID-54013"></A><ACLASS="indexterm"NAME="AUTOID-54014"></A><ACLASS="indexterm"NAME="AUTOID-54015"></A></P><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">JP</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch45_21.htm"TITLE="45.21 n&gt;&amp;m: Swap Standard Output and Standard Error "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 45.21 n&gt;&amp;m: Swap Standard Output and Standard Error "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch45_23.htm"TITLE="45.23 The Ins and Outs of Redirected I/O Loops "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 45.23 The Ins and Outs of Redirected I/O Loops "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">45.21 n&gt;&amp;m: Swap Standard Output and Standard Error </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">45.23 The Ins and Outs of Redirected I/O Loops </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>