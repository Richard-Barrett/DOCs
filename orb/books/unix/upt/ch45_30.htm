<HTML><HEAD><TITLE>[Chapter 45] 45.30 Grabbing Parts of a String </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:55:04Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch45_01.htm"TITLE="45. Shell Programming for the Initiated"><LINKREL="prev"HREF="ch45_29.htm"TITLE="45.29 Testing Characters in a String with expr "><LINKREL="next"HREF="ch45_31.htm"TITLE="45.31 Nested Command Substitution "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch45_29.htm"TITLE="45.29 Testing Characters in a String with expr "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 45.29 Testing Characters in a String with expr "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 45<BR>Shell Programming for the Initiated</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch45_31.htm"TITLE="45.31 Nested Command Substitution "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 45.31 Nested Command Substitution "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-0232">45.30 Grabbing Parts of a String </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-54621"></A><ACLASS="indexterm"NAME="AUTOID-54624"></A><ACLASS="indexterm"NAME="AUTOID-54627"></A>How can you parse (split, search) a string of text to find the lastword, the second column, and so on?There are a lot of different ways.Pick the one that works best for you&nbsp;- or invent another one!(UNIX has slots of ways to work with strings of text.)</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-232-SECT-1.1">45.30.1 Matching with expr </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-54633"></A><ACLASS="indexterm"NAME="AUTOID-54636"></A><ACLASS="indexterm"NAME="AUTOID-54639"></A><ACLASS="indexterm"NAME="AUTOID-54642"></A><ACLASS="indexterm"NAME="AUTOID-54645"></A><ACLASS="indexterm"NAME="AUTOID-54648"></A><ACLASS="indexterm"NAME="AUTOID-54652"></A>The<SPANCLASS="link"><EMCLASS="emphasis">expr</EM> command (<ACLASS="linkend"HREF="ch45_28.htm"TITLE="Quick Reference: expr ">45.28</A>)</SPAN>can grab part of a string with a regular expression.The example below is from a shell script whose last command-line argumentis a filename.The two commands below use <EMCLASS="emphasis">expr</EM> to grab the last argument and allarguments except the last one.The <CODECLASS="literal">&quot;$*&quot;</CODE> gives <EMCLASS="emphasis">expr</EM> a list of all command-line argumentsin a single word.(Using<SPANCLASS="link"><CODECLASS="literal">&quot;$@&quot;</CODE> (<ACLASS="linkend"HREF="ch44_15.htm"TITLE="Handling Command-Line Arguments in Shell Scripts ">44.15</A>)</SPAN>here wouldn't work because it gives individually quoted arguments.<EMCLASS="emphasis">expr</EM> needs all arguments in one word.)</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">last=`expr &quot;$*&quot; : '.* \(.*\)'`    # LAST ARGUMENTfirst=`expr &quot;$*&quot; : '\(.*\) .*'`    # ALL BUT LAST ARGUMENT</PRE></BLOCKQUOTE></P><PCLASS="para">Let's look at the regular expression that gets the last word.The leading part of the expression, <CODECLASS="literal">.*&nbsp;</CODE>, matches as manycharacters as it can, followed by a space.This includes all words up to and including the last space.After that, the end of the expression, <CODECLASS="literal">\(.*\)</CODE>, matches thelast word.</P><PCLASS="para">The regular expression that grabs the first words is the same as theprevious one&nbsp;- but I've moved the <CODECLASS="literal">\(&nbsp;\)</CODE> pair.Now it grabs all words up to but not including the last space.The end of the regular expression, <CODECLASS="literal">&nbsp;.*</CODE>, matches the last spaceand last word&nbsp;- and <EMCLASS="emphasis">expr</EM> ignores them.So the final <CODECLASS="literal">.*</CODE> really isn't needed here (though the space is).I've included that final <CODECLASS="literal">.*</CODE> because it follows from the firstexample.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-54676"></A><ACLASS="indexterm"NAME="AUTOID-54679"></A><EMCLASS="emphasis">expr</EM> is great when you want to split a string into just two parts.The <CODECLASS="literal">.*</CODE> also makes <EMCLASS="emphasis">expr</EM> good for skipping a variable numberof words when you don't know how many words a string will have.But <EMCLASS="emphasis">expr</EM> is lousy for getting, say, the fourth word in a string.And it's almost useless for handling more than one line of text at a time.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-232-SECT-1.2">45.30.2 Using echo with awk, colrm, or cut </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-54689"></A><ACLASS="indexterm"NAME="AUTOID-54692"></A><ACLASS="indexterm"NAME="AUTOID-54695"></A><ACLASS="indexterm"NAME="AUTOID-54698"></A><ACLASS="indexterm"NAME="AUTOID-54701"></A><ACLASS="indexterm"NAME="AUTOID-54704"></A><ACLASS="indexterm"NAME="AUTOID-54707"></A><EMCLASS="emphasis">awk</EM>can split lines into words.But <EMCLASS="emphasis">awk</EM> has a lot of overhead and can take some time to execute,especially on a busy system.The<SPANCLASS="link"><EMCLASS="emphasis">cut</EM> (<ACLASS="linkend"HREF="ch35_14.htm"TITLE="Cutting Columns or Fields with cut ">35.14</A>)</SPAN>and<SPANCLASS="link"><EMCLASS="emphasis">colrm</EM> (<ACLASS="linkend"HREF="ch35_15.htm"TITLE="Cutting Columns with colrm ">35.15</A>)</SPAN>commands start more quickly than <EMCLASS="emphasis">awk</EM> but they can't do as much.</P><PCLASS="para">All of those utilities are designed to handle multiple lines of text.You can tell <EMCLASS="emphasis">awk</EM> to handle a single line with its pattern-matchingoperators and its <EMCLASS="emphasis">NR</EM> variable.You can also run those utilities with a single line of text, fed to thestandard input through a pipe from<SPANCLASS="link"><EMCLASS="emphasis">echo</EM> (<ACLASS="linkend"HREF="ch08_06.htm"TITLE="Output Command-Line Arguments ">8.6</A>)</SPAN>.For example, to get the third field from a colon-separated string:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">string=&quot;this:is:just:a:dummy:string&quot;field3_awk=`echo &quot;$string&quot; | awk -F: '{print $3}'`field3_cut=`echo &quot;$string&quot; | cut -d: -f3`</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-54725"></A>Let's combine two <EMCLASS="emphasis">echo</EM> commands.One sends text to <EMCLASS="emphasis">awk</EM>, <EMCLASS="emphasis">cut</EM>, or <EMCLASS="emphasis">colrm</EM> through a pipe;the utility ignores all the text from columns 1-24, then prints columns 25to the end of the variable <EMCLASS="emphasis">text</EM>.The outer <EMCLASS="emphasis">echo</EM> prints <EMCLASS="emphasis">The answer is</EM> and that answer.Notice that the inner double quotes are escaped with backslashesto keep the Bourne shell from interpreting them before the inner<EMCLASS="emphasis">echo</EM> runs:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">echo &quot;The answer is `echo \&quot;$text\&quot; | awk '{print substr($0,25)}'`&quot;echo &quot;The answer is `echo \&quot;$text\&quot; | cut -c25-`&quot;echo &quot;The answer is `echo \&quot;$text\&quot; | colrm 1 24`&quot;</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-232-SECT-1.3">45.30.3 Using set </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-54741"></A><ACLASS="indexterm"NAME="AUTOID-54744"></A><ACLASS="indexterm"NAME="AUTOID-54747"></A>The Bourne shell<SPANCLASS="link"><EMCLASS="emphasis">set</EM> (<ACLASS="linkend"HREF="ch44_19.htm"TITLE="The Bourne Shell set Command ">44.19</A>)</SPAN>command can be used to parse a single-line string andstore it in the<SPANCLASS="link">command-line parameters (<ACLASS="linkend"HREF="ch44_15.htm"TITLE="Handling Command-Line Arguments in Shell Scripts ">44.15</A>)</SPAN><CODECLASS="literal">&quot;$@&quot;</CODE>, <CODECLASS="literal">$*</CODE>, <CODECLASS="literal">$1</CODE>, <CODECLASS="literal">$2</CODE>, and so on.Then you can also loop through the words with a<SPANCLASS="link"><EMCLASS="emphasis">for</EM> loop (<ACLASS="linkend"HREF="ch44_16.htm"TITLE="Handling Command-Line Arguments with a for Loop ">44.16</A>)</SPAN>and use everything else the shell has for dealing with command-lineparameters.Also, you can set the<SPANCLASS="link"><EMCLASS="emphasis">IFS</EM> variable (<ACLASS="linkend"HREF="ch35_21.htm"TITLE="Using IFS to Split Strings ">35.21</A>)</SPAN>to control how the shell splitsthe string.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-232-SECT-1.4">45.30.4 Using sed </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-54765"></A><ACLASS="indexterm"NAME="AUTOID-54768"></A><ACLASS="indexterm"NAME="AUTOID-54771"></A>The UNIX<SPANCLASS="link"><EMCLASS="emphasis">sed</EM> (<ACLASS="linkend"HREF="ch34_24.htm"TITLE="Quick Reference: sed ">34.24</A>)</SPAN>utility is good at parsing input that you may or may not be able tosplit into words otherwise, at finding a single line of text in a group andoutputting it, and many other things.In this example, I want to get the percentage-used of the filesystemmounted on <EMCLASS="emphasis">/home</EM>.That information is buried in the output of the<SPANCLASS="link"><EMCLASS="emphasis">df</EM> (<ACLASS="linkend"HREF="ch24_09.htm"TITLE="How Much Disk Space? ">24.9</A>)</SPAN>command.On my system, <EMCLASS="emphasis">df</EM> output looks like:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>df</B></CODE>Filesystem            kbytes    used   avail capacity  Mounted on   .../dev/sd3c            1294854  914230  251139    78%    /work/dev/sd4c             597759  534123    3861    99%    /home   ...</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-54784"></A>I want the number <EMCLASS="emphasis">99</EM> from the line ending with <EMCLASS="emphasis">/home</EM>.The <EMCLASS="emphasis">sed</EM> address <CODECLASS="literal">/&nbsp;\/home$/</CODE> will find that line (including aspace before the <EMCLASS="emphasis">/home</EM> makes sure the address doesn't match aline ending with <EMCLASS="emphasis">/something/home</EM>).The <EMCLASS="emphasis">-n</EM> option keeps <EMCLASS="emphasis">sed</EM> from printing any lines exceptthe line we ask it to print (with its <EMCLASS="emphasis">p</EM> command).I know that the &quot;capacity&quot; is the only word on the line that endswith a percent sign (<CODECLASS="literal">%</CODE>).A space after the first <CODECLASS="literal">.*</CODE> makes sure that <CODECLASS="literal">.*</CODE> doesn't&quot;eat&quot; the first digit of the number that we want to match by <CODECLASS="literal">[0-9]</CODE>.The <EMCLASS="emphasis">sed</EM><SPANCLASS="link">escaped-parenthesis operators (<ACLASS="linkend"HREF="ch34_10.htm"TITLE="Referencing Portions of a Search String ">34.10</A>)</SPAN>grab that number.Here goes:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">usage=`df | sed -n '/ \/home$/s/.* \([0-9][0-9]*\)%.*/\1/p'`</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-54805"></A><ACLASS="indexterm"NAME="AUTOID-54808"></A><ACLASS="indexterm"NAME="AUTOID-54811"></A><ACLASS="indexterm"NAME="AUTOID-54814"></A>Combining <EMCLASS="emphasis">sed</EM> with<SPANCLASS="link"><EMCLASS="emphasis">eval</EM> (<ACLASS="linkend"HREF="ch08_10.htm"TITLE="eval: When You Need Another Chance ">8.10</A>)</SPAN>lets you set several shell variablesat once from parts of the same line.Here's a command line that sets two shell variables from the <EMCLASS="emphasis">df</EM>output:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval `df |sed -n '/ \/home$/s/^[^ ]*  *\([0-9]*\)  *\([0-9]*\).*/kb=\1 u=\2/p'`</PRE></BLOCKQUOTE></P><PCLASS="para">The left-hand side of that substitution command has a regular expressionthat uses <EMCLASS="emphasis">sed</EM>'s escaped parenthesis operators.They grab the &quot;kbytes&quot; and &quot;used&quot; columns from the <EMCLASS="emphasis">df</EM>output.The right-hand side outputs the two <EMCLASS="emphasis">df</EM> values with Bourne shellvariable-assignmentcommands to set the <EMCLASS="emphasis">kb</EM> and <EMCLASS="emphasis">u</EM> variables.After <EMCLASS="emphasis">sed</EM> finishes, the resulting command line looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">eval kb=597759 u=534123</PRE></BLOCKQUOTE></P><PCLASS="para">Now <CODECLASS="literal">$kb</CODE> will give you <EMCLASS="emphasis">597759</EM>and <CODECLASS="literal">$u</CODE> contains <EMCLASS="emphasis">534123</EM>.</P></DIV><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">JP</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch45_29.htm"TITLE="45.29 Testing Characters in a String with expr "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 45.29 Testing Characters in a String with expr "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch45_31.htm"TITLE="45.31 Nested Command Substitution "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 45.31 Nested Command Substitution "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">45.29 Testing Characters in a String with expr </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">45.31 Nested Command Substitution </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>