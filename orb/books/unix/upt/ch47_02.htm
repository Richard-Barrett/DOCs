<HTML><HEAD><TITLE>[Chapter 47] 47.2 C Shell Programming Considered Harmful </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-04T21:55:53Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch47_01.htm"TITLE="47. C Shell Programming...NOT"><LINKREL="prev"HREF="ch47_01.htm"TITLE="47.1 Why Not? "><LINKREL="next"HREF="ch47_03.htm"TITLE="47.3 Conditional Statements with if "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch47_01.htm"TITLE="47.1 Why Not? "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 47.1 Why Not? "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 47<BR>C Shell Programming...NOT</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch47_03.htm"TITLE="47.3 Conditional Statements with if "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 47.3 Conditional Statements with if "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-0393">47.2 C Shell Programming Considered Harmful </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="UPT-ART-393-IX-BOURNE-SHELL-SH-C-SHELL-COMPARED-TO"></A><ACLASS="indexterm"NAME="UPT-ART-393-IX-C-SHELL-CSH-BOURNE-SHELL-COMPARED-TO"></A><ACLASS="indexterm"NAME="UPT-ART-393-IX-C-SHELL-CSH-BUGS-IN"></A><ACLASS="indexterm"NAME="UPT-ART-393-IX-C-SHELL-CSH-DISADVANTAGES"></A>Resolved: the <EMCLASS="emphasis">csh</EM> is a tool utterly inadequate for programming, andits use for such purposes should be strictly banned.</P><PCLASS="para">I am continually shocked and dismayed to see people write test cases,install scripts, and other random hackery using the <EMCLASS="emphasis">csh</EM>.</P><PCLASS="para">The <EMCLASS="emphasis">csh</EM> is seductive because the conditionals are more C-like,so the path of least resistance is chosen and a <EMCLASS="emphasis">csh</EM> script iswritten.  Sadly, this is a lost cause, and the programmer seldom evenrealizes it, even when he finds that many simple things he wishes todo range from cumbersome to impossible in the <EMCLASS="emphasis">csh</EM>.</P><PCLASS="para">What's more, lack of proficiency in the Bourne shell has been known tocause errors in <EMCLASS="emphasis">/etc/rc</EM> and <EMCLASS="emphasis">.cronrc</EM> files, which is aproblem, because you <EMCLASS="emphasis">must</EM> write these files in that language.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-393-SECT-1.1">47.2.1 File Descriptors </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56081"></A><ACLASS="indexterm"NAME="AUTOID-56084"></A>The most common problem encountered in <EMCLASS="emphasis">csh</EM> programming is thatyou can't do file-descriptor manipulation.  All you are able to do isredirect <EMCLASS="emphasis">stdin</EM>, or <EMCLASS="emphasis">stdout</EM>, or <EMCLASS="emphasis">dup</EM> <EMCLASS="emphasis">stderr</EM> into<EMCLASS="emphasis">stdout</EM>.  Bourne-compatible shells offer you an abundance of moreexotic possibilities.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-393-SECT-1.1.1">47.2.1.1 Writing Files </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56096"></A><ACLASS="indexterm"NAME="AUTOID-56099"></A><ACLASS="indexterm"NAME="AUTOID-56101"></A><ACLASS="indexterm"NAME="AUTOID-56104"></A>In the Bourne shell, you can open or <EMCLASS="emphasis">dup</EM> random file descriptors.For example, </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">exec 2&gt;errs.out</PRE></BLOCKQUOTE></P><PCLASS="para">means that from then on, <EMCLASS="emphasis">stderr</EM> goes into the <EMCLASS="emphasis">errs.out</EM> file.</P><PCLASS="para">Or what if you just want to throw away <EMCLASS="emphasis">stderr</EM> and leave <EMCLASS="emphasis">stdout</EM>alone?Pretty simple operation, eh?</P><PCLASS="para"><TABLECLASS="screen.co"BORDER="1"><TR><THVALIGN="TOP"><PRECLASS="calloutlist"><ACLASS="co"HREF="ch13_14.htm"TITLE="13.14 What Can You Do with an Empty File? ">/dev/null</A> </PRE></TH><TDVALIGN="TOP"><PRECLASS="screen">cmd 2&gt;/dev/null<ACLASS="indexterm"NAME="AUTOID-56119"></A></PRE></TD></TR></TABLE></P><PCLASS="para">That works in the Bourne shell.In the C shell, you can only make a pitiful attempt like this:</P><PCLASS="para"><TABLECLASS="screen.co"BORDER="1"><TR><THVALIGN="TOP"><PRECLASS="calloutlist"><ACLASS="co"HREF="ch45_20.htm"TITLE="45.20 Overview: Open Files and File Descriptors ">/dev/tty</A> </PRE></TH><TDVALIGN="TOP"><PRECLASS="screen">(cmd &gt; /dev/tty) &gt;&amp; /dev/null</PRE></TD></TR></TABLE></P><PCLASS="para">But who said that <EMCLASS="emphasis">stdout</EM> was my terminal?So it's wrong.This simple operation <EMCLASS="emphasis">cannot be done</EM> in the C shell.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56131"></A><ACLASS="indexterm"NAME="AUTOID-56134"></A>Along these same lines, you can't direct error messages in <EMCLASS="emphasis">csh</EM> scripts on <EMCLASS="emphasis">stderr</EM>, as is considered proper.In the Bourne shell, youmight say:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">echo &quot;$0: cannot find $file&quot; 1&gt;&amp;2</PRE></BLOCKQUOTE></P><PCLASS="para">but in the C shell, you can't redirect <EMCLASS="emphasis">stdout</EM> onto <EMCLASS="emphasis">stderr</EM>so you endup doing something silly like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">sh -c &quot;echo '${0}: cannot find $file' 1&gt;&amp;2&quot;</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-393-SECT-1.1.2">47.2.1.2 Reading Files </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56149"></A><ACLASS="indexterm"NAME="AUTOID-56152"></A><ACLASS="indexterm"NAME="AUTOID-56155"></A><ACLASS="indexterm"NAME="AUTOID-56158"></A><ACLASS="indexterm"NAME="AUTOID-56161"></A><ACLASS="indexterm"NAME="AUTOID-56164"></A><ACLASS="indexterm"NAME="AUTOID-56167"></A><ACLASS="indexterm"NAME="AUTOID-56170"></A>In the <EMCLASS="emphasis">csh</EM>, all you've got is <CODECLASS="literal">$&lt;</CODE>,which reads a line from your <EMCLASS="emphasis">tty</EM>.What if you've redirected <EMCLASS="emphasis">stdin</EM>?Tough noogies, you still get your <EMCLASS="emphasis">tty</EM>, which you really can't redirect.Now, the <EMCLASS="emphasis">read</EM> statement in the Bourne shell allows you to read from<EMCLASS="emphasis">stdin</EM>, which catches redirection.It also means that you can do things like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">exec 3&lt; file1exec 4&lt; file2</PRE></BLOCKQUOTE></P><PCLASS="para">&#13;Now you can read from file descriptor 3 and get lines from <EMCLASS="emphasis">file1</EM>, or from<EMCLASS="emphasis">file2</EM> through fd 4.In modern, Bourne-like shells, this suffices: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">read some_var 0&lt;&amp;3read another_var 0&lt;&amp;4</PRE></BLOCKQUOTE></P><PCLASS="para">Although in older ones where <EMCLASS="emphasis">read</EM> only goes from 0, you trick it:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">exec 5&lt;&amp;0  # save old stdinexec 0&lt;&amp;3; read some_varexec 0&lt;&amp;4; read another_varexec 0&lt;&amp;5  # restore it</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-393-SECT-1.1.3">47.2.1.3 Closing FDs </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56194"></A><ACLASS="indexterm"NAME="AUTOID-56196"></A><ACLASS="indexterm"NAME="AUTOID-56199"></A>In the Bourne shell, you can close file descriptors you don'twant open, like <CODECLASS="literal">2&gt;&amp;-</CODE>, which isn't the same as redirecting itto <EMCLASS="emphasis">/dev/null</EM>.&#13;</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-393-SECT-1.1.4">47.2.1.4 More Elaborate Combinations </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56207"></A><ACLASS="indexterm"NAME="AUTOID-56210"></A>Maybe you want to pipe <EMCLASS="emphasis">stderr</EM> to a command and leave <EMCLASS="emphasis">stdout</EM> alone.Not too hard an idea, right?As I mentioned above, you can't do this in the C shell.In a Bourne shell, you can do things like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>exec 3&gt;&amp;1; grep yyy xxx 2&gt;&amp;1 1&gt;&amp;3 3&gt;&amp;- | sed s/file/foobar/ 1&gt;&amp;2 3&gt;&amp;-</B></CODE>grep: xxx: No such foobar or directory</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56219"></A><ACLASS="indexterm"NAME="AUTOID-56222"></A><ACLASS="indexterm"NAME="AUTOID-56225"></A><ACLASS="indexterm"NAME="AUTOID-56228"></A><ACLASS="indexterm"NAME="AUTOID-56231"></A><ACLASS="indexterm"NAME="AUTOID-56234"></A>Normal output would be unaffected.The fd closes (<CODECLASS="literal">3&gt;&amp;-</CODE>) were there in casesomething really cared about all its FDs.We send <EMCLASS="emphasis">stderr</EM> to <EMCLASS="emphasis">sed</EM>,and then put it back out FD 2.</P><PCLASS="para">Consider the pipeline:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="replaceable"><I>A</I></CODE> | <CODECLASS="replaceable"><I>B</I></CODE> | <CODECLASS="replaceable"><I>C</I></CODE></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56247"></A>You want to know the status of <EMCLASS="emphasis">C</EM>, well, that's easy: it's in <CODECLASS="literal">$?</CODE>,or <CODECLASS="literal">$status</CODE> in <EMCLASS="emphasis">csh</EM>.But if you want it from <EMCLASS="emphasis">A</EM>, you're out of luck&nbsp;- ifyou're in the C shell, that is.In the Bourne shell, you can get it, although doing so is a bit tricky. Here's something I had to do where I ran <EMCLASS="emphasis">dd</EM>'s<EMCLASS="emphasis">stderr</EM> into a <EMCLASS="emphasis">grep -v</EM> pipe to get rid of the <CODECLASS="literal">recordsin/out</CODE> noise, but hadto return the <EMCLASS="emphasis">dd</EM>'s exit status, not the <EMCLASS="emphasis">grep</EM>'s:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">device=/dev/rmt8dd_noise='^[0-9]+\+[0-9]+ records (in|out)$'<ACLASS="indexterm"NAME="AUTOID-56263"></A>exec 3&gt;&amp;1status=`((dd if=$device ibs=64k 2&gt;&amp;1 1&gt;&amp;3 3&gt;&amp;- 4&gt;&amp;-; echo $? &gt;&amp;4) |   egrep -v &quot;$dd_noise&quot; 1&gt;&amp;2 3&gt;&amp;- 4&gt;&amp;-) 4&gt;&amp;1`exit $status;</PRE></BLOCKQUOTE></P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-393-SECT-1.2">47.2.2 Command Orthogonality </A></H3><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-393-SECT-1.2.1">47.2.2.1 Built-Ins </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56271"></A>The <EMCLASS="emphasis">csh</EM> is a horrid botch with its built-ins.You can't put them together in any reasonable way.Even a simple little thing like this:   </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><ACLASS="indexterm"NAME="AUTOID-56277"></A><ACLASS="indexterm"NAME="AUTOID-56280"></A>% <CODECLASS="userinput"><B>time | echo</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">&#13;while nonsensical, shouldn't give me this message:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Reset tty pgrp from 9341 to 26678</PRE></BLOCKQUOTE></P><PCLASS="para">Others are more fun:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><ACLASS="indexterm"NAME="AUTOID-56290"></A><ACLASS="indexterm"NAME="AUTOID-56293"></A>% <CODECLASS="userinput"><B>sleep 1 | while</B></CODE>while: Too few arguments.[5] 9402% <CODECLASS="userinput"><B>jobs</B></CODE>[5]     9402 Done                 sleep |</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56299"></A><ACLASS="indexterm"NAME="AUTOID-56302"></A><ACLASS="indexterm"NAME="AUTOID-56305"></A><ACLASS="indexterm"NAME="AUTOID-56308"></A>Some can even hang your shell.Try typing CTRL-z while you're <EMCLASS="emphasis">source</EM>ing something, or redirecting a <EMCLASS="emphasis">source</EM> command.Just make sure you have another window handy.&#13;</P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-393-SECT-1.2.2">47.2.2.2 Flow Control </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56316"></A><ACLASS="indexterm"NAME="AUTOID-56319"></A>You can't mix flow control and commands, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">who | while read line; do    echo &quot;gotta $line&quot;done</PRE></BLOCKQUOTE></P><PCLASS="para">You can't combine multiline pipes constructs in a <EMCLASS="emphasis">csh</EM> using semicolons.There's no easy way to do this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">alias cmd 'if (foo) then bar; else snark; endif'</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="UPT-ART-393-SECT-1.2.3">47.2.2.3 Stupid Parsing Bugs </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56331"></A><ACLASS="indexterm"NAME="AUTOID-56334"></A><ACLASS="indexterm"NAME="AUTOID-56337"></A><ACLASS="indexterm"NAME="AUTOID-56340"></A><ACLASS="indexterm"NAME="AUTOID-56343"></A>Certain reasonable things just don't work, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>kill -1 `cat foo`</B></CODE>`cat foo`: Ambiguous.</PRE></BLOCKQUOTE></P><PCLASS="para">But this is ok:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>/bin/kill -1 `cat foo`</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">If you have a stopped job:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[2]     Stopped              rlogin globhost</PRE></BLOCKQUOTE></P><PCLASS="para">You should be able to kill it with: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>kill %?glob</B></CODE>kill: No match</PRE></BLOCKQUOTE></P><PCLASS="para">but:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>fg %?glob</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">works.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56366"></A><ACLASS="indexterm"NAME="AUTOID-56369"></A>White space can matter:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if(expr)</PRE></BLOCKQUOTE></P><PCLASS="para">may fail on some versions of csh, while:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if (expr)</PRE></BLOCKQUOTE></P><PCLASS="para">works!</P></DIV></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-393-SECT-1.3">47.2.3 Signals </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56381"></A><ACLASS="indexterm"NAME="AUTOID-56383"></A><ACLASS="indexterm"NAME="AUTOID-56386"></A><ACLASS="indexterm"NAME="AUTOID-56389"></A><ACLASS="indexterm"NAME="AUTOID-56392"></A>In the C shell, all you can do with signals is trap <EMCLASS="emphasis">SIGINT</EM>.In the Bourne shell, you can trap any signal, or the end-of-program exit.For example, to blow away a temporary file on any of a variety of signals:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">trap 'rm -f /usr/adm/tmp/i$$ ;    echo &quot;ERROR: abnormal exit&quot;;    exit' 1 2 3 15trap 'rm tmp.$$' 0   # on program exit</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-393-SECT-1.4">47.2.4 Quoting </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56401"></A><ACLASS="indexterm"NAME="AUTOID-56404"></A><ACLASS="indexterm"NAME="AUTOID-56407"></A><ACLASS="indexterm"NAME="AUTOID-56410"></A>You can't quote things reasonably in the <EMCLASS="emphasis">csh</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">set foo = &quot;Bill asked, \&quot;How's tricks?\&quot;&quot;</PRE></BLOCKQUOTE></P><PCLASS="para">doesn't work.This makes it<SPANCLASS="link">really hard (<ACLASS="linkend"HREF="ch10_08.htm"TITLE="Fix Quoting in csh Aliases with makealias and quote ">10.8</A>)</SPAN>to construct strings with mixed quotes in them.In the Bourne shell, this works just fine. In fact, so does this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">cd /mnt; /usr/ucb/finger -m -s `ls \`u\``</PRE></BLOCKQUOTE></P><PCLASS="para">Dollar signs (<CODECLASS="literal">$</CODE>) cannot be escaped in double quotes in the<EMCLASS="emphasis">csh</EM>.Ugh.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">set foo = &quot;this is a \$dollar quoted and this is $HOME not quoted&quot; dollar: Undefined variable.</PRE></BLOCKQUOTE></P><PCLASS="para">You have to use backslashes (<CODECLASS="literal">\</CODE>) for newlines, and it's just darnhard toget them into strings sometimes.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><ACLASS="indexterm"NAME="AUTOID-56429"></A>% <CODECLASS="userinput"><B>set foo = &quot;this \and that&quot;;</B></CODE>% <CODECLASS="userinput"><B>echo $foo</B></CODE>this  and that% <CODECLASS="userinput"><B>echo &quot;$foo&quot;</B></CODE>Unmatched &quot;.</PRE></BLOCKQUOTE></P><PCLASS="para">Say what?You don't have these problems in the Bourne shell, where it'sjust fine to write things like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">echo    'This is      some text that contains     several newlines.'</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-393-SECT-1.5">47.2.5 Variable Syntax </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56441"></A><ACLASS="indexterm"NAME="AUTOID-56444"></A><ACLASS="indexterm"NAME="AUTOID-56447"></A><ACLASS="indexterm"NAME="AUTOID-56450"></A><ACLASS="indexterm"NAME="AUTOID-56453"></A><ACLASS="indexterm"NAME="AUTOID-56456"></A><ACLASS="indexterm"NAME="AUTOID-56459"></A><ACLASS="indexterm"NAME="AUTOID-56462"></A>There's this big difference between global -vironment) and local(shell) variables.In <EMCLASS="emphasis">csh</EM>, you use a totally different syntax to set one from the other.</P><PCLASS="para">In Bourne shell, this: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">VAR=foo cmds args</PRE></BLOCKQUOTE></P><PCLASS="para">is the same as:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">(export VAR; VAR=foo; cmd args)</PRE></BLOCKQUOTE></P><PCLASS="para">or <EMCLASS="emphasis">csh</EM>'s:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">(setenv VAR; cmd args)</PRE></BLOCKQUOTE></P><PCLASS="para">You can't use<SPANCLASS="link"><CODECLASS="literal">:t</CODE>, <CODECLASS="literal">:h</CODE>, etc. (<ACLASS="linkend"HREF="ch09_06.htm"TITLE="String Editing (Colon) Operators ">9.6</A>)</SPAN>on environment variables.Watch:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>echo Try testing with $SHELL:t</B></CODE>Try testing with /bin/csh:t</PRE></BLOCKQUOTE></P><PCLASS="para">It's really nice to be able to say<SPANCLASS="link"><CODECLASS="literal">${PAGER-more}</CODE> or <CODECLASS="literal">FOO=${BAR:-${BAZ}}</CODE> (<ACLASS="linkend"HREF="ch45_12.htm"TITLE="Parameter Substitution ">45.12</A>)</SPAN>to be able to run the user's <EMCLASS="emphasis">PAGER</EM> if set, and <EMCLASS="emphasis">more</EM> otherwise.You can't do this in the <EMCLASS="emphasis">csh</EM>.It takes more verbiage.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56491"></A>You can't get the process number of the last background command from theC shell, something you might like to do if you're starting up several jobs inthe background.In the Bourne shell, the PID of the last command put inthe background is available in <CODECLASS="userinput"><B>$!</B></CODE>.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56496"></A><ACLASS="indexterm"NAME="AUTOID-56499"></A><ACLASS="indexterm"NAME="AUTOID-56502"></A><ACLASS="indexterm"NAME="AUTOID-56505"></A>The <EMCLASS="emphasis">csh</EM> is also flaky about what it does when it imports an environment variable into a local shell variable, as it doeswith <EMCLASS="emphasis">HOME</EM>, <EMCLASS="emphasis">USER</EM>, <EMCLASS="emphasis">PATH</EM>, and <EMCLASS="emphasis">TERM</EM>.Consider this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>setenv TERM '`/bin/ls -l / &gt; /dev/tty`'</B></CODE>% <CODECLASS="userinput"><B>csh -f</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">And watch the fun!</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-393-SECT-1.6">47.2.6 Expression Evaluation </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56521"></A><ACLASS="indexterm"NAME="AUTOID-56524"></A>Consider this statement in the <EMCLASS="emphasis">csh</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if ($?MANPAGER) setenv PAGER $MANPAGER</PRE></BLOCKQUOTE></P><PCLASS="para">Despite your attempts to set only <EMCLASS="emphasis">PAGER</EM> when you wantto, the <EMCLASS="emphasis">csh</EM> aborts:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">MANPAGER: Undefined variable.</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56536"></A>That's because it parses the whole line anyway <EMCLASS="emphasis">and evaluates it</EM>!You have to write this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if ($?MANPAGER) then    setenv PAGER $MANPAGERendif</PRE></BLOCKQUOTE></P><PCLASS="para">That's the same problem you have here:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>if ($?X &amp;&amp; $X == 'foo') echo ok</B></CODE>X: Undefined variable</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56547"></A>This forces you to write a couple of nested <EMCLASS="emphasis">if</EM> statements.This is highly undesirable because it renders short-circuit Booleans useless in situations like these.If the <EMCLASS="emphasis">csh</EM> were really C-like, you would expect to be ableto safely employ this kind of logic.Consider the common C construct:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">if (p &amp;&amp; p-&gt;member)</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56555"></A>Undefined variables are not fatal errors in the Bourne shell, so this issue does not arise there.</P><PCLASS="para">While the <EMCLASS="emphasis">csh</EM> does have built-in expression handling, it's notwhat you might think.In fact, it's space-sensitive.This is an error:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">@ a = 4/2</PRE></BLOCKQUOTE></P><PCLASS="para">but this is okay:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">@ a = 4 / 2</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-393-SECT-1.7">47.2.7 Error Handling </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-56568"></A><ACLASS="indexterm"NAME="AUTOID-56571"></A>Wouldn't it be nice to know you had an error in your script beforeyou ran it?That's what the <EMCLASS="emphasis">-n</EM> flag is for: just check the syntax.This is especially good to make sure seldom taken segments of code are correct.Alas, the <EMCLASS="emphasis">csh</EM> implementation of this doesn't work.Consider this statement:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">exit (i)</PRE></BLOCKQUOTE></P><PCLASS="para">Of course, they really meant:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">exit (1)</PRE></BLOCKQUOTE></P><PCLASS="para">or just:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">exit 1</PRE></BLOCKQUOTE></P><PCLASS="para">Either shell will complain about this.But if you hide this in an <EMCLASS="emphasis">if</EM> clause, like so:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#!/bin/csh -fnif (1) then    exit (i)endif</PRE></BLOCKQUOTE></P><PCLASS="para">the C shell tells you there's nothing wrong with this script.The equivalentconstruct in the Bourne shell, on the other hand, tells you this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">#!/bin/sh -nif (1) then    exit (i)endif/tmp/x: syntax error at line 3: `(' unexpected</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="UPT-ART-393-SECT-1.8">47.2.8 Random Bugs </A></H3><PCLASS="para">Here's one:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">!%s%x%s</PRE></BLOCKQUOTE></P><PCLASS="para">Core dump, or garbage.</P><PCLASS="para">If you have an alias with backquotes (<CODECLASS="literal">``</CODE>), and use that in backquotes in another one, you get a core dump.</P><PCLASS="para">Try this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>repeat 3 echo &quot;/vmu*&quot;</B></CODE>/vmu*/vmunix/vmunix</PRE></BLOCKQUOTE></P><PCLASS="para">What???</P><PCLASS="para">While some vendors have fixed some of the <EMCLASS="emphasis">csh</EM>'s bugs (the<SPANCLASS="link"><EMCLASS="emphasis">tcsh</EM> (<ACLASS="linkend"HREF="ch08_03.htm"TITLE="Introduction to tcsh">8.3</A>)</SPAN>alsodoes much better here), most of its problems can never be solvedbecause they're a result of braindead design decisions.Do yourselfa favor, and if you have to write a shell script, do it in the Bourne shell.<ACLASS="indexterm"NAME="AUTOID-56608"></A><ACLASS="indexterm"NAME="AUTOID-56609"></A><ACLASS="indexterm"NAME="AUTOID-56610"></A><ACLASS="indexterm"NAME="AUTOID-56611"></A><ACLASS="indexterm"NAME="AUTOID-56612"></A></P></DIV><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">TC</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch47_01.htm"TITLE="47.1 Why Not? "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 47.1 Why Not? "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch47_03.htm"TITLE="47.3 Conditional Statements with if "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 47.3 Conditional Statements with if "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">47.1 Why Not? </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">47.3 Conditional Statements with if </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>