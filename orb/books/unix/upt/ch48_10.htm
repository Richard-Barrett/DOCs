<HTML><HEAD><TITLE>[Chapter 48] 48.10 Working with Names and Addresses </TITLE><METANAME="DC.title"CONTENT="UNIX Power Tools"><METANAME="DC.creator"CONTENT="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-10-23T15:55:35Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="1-56592-260-3"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch48_01.htm"TITLE="48. Office Automation"><LINKREL="prev"HREF="ch48_09.htm"TITLE="48.9 PostScript Calendars with pcal "><LINKREL="next"HREF="ch48_11.htm"TITLE="48.11 The index Database Program "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="UNIX Power Tools"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,58"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/psrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch48_09.htm"TITLE="48.9 PostScript Calendars with pcal "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 48.9 PostScript Calendars with pcal "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 48<BR>Office Automation</FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch48_11.htm"TITLE="48.11 The index Database Program "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 48.11 The index Database Program "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="UPT-ART-7780">48.10 Working with Names and Addresses </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="UPT-ART-7780-IX-ADDRESS-DATABASES-CREATED-USING-AWK"></A><ACLASS="indexterm"NAME="UPT-ART-7780-IX-DATABASES-CREATED-USING-AWK"></A><ACLASS="indexterm"NAME="UPT-ART-7780-IX-NAWK-UTILITY-DATABASES-CREATED-USING"></A>One of the simplest applications of<SPANCLASS="link"><EMCLASS="emphasis">awk</EM> (<ACLASS="linkend"HREF="ch33_11.htm"TITLE="Quick Reference: awk ">33.11</A>)</SPAN>is building a name and address database.It is a good exercisefor learning <EMCLASS="emphasis">awk</EM> as well. It involves organizingthe information as a record and then writing programsthat extract information from the records for displayin reports.The scripts in this article use<SPANCLASS="link"><EMCLASS="emphasis">nawk</EM> (<ACLASS="linkend"HREF="ch33_12.htm"TITLE="Versions of awk ">33.12</A>)</SPAN>instead of <EMCLASS="emphasis">awk</EM>, but the principles are the same.</P><PCLASS="para">The first thing to decide is the structure of a record.At the very least we'd like to have the following fields:</P><BLOCKQUOTECLASS="literallayout"><PCLASS="literallayout">Name<BR>Street<BR>City<BR>State<BR>Zip</P></BLOCKQUOTE><PCLASS="para">But we may wish to have a more complex record structure:</P><BLOCKQUOTECLASS="literallayout"><PCLASS="literallayout">Name<BR>Title<BR>Company<BR>Division<BR>Street<BR>City<BR>State<BR>Zip<BR>Phone<BR>Fax<BR>Email<BR>Directory<BR>Comments</P></BLOCKQUOTE><PCLASS="para">It doesn't matter to our programming effort whether therecord has five fields or thirteen. It does matter thatthe structure is decided upon before you begin programming. </P><PCLASS="para">The next decision we must make is how to distinguishone field from the next and how to distinguish one recordfrom another. If your records are short, you could haveone record per line and use an oddball character as a fielddelimiter:</P><PCLASS="para"><BLOCKQUOTECLASS="literallayout"><PCLASS="literallayout">Name~Street~City~State~Zip<BR>Name1~Street1~City1~State1~Zip1</P></BLOCKQUOTE></P><PCLASS="para">The downside of this solution is that it can be difficultto edit the records. (We are going to try to avoid writingprograms for automating data entry. Instead, we will assumethat you create the record with a text editor-<EMCLASS="emphasis">vi</EM> or Emacs,for example.)</P><PCLASS="para">Another solution is to put each field on a line by itselfand separate the records with a blank line: </P><BLOCKQUOTECLASS="literallayout"><PCLASS="literallayout">Name<BR>Street<BR>City<BR>State<BR>Zip<BR><BR>Name1<BR>Street1<BR>City1<BR>State1<BR>Zip1</P></BLOCKQUOTE><PCLASS="para">This is a good solution. You have to be careful that thedata does not itself contain blank lines. For instance,if you wanted to add a field for Company name, and notall records have a value for Company, then you must usea placeholder character to indicate an empty value.</P><PCLASS="para">Another solution is to put each record in its own file and put each field on its own line. This is the record organizationwe will implement for our program. Two advantagesof it are that it permits variable length records and it doesnot require the use of special delimiter characters. Itis therefore pretty easy to create or edit a record. It isalso very easy to select a subset of records for processing.</P><PCLASS="para">We will give each file a name that uniquely identifies it in the current directory.A list of records is the same as a list of files.Here is a sample record in a file named <EMCLASS="emphasis">pmui</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Peter MuiInternational Sales ManagerO'Reilly &amp; Associates, Inc.East Coast Division90 Sherman StreetCambridgeMA01240617-354-5800617-661-1116peter@ora.com/home/peterAny number of lines may appear as a comment.</PRE></BLOCKQUOTE></P><PCLASS="para">In this record, there are thirteen fields, any of which can be blank (butthe blank line must be there to save the position), and thelast field can have as many lines as needed. </P><PCLASS="para">Our record does not contain labels that identify what eachfield contains. While we could put that information inthe record itself, it is better to maintain the labels separatelyso they can be changed in a single location.(You can create a record template thatcontains the labelsto help you identify fields when adding a new record.)</P><PCLASS="para">We have put the labels for these fields in a separatefile named <EMCLASS="emphasis">dict</EM>. We won't show this file because its contents describe the record structure as shown above.</P><PCLASS="para">We are going to have three programs and they share the samesyntax:</P><BLOCKQUOTECLASS="literallayout"><PCLASS="literallayout"><CODECLASS="replaceable"><I>command record-list</I></CODE></P></BLOCKQUOTE><PCLASS="para">The <CODECLASS="replaceable"><I>record-list</I></CODE> is a list of one or more filenames. Youcan use wildcard characters, of course, on the command line tospecify multiple records.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-58251"></A>The first program, <EMCLASS="emphasis">read.base</EM>,reads the <EMCLASS="emphasis">dict</EM> fileto get the labels and outputs a formatted record.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>read.base record</B></CODE>pmui:1.  Name:   Peter Mui2.  Title:   International Sales Manager3.  Company:   O'Reilly &amp; Associates, Inc.4.  Division:   East Coast Division5.  Street:   90 Sherman Street6.  City:   Cambridge7.  State:   MA8.  Zip:   012409.  Phone:   617-354-580010. Fax:   617-661-111611. Email:   peter@ora.com12. Directory:   /home/peter13. Comments:   Any number of lines may appear as a comment.</PRE></BLOCKQUOTE></P><PCLASS="para"><EMCLASS="emphasis">read.base</EM> first outputs the record name and thenlists each field.Let's look at <EMCLASS="emphasis">read.base</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">nawk 'BEGIN { FS=&quot;:&quot;    # test to see that at least one record was specified    if (ARGC &lt; 2) {        print &quot;Please supply record list on command line&quot;        exit     }    # name of local file containing field labels:    record_template = &quot;dict&quot;    # loop to read the record_template    # field_inc = the number of fields      # fields[] = an array of labels indexed by position    field_inc=0    while ((getline &lt; record_template) &gt; 0) {        ++field_inc        fields[field_inc] = $1    }    field_tot=field_inc}# Now we are reading the records# Print filename for each new recordFNR == 1 {     field_inc=0    print &quot;\n&quot; FILENAME &quot;:&quot;}{     # Print the field's position, label and value      # The last field can have any number of lines without a label.    if (++field_inc &lt;= field_tot){        if (field_inc &gt;= 10)            space = &quot;. &quot;        else            space = &quot;.  &quot;        print field_inc space fields[field_inc] &quot;:\t&quot; $NF }else    print $NF }' $*</PRE></BLOCKQUOTE></P><PCLASS="para">Note that the program is notdoing any input validation. If the record is missinga Division name (and you didn't leave the fourth lineblank), whatever is on line&nbsp;4 will match up with Division,even if it's really a street address.One of the uses of <EMCLASS="emphasis">read.base</EM> is simply to verifythat what you entered in the file is correct.</P><PCLASS="para">If you specify more than one record, then you willget all of those records output in the order thatyou specified them on the command line.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-58267"></A>The second program is <EMCLASS="emphasis">mail.base</EM>.It extractsmailing label information.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>mail.base pmui</B></CODE>Peter MuiInternational Sales ManagerO'Reilly &amp; Associates, Inc.East Coast Division90 Sherman StreetCambridge, MA 01240</PRE></BLOCKQUOTE></P><PCLASS="para">If you supply a <EMCLASS="emphasis">record-list</EM>, then you will get a listof mailing labels. </P><PCLASS="para">Here is the <EMCLASS="emphasis">mail.base</EM> program:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">nawk 'BEGIN { FS=&quot;\n&quot;;     # test that user supplies a record    if (ARGC &lt; 2) {        print &quot;Please supply record list on command line&quot;        exit     }}# ignore blank lines/^$/ { next }# this is hard-coded to record format;# print first 5 fields and then print# city, state zip on one line.{     if (FNR &lt; 6)        print $0     else        if (FNR == 6)            printf $0 &quot;, &quot;        else if (FNR == 7)            printf $0        else if (FNR == 8)            printf &quot; &quot; $0 &quot;\n\n&quot;}' $*</PRE></BLOCKQUOTE></P><PCLASS="para">Variations on this very simple program can be written to extract or compile other pieces of information. You could also outputformatting codes used when printing the labels.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-58281"></A>The last program is <EMCLASS="emphasis">list.base</EM>.It prepares a tabularlist of names and records and allows you to select aparticular record.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">% <CODECLASS="userinput"><B>list.base lwalsh pmui jberlin</B></CODE>  # NAME &amp; COMPANY                           FILE            1. Linda Walsh, O'Reilly &amp; Associates, Inc. lwalsh          2. Peter Mui, O'Reilly &amp; Associates, Inc.   pmui         3. Jill Berlin, O'Reilly &amp; Associates, Inc. jberlin        Select a record by number: 2</PRE></BLOCKQUOTE></P><PCLASS="para">When you select the record number, thatrecord is displayed by using <EMCLASS="emphasis">read.base</EM>. I have not built in anypaging capability, so the list will scroll continuouslyrather than pause after 24 lines or so as it might.</P><PCLASS="para">Here is the <EMCLASS="emphasis">list.base</EM> program:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">nawk 'BEGIN {     # Do everything as BEGIN procedure    # test that user supplied record-list    if (ARGC &lt; 2) {        print &quot;Please supply record list on command line&quot;        exit     }    # Define report format string in one place.    FMTSTR = &quot;%3s %-40s %-15s\n&quot;    # print report header    printf(FMTSTR, &quot;#&quot;,&quot;NAME &amp; COMPANY&quot;, &quot;FILE&quot;)     # For each record, get Name, Title and Company and print it.    inc=0    for (x=1; x &lt; ARGC; x++){        getline NAME &lt; ARGV[x]        getline TITLE &lt; ARGV[x]        getline COMPANY &lt; ARGV[x]        record_list[x] = ARGV[x]        printf(FMTSTR, ++inc &quot;.&quot;, NAME &quot;, &quot;  COMPANY, ARGV[x])     }    # Prompt user to select a record by number    printf &quot;Select a record by number:&quot;    getline answer &lt; &quot;-&quot;    # Call read.base program to display the selected record    system(&quot;read.base &quot; record_list[answer])}' $*</PRE></BLOCKQUOTE></P><PCLASS="para">&#13;Different versions of this program can be written to examineindividual pieces of information across a set of records.</P><PCLASS="para">Article<ACLASS="xref"HREF="ch45_22.htm"TITLE="Handling Files Line-by-Line ">45.22</A>shows how to write a shell script that creates a prompt-driven frontend to collect names and addresses.(It needs to be modified to put out a blank line for empty fieldsand not to write the labels into the file.)<ACLASS="indexterm"NAME="AUTOID-58296"></A><ACLASS="indexterm"NAME="AUTOID-58297"></A><ACLASS="indexterm"NAME="AUTOID-58298"></A></P><DIVCLASS="sect1info"><PCLASS="SECT1INFO">- <SPANCLASS="authorinitials">DD</SPAN></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch48_09.htm"TITLE="48.9 PostScript Calendars with pcal "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 48.9 PostScript Calendars with pcal "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="UNIX Power Tools"><IMGSRC="../gifs/txthome.gif"ALT="UNIX Power Tools"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch48_11.htm"TITLE="48.11 The index Database Program "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 48.11 The index Database Program "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">48.9 PostScript Calendars with pcal </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_0.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">48.11 The index Database Program </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="../vi/index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>