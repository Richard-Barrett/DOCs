<HTML><HEAD><TITLE>[Chapter 6] 6.3 Pattern-matching Rules </TITLE><METANAME="DC.title"CONTENT="Learning the vi Editor"><METANAME="DC.creator"CONTENT="Linda Lamb"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T20:52:05Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="0-937175-67-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch06_01.htm"TITLE="6. Global Replacement "><LINKREL="prev"HREF="ch06_02.htm"TITLE="6.2 Context-sensitive Replacement "><LINKREL="next"HREF="ch06_04.htm"TITLE="6.4 Pattern-matching Examples "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the vi Editor"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/vsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Context-sensitive Replacement "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.2 Context-sensitive Replacement "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 6<BR>Global Replacement </FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_04.htm"TITLE="6.4 Pattern-matching Examples "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.4 Pattern-matching Examples "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="VI6-CH-6-SECT-3">6.3 Pattern-matching Rules </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-EX-PATTERN-MATCHING"></A><ACLASS="indexterm"NAME="VI6-CH-6-IX-SRCH-PATTERN-MATCH"></A><ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-PATT-MATCH"></A>In making global replacements, UNIX editors such as <EMCLASS="emphasis">vi</EM> allow you to search not just for fixed strings of characters, but also for variable patterns of words, referred to as <EMCLASS="emphasis">regularexpressions</EM>.</P><PCLASS="para">When you specify a literal string of characters, the searchmight turn up other occurrences that you didn't want to match.The problem with searching for words in a file is that a wordcan be used in different ways.  Regular expressions help you conduct a search for words in context.Note that regular expressions can be used with the <EMCLASS="emphasis">vi</EM> searchcommands <CODECLASS="literal">/</CODE> and <CODECLASS="literal">?</CODE> as well as in the <EMCLASS="emphasis">ex</EM> <CODECLASS="literal">:g</CODE>and <CODECLASS="literal">:s</CODE> commands.  For the most part, the same regularexpressions work with other UNIX programs such as <CODECLASS="literal">grep</CODE>,<CODECLASS="literal">sed</CODE>, and <CODECLASS="literal">awk</CODE>.</P><PCLASS="para">Regular expressions are made up by combining normal characters with a numberof special characters called <EMCLASS="emphasis">metacharacters</EM>.  The meta\%characters and their uses are listed below.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-6-SECT-3.1">6.3.1 Metacharacters Used in Search Patterns </A></H3><PCLASS="para"></P><DLCLASS="variablelist"><DTCLASS="term"><CODECLASS="literal">.</CODE></DT><DDCLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-METACHS-SRCH-PATTERNS"></A><ACLASS="indexterm"NAME="VI6-CH-6-IX-REGEX-SEARCH-PATTERNS"></A><ACLASS="indexterm"NAME="AUTOID-5640"></A>Matches any <EMCLASS="emphasis">single</EM> character except a newline (carriagereturn).Remember that spaces are treated as characters.For example, <CODECLASS="literal">p.p</CODE> matches character strings such as <EMCLASS="emphasis">pep</EM>, <EMCLASS="emphasis">pip</EM>, <EMCLASS="emphasis">pcp</EM>.</P></DD><DTCLASS="term"><CODECLASS="literal">*</CODE></DT><DDCLASS="listitem"><PCLASS="para">Matches any number (or none) of the single character that immediately precedes it.  For example, <CODECLASS="literal">bugs*</CODE> willmatch <EMCLASS="emphasis">bugs</EM> (one <EMCLASS="emphasis">s</EM>) or <EMCLASS="emphasis">bug</EM> (no <EMCLASS="emphasis">s</EM>'s).</P><PCLASS="para">The character preceding the * can be one that isspecified by a regular expression.For example, since .  (dot) means any character, <CODECLASS="literal">.*</CODE> means &quot;match any number of any character.&quot;  </P><PCLASS="para">Here's a specificexample of this.  The command <CODECLASS="literal">:s/End.*/End/</CODE> removesall characters after <EMCLASS="emphasis">End</EM> (it replaces the remainder of theline with nothing).</P></DD><DTCLASS="term"><CODECLASS="literal">^</CODE></DT><DDCLASS="listitem"><PCLASS="para">Requires that the following regular expression be found at the beginning ofthe line; for example, <CODECLASS="literal">^Part</CODE> matches<EMCLASS="emphasis">Part</EM> when it occurs at the beginning of a line, and <CODECLASS="literal">^...</CODE>matches the first three characters of a line.</P></DD><DTCLASS="term"><CODECLASS="literal">$</CODE></DT><DDCLASS="listitem"><PCLASS="para">Requires that the preceding regular expression be found at the end of the line; for example, <CODECLASS="literal">here:$</CODE>.</P></DD><DTCLASS="term"><CODECLASS="literal">\</CODE></DT><DDCLASS="listitem"><PCLASS="para">Treats the following special character as an ordinary character.  For example,<CODECLASS="literal">\.</CODE> matches an actual period instead of &quot;any singlecharacter,&quot; and <CODECLASS="literal">\*</CODE> matches an actual asterisk instead of&quot;any number of a character.&quot;  The \ (backslash)prevents the interpretation of a special character.This prevention is called &quot;escaping the character.&quot;</P></DD><DTCLASS="term"><CODECLASS="literal">[  ]</CODE></DT><DDCLASS="listitem"><PCLASS="para">Matches any <EMCLASS="emphasis">one</EM> of the characters enclosed between the brackets.For example, <CODECLASS="literal">[AB]</CODE> matches either <EMCLASS="emphasis">A</EM> or <EMCLASS="emphasis">B</EM>, and <CODECLASS="literal">p[aeiou]t</CODE> matches <EMCLASS="emphasis">pat</EM>, <EMCLASS="emphasis">pet</EM>, <EMCLASS="emphasis">pit</EM>, <EMCLASS="emphasis">pot</EM>, or <EMCLASS="emphasis">put</EM>.  A range of consecutive characters can be specified by separating the first and last characters in the range with a hyphen.  For example, <CODECLASS="literal">[A-Z]</CODE> will match any uppercaseletter from <EMCLASS="emphasis">A</EM> to <EMCLASS="emphasis">Z</EM>, and <CODECLASS="literal">[0-9]</CODE> will match any digit from <EMCLASS="emphasis">0</EM> to <EMCLASS="emphasis">9</EM>.  </P><PCLASS="para">You can include more than onerange inside brackets, and you can specify a mix of ranges andseparate characters.  For example, [<CODECLASS="literal">:;A-Za-z()</CODE>]will match four different punctuation marks, plus all letters.</P><PCLASS="para">Most metacharacters lose their special meaning inside brackets,so you don't need to escape them if you want to use them asordinary characters.  Within brackets, the three metacharacters you still need to escapeare <CODECLASS="literal">\</CODE> <CODECLASS="literal">-</CODE> <CODECLASS="literal">]</CODE>.  (The hyphen (<CODECLASS="literal">-</CODE>)acquires meaning as a range specifier; to use an actual hyphen, you can also place it as the the first character inside thebrackets.)</P><PCLASS="para">A caret (<CODECLASS="literal">^</CODE>) has special meaning only when it is thefirst character inside the brackets, but in this case the meaningdiffers from that of the normal <CODECLASS="literal">^</CODE> metacharacter.  As the first character within brackets, a <CODECLASS="literal">^</CODE> reverses their sense:  the bracketswill match any one character <EMCLASS="emphasis">not</EM> in the list.  For example,<CODECLASS="literal">[^a-z]</CODE> matches any character that is not a lowercase letter.&#13;</P></DD><DTCLASS="term">\(&nbsp;&nbsp;\)</DT><DDCLASS="listitem"><PCLASS="para">Saves the pattern enclosed between <CODECLASS="literal">\(</CODE> and <CODECLASS="literal">\)</CODE> into a special holding space or &quot;hold buffer.&quot;Up to nine patterns can be saved in this way on a single line.For example, the pattern:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">\(That\) or \(this\)</PRE></BLOCKQUOTE></P><PCLASS="para">saves <EMCLASS="emphasis">That</EM> in hold buffer number 1 and saves <EMCLASS="emphasis">this</EM> in hold buffer number 2.The patterns held can be &quot;replayed&quot; in substitutions by the sequences <CODECLASS="literal">\1</CODE> to <CODECLASS="literal">\9</CODE>.  For example, to rephrase <EMCLASS="emphasis">That or this</EM> to read<EMCLASS="emphasis">this or That</EM>, you could enter:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/\(That\) or \(this\)/\2 or \1/</PRE></BLOCKQUOTE></P><PCLASS="para"></P></DD><DTCLASS="term"><CODECLASS="literal">\&lt;&nbsp;&nbsp;\&gt;</CODE></DT><DDCLASS="listitem"><PCLASS="para">Matches characters at the beginning (<CODECLASS="literal">\&lt;</CODE>) or at the end(<CODECLASS="literal">\&gt;</CODE>) of a word.  The end or beginning of aword is determined either by a punctuation mark or by a space.For example, the expression <CODECLASS="literal">\&lt;ac</CODE> will match only wordsthat begin with <EMCLASS="emphasis">ac</EM>, such as <EMCLASS="emphasis">action</EM>. The expression <CODECLASS="literal">ac\&gt;</CODE> will match only wordsthat end with <EMCLASS="emphasis">ac</EM>, such as <EMCLASS="emphasis">maniac</EM>.Neither expression will match <EMCLASS="emphasis">react</EM>.  </P></DD><DTCLASS="term"><CODECLASS="literal">~</CODE></DT><DDCLASS="listitem"><PCLASS="para">Matches whatever regular expression was used in the <EMCLASS="emphasis">last</EM> search.  For example, if you searched for <EMCLASS="emphasis">The</EM>, you could search for <EMCLASS="emphasis">Then</EM> with <CODECLASS="literal">/~n</CODE>.  Note that you can use this pattern only in a regular search(with <CODECLASS="literal">/</CODE>).  It won't work as the pattern in a substitute command.  It does,however, have a similar meaning in the replacement portion of a substitute command.</P></DD></DL><ACLASS="indexterm"NAME="AUTOID-5760"></A><ACLASS="indexterm"NAME="AUTOID-5761"></A></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-6-SECT-3.2">6.3.2 Metacharacters Used in Replacement Strings </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-METACHS-REPL-STRINGS"></A><ACLASS="indexterm"NAME="VI6-CH-6-IX-REGEX-RPL-STRINGS"></A>When you make global replacements, the regular expressions above carry their special meaning only within the search portion (the first part) of the command.  For example, when you type this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/1\.  Start/2.  Next, start with $100/</PRE></BLOCKQUOTE></P><PCLASS="para">note that the replacement stringunderstands the characters <CODECLASS="literal">.</CODE> and <CODECLASS="literal">$</CODE>, without yourhaving to escape them.By the same token, let's say you enter:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/[ABC]/[abc]/g</PRE></BLOCKQUOTE></P><PCLASS="para">If you're hoping to replace <EMCLASS="emphasis">A</EM> with <EMCLASS="emphasis">a</EM>, <EMCLASS="emphasis">B</EM> with <EMCLASS="emphasis">b</EM>, and <EMCLASS="emphasis">C</EM> with <EMCLASS="emphasis">c</EM>,you're in for a surprise.  Since brackets behave likeordinary characters in a replacement string, this commandwill change every occurrence of <EMCLASS="emphasis">A</EM>, <EMCLASS="emphasis">B</EM>, or <EMCLASS="emphasis">C</EM> to the five-character string <EMCLASS="emphasis">[abc]</EM>.  </P><PCLASS="para">To solve problems like this, you need a way to specify variablereplacement strings.  Fortunately, there are additional regularexpressions that have special meaning in a <EMCLASS="emphasis">replacement</EM> string.</P><DLCLASS="variablelist"><DTCLASS="term"><EMCLASS="emphasis">\n</EM></DT><DDCLASS="listitem"><PCLASS="para">Matches the <EMCLASS="emphasis">n</EM>th pattern previously saved by \( and \), where<EMCLASS="emphasis">n</EM> is a number from 1 to 9, and previously saved patterns are countedfrom the left on the line.  See the explanation for\( and \) in the previous section.</P></DD><DTCLASS="term"><CODECLASS="literal">\</CODE></DT><DDCLASS="listitem"><PCLASS="para">Treats the following special character as an ordinary character.  Backslashes are metacharacters in replacement stringsas well as in search patterns.To specify a real backslash, type two in a row (\\).</P></DD><DTCLASS="term"><CODECLASS="literal">&amp;</CODE></DT><DDCLASS="listitem"><PCLASS="para">Prints the entire search pattern when used in a replacementstring.  This is useful when you want to avoid retyping text:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/Yazstremski/&amp;, Carl/</PRE></BLOCKQUOTE></P><PCLASS="para">The replacement will say <EMCLASS="emphasis">Yazstremski, Carl</EM>.  The <CODECLASS="literal">&amp;</CODE> can also replace a variable pattern (as specified by a regular expression).  For example, to surround each line from 1 to 10 withparentheses, type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:1,10s/.*/(&amp;)/</PRE></BLOCKQUOTE></P><PCLASS="para">The search pattern matches the whole line, and the <CODECLASS="literal">&amp;</CODE> &quot;replays&quot; the line, followed by your text.</P></DD><DTCLASS="term"><CODECLASS="literal">~</CODE></DT><DDCLASS="listitem"><PCLASS="para">Has a similar meaning as when it is used in a search pattern;  the string found is replaced with the replacementtext specified in the last substitute command.  This is useful for repeating an edit.  For example, you could say <CODECLASS="literal">:s/thier/their/</CODE> on one line and repeat the change on another with  <CODECLASS="literal">:s/thier/~/</CODE>.The search pattern doesn't need to be the same, though.  Forexample, you could say <CODECLASS="literal">:s/his/their/</CODE> onone line and repeat the replacement on another with<CODECLASS="literal">:s/her/~/</CODE>.</P></DD><DTCLASS="term"><CODECLASS="literal">\u</CODE>&nbsp;or&nbsp;<CODECLASS="literal">\l</CODE></DT><DDCLASS="listitem"><PCLASS="para">Causes the next character in the replacement string to be changed to uppercase or lowercase, respectively.  For example, to change<EMCLASS="emphasis">yes, doctor</EM> into <EMCLASS="emphasis">Yes, Doctor</EM>, you could say:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/yes, doctor/\uyes, \udoctor/</PRE></BLOCKQUOTE></P><PCLASS="para">This is a pointless example, though, since it's easierjust to type the replacement string with initial caps in thefirst place.  As with any regular expression, <CODECLASS="literal">\u</CODE> and <CODECLASS="literal">\l</CODE> are most useful with a variable string.  Take, forexample, the command we used earlier:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/\(That\) or \(this\)/\2 or \1/</PRE></BLOCKQUOTE></P><PCLASS="para">The result is <EMCLASS="emphasis">this or That</EM>, but we need to adjust thecases.  We'll use <CODECLASS="literal">\u</CODE> to uppercase the first letter in <EMCLASS="emphasis">this</EM> (currently saved in hold buffer 2); we'll use <CODECLASS="literal">\l</CODE> to lowercase the first letter in <EMCLASS="emphasis">That</EM> (currently saved in hold buffer 1):</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:s/\(That\) or \(this\)/\u\2 or \l\1/</PRE></BLOCKQUOTE></P><PCLASS="para">The result is <EMCLASS="emphasis">This or that</EM>.  (Don't confuse the number onewith the lowercase <CODECLASS="literal">l</CODE>; the one comes after.)</P></DD><DTCLASS="term"><CODECLASS="literal">\U</CODE>&nbsp;or&nbsp;<CODECLASS="literal">\L</CODE></DT><DDCLASS="listitem"><PCLASS="para">Similar to <CODECLASS="literal">\u</CODE> or <CODECLASS="literal">\l</CODE>, but all following characters areconverted to uppercase or lowercase until the end of thereplacement string or until <CODECLASS="literal">\e</CODE> or <CODECLASS="literal">\E</CODE> is reached.If there is no <CODECLASS="literal">\e</CODE> or <CODECLASS="literal">\E</CODE>, all characters of thereplacement text are affected by the <CODECLASS="literal">\U</CODE> or <CODECLASS="literal">\L</CODE>.For example, to uppercase <EMCLASS="emphasis">Fortran</EM>, you could say:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/Fortran/\UFortran/</PRE></BLOCKQUOTE></P><PCLASS="para">or, using the <CODECLASS="literal">&amp;</CODE> character to repeat the search string:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/Fortran/\U&amp;/</PRE></BLOCKQUOTE></P><PCLASS="para"></P></DD></DL><PCLASS="para">All pattern searches are case-sensitive.  That is, a search for <EMCLASS="emphasis">the</EM> will not find <EMCLASS="emphasis">The</EM>.  You can get around this by specifying both uppercase and lowercase in the pattern:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="literal">/[Tt]he</CODE></PRE></BLOCKQUOTE></P><PCLASS="para">You can also instruct <EMCLASS="emphasis">vi</EM> to ignore case by typing <CODECLASS="literal">:set</CODE> <CODECLASS="literal">ic</CODE>.  See <ACLASS="xref"HREF="ch07_01.htm"TITLE="Advanced Editing ">Chapter 7, Advanced Editing </A>, for additional details.<ACLASS="indexterm"NAME="AUTOID-5886"></A><ACLASS="indexterm"NAME="AUTOID-5889"></A><ACLASS="indexterm"NAME="AUTOID-5892"></A><ACLASS="indexterm"NAME="AUTOID-5895"></A><ACLASS="indexterm"NAME="AUTOID-5896"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_02.htm"TITLE="6.2 Context-sensitive Replacement "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.2 Context-sensitive Replacement "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the vi Editor"><IMGSRC="../gifs/txthome.gif"ALT="Learning the vi Editor"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_04.htm"TITLE="6.4 Pattern-matching Examples "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 6.4 Pattern-matching Examples "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">6.2 Context-sensitive Replacement </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_a.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">6.4 Pattern-matching Examples </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>