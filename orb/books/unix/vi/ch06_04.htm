<HTML><HEAD><TITLE>[Chapter 6] 6.4 Pattern-matching Examples </TITLE><METANAME="DC.title"CONTENT="Learning the vi Editor"><METANAME="DC.creator"CONTENT="Linda Lamb"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T20:52:24Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="0-937175-67-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch06_01.htm"TITLE="6. Global Replacement "><LINKREL="prev"HREF="ch06_03.htm"TITLE="6.3 Pattern-matching Rules "><LINKREL="next"HREF="ch07_01.htm"TITLE="7. Advanced Editing "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the vi Editor"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/vsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_03.htm"TITLE="6.3 Pattern-matching Rules "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.3 Pattern-matching Rules "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 6<BR>Global Replacement </FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch07_01.htm"TITLE="7. Advanced Editing "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7. Advanced Editing "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="VI6-CH-6-SECT-4">6.4 Pattern-matching Examples </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-WHOLE-WORD"></A>Unless you are already familiar with regular expressions,the discussion of special characters above probably looks forbiddinglycomplex.  A few more examples should make things clearer.  In the examples that follow, a square (<IMGSRC="../chars/squ.gif"ALT=" ">)is used to mark a blank space;  it is not a special character.</P><PCLASS="para">Let's work through how you might use some special characters in a replacement.Suppose that you have a long file and that you want to substitute the word <EMCLASS="emphasis">child</EM> with the word <EMCLASS="emphasis">children</EM> throughout that file.  You first save the edited buffer with <CODECLASS="literal">:w</CODE>, thentry the global replacement:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/child/children/g</PRE></BLOCKQUOTE></P><PCLASS="para">When you continue editing, you notice occurrences of wordssuch as <EMCLASS="emphasis">childrenish</EM>.  You have unintentionally matched the word <EMCLASS="emphasis">childish</EM>.Returning to the last saved buffer with<CODECLASS="literal">:e!</CODE>, you now try:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/child<IMGSRC="../chars/squ.gif"ALT=" ">/children<IMGSRC="../chars/squ.gif"ALT=" ">/g</PRE></BLOCKQUOTE></P><PCLASS="para">(Note that there is a space after <EMCLASS="emphasis">child</EM>.)But this command missesthe occurrences <EMCLASS="emphasis">child.</EM>, <EMCLASS="emphasis">child,</EM>, <EMCLASS="emphasis">child:</EM> and so on.  After some thought, you remember that bracketsallow you to specify one character from among a list, soyou come upon the solution:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/child[<IMGSRC="../chars/squ.gif"ALT=" ">,.;:!?]/children[<IMGSRC="../chars/squ.gif"ALT=" ">,.;:!?]/g</PRE></BLOCKQUOTE></P><PCLASS="para">This searches for <EMCLASS="emphasis">child</EM> followed by either aspace (indicated by <IMGSRC="../chars/squ.gif"ALT=" ">) or any one of the punctuation characters <CODECLASS="literal">,.;:!?</CODE>.   You expect toreplace this with <EMCLASS="emphasis">children</EM> followed by the correspondingspace or punctuation mark,but you've ended up witha bunch of punctuation marks after every occurrence of <EMCLASS="emphasis">children</EM>.You need to save thespace and punctuation marks inside a <CODECLASS="literal">\(</CODE> and <CODECLASS="literal">\)</CODE>.  Then you can &quot;replay&quot;them with a <CODECLASS="literal">\1</CODE>.  Here's the next attempt:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/child\([<IMGSRC="../chars/squ.gif"ALT=" ">,.;:!?]\)/children\1/g</PRE></BLOCKQUOTE></P><PCLASS="para">When the search matches a character inside the <CODECLASS="literal">\(</CODE> and <CODECLASS="literal">\)</CODE>,the <CODECLASS="literal">\1</CODE> on the right-hand side restores the same character.The syntax may seem awfully complicated, but this command sequence can save you a lot of work! <EMCLASS="emphasis">Any time you spend learning regular expression syntax will be repaid a thousandfold!</EM></P><PCLASS="para">The command is still not perfect, though.  You've noticedthat occurrences of <EMCLASS="emphasis">Fairchild</EM> have been changed,so you need a way to match <EMCLASS="emphasis">child</EM> when it isn't part of anotherword.</P><PCLASS="para">As it turns out, <EMCLASS="emphasis">vi</EM> (but not all other programs that use regular expressions) has a special syntax for saying &quot;only if the pattern is a complete word.&quot;  The character sequence <CODECLASS="literal">\&lt;</CODE> requires the patternto match at the beginning of a word, whereas <CODECLASS="literal">\&gt;</CODE> requires thepattern to match at the end of a word.  Using both will restrictthe match to a whole word.  So, in the task given above,<CODECLASS="literal">\&lt;child\&gt;</CODE> will find all instances of the word <EMCLASS="emphasis">child</EM>,whether followed by punctuation or spaces.Here's the substitution command you should use:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/\&lt;child\&gt;/children/g</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-5949"></A></P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-6-SECT-4.1">6.4.1 Search for General Class of Words </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-SRCH-CLASS-OF-WORDS"></A><ACLASS="indexterm"NAME="VI6-CH-6-IX-EX-SEARCH-CLASS-WORDS"></A><ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-CLASS-WORDS"></A>Suppose you have subroutine names beginning with the prefixes:  <EMCLASS="emphasis">mgi</EM>, <EMCLASS="emphasis">mgr</EM> and <EMCLASS="emphasis">mga</EM>.  <TABLECLASS="informaltable"><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">mgibox routine,mgrbox routine,mgabox routine,</PRE></BLOCKQUOTE></TD></TR></TBODY></TABLE></P><PCLASS="para">If you want to save the prefixes but want to change the name <EMCLASS="emphasis">box</EM> to<EMCLASS="emphasis">square</EM>, either of the following replacement commands will do the trick.  The first example illustrates how <CODECLASS="literal">\(</CODE> and <CODECLASS="literal">\)</CODE> can be used to save whatever pattern was actually matched.  The second example shows how you can search for one pattern but change another.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="literal">:g/mg\([ira]\)box/s//mg\1square/g</CODE></PRE></BLOCKQUOTE></P><PCLASS="para"><TABLECLASS="informaltable"><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">mgisquare routine,mgrsquare routine,mgasquare routine,</PRE></BLOCKQUOTE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">The global replacement keeps track of whether an <EMCLASS="emphasis">i</EM>,<EMCLASS="emphasis">r</EM> or <EMCLASS="emphasis">a</EM> is saved.  In that way,<EMCLASS="emphasis">box</EM> is changed to <EMCLASS="emphasis">square</EM> only when <EMCLASS="emphasis">box</EM> is part of theroutine's name.</P></TD></TR></TBODY></TABLE></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><CODECLASS="literal">:g/mg[ira]box/s/box/square/g</CODE></PRE></BLOCKQUOTE></P><PCLASS="para"><TABLECLASS="informaltable"><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">mgisquare routine,mgrsquare routine,mgasquare routine,</PRE></BLOCKQUOTE></TD></TR><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><PCLASS="para">Has the same effect as the previous command, but it is a little less safesince it could change other instances of <EMCLASS="emphasis">box</EM> on the sameline, not just those within the routine names.</P></TD></TR></TBODY></TABLE><ACLASS="indexterm"NAME="AUTOID-6020"></A><ACLASS="indexterm"NAME="AUTOID-6021"></A><ACLASS="indexterm"NAME="AUTOID-6022"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-6-SECT-4.2">6.4.2 Block Move by Patterns </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6026"></A><ACLASS="indexterm"NAME="AUTOID-6029"></A><ACLASS="indexterm"NAME="AUTOID-6032"></A><ACLASS="indexterm"NAME="AUTOID-6035"></A><ACLASS="indexterm"NAME="AUTOID-6038"></A>You can also move blocks of text delimited by patterns.  For example, assume you have a 150-page reference manual.  All references pages are organized into three paragraphs withthe same three headings:  SYNTAX, DESCRIPTION, and PARAMETERS.  A sample of one reference page follows:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">.Rh 0 &quot;Get status of named file&quot; &quot;STAT&quot;.Rh &quot;SYNTAX&quot;.nfinteger*4 stat, retvalinteger*4 status(11)character*123 filename...retval = stat (filename, status).fi.Rh &quot;DESCRIPTION&quot;Writes the fields of a system data structure into thestatus array.  These fields contain (among otherthings) information about the file's location, accessprivileges, owner, and time of last modification..Rh &quot;PARAMETERS&quot;.IP &quot;\fBfilename\fR&quot; 15nA character string variable or constant containingthe UNIX pathname for the file whose status you wantto retrieve.  You can give the ...</PRE></BLOCKQUOTE></P><PCLASS="para">Suppose that it is decided to move DESCRIPTION above the SYNTAXparagraph.  With pattern matching, you can move blocks of text on all 150 pageswith one command!</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g /SYNTAX/,/DESCRIPTION/-1 mo /PARAMETERS/-1</PRE></BLOCKQUOTE></P><PCLASS="para">This command operates on the block oftext between the line containing the word <EMCLASS="emphasis">SYNTAX</EM> and the line justbefore the word <EMCLASS="emphasis">DESCRIPTION</EM> (<CODECLASS="literal">/DESCRIPTION/-1</CODE>).The block is moved (using <CODECLASS="literal">mo</CODE>)to the line just before <EMCLASS="emphasis">PARAMETERS</EM>(<CODECLASS="literal">/PARAMETERS/-1</CODE>).  Note that <EMCLASS="emphasis">ex</EM> can place text only below the line specified.To tell <EMCLASS="emphasis">ex</EM> to place text above a line, you first have to move up a line with <CODECLASS="literal">-1</CODE>, and then place your text below.In a case like this, one command saves literally hours of work.  (This is a real-life example&nbsp;- we once used a pattern match like thisto rearrange a reference manual containing hundreds of pages.)</P><PCLASS="para">Block definition by patterns can be used equally well with other <EMCLASS="emphasis">ex</EM> commands.  For example, if you wanted to delete all DESCRIPTION paragraphs inthe reference chapter, you could enter:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/DESCRIPTION/,/PARAMETERS/-1d</PRE></BLOCKQUOTE></P><PCLASS="para">This very powerful kind of change is implicit in <EMCLASS="emphasis">ex's</EM> lineaddressing syntax, but it is not readily apparent even to experiencedusers.  For this reason,whenever you are faced with a complex, repetitive editing task, takethe time to analyze the problemand find out if you can applypattern-matching tools to get the job done.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-6-SECT-4.3">6.4.3 More Examples </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6065"></A>Since the best way to learn pattern matching is by example, here is a list of pattern-matching examples, with explanations.Study the syntax carefully, so that you understand the principles atwork.  You should then be able to adapt these examples to your own situation.</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Put <EMCLASS="emphasis">troff</EM> italicization codes around   the word <EMCLASS="emphasis">RETURN</EM>:  <ACLASS="indexterm"NAME="AUTOID-6073"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/RETURN/\\fIRETURN\\fP/g</PRE></BLOCKQUOTE></P><PCLASS="para">Notice that two backslashes (<CODECLASS="literal">\\</CODE>) are needed in the replacement,because the backslash in the <EMCLASS="emphasis">troff</EM> italicization code will be interpreted as a special character.  (<CODECLASS="literal">\fI</CODE> alone would be interpreted as <EMCLASS="emphasis">fI</EM>;  you must type <CODECLASS="literal">\\fI</CODE> to get<EMCLASS="emphasis">\fI</EM>.)</P></LI><LICLASS="listitem"><PCLASS="para">Modify a list of pathnames in a file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/\/usr\/tim/\/usr\/linda/g</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6090"></A>A slash (used as a delimiter in the global replacement sequence) must be escaped with a backslash when it is part of the pattern orreplacement; use <CODECLASS="literal">\/</CODE> to get /.  An alternate way to achieve this sameeffect is to use a different character as the pattern delimiter.  For example, you could make the above replacement using colons asdelimiters.  Thus:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s:/usr/tim:/usr/linda:g</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Change all periods to semicolons in lines 1 to 10:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:1,10s/\./;/g</PRE></BLOCKQUOTE></P><PCLASS="para">A dot has special meaning in regular expression syntax and mustbe escaped with a backslash (\.).</P></LI><LICLASS="listitem"><PCLASS="para">Change all occurrences of the word <EMCLASS="emphasis">help</EM>(or <EMCLASS="emphasis">Help</EM>) to <EMCLASS="emphasis">HELP</EM>:  <ACLASS="indexterm"NAME="AUTOID-6107"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/[Hh]elp/HELP/g</PRE></BLOCKQUOTE></P><PCLASS="para">or:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/[Hh]elp/\U&amp;/g</PRE></BLOCKQUOTE></P><PCLASS="para">The <CODECLASS="literal">\U</CODE> changes the pattern that follows to all uppercase.  Thepattern that follows is the repeated search pattern, which iseither <EMCLASS="emphasis">help</EM> or <EMCLASS="emphasis">Help</EM>.</P></LI><LICLASS="listitem"><PCLASS="para">Replace <EMCLASS="emphasis">one or more</EM> spaces with a single space:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">*/<IMGSRC="../chars/squ.gif"ALT=" ">/g</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-ONEPLUS-CHARS"></A>Make sure you understand how the asterisk works as a specialcharacter.  An asterisk following any character (or following any regularexpression that matches a single character, such as <CODECLASS="literal">.</CODE>  or <CODECLASS="literal">[a-z]</CODE>)matches <EMCLASS="emphasis">zero or more</EM> instances of that character.Therefore, you must specify <EMCLASS="emphasis">two</EM> spaces followed by an asterisk to match one or more spaces (one space, plus zero or more spaces).  </P></LI><LICLASS="listitem"><PCLASS="para">Replace one or more spaces following a colon with two spaces:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/:<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">*/:<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">/g</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Replace one or more spaces following a period <EMCLASS="emphasis">or</EM> a colon with two spaces:  </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/\([:.]\)<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">*/\1<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">/g</PRE></BLOCKQUOTE></P><PCLASS="para">Either of the two characters within brackets can be matched.This character is saved into a hold buffer, using <CODECLASS="literal">\(</CODE> and <CODECLASS="literal">\)</CODE>, and restored on the right-hand side by the <CODECLASS="literal">\1</CODE>.Note that within brackets a special character such as a dot does not need to be escaped.</P></LI><LICLASS="listitem"><PCLASS="para">Standardize various uses of a word or heading:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/^Note[<IMGSRC="../chars/squ.gif"ALT=" ">:s]*/Notes:<IMGSRC="../chars/squ.gif"ALT=" ">/g</PRE></BLOCKQUOTE></P><PCLASS="para">The brackets enclose three characters:  a space,a colon, and the letter <EMCLASS="emphasis">s</EM>.  Therefore, the pattern <CODECLASS="literal">Note[<IMGSRC="../chars/squ.gif"ALT=" ">s:]</CODE> will match<EMCLASS="emphasis">Note<IMGSRC="../chars/squ.gif"ALT=" "></EM>,<EMCLASS="emphasis">Notes</EM> or <EMCLASS="emphasis">Note:</EM>.An asterisk is added to the pattern so that it also matches<EMCLASS="emphasis">Note</EM> (with zero spaces after it) and <EMCLASS="emphasis">Notes:</EM> (thealready correct spelling).  Without the asterisk,<EMCLASS="emphasis">Note</EM> would be missed entirely and <EMCLASS="emphasis">Notes:</EM> would beincorrectly changed to <EMCLASS="emphasis">Notes:<IMGSRC="../chars/squ.gif"ALT=" ">:</EM>.<ACLASS="indexterm"NAME="AUTOID-6161"></A></P></LI><LICLASS="listitem"><PCLASS="para">Delete all blank lines:  <ACLASS="indexterm"NAME="AUTOID-6164"></A><ACLASS="indexterm"NAME="AUTOID-6167"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/^$/d</PRE></BLOCKQUOTE></P><PCLASS="para">What you are actually matching here is the beginning of the line (^)followed by the end of the line ($), with nothing in between.</P></LI><LICLASS="listitem"><PCLASS="para">Delete all blank lines, plus any lines that contain only white space:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/^[<IMGSRC="../chars/squ.gif"ALT=" "><EMCLASS="emphasis">tab</EM>]*$/d</PRE></BLOCKQUOTE></P><PCLASS="para">(In the line above, a tab is shown as <EMCLASS="emphasis">tab</EM>.)A line may appear to be blank but may in fact contain spaces or tabs.The previous example will not delete such a line.This example, like the one above it, searches for the beginning and endof the line.  But instead of having nothing in between, thepattern tries to find any number of spaces or tabs.If no spaces or tabs are matched, the line is blank.To delete lines that contain white space but that <EMCLASS="emphasis">aren't</EM> blank,you would have to match lines with <EMCLASS="emphasis">at least</EM> one space or tab:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/^[<IMGSRC="../chars/squ.gif"ALT=" "><EMCLASS="emphasis">tab</EM>][<IMGSRC="../chars/squ.gif"ALT=" "><EMCLASS="emphasis">tab</EM>]*$/d</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Delete all leading spaces on a line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/^<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">*\(.*\)/\1/</PRE></BLOCKQUOTE></P><PCLASS="para">Use<CODECLASS="literal"> ^<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">*</CODE>to search for one or more spaces at the beginning of a line;then use <CODECLASS="literal">\(.*\)</CODE>to save the rest of the line into the first hold buffer.Restore the line without spaces, using <CODECLASS="literal">\1</CODE>.</P></LI><LICLASS="listitem"><PCLASS="para">Delete all spaces at the end of a line:  </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/\(.*\)<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">*$/\1/</PRE></BLOCKQUOTE></P><PCLASS="para">Use <CODECLASS="literal">\(.*\)</CODE>to save all the text on the line, but only up until one or more spacesat the end of the line.Restore the saved text without the spaces.</P><PCLASS="para">The substitutions in this example and the previous onewill happen only once on any given line, so the <CODECLASS="literal">g</CODE> option doesn't need to follow the replacement string.</P></LI><LICLASS="listitem"><PCLASS="para">Insert a  &gt;<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">at the start of every line in a file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/^/&gt;<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">/</PRE></BLOCKQUOTE></P><PCLASS="para">What we're really doing here is &quot;replacing&quot; the start of the line with&gt;<IMGSRC="../chars/squ.gif"ALT=" "><IMGSRC="../chars/squ.gif"ALT=" ">Of course, the start of the line (being a logical construct, not anactual character) isn't really replaced!</P><PCLASS="para">This command is useful when replying to mail or USENET news postings.Frequently, it is desirable to include part of the original message in your reply.  By convention, the inclusion is distinguished from your replyby setting off the included text with a right angle bracket and a couple of spaces at the start of the line.  This can be done easily as shown above.  (Typically, only part of the original message will be included.  Unneeded text can be deleted either before or after the above replacement.)  Advanced mail systems do this automatically.However, if you're using a primitive mail program, you may need to do it manually.</P></LI><LICLASS="listitem"><PCLASS="para">Add a period to the end of the next six lines:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:.,+5s/$/./</PRE></BLOCKQUOTE></P><PCLASS="para">The line address indicates the current line plus five lines.The <CODECLASS="literal">$</CODE> indicates the end of line.  As in the previousexample, the <CODECLASS="literal">$</CODE> is a logical construct.  You aren't really replacing the end of the line.</P></LI><LICLASS="listitem"><PCLASS="para">Reverse the order of all hyphen-separated items in a list:<ACLASS="indexterm"NAME="AUTOID-6218"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/\(.*\)<IMGSRC="../chars/squ.gif"ALT=" ">-<IMGSRC="../chars/squ.gif"ALT=" ">\(.*\)/\2<IMGSRC="../chars/squ.gif"ALT=" ">-<IMGSRC="../chars/squ.gif"ALT=" ">\1/</PRE></BLOCKQUOTE></P><PCLASS="para">Use<CODECLASS="literal">\(.*\)</CODE> to save text on the line into the first hold buffer, butonly until you find <IMGSRC="../chars/squ.gif"ALT=" ">-<IMGSRC="../chars/squ.gif"ALT=" ">.Then use<CODECLASS="literal">\(.*\)</CODE>to save the rest of the line into thesecond hold buffer.Restore the saved portions of the line, reversing the order of the two hold buffers.The effect of this command on several items is shown below.  </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">more - display files</PRE></BLOCKQUOTE></P><PCLASS="para">becomes:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">display files - more</PRE></BLOCKQUOTE></P><PCLASS="para">and:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">lp - print files</PRE></BLOCKQUOTE></P><PCLASS="para">becomes:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">print files - lp</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">Change every word in a file to uppercase:<ACLASS="indexterm"NAME="AUTOID-6240"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/.*/\U&amp;/</PRE></BLOCKQUOTE></P><PCLASS="para">or:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/./\U&amp;/g</PRE></BLOCKQUOTE></P><PCLASS="para">The <CODECLASS="literal">\U</CODE> flag at the start of the replacement string tells <EMCLASS="emphasis">vi</EM> to change the replacement to uppercase.  The <CODECLASS="literal">&amp;</CODE> character replays the search pattern as the replacement.These two commands are equivalent;  however, the first form is considerably faster, since it results in only one substitution perline (<CODECLASS="literal">.*</CODE> matches the entire line, once per line),whereas the second form results in repeated substitutions on each line (<CODECLASS="literal">.</CODE> matches only a single character, with the replacement repeated on account of the trailing <CODECLASS="literal">g</CODE>).</P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6257"></A>Reverse the order of lines in a file:[1]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] From the article by Walter Zintz in <EMCLASS="emphasis">UNIX World</EM>, May 1990.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/.*/mo0</PRE></BLOCKQUOTE></P><PCLASS="para">The search pattern matches all lines (a line contains zero or more characters).Each line is moved, one by one, to the top of the file (thatis, moved after imaginary line 0).  As each matched line isplaced at the top, it pushes the previously moved lines down, one by one, until the last line is on top.Since all lines have a beginning, the same result can be achievedmore succinctly:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/^/mo0</PRE></BLOCKQUOTE></P><PCLASS="para"></P></LI><LICLASS="listitem"><PCLASS="para">In a database, on all lines not marked <EMCLASS="emphasis">Paid in full</EM>,append the phrase <EMCLASS="emphasis">Overdue</EM>:<ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-NOT-MATCH-LNS"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g!/Paid<IMGSRC="../chars/squ.gif"ALT=" ">in<IMGSRC="../chars/squ.gif"ALT=" ">full/s/$/Overdue/</PRE></BLOCKQUOTE></P><PCLASS="para">or the equivalent:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:v/Paid<IMGSRC="../chars/squ.gif"ALT=" ">in<IMGSRC="../chars/squ.gif"ALT=" ">full/s/$/Overdue/</PRE></BLOCKQUOTE></P><PCLASS="para">To affect all lines <EMCLASS="emphasis">except</EM> those matching your pattern,add a <CODECLASS="literal">!</CODE> to the <CODECLASS="literal">g</CODE> command, or simply use the <CODECLASS="literal">v</CODE> command.</P></LI><LICLASS="listitem"><PCLASS="para">For any line that doesn't begin with a number, move the lineto the end of the file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g!/^[1-9]/m$</PRE></BLOCKQUOTE></P><PCLASS="para">or:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/^[^1-9]/m$</PRE></BLOCKQUOTE></P><PCLASS="para">As the first character within brackets, a caret negates thesense, so the two commands have the same effect.  The first onesays, &quot;Don't match lines that begin with a number,&quot; and thesecond one says, &quot;Match lines that don't begin with a number.&quot;<ACLASS="indexterm"NAME="AUTOID-6294"></A></P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-ONEPLUS-CHARSA"></A>Change manually numbered section heads (e.g., 1.1, 1.2, etc.) to a <EMCLASS="emphasis">troff</EM> macro (e.g., <EMCLASS="emphasis">.Ah</EM> for an A-level heading):  </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/[1-9]\.[1-9]/.Ah/</PRE></BLOCKQUOTE></P><PCLASS="para">The search string matches a digit other than zero, followed by aperiod, followed by another nonzero digit.  Notice that the period doesn't need to be escaped in the replacement(though a <CODECLASS="literal">\</CODE> would have no effect, either).The command above won't find chapter numbers containing two or more digits.  To do so, modify the command like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/[1-9][0-9]*\.[1-9]/.Ah/</PRE></BLOCKQUOTE></P><PCLASS="para">Now it will match chapters 10 to 99 (digits 1 to 9, followed by a digit),100 to 999 (digits 1 to 9, followed by two digits),etc.The command still finds chapters1 to 9 (digits 1 to 9, followed by no digit).</P></LI><LICLASS="listitem"><PCLASS="para">Remove numbering from section headings in a document.You want to change the sample lines:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">2.1 Introduction10.3.8 New Functions</PRE></BLOCKQUOTE></P><PCLASS="para">into the lines:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">IntroductionNew Functions</PRE></BLOCKQUOTE></P><PCLASS="para">Here's the command to do this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/^[1-9][0-9]*\.[1-9][1-9.]*<IMGSRC="../chars/squ.gif"ALT=" ">//</PRE></BLOCKQUOTE></P><PCLASS="para">The search pattern resembles the one in the previous example, but nowthe numbers vary in length.  At a minimum, the headings contain <EMCLASS="emphasis">number</EM>, <EMCLASS="emphasis">period</EM>, <EMCLASS="emphasis">number</EM>, so you startwith the search pattern from the previous example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[1-9][0-9]*\.[1-9]</PRE></BLOCKQUOTE></P><PCLASS="para">But in this example, the heading may continue with any number ofdigits or periods:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[1-9.]*</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6329"></A></P></LI><LICLASS="listitem"><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6332"></A>Change the word <EMCLASS="emphasis">Fortran</EM> to the phrase <EMCLASS="emphasis">FORTRAN (acronym of FORmulaTRANslation)</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/\(For\)\(tran\)/\U\1\2\E<IMGSRC="../chars/squ.gif"ALT=" ">(acronym<IMGSRC="../chars/squ.gif"ALT=" ">of<IMGSRC="../chars/squ.gif"ALT=" ">\U\1\Emula<IMGSRC="../chars/squ.gif"ALT=" ">\U\2\Eslation)/g</PRE></BLOCKQUOTE></P><PCLASS="para">First, since we notice thatthe words <EMCLASS="emphasis">FORmula</EM> and <EMCLASS="emphasis">TRANslation</EM> use portions of theoriginal word, we decide to save the search pattern in twopieces:  <CODECLASS="literal">\(For\)</CODE> and <CODECLASS="literal">\(tran\)</CODE>.  The first time we restore it,we use both pieces together, converting all characters to uppercase:<CODECLASS="literal">\U\1\2</CODE>.  Next, we undo the uppercase with <CODECLASS="literal">\E</CODE>;otherwise theremaining replacement text would all be uppercase.  Thereplacement continues with actual typed words,then we restore the first hold buffer.  This buffer still contains<EMCLASS="emphasis">For</EM>, so again we convert to uppercase first:  <CODECLASS="literal">\U\1</CODE>.Immediately after, we lowercase the rest of the word:  <CODECLASS="literal">\Emula</CODE>.Finally, we restore the second hold buffer.  This contains <EMCLASS="emphasis">tran</EM>, so we precede the &quot;replay&quot; with uppercase, follow itwith lowercase, and type out the rest of the word: <CODECLASS="literal">\U\2\Eslation</CODE>).</P></LI></OL></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-6-SECT-4.4">6.4.4 A Final Look at Pattern Matching </A></H3><PCLASS="para">We conclude this chapter by presenting sample tasks that involve complex pattern-matching concepts.  Rather than solve the problems right away, we'll work toward the solutions step by step.</P><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="VI6-CH-6-SECT-4.4.1">6.4.4.1 Deleting an Unknown Block of Text </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-DEL-VARTXTSTR"></A>Suppose you have a few lines with this general form:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">the best of times; the worst of times:  movingThe coolest of times; the worst of times:  moving</PRE></BLOCKQUOTE></P><PCLASS="para">The lines that you're concerned with always endwith <EMCLASS="emphasis">moving</EM>, but you never know what the first two wordsmight be.  You want to changeany line that ends with <EMCLASS="emphasis">moving</EM> to read:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">The greatest of times; the worst of times:  moving</PRE></BLOCKQUOTE></P><PCLASS="para">Since the changes must occur on certain lines, you need tospecify a context-sensitive global replacement.  Using<CODECLASS="literal">:g/moving$/</CODE> will match lines that end with <EMCLASS="emphasis">moving</EM>.Next, you realize that your search pattern could be any number ofany character, so the metacharacters <CODECLASS="literal">.*</CODE> come to mind.But these will match the whole line unless you somehow restrictthe match.  Here's your first attempt:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/moving$/s/.*of/The<IMGSRC="../chars/squ.gif"ALT=" ">greatest<IMGSRC="../chars/squ.gif"ALT=" ">of/</PRE></BLOCKQUOTE></P><PCLASS="para">This search string, you decide, will match from the beginning ofthe line to the first <EMCLASS="emphasis">of</EM>.  Since you needed to specify theword <EMCLASS="emphasis">of</EM> to restrict the search, you simply repeat it in thereplacement.  Here's the resulting line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">The greatest of times:  moving</PRE></BLOCKQUOTE></P><PCLASS="para">Something went wrong.  The replacement gobbled the line up to the second<EMCLASS="emphasis">of</EM> instead of the first.  Here's why.  When given achoice, the action of &quot;match any number of any character&quot; willmatch as much text as possible.In this case, since the word <EMCLASS="emphasis">of</EM> appears twice, your search string finds:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">the best of times; the worst of</PRE></BLOCKQUOTE></P><PCLASS="para">rather than:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">the best of</PRE></BLOCKQUOTE></P><PCLASS="para">Your search pattern needs to be more restrictive:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/moving$/s/.*of times;/The greatest of times;/</PRE></BLOCKQUOTE></P><PCLASS="para">Now the <CODECLASS="literal">.*</CODE> will match all characters up tothe instance of the phrase <EMCLASS="emphasis">of times;</EM>.Since there's only one instance, it has to be the first.</P><PCLASS="para">There are cases, though, when it isinconvenient, or even incorrect, to use the <CODECLASS="literal">.*</CODE> metacharacters.For example, you might find yourself typingmany words to restrict your search pattern, or you mightbe unable to restrict the pattern by specific words (if the textin the lines varies widely).  The next section presents such acase.<ACLASS="indexterm"NAME="AUTOID-6394"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="VI6-CH-6-SECT-4.4.2">6.4.4.2 Switching Items in a Database </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-REV-WORDS"></A>Suppose you want to switch the order of all last names and first names in a database.The lines look like this:  </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">Name: Feld, Ray; Areas: PC, UNIX; Phone: 123-4567Name: Joy, Susan S.; Areas: Graphics; Phone: 999-3333</PRE></BLOCKQUOTE></P><PCLASS="para">The name of each field ends with a colon, and each field isseparated by a semicolon.  Using the top line as an example, youwant to change <EMCLASS="emphasis">Feld, Ray</EM> to <EMCLASS="emphasis">Ray Feld</EM>.  We'll present some commands that look promising but don't work.  After each command, we show you the line the way it looked beforethe change and after the change.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/: \(.*\), \(.*\);/: \2 \1;/Name: <CODECLASS="userinput"><B>Feld, Ray; Areas: PC</B></CODE>, <EMCLASS="emphasis">UNIX</EM>; Phone: 123-4567	<ICLASS="lineannotation">Before</I>Name: <EMCLASS="emphasis">UNIX</EM> <CODECLASS="userinput"><B>Feld, Ray; Areas: PC</B></CODE>; Phone: 123-4567	<ICLASS="lineannotation">After</I></PRE></BLOCKQUOTE></P><PCLASS="para">We've highlighted the contents of the first hold buffer in <CODECLASS="userinput"><B>bold</B></CODE>and the contents of the second hold buffer in <CODECLASS="replaceable"><I>italic</I></CODE>.Note that the first hold buffer contains more than you want.Since it was not sufficiently restricted by the pattern thatfollows it, the hold buffer was able to save up to the second comma.Now you try to restrict the contents of the first hold buffer:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/: \(....\), \(.*\);/: \2 \1;/Name: <CODECLASS="userinput"><B>Feld</B></CODE>, <EMCLASS="emphasis">Ray; Areas: PC, UNIX</EM>; Phone: 123-4567	<ICLASS="lineannotation">Before</I>Name: <EMCLASS="emphasis">Ray; Areas: PC, UNIX</EM> <CODECLASS="userinput"><B>Feld</B></CODE>; Phone: 123-4567	<ICLASS="lineannotation">After</I></PRE></BLOCKQUOTE></P><PCLASS="para">Here you've managed to save the last name in the first holdbuffer, but now the second hold buffer will save anythingup to the last semicolon on the line.  Now you restrict thesecond hold buffer, too:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/: \(....\), \(...\);/: \2 \1;/Name: <CODECLASS="userinput"><B>Feld</B></CODE>, <EMCLASS="emphasis">Ray</EM>; Areas: PC, UNIX; Phone: 123-4567	<ICLASS="lineannotation">Before</I>Name: <EMCLASS="emphasis">Ray</EM> <CODECLASS="userinput"><B>Feld</B></CODE>; Areas: PC, UNIX; Phone: 123-4567	<ICLASS="lineannotation">After</I></PRE></BLOCKQUOTE></P><PCLASS="para">This gives you what you want, but only in the specific case of afour-letter last name and a three-letter first name.  (Theprevious attempt included the same mistake.)  Why not just returnto the first attempt, but this time be more selective about theend of the search pattern?</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/: \(.*\), \(.*\); Area/: \2 \1;/Name: <CODECLASS="userinput"><B>Feld</B></CODE>, <EMCLASS="emphasis">Ray</EM>; Areas: PC, UNIX; Phone: 123-4567	<ICLASS="lineannotation">Before</I>Name: <EMCLASS="emphasis">Ray</EM> <CODECLASS="userinput"><B>Feld</B></CODE>; Areas: PC, UNIX; Phone: 123-4567	<ICLASS="lineannotation">After</I></PRE></BLOCKQUOTE></P><PCLASS="para">This works, but we'll continue the discussion byintroducing an additional concern.  Suppose that the <EMCLASS="emphasis">Area</EM>field isn't always present or isn't always the second field.The above command won't work on such lines.</P><PCLASS="para">We introduce this problem to make a point.  Whenever you rethinka pattern match, it's usually better to work toward refining thevariables (the metacharacters), rather than using specific textto restrict pattterns.  The more variables you use in yourpatterns, the more powerful your commands will be.</P><PCLASS="para">In the current example, think again about the patterns you want to switch.Each word starts with an uppercase letter and is followed by anynumber of lowercase letters, so you can match the names like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[A-Z][a-z]*</PRE></BLOCKQUOTE></P><PCLASS="para">Ok, but a last name might also have more than one uppercase letter (<EMCLASS="emphasis">McFly</EM>, for example),so you'd want to search for this possibility in the second andsucceeding letters:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[A-Z][A-Za-z]*</PRE></BLOCKQUOTE></P><PCLASS="para">It doesn't hurt to use this for the first name, too (you neverknow when <EMCLASS="emphasis">McGeorge Bundy</EM> will turn up).Your command now becomes:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/: \([A-Z][A-Za-z]*\), \([A-Z][A-Za-z]*\);/: \2 \1;/</PRE></BLOCKQUOTE></P><PCLASS="para">Quite forbidding, isn't it?  It still doesn't cover the case of a name like <EMCLASS="emphasis">Joy, Susan S.</EM> Since the first-name field might include a middle initial, you need toadd a space and a period within the second pair of brackets.But enough is enough.  Sometimes, specifying exactly whatyou want is more difficult than specifying what you <EMCLASS="emphasis">don't</EM> want.  In your sample database, the last names end with a comma,so a last-name field can be thought of as a string of charactersthat are <EMCLASS="emphasis">not</EM> commas:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[^,]*</PRE></BLOCKQUOTE></P><PCLASS="para">This pattern matches characters up until the first comma.Similarly, the first-name field is a string of characters thatare <EMCLASS="emphasis">not</EM> semicolons:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">[^;]*</PRE></BLOCKQUOTE></P><PCLASS="para">Putting these more efficient patterns back into your previouscommand, you get this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:%s/: \([^,]*\), \([^;]*\);/: \2 \1;/</PRE></BLOCKQUOTE></P><PCLASS="para">The same command could also be entered as a context-sensitive replacement.If all lines begin with <EMCLASS="emphasis">Name</EM>, you can say:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/^Name/s/: \([^,]*\), \([^;]*\);/: \2 \1;/</PRE></BLOCKQUOTE></P><PCLASS="para">You can also add an asterisk after the first space, in order to match a colon that has extra spaces (or no spaces)after it:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/^Name/s/: *\([^,]*\), \([^;]*\);/: \2 \1;/</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-6478"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="VI6-CH-6-SECT-4.4.3">6.4.4.3 Using :g to Repeat a Command </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-RPT-EX-CMND"></A>As we've usually seen the <CODECLASS="literal">:g</CODE> command used, it selects lines thatare typically then edited by subsequent commands on the same line&nbsp;- forexample, we select lines with <CODECLASS="literal">g</CODE>, and then make substitutionson them, or select them and delete them:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/mg[ira]box/s/box/square/g:g/^$/d</PRE></BLOCKQUOTE></P><PCLASS="para">However, in his two-part tutorial in <EMCLASS="emphasis">UNIX World</EM>, [2]Walter Zintz makes an interesting point about the <CODECLASS="literal">g</CODE>command.  This command selects lines&nbsp;- but the associated editingcommands need not actually affect the lines that are selected.</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] Part 1, &quot;<EMCLASS="emphasis">vi</EM> Tips for Power Users,&quot; appears in the April 1990issue of <EMCLASS="emphasis">UNIX World</EM>.  Part&nbsp;2, &quot;Using <EMCLASS="emphasis">vi</EM> to AutomateComplex Edits,&quot; appears in the May 1990 issue.The examples presented are from Part&nbsp;2.</P></BLOCKQUOTE><PCLASS="para">Instead, he demonstrates a technique by which you can repeat<EMCLASS="emphasis">ex</EM> commandssome arbitrary number of times.  For example, suppose you want to placeten copies of lines 12 through 17 of your file at the end of yourcurrent file.  You could type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:1,10g/^/ 12,17t$</PRE></BLOCKQUOTE></P><PCLASS="para">This is a very unexpected use of <CODECLASS="literal">g</CODE>, but it works!  The<CODECLASS="literal">g</CODE> commandselects line 1, executes the specified <CODECLASS="literal">t</CODE> command, then goes on toline&nbsp;2, to execute the next copy command.  When line 10 isreached, <EMCLASS="emphasis">ex</EM> will have made ten copies.<ACLASS="indexterm"NAME="AUTOID-6506"></A></P></DIV><DIVCLASS="sect3"><H4CLASS="sect3"><ACLASS="title"NAME="VI6-CH-6-SECT-4.4.4">6.4.4.4 Collecting Lines </A></H4><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-6-IX-GLB-RPL-COLLECT-LINES"></A>Here's another advanced <CODECLASS="literal">g</CODE> example, again building onsuggestions provided in Zintz's article.  Suppose you're editing a document that consists of several parts.  Part&nbsp;2 of this file is shown below, using ellipses toshow omitted text and displaying line numbers for reference.</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">301  Part 2302  Capability Reference303  .LP304  Chapter 7305  Introduction to the Capabilities<BCLASS="emphasis.bold">306  This and the next three chapters ...</B>400  ... and a complete index at the end.401  .LP402  Chapter 8403  Screen Dimensions<BCLASS="emphasis.bold">404  Before you can do anything useful</B>405  on the screen, you need to know ...555  .LP556  Chapter 9557  Editing the Screen<BCLASS="emphasis.bold">558  This chapter discusses ...</B>821  .LP822  Part 3:823  Advanced Features824  .LP825  Chapter 10</PRE></BLOCKQUOTE></P><PCLASS="para">The chapter numbers appear on one line, theirtitles appear on the line below, and the chapter text(highlighted for emphasis)begins on the line below that.The first thing you'd like to do is copy the beginning lineof each chapter, sending it to an already existing file called<EMCLASS="emphasis">begin</EM>.</P><PCLASS="para">Here's the command that does this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g /^Chapter/ .+2w &gt;&gt; begin</PRE></BLOCKQUOTE></P><PCLASS="para">You must be at the top of your file before issuing this command.First you search for <EMCLASS="emphasis">Chapter</EM> at the start of a line,but then you want to run the command on the beginning line of eachchapter&nbsp;- the second line below <EMCLASS="emphasis">Chapter</EM>.Because a line beginning with <EMCLASS="emphasis">Chapter</EM> is now selected as the current line, the line address <CODECLASS="literal">.+2</CODE> will indicate the second line below it.The equivalent lineaddresses <CODECLASS="literal">+2</CODE> or <CODECLASS="literal">++</CODE> work as well.You want to write these lines to an existing file named<EMCLASS="emphasis">begin</EM>, so you issue the <CODECLASS="literal">w</CODE> command with the append operator<CODECLASS="literal">&gt;&gt;</CODE>.  </P><PCLASS="para">Suppose you want to send the beginnings of chapters that are onlywithin Part 2.  You need to restrict the lines selected by <CODECLASS="literal">g</CODE>, so you change your command to this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:/^Part 2/,/^Part 3/g /^Chapter/ .+2w &gt;&gt; begin</PRE></BLOCKQUOTE></P><PCLASS="para">Here, the <CODECLASS="literal">g</CODE> command selects the lines that begin with<EMCLASS="emphasis">Chapter</EM>, but it searches only that portion of the file from a linestarting with <EMCLASS="emphasis">Part 2</EM> through a line starting with <EMCLASS="emphasis">Part 3</EM>.If you issue the above command,the last lines of the file <EMCLASS="emphasis">begin</EM> will read as follows:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">This and the next three chapters ...Before you can do anything usefulThis chapter discusses ...</PRE></BLOCKQUOTE></P><PCLASS="para">These are the lines that begin Chapters 7, 8, and 9.</P><PCLASS="para">In addition to the lines you've just sent,you'd like to copy chapter titles to the end ofthe document, in preparation for making a table of contents.  You can use the vertical bar to tack a second command after your first command, like so:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:/^Part 2/,/^Part 3/g /^Chapter/ .+2w &gt;&gt; begin | +t$</PRE></BLOCKQUOTE></P><PCLASS="para">Remember that with any subsequent command, line addresses arerelative to the previous command.  The first command has marked lines(within Part 2) that start with <EMCLASS="emphasis">Chapter</EM>, and the chapter titlesappear on a line below such lines.  Therefore, to access chapter titles in the second command, the lineaddress is <CODECLASS="literal">+</CODE> (or the equivalents <CODECLASS="literal">+1</CODE> or <CODECLASS="literal">.+1</CODE>).Then use <CODECLASS="literal">t$</CODE> to copy the chapter titles to the end of thefile.<ACLASS="indexterm"NAME="AUTOID-6556"></A></P><PCLASS="para">As these examples illustrate, thought andexperimentation may lead you to some unusual editing solutions.Don't be afraid to try things!  Just be sure to back up your filefirst.<ACLASS="indexterm"NAME="AUTOID-6558"></A><ACLASS="indexterm"NAME="AUTOID-6559"></A><ACLASS="indexterm"NAME="AUTOID-6560"></A><ACLASS="indexterm"NAME="AUTOID-6561"></A></P></DIV></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch06_03.htm"TITLE="6.3 Pattern-matching Rules "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 6.3 Pattern-matching Rules "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the vi Editor"><IMGSRC="../gifs/txthome.gif"ALT="Learning the vi Editor"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="CHAPTER"HREF="ch07_01.htm"TITLE="7. Advanced Editing "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7. Advanced Editing "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">6.3 Pattern-matching Rules </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_a.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">7. Advanced Editing </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>