<HTML><HEAD><TITLE>[Chapter 7] 7.3 Saving Commands </TITLE><METANAME="DC.title"CONTENT="Learning the vi Editor"><METANAME="DC.creator"CONTENT="Linda Lamb"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T20:53:19Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="0-937175-67-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch07_01.htm"TITLE="7. Advanced Editing "><LINKREL="prev"HREF="ch07_02.htm"TITLE="7.2 Executing UNIX Commands "><LINKREL="next"HREF="ch07_04.htm"TITLE="7.4 Using ex Scripts "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the vi Editor"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/vsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_02.htm"TITLE="7.2 Executing UNIX Commands "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 7.2 Executing UNIX Commands "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 7<BR>Advanced Editing </FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_04.htm"TITLE="7.4 Using ex Scripts "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7.4 Using ex Scripts "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="VI6-CH-7-SECT-3">7.3 Saving Commands </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7065"></A><ACLASS="indexterm"NAME="AUTOID-7068"></A>Often you type the same long phrases over and over in a file.  <EMCLASS="emphasis">vi</EM> and <EMCLASS="emphasis">ex</EM> have a number of different ways of saving longsequences of commands, both in command mode and in insert mode.When you call up one of these saved sequences to executeit, all you do is type a few characters (or even only one), and theentire sequence is executed as if you had entered the whole sequenceof commands one by one.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-3.1">7.3.1 Word Abbreviation </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-7-IX-EX-CMNDS-ABBREV-WRDS"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-CMNDS-ABBREV-WRDS"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-WORD-ABBREV"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-ABBREV-CMND"></A>You can define abbreviations that <EMCLASS="emphasis">vi</EM> will automatically expand into the full text whenever you type the abbreviation in insert mode.  To define an abbreviation, use the <EMCLASS="emphasis">ex</EM> command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:ab <EMCLASS="emphasis">abbr phrase</EM></PRE></BLOCKQUOTE></P><PCLASS="para"><EMCLASS="emphasis">abbr</EM> is an abbreviation for the specified <EMCLASS="emphasis">phrase</EM>.  The sequence of characters that make up the abbreviation will beexpanded in insert mode only if you type it as a full word;  <EMCLASS="emphasis">abbr</EM>will not be expanded within a word.</P><PCLASS="para">Suppose in the file <EMCLASS="emphasis">practice</EM> you want to enter text thatcontains a frequently recurring phrase such as a difficult productor company name.  The command:<BLOCKQUOTECLASS="screen"><PRECLASS="screen">:ab imrc International Materials Research Center</PRE></BLOCKQUOTE>abbreviates <EMCLASS="emphasis">International Materials Research Center</EM> to the initials <EMCLASS="emphasis">imrc</EM>.  Now whenever you type <EMCLASS="emphasis">imrc</EM> in insert mode, <EMCLASS="emphasis">imrc</EM> expands to the full text.<TABLECLASS="informaltable"><THEADCLASS="thead"><TRCLASS="row"VALIGN="TOP"><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Keystrokes</TH><THCLASS="entry"ALIGN="LEFT"ROWSPAN="1"COLSPAN="1">Results</TH></TR></THEAD><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><CODECLASS="literal">ithe imrc</CODE></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">the International Materials Research Center</PRE></BLOCKQUOTE></TD></TR></TBODY></TABLE>Abbreviations expand as soon as you press a non-alphanumeric character(e.g., punctuation), a space, a carriage return, or <KBDCLASS="keycap">[ESC]</KBD>(returning to command mode).When you are choosing abbreviations, choose combinations ofcharacters that don't ordinarily occur while you are typing text.If you create an abbreviation that ends up expanding in placeswhere you don't want it to, you can disable the abbreviation bytyping:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:unab <EMCLASS="emphasis">abbr</EM></PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7121"></A><ACLASS="indexterm"NAME="AUTOID-7124"></A>To list your currently defined abbreviations, type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:ab</PRE></BLOCKQUOTE></P><PCLASS="para">The characters that compose your abbreviation cannot also appear at the end of your phrase.For example, if you issue the command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:ab PG This movie is rated PG</PRE></BLOCKQUOTE></P><PCLASS="para">you'll get the message &quot;No tail recursion,&quot;and the abbreviation won't be set. The message means that you have tried to define something that willexpand itself repeatedly, creating an infinite loop.<ACLASS="indexterm"NAME="AUTOID-7133"></A>If you issue the command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:ab PG the PG rating system</PRE></BLOCKQUOTE></P><PCLASS="para">you may or may not produce an infinite loop, but in either caseyou won't get a warning message.For example, when the above command was tested on a System V versionof UNIX, the expansion worked.  On a Berkeley version, though,the abbreviation expanded repeatedly, like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">the the the the the ...</PRE></BLOCKQUOTE></P><PCLASS="para">until a memory error occurred and <EMCLASS="emphasis">vi</EM> quit.We recommend that you avoid repeating your abbreviationas part of the defined phrase.<ACLASS="indexterm"NAME="AUTOID-7143"></A><ACLASS="indexterm"NAME="AUTOID-7144"></A><ACLASS="indexterm"NAME="AUTOID-7145"></A><ACLASS="indexterm"NAME="AUTOID-7146"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-3.2">7.3.2 Using the map Command </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-7-IX-EX-CMNDS-MAP-CMND-SQNCE"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-CMNDS-MPNG"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-MPNG-CMNDS"></A>While you're editing, you may find that you are using a command sequencefrequently, or you may occasionally use a very complex commandsequence.  To save yourself keystrokes, or the time that it takesto remember the sequence, you can assign the sequence to an unused keyby using the <CODECLASS="literal">map</CODE> command.</P><PCLASS="para">The <CODECLASS="literal">map</CODE> command acts a lot like <CODECLASS="literal">ab</CODE> except that youdefine a macro for command mode instead of insert mode.</P><DLCLASS="variablelist"><DTCLASS="term"><CODECLASS="literal">:map</CODE>&nbsp;<CODECLASS="replaceable"><I>x&nbsp;sequence</I></CODE></DT><DDCLASS="listitem"><PCLASS="para">Define character <EMCLASS="emphasis">x</EM> as a <EMCLASS="emphasis">sequence</EM> of editing commands.</P></DD><DTCLASS="term"><CODECLASS="literal">:unmap</CODE>&nbsp;<CODECLASS="replaceable"><I>x</I></CODE></DT><DDCLASS="listitem"><PCLASS="para">Disable the <EMCLASS="emphasis">sequence</EM> defined for <EMCLASS="emphasis">x</EM>.</P></DD><DTCLASS="term"><CODECLASS="literal">:map</CODE></DT><DDCLASS="listitem"><PCLASS="para">List the characters that are currently mapped.</P></DD></DL><PCLASS="para">Before you can start creating your own maps, you need to know thekeys not used in command mode that are available for user-definedcommands:<ACLASS="indexterm"NAME="AUTOID-7186"></A></P><DLCLASS="variablelist"><DTCLASS="term">Letters:</DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">g K q V v</CODE></P></DD><DTCLASS="term">Control keys:</DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">^A ^K ^O ^T ^W ^X</CODE></P></DD><DTCLASS="term">Symbols:</DT><DDCLASS="listitem"><PCLASS="para"><CODECLASS="literal">_ * \ =</CODE>(Note:  The = is used by <EMCLASS="emphasis">vi</EM> if Lisp mode is set.)</P></DD></DL><PCLASS="para">Depending on your terminal, you may also be able to associate mapsequences with special function keys.  </P><PCLASS="para">With maps you can create simple or complex command sequences.  As a simple example, you could define a command to reverse the order ofwords.  In <EMCLASS="emphasis">vi</EM>, with the cursor as shown:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">you can <UCLASS="cursor">t</U>he scroll page</PRE></BLOCKQUOTE></P><PCLASS="para">the sequence to put <EMCLASS="emphasis">the</EM> after <EMCLASS="emphasis">scroll</EM> would be<CODECLASS="literal">dwelp</CODE>:  delete word, <CODECLASS="literal">dw</CODE>;  move to the end of next word,<CODECLASS="literal">e</CODE>;  move one space to the right, <CODECLASS="literal">l</CODE>;  put the deleted wordthere, <CODECLASS="literal">p</CODE>.  Saving this sequence:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map v dwelp</PRE></BLOCKQUOTE></P><PCLASS="para">enables you to reverse the order of two words at any time in the editingsession with the single keystroke <CODECLASS="literal">v</CODE>.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-3.3">7.3.3 Protecting Keys from Interpretation by ex </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7227"></A>Note that when defining a map, you cannot simply type certain keys,such as<KBDCLASS="keycap">[RETURN]</KBD>,<KBDCLASS="keycap">[ESC]</KBD>,<KBDCLASS="keycap">[BACKSPACE]</KBD>,and<KBDCLASS="keycap">[DELETE]</KBD>as part of the command to be mapped, because these keys already have meaning within <EMCLASS="emphasis">ex</EM>.If you want to include one of these keys as part of the commandsequence, you must escape the normal meaning by preceding the key with <CODECLASS="literal">^V</CODE><KBDCLASS="keycap">[CTRL-V]</KBD>.The keystroke <CODECLASS="literal">^V</CODE> appears in the map as the ^ character.Characters following the <CODECLASS="literal">^V</CODE> alsodo not appear as you expect.  For example, a carriage return appears as <CODECLASS="literal">^M</CODE>, escape as <CODECLASS="literal">^[</CODE>, backspace as<CODECLASS="literal">^H</CODE>, and so on.</P><PCLASS="para">On the other hand, if you want to use a control character as thecharacter to be mapped,in most cases all you have to do is hold down the<KBDCLASS="keycap">[CTRL]</KBD>key and press the letter key at the same time.So, for example, all you need to do in order to map <CODECLASS="literal">^A</CODE> is to type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map <KBDCLASS="keycap">[CTRL-A]</KBD> <CODECLASS="replaceable"><I>sequence</I></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">There are, however, three control characters that must be escaped with a <CODECLASS="literal">^V</CODE>.  They are<CODECLASS="literal">^T</CODE>, <CODECLASS="literal">^W</CODE>, and <CODECLASS="literal">^X</CODE>.So, for example, if you want to map <CODECLASS="literal">^T</CODE>, you must type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map <KBDCLASS="keycap">[CTRL-V]</KBD> <KBDCLASS="keycap">[CTRL-T]</KBD> <CODECLASS="replaceable"><I>sequence</I></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">The use of  <KBDCLASS="keycap">[CTRL-V]</KBD>applies to any <EMCLASS="emphasis">ex</EM> command, not just a map command.This means that you can type a carriage return in an abbreviationor a substitution command.  For example, the abbreviation:<ACLASS="indexterm"NAME="AUTOID-7263"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:ab 123 one^Mtwo^Mthree</PRE></BLOCKQUOTE></P><PCLASS="para">expands to this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">onetwothree</PRE></BLOCKQUOTE></P><PCLASS="para">(Here we show the sequence <KBDCLASS="keycap">[CTRL-V]</KBD><KBDCLASS="keycap">[RETURN]</KBD>as <CODECLASS="literal">^M</CODE>, the way it would appear on your screen.)</P><PCLASS="para">You can also globally add lines at certain locations.<ACLASS="indexterm"NAME="AUTOID-7276"></A>The command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:g/^Section/s//As you recall, in^M&amp;/</PRE></BLOCKQUOTE></P><PCLASS="para">inserts, before all lines beginning with the word <EMCLASS="emphasis">Section</EM>,a phrase on a separate line.  The <CODECLASS="literal">&amp;</CODE> restores the search pattern.</P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7285"></A>Unfortunately, one character always has special meaning in <EMCLASS="emphasis">ex</EM> commands, even if you try to quote it with<KBDCLASS="keycap">[CTRL-V]</KBD>.Recall that the vertical bar (<CODECLASS="literal">|</CODE>) has special meaning as a separator of multiple <EMCLASS="emphasis">ex</EM> commands.You cannot use a vertical bar in insert mode maps.</P><PCLASS="para">Now that you've seen how to use<KBDCLASS="keycap">[CTRL-V]</KBD>to protect certain keys inside <EMCLASS="emphasis">ex</EM> commands, you're ready todefine some powerful map sequences.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-3.4">7.3.4 Complex Mapping Example </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-7-IX-MPNG-EXAMPLES"></A>Assume that you have a glossary with entries like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">map - an ex command which allows you to associate a complex command sequence with a single key.</PRE></BLOCKQUOTE></P><PCLASS="para">You would like to convert this glossary list to <EMCLASS="emphasis">nroff</EM>format, so that it looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">.IP &quot;map&quot; 10 nAn ex command...</PRE></BLOCKQUOTE></P><PCLASS="para">The best way to define a complex map is to do the edit once manually,writing down each keystroke that you must type.Then recreate these keystrokes as a map.You want to: </P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Insert the ms macro for an indented paragraph at the beginning of the line.  Insert the first quotation mark as well (<CODECLASS="literal">I.IP &lt;&quot;&gt;</CODE>).</P></LI><LICLASS="listitem"><PCLASS="para">Press<KBDCLASS="keycap">[ESC]</KBD>to terminate insert mode.  </P></LI><LICLASS="listitem"><PCLASS="para">Move to the end of the first word (<CODECLASS="literal">e</CODE>) and add a secondquotation mark, followed by a space and the size of the indent (<CODECLASS="literal">a&lt;&quot;&gt; 10n</CODE>).</P></LI><LICLASS="listitem"><PCLASS="para">Press <KBDCLASS="keycap">[RETURN]</KBD>to insert a new line.</P></LI><LICLASS="listitem"><PCLASS="para">Press <KBDCLASS="keycap">[ESC]</KBD>to terminate insert mode.</P></LI><LICLASS="listitem"><PCLASS="para">Remove the hyphen and two surrounding spaces (<CODECLASS="literal">3x</CODE>) and capitalize the next word (~).</P></LI></OL><PCLASS="para">That's quite an editing chore if you have to repeat it more than a few times.  With <CODECLASS="literal">:map</CODE> you can save the entire sequence so that itcan be re-executed with a single keystroke:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map g I.IP &quot;^[ea&quot; 10n^M^[3x~</PRE></BLOCKQUOTE></P><PCLASS="para">Note that you have to &quot;quote&quot; both the<KBDCLASS="keycap">[ESC]</KBD>and<KBDCLASS="keycap">[RETURN]</KBD>characters with<KBDCLASS="keycap">[CTRL-V]</KBD>.<CODECLASS="literal">^[</CODE> is the sequence that appears when you type<KBDCLASS="keycap">[CTRL-V]</KBD>followed by <KBDCLASS="keycap">[ESC]</KBD>.<CODECLASS="literal">^M</CODE> is the sequence shown when you type<KBDCLASS="keycap">[CTRL-V]</KBD><KBDCLASS="keycap">[RETURN]</KBD>.</P><PCLASS="para">Now, simply typing <CODECLASS="literal">g</CODE> will perform the entire series of edits.  At a slow baud rate you can actually see the edits happening individually.  At a fast baud rate it will seem to happen by magic.  </P><PCLASS="para">Don't be discouraged if your first attempt at key mapping fails.  A small error in defining the map can give very different results from the ones you expect.  Type <CODECLASS="literal">u</CODE> to undo the edit, and try again.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-3.5">7.3.5 More Examples of Mapping Keys </A></H3><PCLASS="para">The examples below will give you an idea of the clevershortcuts possible when defining keyboard maps.</P><OLCLASS="orderedlist"><LICLASS="listitem"><PCLASS="para">Add text whenever you move to the end of a word:<ACLASS="indexterm"NAME="AUTOID-7352"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map e ea</PRE></BLOCKQUOTE></P><PCLASS="para">Most of the time, the only reason you want to move to the end ofa word is to add text.  This map sequence puts you in insert modeautomatically.Note that the mapped key, <CODECLASS="literal">e</CODE>, has meaning in <EMCLASS="emphasis">vi</EM>.You're allowed to map a key that is already used by <EMCLASS="emphasis">vi</EM>,but the key's normal function will be unavailable as longas the map is in effect.  This isn't so bad in this case, sincethe <CODECLASS="literal">E</CODE> command is often identical to <CODECLASS="literal">e</CODE>.</P></LI><LICLASS="listitem"><PCLASS="para">Transpose two words:<ACLASS="indexterm"NAME="AUTOID-7366"></A><ACLASS="indexterm"NAME="AUTOID-7370"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map K dwElp</PRE></BLOCKQUOTE></P><PCLASS="para">We discussed this sequence earlier in the chapter, but nowyou need to use <CODECLASS="literal">E</CODE> (assume here, and in the remaining examples, that the <CODECLASS="literal">e</CODE> command is mapped to <CODECLASS="literal">ea</CODE>).Remember that the cursor begins on the first of the two words.Unfortunately, because of the <CODECLASS="literal">l</CODE> command, this sequence(and the earlier version)doesn't work if the two words are at the end of a line:during the sequence, the cursor ends up at the end of the line,and <CODECLASS="literal">l</CODE> cannot move further right.Here's a better solution:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map K dwwP</PRE></BLOCKQUOTE></P><PCLASS="para">You could also use <CODECLASS="literal">W</CODE> instead of <CODECLASS="literal">w</CODE>.</P></LI><LICLASS="listitem"><PCLASS="para">Save a file and edit the next one in a series:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map q :w^M:n^M</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7391"></A>Notice that you can map keys to <EMCLASS="emphasis">ex</EM> commands, but be sureto finish each <EMCLASS="emphasis">ex</EM> command with a carriage return.This sequence makes it easy to move from one file to the nextand is useful when you've opened many short files with one <EMCLASS="emphasis">vi</EM>command.  Mapping the letter <CODECLASS="literal">q</CODE> helps youremember that the sequence is similar to a &quot;quit.&quot;</P></LI><LICLASS="listitem"><PCLASS="para">Put <EMCLASS="emphasis">troff</EM> emboldening codes around a word: <ACLASS="indexterm"NAME="VI6-CH-7-IX-MPNG-FONT-CODES"></A></P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map v i\fB^[e\fP^[</PRE></BLOCKQUOTE></P><PCLASS="para">This sequence assumes that the cursor is at the beginning of theword.  First, you enter insert mode, then you type the code forbold font.  In map commands, you don't need to type two backslashes to produce one backslash.  Next, you return to command modeby typing a &quot;quoted&quot;<KBDCLASS="keycap">[ESC]</KBD>.Finally, you append the closing <EMCLASS="emphasis">troff</EM> code at the end of the word, and you return to command mode.Notice that when we appended to the end of the word,we didn't need to use <CODECLASS="literal">ea</CODE>, since this sequence is itselfmapped to the single letter <CODECLASS="literal">e</CODE>.  This shows you that map sequences are allowed to contain other map commands.  (The ability to use nested map sequences iscontrolled by <EMCLASS="emphasis">vi</EM>'s <CODECLASS="literal">remap</CODE> option, which is normallyenabled.)</P></LI><LICLASS="listitem"><PCLASS="para">Put <EMCLASS="emphasis">troff</EM> emboldening codes around a word, even when thecursor is not at the beginning of the word:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map V lbi\fB^[e\fP^[</PRE></BLOCKQUOTE></P><PCLASS="para">This sequence is the same as the previous one, except that ituses <CODECLASS="literal">lb</CODE> tohandle the additional task of positioning the cursor at thebeginning of the word.  The cursor might be in the middle of theword, so you want to move to the beginning with the <CODECLASS="literal">b</CODE> command.  </P><PCLASS="para">But if the cursor were already at the beginning of theword, the <CODECLASS="literal">b</CODE> command would move the cursor to the previousword instead.  To guard against that case,type an <CODECLASS="literal">l</CODE> before moving back with <CODECLASS="literal">b</CODE>, so that the cursor never starts on the first letter of the word.You can define variations of this sequence by replacing the <CODECLASS="literal">b</CODE> with <CODECLASS="literal">B</CODE> and the <CODECLASS="literal">e</CODE> with <CODECLASS="literal">Ea</CODE>.In all cases, though, the <CODECLASS="literal">l</CODE> command prevents this sequencefrom working if the cursor is at the end of a line.(You could append a space to get around this.)<ACLASS="indexterm"NAME="AUTOID-7432"></A></P></LI><LICLASS="listitem"><PCLASS="para">Repeatedly find and remove parentheses from around a word or phrase:[1]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[1] From the article by Walter Zintz, in <EMCLASS="emphasis">UNIX World</EM>, April 1990.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map = xf)xn</PRE></BLOCKQUOTE></P><PCLASS="para">This sequence assumes that you firstfound an open parenthesis, by typing <CODECLASS="literal">/(</CODE> followed by <KBDCLASS="keycap">[RETURN]</KBD></P><PCLASS="para">If you choose to remove the parentheses, then use the map command:delete the open parenthesis with <CODECLASS="literal">x</CODE>, find theclosing one with <CODECLASS="literal">f)</CODE>, delete it with <CODECLASS="literal">x</CODE>, and then repeat your search for an open parenthesis with <CODECLASS="literal">n</CODE>.</P><PCLASS="para">If you don't want to remove the parentheses (for example, if they're being used correctly), then don't use the map command:press <CODECLASS="literal">n</CODE> instead to find the next open parenthesis.</P><PCLASS="para">You could also modify the map sequence above to handle matchingpairs of quotes.</P></LI><LICLASS="listitem"><PCLASS="para">Place C comments around an entire line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map g I/* ^[A */^[</PRE></BLOCKQUOTE></P><PCLASS="para">This sequence inserts <CODECLASS="literal">/*</CODE> at the line's beginningand appends <CODECLASS="literal">*/</CODE> at the line's end.You could also map a substitute command to do the same thing:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map g :s/.*/\/* &amp; *\//^M</PRE></BLOCKQUOTE></P><PCLASS="para">Here, you match the entire line (with <CODECLASS="literal">.*</CODE>), and when youreplay it (with <CODECLASS="literal">&amp;</CODE>), you surround the line with thecomment symbols.  Note that you have to escape the <CODECLASS="literal">/</CODE> in the comment.</P></LI><LICLASS="listitem"><PCLASS="para">Safely repeat a long insertion:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map ^J :set wm=0^M.:set wm=10^M</PRE></BLOCKQUOTE></P><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7469"></A><ACLASS="indexterm"NAME="AUTOID-7473"></A>We mentioned in <ACLASS="xref"HREF="ch02_01.htm"TITLE="Simple Editing ">Chapter 2, Simple Editing </A>that<EMCLASS="emphasis">vi</EM> occasionally has difficulty repeating long insertionsof text when <CODECLASS="literal">wrapmargin</CODE> is set.  This map command is a useful workaround.  It temporarily turns offthe wrapmargin (by setting to 0), gives the repeat command, andthen restores the wrapmargin.Note that a map sequence can combine <EMCLASS="emphasis">ex</EM> and <EMCLASS="emphasis">vi</EM> commands.</P></LI></OL><PCLASS="para">In the previous example, even though <CODECLASS="literal">^J</CODE> is a <EMCLASS="emphasis">vi</EM> command (it moves the cursordown a line), this key is safe to map becauseit's really the same as the <CODECLASS="literal">j</CODE> command.There are many keys that either perform the same tasks as otherkeys or that are rarely used.  However, you should be familiarwith the <EMCLASS="emphasis">vi</EM> commands before you boldly disable their normal use by using them in map definitions.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-3.6">7.3.6 Mapping Keys for Insert Mode </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7490"></A><ACLASS="indexterm"NAME="AUTOID-7493"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-MPNG-INSERT-MODE"></A>Normally, maps apply only to command mode&nbsp;-  after all, in insert mode,keys stand for themselves and shouldn't be mapped as commands.However, by adding an exclamation mark (<CODECLASS="literal">!</CODE>) to the <CODECLASS="literal">map</CODE> command,you can force it to override the ordinary meaning of a key and producethe map in insert mode.  This feature is useful when you findyourself in insert mode but need to escape briefly to commandmode, run a command, and then return to insert mode.</P><PCLASS="para">For example, suppose you just typed a word but forgot to italicize it (or place quotes around it, etc.).  You can define this map:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map! + ^[bi\fI^[ea\fP</PRE></BLOCKQUOTE></P><PCLASS="para">Now, when you type a <CODECLASS="literal">+</CODE> at the end of a word, you will surroundthe word with <EMCLASS="emphasis">troff</EM> italicization codes.  The <CODECLASS="literal">+</CODE> won't show upin the text.</P><PCLASS="para">The sequence above escapes to command mode (<CODECLASS="literal">^[</CODE>), backs up to insert the first code (<CODECLASS="literal">bi\fI</CODE>), escapes again (<CODECLASS="literal">^[</CODE>), and moves ahead to append the second code (<CODECLASS="literal">ea\fP</CODE>).  Since the map sequencebegins and ends in insert mode, you can continue entering text afteritalicizing the word.</P><PCLASS="para">Here's another example.Suppose that you've been typing your text, and you realizethat the previous line should have ended with a colon.You can correct that by defining this map sequence:[2]</P><BLOCKQUOTECLASS="footnote"><PCLASS="para">[2] From the article by Walter Zintz, in <EMCLASS="emphasis">UNIX World</EM>, April 1990.</P></BLOCKQUOTE><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map! % ^[kA:^[jA</PRE></BLOCKQUOTE></P><PCLASS="para">Now, if you type a <CODECLASS="literal">%</CODE> anywhere along your current line,you'll append a colon to the end of the previous line.This command escapes to command mode, moves up a line, andappends the colon (<CODECLASS="literal">^[kA:</CODE>).  The command then escapes again,moves down to the line you were on, and leaves you in insert mode (<CODECLASS="literal">^[jA</CODE>).</P><PCLASS="para">Note that we wanted to use uncommon characters (<CODECLASS="literal">%</CODE> and <CODECLASS="literal">+</CODE>) for the previous map commands.When a character is mapped for insert mode, youcan no longer type that character as text.To reinstate a character for normal typing, use the command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:unmap! <EMCLASS="emphasis">x</EM></PRE></BLOCKQUOTE></P><PCLASS="para">where <EMCLASS="emphasis">x</EM> is the character that was previously mapped forinsert mode.</P><PCLASS="para">Insert-mode mapping is often moreappropriate for tying character strings to special keys that you wouldn't otherwise use.  It is especially useful with programmable function keys. <ACLASS="indexterm"NAME="AUTOID-7532"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-3.7">7.3.7 Mapping Function Keys </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-7-IX-MPNG-FNCT-KEYS"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-EX-CMNDS-MAP-FNCT-KEYS"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-FNCT-KEYS-MPNG"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-CMNDS-MAPPED-FNCT-KEYS"></A>Many terminals have programmable function keys.  You can usually setup these keys to print whatever character or characters you want usinga special setup mode on the terminal.  However, keys programmed using a terminal's setup mode only work onthat terminal; they may alsolimit the action of programs that want toset up those function keys themselves.</P><PCLASS="para"><EMCLASS="emphasis">ex</EM> allows you to map function keys by number, using the syntax:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map #1 <EMCLASS="emphasis">commands</EM></PRE></BLOCKQUOTE></P><PCLASS="para">for function key number 1, and so on.(It can do this because theeditor has access to the entry for that terminal found in either the <EMCLASS="emphasis">termcap</EM> or <EMCLASS="emphasis">terminfo</EM> database and knows the escape sequence normally put out by the function key.)  </P><PCLASS="para">As with other keys, maps apply by default to command mode, but byusing the <CODECLASS="literal">map!</CODE> commands as well, you can define two separatevalues for a function key&nbsp;- one to be used in command mode, the other ininsert mode.  For example, if you are a <EMCLASS="emphasis">troff</EM> user, you mightwant to put font-switch codes on function keys.  For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map #1 i\fI^[:map! #1 \fI</PRE></BLOCKQUOTE></P><PCLASS="para">If you are in command mode, the first function key will enter insertmode, type in the three characters <CODECLASS="literal">\fI</CODE>, and return to command mode.  If you are already in insert mode,the key will simply type thethree-character <EMCLASS="emphasis">troff</EM> code.  <ACLASS="indexterm"NAME="AUTOID-7563"></A><ACLASS="indexterm"NAME="AUTOID-7567"></A></P><BLOCKQUOTECLASS="note"><PCLASS="para"><STRONG>NOTE:</STRONG> If function keys have been redefined in the terminal's setupmode, the <CODECLASS="literal">#</CODE><EMCLASS="emphasis">n</EM> syntax might not work  since the function keys no longer put out the expected controlor escape sequence as described in its terminal database entry.  You will need to examine the <EMCLASS="emphasis">termcap</EM> entry (or <EMCLASS="emphasis">terminfo</EM> source) for your terminal and check the definitions for the function keys.  In addition, there are some terminals whose function keys perform onlylocal actions and don't actually send any characters to the computer.Such function keys can't be mapped.  </P></BLOCKQUOTE><PCLASS="para">The terminal capabilities<CODECLASS="literal">k1</CODE>, <CODECLASS="literal">k2</CODE> through <CODECLASS="literal">k0</CODE> describe the first ten function keys.  The capabilities <CODECLASS="literal">l1</CODE>, <CODECLASS="literal">l2</CODE> through <CODECLASS="literal">l0</CODE> describe the remaining function keys.  Using your terminal's setup mode, you can change the controlor escape sequence output by the function key to correspond with the <EMCLASS="emphasis">termcap</EM> or<EMCLASS="emphasis">terminfo</EM> entry.  (For more information, see the Nutshell Handbook <EMCLASS="emphasis">termcap &amp; terminfo</EM>.)</P><PCLASS="para">If the sequence contains <CODECLASS="literal">^M</CODE>, which is a carriage return, press <KBDCLASS="keycap">[CTRL-M]</KBD>.For instance, in order to have function key 1 available formapping, the terminal database entry for your terminal musthave a definition of <CODECLASS="literal">k1</CODE>, such as:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">k1=^A@^M</PRE></BLOCKQUOTE></P><PCLASS="para">In turn, the definition:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">^A@^M</PRE></BLOCKQUOTE></P><PCLASS="para">must be what is output when you press that key.  </P><PCLASS="para">To test what the function key puts out, press the key at the UNIX prompt, followed by a <KBDCLASS="keycap">[RETURN]</KBD>if necessary.  The shell should display the sequence output by the function key after trying unsuccessfully to execute it as a UNIX command.<ACLASS="indexterm"NAME="AUTOID-7599"></A><ACLASS="indexterm"NAME="AUTOID-7600"></A><ACLASS="indexterm"NAME="AUTOID-7601"></A><ACLASS="indexterm"NAME="AUTOID-7602"></A><ACLASS="indexterm"NAME="AUTOID-7603"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-3.8">7.3.8 Mapping Other Special Keys </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-7-IX-MPNG-SPECIAL-KEYS"></A>Many keyboards have special keys, such as<KBDCLASS="keycap">[HOME]</KBD>,<KBDCLASS="keycap">[END]</KBD>,<KBDCLASS="keycap">[PAGE UP]</KBD>,and<KBDCLASS="keycap">[PAGE DOWN]</KBD>that duplicate commands in <EMCLASS="emphasis">vi</EM>.  If the terminal's <EMCLASS="emphasis">termcap</EM> or <EMCLASS="emphasis">terminfo</EM> description iscomplete,<EMCLASS="emphasis">vi</EM> will be able to recognize these keys.But if it isn't, you can use the <CODECLASS="literal">map</CODE> command to make themavailable to <EMCLASS="emphasis">vi</EM>.These keys generally send an escape sequence to the computer&nbsp;- anescape character followed by a string of one or more other characters.In order to trap the escape, you should press <CODECLASS="literal">^V</CODE> beforepressing the special key in the map.  For example, to map the <KBDCLASS="keycap">[HOME]</KBD>key on the keyboard of an IBM PC to a reasonable <EMCLASS="emphasis">vi</EM> equivalent,you might define the following map:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map <KBDCLASS="keycap">[CTRL-V]</KBD> <KBDCLASS="keycap">[HOME]</KBD></PRE></BLOCKQUOTE></P><PCLASS="para">This appears on your screen as:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map ^[[H 1G</PRE></BLOCKQUOTE></P><PCLASS="para">Similar map commands display as follows:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:map <KBDCLASS="keycap">[CTRL-V]</KBD> <KBDCLASS="keycap">[END]</KBD> &nbsp;G          <ICLASS="lineannotation">displays</I>    :map ^[[Y G:map <KBDCLASS="keycap">[CTRL-V]</KBD> <KBDCLASS="keycap">[PAGE&nbsp;UP]</KBD> &nbsp;^F	<ICLASS="lineannotation">displays</I>    :map ^[[V ^F:map <KBDCLASS="keycap">[CTRL-V]</KBD> <KBDCLASS="keycap">[PAGE&nbsp;DOWN]</KBD> &nbsp;^B	<ICLASS="lineannotation">displays</I>    :map ^[[U ^B</PRE></BLOCKQUOTE></P><PCLASS="para">You'll probably want to place these maps in your <EMCLASS="emphasis">.exrc</EM> file.Note that if a special key generates a long escape sequence(containing multiple non-printing characters), <CODECLASS="literal">^V</CODE> quotes only the initial escapecharacter, and the map doesn't work.  You will have to find the entire escape sequence (perhapsfrom the terminal manual) and type it in manually, quoting at theappropriate points, rather than simply pressing <CODECLASS="literal">^V</CODE> and then the key.<ACLASS="indexterm"NAME="AUTOID-7646"></A><ACLASS="indexterm"NAME="AUTOID-7647"></A><ACLASS="indexterm"NAME="AUTOID-7648"></A><ACLASS="indexterm"NAME="AUTOID-7649"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-3.9">7.3.9 @-Functions </A></H3><PCLASS="para">Named buffers provide yet another way to create &quot;macros&quot;&nbsp;- complexcommand sequences that you can repeat with only a few keystrokes.<ACLASS="indexterm"NAME="AUTOID-7653"></A><ACLASS="indexterm"NAME="AUTOID-7656"></A><ACLASS="indexterm"NAME="AUTOID-7659"></A><ACLASS="indexterm"NAME="AUTOID-7662"></A></P><PCLASS="para">If you type a command line in your text (either a <EMCLASS="emphasis">vi</EM> sequenceor an <EMCLASS="emphasis">ex</EM> command <EMCLASS="emphasis">preceded by a colon</EM>), then delete itinto a named buffer, you can execute the contents of that buffer withthe <CODECLASS="literal">@</CODE> command.  For example, open a new line and enter:<TABLECLASS="informaltable"><TBODYCLASS="tbody"><TRCLASS="row"VALIGN="TOP"><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"></TD><TDCLASS="entry"ROWSPAN="1"COLSPAN="1"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">cwgadfly <KBDCLASS="keycap">[CTRL-V ]</KBD><KBDCLASS="keycap">[ESC]</KBD></PRE></BLOCKQUOTE></TD></TR></TBODY></TABLE>This will appear as:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">cwgadfly^[</PRE></BLOCKQUOTE></P><PCLASS="para">on your screen.  Press<KBDCLASS="keycap">[ESC]</KBD>again to exit insert mode, then delete the lineinto buffer g by typing <CODECLASS="literal">&quot;gdd</CODE>.  Now, whenever you place the cursor at the beginning of a word andtype <CODECLASS="literal">@g</CODE>, that word in your text will be changed to<EMCLASS="emphasis">gadfly</EM>.  </P><PCLASS="para">Since <CODECLASS="literal">@</CODE> is interpreted as a <EMCLASS="emphasis">vi</EM> command,a dot (.) will repeat the entire sequence, even if the buffercontains an <EMCLASS="emphasis">ex</EM> command.<CODECLASS="literal">@@</CODE> repeats the last <CODECLASS="literal">@</CODE>, and <CODECLASS="literal">u</CODE> or <CODECLASS="literal">U</CODE> canbe used to undo the effect of <CODECLASS="literal">@</CODE>.</P><PCLASS="para">This is a simple example.  @-functions are useful because they can be adapted to very specificcommands.  They are especially useful when you are editing between files, becauseyou can store the commands in their named buffersand access them from any file you edit.  @-functions are also useful in combination with the globalreplacement commands discussed in <ACLASS="xref"HREF="ch06_01.htm"TITLE="Global Replacement ">Chapter 6, Global Replacement </A>.</P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_02.htm"TITLE="7.2 Executing UNIX Commands "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 7.2 Executing UNIX Commands "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the vi Editor"><IMGSRC="../gifs/txthome.gif"ALT="Learning the vi Editor"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_04.htm"TITLE="7.4 Using ex Scripts "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7.4 Using ex Scripts "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">7.2 Executing UNIX Commands </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_a.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">7.4 Using ex Scripts </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>