<HTML><HEAD><TITLE>[Chapter 7] 7.4 Using ex Scripts </TITLE><METANAME="DC.title"CONTENT="Learning the vi Editor"><METANAME="DC.creator"CONTENT="Linda Lamb"><METANAME="DC.publisher"CONTENT="O'Reilly &amp; Associates, Inc."><METANAME="DC.date"CONTENT="1998-08-03T20:54:04Z"><METANAME="DC.type"CONTENT="Text.Monograph"><METANAME="DC.format"CONTENT="text/html"SCHEME="MIME"><METANAME="DC.source"CONTENT="0-937175-67-6"SCHEME="ISBN"><METANAME="DC.language"CONTENT="en-US"><METANAME="generator"CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINKREV="made"HREF="mailto:online-books@oreilly.com"TITLE="Online Books Comments"><LINKREL="up"HREF="ch07_01.htm"TITLE="7. Advanced Editing "><LINKREL="prev"HREF="ch07_03.htm"TITLE="7.3 Saving Commands "><LINKREL="next"HREF="ch07_05.htm"TITLE="7.5 Editing Program Source Code "></HEAD><BODYBGCOLOR="#FFFFFF"TEXT="#000000"><DIVCLASS="htmlnav"><H1><IMGSRC="gifs/smbanner.gif"ALT="Learning the vi Editor"USEMAP="#srchmap"BORDER="0"></H1><MAPNAME="srchmap"><AREASHAPE="RECT"COORDS="0,0,466,65"HREF="index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="467,0,514,18"HREF="../search/vsrch.htm"ALT="Search this book"></MAP><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_03.htm"TITLE="7.3 Saving Commands "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 7.3 Saving Commands "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><B><FONTFACE="ARIEL,HELVETICA,HELV,SANSERIF"SIZE="-1">Chapter 7<BR>Advanced Editing </FONT></B></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_05.htm"TITLE="7.5 Editing Program Source Code "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7.5 Editing Program Source Code "BORDER="0"></A></TD></TR></TABLE>&nbsp;<HRALIGN="LEFT"WIDTH="515"TITLE="footer"></DIV><DIVCLASS="SECT1"><H2CLASS="sect1"><ACLASS="title"NAME="VI6-CH-7-SECT-4">7.4 Using ex Scripts </A></H2><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-7-IX-SCRPTS-EX-CMNDS"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-EX-CMNDS-SCRIPTS"></A>Certain <EMCLASS="emphasis">ex</EM> commands you use only within <EMCLASS="emphasis">vi</EM>, such asmaps, abbreviations, and so on.If you store these commands in a separate file called <EMCLASS="emphasis">.exrc</EM>,the commands will automatically be executed when you invoke <EMCLASS="emphasis">vi</EM>.Any file that contains commands to execute is called a <EMCLASS="emphasis">script</EM>.</P><PCLASS="para">The commands in a typical <EMCLASS="emphasis">.exrc</EM> script are of no use outside <EMCLASS="emphasis">vi</EM>.However, you can save other <EMCLASS="emphasis">ex</EM> commands in a script,and then execute the script on a file or on multiple files.Mostly you'll use substitute commands in these external scripts.</P><PCLASS="para">For a writer, a useful application of <EMCLASS="emphasis">ex</EM> scripts is to ensureconsistency of terminology&nbsp;- or even of spelling&nbsp;-  across adocument set.For example, let's assume that you've run the UNIX<CODECLASS="literal">spell</CODE> command on two filesand that the command has printed out the following list ofmisspellings:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>spell sect1 sect2</B></CODE>chmodditroffmyfilethierwriteable</PRE></BLOCKQUOTE></P><PCLASS="para">As is often the case, <CODECLASS="literal">spell</CODE> has flagged a few technical termsand special cases it doesn't recognize, but it has also identified twogenuine spelling errors.</P><PCLASS="para">Because we checked two files at once, we don't know which files theerrors occurred in or where they are in the files.Although there are ways to find this out, and the job wouldn't be toohard for only two errors in two files, you can easily imagine howtime consuming the job could grow for a poor speller or for a typist proofingmany files at once.</P><PCLASS="para">To make the job easier, you could write an <EMCLASS="emphasis">ex</EM> script containingthe following commands:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">%s/thier/their/g%s/writeable/writable/gx</PRE></BLOCKQUOTE></P><PCLASS="para">Assume you've saved these lines in a file named <EMCLASS="emphasis">exscript</EM>.  The script could be executed from within <EMCLASS="emphasis">vi</EM> with the command:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">:so exscript</PRE></BLOCKQUOTE></P><PCLASS="para">or the script can be applied to a file right from the command line.Then you could edit the files <EMCLASS="emphasis">sect1</EM> and <EMCLASS="emphasis">sect2</EM> as follows:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">ex - sect1 &lt; exscript</B>$ <BCLASS="emphasis.bold">ex - sect2 &lt; exscript</B></PRE></BLOCKQUOTE></P><PCLASS="para">(The minus sign following the invocation of <EMCLASS="emphasis">ex</EM> tells it tosuppress the normal terminal messages.)</P><PCLASS="para">If the script were longer than the one in our simple example, we wouldalready have saved a fair amount of time.However, you might wonder if there isn't some way to avoid repeatingthe process for each file to be edited.Sure enough, we can write a shell script that includes, but generalizes, the invocationof <EMCLASS="emphasis">ex</EM>, so that it can be used on any number of files.</P><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-4.1">7.4.1 Looping in a Shell Script </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-7-IX-SHELL-SCRIPT-LOOP"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-EX-CMNDS-FOR-LOOP-WITH"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-FOR-LOOP"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-LOOP-EX-SCRIPT"></A>If you don't already know this, it's about time you learned that the shell is a programming language as well as a command-line interpreter.To invoke <EMCLASS="emphasis">ex</EM> on a number of files, we use a simple type of shell scriptcommand called the <CODECLASS="literal">for</CODE> loop.A <CODECLASS="literal">for</CODE> loop allows you to applya sequence of commands for each argument given to the script.(The <CODECLASS="literal">for</CODE> loop is probably the single most useful piece ofshell programming for beginners.You'll want to remember it even if you don't write any other shellprograms.)</P><PCLASS="para">Here's the syntax of a <CODECLASS="literal">for</CODE> loop:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for <EMCLASS="emphasis">variable</EM> in <EMCLASS="emphasis">list</EM>do    <EMCLASS="emphasis">command(s)</EM>done</PRE></BLOCKQUOTE></P><PCLASS="para">For example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for file in $*do    ex - $file &lt; exscriptdone</PRE></BLOCKQUOTE></P><PCLASS="para">(The command doesn't need to be indented;  we indented it forclarity.)After we create this shell script, we save it in a file called<EMCLASS="emphasis">correct</EM>  and make it executable with the <CODECLASS="literal">chmod</CODE>command.(If you aren't familiar with the <CODECLASS="literal">chmod</CODE> command and the procedures for adding a command to your UNIX search path, see the Nutshell Handbook <EMCLASS="emphasis">Learning the UNIX Operating System</EM>.)Now we can simply type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>correct sect1 sect2</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">The <CODECLASS="literal">for</CODE> loop in <EMCLASS="emphasis">correct</EM> will assign each argument(each file in the list specified by <CODECLASS="literal">$*</CODE>, which standsfor <EMCLASS="emphasis">all arguments</EM>) to the variable <EMCLASS="emphasis">file</EM> andexecute the <EMCLASS="emphasis">ex</EM> script on the contents of that variable.</P><PCLASS="para">It may be easier to grasp how the <CODECLASS="literal">for</CODE> loop works with anexample whose output is more visible.Let's look at a script to rename files:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for file in $*do    mv $file $file.xdone</PRE></BLOCKQUOTE></P><PCLASS="para">Assuming this script is in an executable file called <EMCLASS="emphasis">move</EM>,here's what we can do:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>ls</B></CODE>ch01 ch02 ch03 move$ <CODECLASS="userinput"><B>move ch??</B></CODE>$ <CODECLASS="userinput"><B>ls</B></CODE>ch01.x ch02.x ch03.x move</PRE></BLOCKQUOTE></P><PCLASS="para">With a little creativity, you could rewrite the script to rename thefiles more specifically:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for nn in $*do    mv ch$nn sect$nndone</PRE></BLOCKQUOTE></P><PCLASS="para">With the script written this way, you'd specify numbers instead offilenames on the command line:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>ls</B></CODE>ch01 ch02 ch03 move$ <CODECLASS="userinput"><B>move 01 02 03</B></CODE>$ <CODECLASS="userinput"><B>ls</B></CODE>sect01 sect02 sect03 move</PRE></BLOCKQUOTE></P><PCLASS="para">The <CODECLASS="literal">for</CODE> loop need not take <CODECLASS="literal">$*</CODE> (all arguments) as thelist of values to be substituted.You can specify an explicit list as well;  for example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for <EMCLASS="emphasis">variable</EM> in <EMCLASS="emphasis">a b c d</EM></PRE></BLOCKQUOTE></P><PCLASS="para">will assign <EMCLASS="emphasis">variable</EM> to <EMCLASS="emphasis">a</EM>, <EMCLASS="emphasis">b</EM>, <EMCLASS="emphasis">c</EM>, and<EMCLASS="emphasis">d</EM> in turn.Or you can substitute the output of a command;  for example:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for <EMCLASS="emphasis">variable</EM> in `grep -l &quot;Alcuin&quot;`</PRE></BLOCKQUOTE></P><PCLASS="para">will assign <EMCLASS="emphasis">variable</EM> in turn to the name of each file in which<CODECLASS="literal">grep</CODE> finds the string <EMCLASS="emphasis">Alcuin</EM>.</P><PCLASS="para">If no list is specified:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for <EMCLASS="emphasis">variable</EM></PRE></BLOCKQUOTE></P><PCLASS="para">the variable will be assigned to each command-line argument in turn,much as it was in our initial example.This is actually not equivalent to: </P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for <EMCLASS="emphasis">variable</EM> in $*</PRE></BLOCKQUOTE></P><PCLASS="para">but to:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for <EMCLASS="emphasis">variable</EM> in $@</PRE></BLOCKQUOTE></P><PCLASS="para">which has a slightly different meaning.The symbol <CODECLASS="literal">$*</CODE> expands to <EMCLASS="emphasis">$1</EM>, <EMCLASS="emphasis">$2</EM>, <EMCLASS="emphasis">$3</EM>,etc., but <CODECLASS="literal">$@</CODE> expands to <EMCLASS="emphasis">&quot;$1&quot;</EM>, <EMCLASS="emphasis">&quot;$2&quot;</EM>,<EMCLASS="emphasis">&quot;$3&quot;</EM>, etc.Quotation marks prevent further interpretation of special characters.</P><PCLASS="para">Let's return to our main point and our original script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for file in $*do    ex - $file &lt; exscriptdone</PRE></BLOCKQUOTE></P><PCLASS="para">It may seem a little inelegant to have to use two scripts&nbsp;- the shellscript and the <EMCLASS="emphasis">ex</EM> script.And in fact, the shell does provide a way to include an editing scriptinside a shell script.<ACLASS="indexterm"NAME="AUTOID-7855"></A><ACLASS="indexterm"NAME="AUTOID-7856"></A><ACLASS="indexterm"NAME="AUTOID-7857"></A><ACLASS="indexterm"NAME="AUTOID-7858"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-4.2">7.4.2 Here Documents </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7862"></A><ACLASS="indexterm"NAME="AUTOID-7864"></A><ACLASS="indexterm"NAME="AUTOID-7868"></A>In a shell script, the operator &lt;&lt; means to take the following lines, up to a specifiedstring, as input to a command.(This is often called a <EMCLASS="emphasis">here document</EM>.)Using this syntax, we could include our editing commands in<EMCLASS="emphasis">correct</EM> like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">for file in $*do ex - $file &lt;&lt; end-of-scriptg/thier/s//their/gg/writeable/s//writable/gwqend-of-scriptdone</PRE></BLOCKQUOTE></P><PCLASS="para">The string <EMCLASS="emphasis">end-of-script</EM> is entirely arbitrary&nbsp;- it just needsto be a string that won't otherwise appear in the input and can beused by the shell to recognize when the here document is finished.By convention, many users specify the end of a here document with thestring <EMCLASS="emphasis">EOF</EM>, or <EMCLASS="emphasis">E_O_F</EM>, to indicate the end of the file.</P><PCLASS="para">There are advantages and disadvantages to each approach shown.If you want to make a one-time series of edits and don't mind rewriting the script each time, the here document provides aneffective way to do the job.</P><PCLASS="para">However, it's more flexible to write the editing commands in a separate file from theshell script.For example, you could establish the convention that you will alwaysput editing commands in a file called <EMCLASS="emphasis">exscript</EM>.Then you only need to write the <EMCLASS="emphasis">correct</EM> script once.You can store it away in your personal &quot;tools&quot; directory (which you'veadded to your search path) and use it whenever you like.</P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-4.3">7.4.3 Sorting Text Blocks:  A Sample ex Script </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-7-IX-SCRPTS-SRT-TBLOCKS"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-EX-CMNDS-SORT-TBLKS"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-SORT-TEXT-BLOCKS"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-TEXT-BLOCKS-SORTING"></A>Suppose you want to alphabetize a file of <EMCLASS="emphasis">nroff</EM>-encoded glossarydefinitions.Each term begins with an .IP macro.In addition, each entry is surrounded by the .KS/.KEmacro pair.  (This ensures that the term and its definition willprint as a block and will not be split across a new page.)The glossary file looks something like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">.KS.IP &quot;TTY_ARGV&quot; 2nThe command, specified as an argument vector, that the TTY subwindow executes..KE.KS.IP &quot;ICON_IMAGE&quot; 2nSets or gets the remote image for icon's image.  .KE.KS.IP &quot;XV_LABEL&quot; 2nSpecifies a frame's header or an icon's label.  .KE.KS.IP &quot;SERVER_SYNC&quot; 2nSynchronizes with the server once. Does not set synchronous mode..KE</PRE></BLOCKQUOTE></P><PCLASS="para">You can alphabetize a file by running the lines through the UNIX<CODECLASS="literal">sort</CODE> command, but you don't really want to sort everyline.You want to sort only the glossary terms, moving eachdefinition&nbsp;-  untouched&nbsp;- along with its corresponding term.As it turns out, you cantreat each text block as a unitby joining the block into one line.  Here's the first versionof your <EMCLASS="emphasis">ex</EM> script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">g/\.KS/,/\.KE/j%!sort</PRE></BLOCKQUOTE></P><PCLASS="para">Each glossary entry is found between a  .KS and .KE macro.<CODECLASS="literal">j</CODE> is the <EMCLASS="emphasis">ex</EM> command to join a line (the equivalent in <EMCLASS="emphasis">vi</EM> is J).So, the first command joins every glossary entry into one &quot;line.&quot;The second command then sorts the file, producing lines like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">.KS .IP&nbsp; &quot;ICON_IMAGE&quot; 2n Sets or gets ... image.  &nbsp;&nbsp;.KE.KS .IP&nbsp; &quot;SERVER_SYNC&quot; 2n Synchronizes with ... mode.  &nbsp;&nbsp;.KE.KS .IP&nbsp; &quot;TTY_ARGV&quot; 2n The command, ... executes.  &nbsp;&nbsp;.KE.KS .IP&nbsp; &quot;XV_LABEL&quot; 2n Specifies a ... icon's label.  &nbsp;&nbsp;.KE</PRE></BLOCKQUOTE></P><PCLASS="para">The lines are now sorted by glossary entry; unfortunately,each line also hasmacros and text mixed in (we've used ellipses (...) to showomitted text).Somehow, you need to insert carriage returns to &quot;un-join&quot; the lines.  You can do this by modifying your<EMCLASS="emphasis">ex</EM> script:  mark the joining points of thetext blocks <EMCLASS="emphasis">before</EM> you join them, and then replace the markerswith carriage returns.  Here's the expanded <EMCLASS="emphasis">ex</EM> script:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">g/\.KS/,/\.KE/-1s/$/@@/g/\.KS/,/\.KE/j%!sort%s/@@ /^M/g</PRE></BLOCKQUOTE></P><PCLASS="para">The first three commands produce lines like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"></PRE></BLOCKQUOTE></P><BLOCKQUOTECLASS="screen"><PRECLASS="screen">.KS@@ .IP &quot;ICON_IMAGE&quot; 2nn@@ Sets or gets ... image. @@ .KE.KS@@ .IP &quot;SERVER_SYNC&quot; 2nn@@ Synchronizes with ... mode. @@ .KE.KS@@ .IP &quot;TTY_ARGV&quot; 2nn@@ The ... vector, @@ that ... .@@ .KE.KS@@ .IP &quot;XV_LABEL&quot; 2nn@@ Specifies a ... icon'slabel. @@ .KE</PRE></BLOCKQUOTE><PCLASS="para">Note the extra space following the <CODECLASS="literal">@@</CODE>.  The spaces result fromthe <CODECLASS="literal">j</CODE> command, because it converts each carriage return intoa space.  </P><PCLASS="para">The first command marks the original line breaks with <CODECLASS="literal">@@</CODE>. You don't need to mark the end of the block(after the .KE), so the first command uses a <CODECLASS="literal">-1</CODE> tomove back up one line at the end of each block.The fourth command restores the line breaks by replacing the markers(plus the extra space)with carriage returns.  Now, your file is sorted by blocks.<ACLASS="indexterm"NAME="AUTOID-7927"></A><ACLASS="indexterm"NAME="AUTOID-7928"></A><ACLASS="indexterm"NAME="AUTOID-7929"></A><ACLASS="indexterm"NAME="AUTOID-7930"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-4.4">7.4.4 Comments in ex Scripts </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="AUTOID-7934"></A>You may want to reuse such a script, adapting it to a new situation.  With a complex script like this, it is wise to add comments so that it's easier for someone else (or even yourself!) to reconstruct how it works.  In <EMCLASS="emphasis">ex</EM> scripts, anything following a double quoteis ignored during execution, so a double quote can mark thebeginning of a comment.  Comments can go on their own line.They can also go at the end of any command that doesn'tinterpret a quote as part of the command.  (For example, a quotehas meaning to map commands and shell escapes, so you can't endsuch lines with a comment.)</P><PCLASS="para">Besides using comments, you can specify a command byits full name, something that would ordinarily be tootime consuming from within <EMCLASS="emphasis">vi</EM>.  Finally, if you add spaces, the <EMCLASS="emphasis">ex</EM> script above becomes this more readable one:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">&quot; Mark lines between each KS/KE block global /\.KS/,/\.KE/-1 substitute /$/@@/&quot; Now join the blocks into one lineglobal /\.KS/,/\.KE/ join&quot; Sort each block--now really one line each %!sort&quot; Restore the joined lines to original blocks% substitute /@@ /^M/g</PRE></BLOCKQUOTE></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-4.5">7.4.5 ex Scripts Built by diff </A></H3><PCLASS="para"><ACLASS="indexterm"NAME="VI6-CH-7-IX-SCRIPTS-BY-DIFF"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-EX-CMNDS-SCRPTS-DIFF"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-UX-CMNDS-CMP-FLS"></A><ACLASS="indexterm"NAME="VI6-CH-7-IX-DIFF-CMND"></A>A further example of the use of <EMCLASS="emphasis">ex</EM> scripts is built into aUNIX program called <CODECLASS="literal">diff</CODE>, which compares two files andprints out lines that differ.The <CODECLASS="literal">-e</CODE> option of <CODECLASS="literal">diff</CODE> produces an editing scriptusable with either <EMCLASS="emphasis">ed</EM> or <EMCLASS="emphasis">ex</EM>, instead of the usual output.This script consists of a sequence of <CODECLASS="literal">a</CODE> (add), <CODECLASS="literal">c</CODE>(change), and <CODECLASS="literal">d</CODE> (delete) commands necessary to recreate <EMCLASS="emphasis">file1</EM> from <EMCLASS="emphasis">file2</EM> (the first and second files specified onthe <CODECLASS="literal">diff</CODE> command line).</P><PCLASS="para">Obviously there is no need to completely recreate the first file fromthe second, because you could do that easily with <CODECLASS="literal">cp</CODE>.However, by editing the script produced by <CODECLASS="literal">diff</CODE>, you can come upwith some desired combination of the two versions.</P><PCLASS="para">It might take you a moment to think of a case in which you might haveuse for this feature.Consider this one:  two people have unknowingly made edits todifferent copies of a file, and you need the two versions merged.(This can happen especially easily in a networked environment, inwhich people copy files between machines.Poor coordination can easily result in this kind of problem.)</P><PCLASS="para">To make this situation concrete, let's take a look at two versions ofthe same paragraph, which we want to combine:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen"><EMCLASS="emphasis">Version 1:</EM>The Book of Kells,now one of the treasures of the Trinity College Library in Dublin,was found in the ancient monastery at Ceannanus Mor, now called Kells.It is a beautifully illustrated manuscript of the Latin Gospels, and also contains notes on local history.  It was written in the eighth century.  The manuscript is generally regarded as the finest example of Celtic illumination.<EMCLASS="emphasis">Version 2:</EM>The Book of Kellswas found in the ancient monastery at Ceannanus Mor, now called Kells.It is a beautifully illustrated manuscript of the Latin Gospels, and also contains notes on local history.  It is believed to have been written in the eighth century.  The manuscript is generally regarded as the finest example of Celtic illumination.</PRE></BLOCKQUOTE></P><PCLASS="para">As you can see, there is one additional phrase in each of the two files.We can merge them into one file that incorporates bothedits.Typing:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>diff -e version1 version2 &gt; exscript</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">will yield the following output in the file <EMCLASS="emphasis">exscript</EM>:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">8cIt is believed to have been written in the eighth century.  .1,3cThe Book of Kells.</PRE></BLOCKQUOTE></P><PCLASS="para">You'll notice that the script appears in reverse order, with thechanges later in the file appearing first.This is essential whenever you're making changes based on linenumbers;  otherwise, changes made earlier in the file may change thenumbering, rendering the later parts of the script ineffective.You'll also notice that, as mentioned, this script will simplyrecreate <EMCLASS="emphasis">version1</EM>, which is not what we want.We want the change to line 8, but not the change to lines 1 through 3.We want to edit the script so that it looks like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">8cIt is believed to have been written in the eighth century.  .w</PRE></BLOCKQUOTE></P><PCLASS="para">(Notice that we had to add the <CODECLASS="literal">w</CODE> command to write the resultsof the edit back into the file.)Now we can type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">ex - version1 &lt; exscript</B></PRE></BLOCKQUOTE></P><PCLASS="para">to get the resulting merged file:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">The Book of Kells,now one of the treasures of the Trinity College Library in Dublin,was found in the ancient monastery at Ceannanus Mor, now called Kells.It is a beautifully illustrated manuscript of the Latin Gospels, and also contains notes on local history.  It is believed to have been written in the eighth century.  The manuscript is generally regarded as the finest example of Celtic illumination.</PRE></BLOCKQUOTE></P><PCLASS="para">Using <CODECLASS="literal">diff</CODE> like this can get confusing, especially when thereare many changes.It is easy to get the direction of changes confused or to make the wrong edits.Just remember to do the following:</P><ULCLASS="itemizedlist"><LICLASS="listitem"><PCLASS="para">Specify the file that is closest in content to your eventual target asthe first file on the <CODECLASS="literal">diff</CODE> command line.This will minimize the size of the editing script that is produced.</P></LI><LICLASS="listitem"><PCLASS="para">After you have corrected the editing script so that it makes only thechanges that you want, apply it to that same file (the first file).</P></LI></UL><PCLASS="para">Nonetheless, because there is so much room for error, it is better notto have your script write the changes back directly into one of yoursource files.Instead of adding a <CODECLASS="literal">w</CODE> command at the end of the script, addthe command <CODECLASS="literal">%p</CODE> (or <CODECLASS="literal">1,$p</CODE>) to write the results to standard output.This is almost always preferable when you are using a complex editingscript.</P><PCLASS="para">If we use this command in the editing script, the command line toactually make the edits would look like this:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <BCLASS="emphasis.bold">ex - version1 &lt; exscript &gt; version3</B></PRE></BLOCKQUOTE></P><PCLASS="para">Writers often find themselves making extensive changes and thenwishing they could go back and recover some part of an earlierversion.Obviously, frequent backups will help.However, if backup storage space is at a premium, it is possible(though a little awkward) to save only some older version of a file,and then keep incremental <CODECLASS="literal">diff</CODE> <CODECLASS="literal">-e</CODE> scripts to mark thedifferences between each successive version.</P><PCLASS="para">To apply multiple scripts to a single file, you can simply pipe themto <EMCLASS="emphasis">ex</EM> rather than redirecting input:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>cat script1 script2 script3 | ex - oldfile</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">But wait!How do you get your <CODECLASS="literal">w</CODE> (or <CODECLASS="literal">%p</CODE>) command into thepipeline?You could edit the last script to include one of these commands.But there's another trick that we ought to look at because itillustrates another useful feature of the shell that many people areunaware of.If you enclose a semicolon-separated list of commands in parentheses,the standard output of all of the commands are combined, and can beredirected together.The immediate application is that, if you type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>cat script1 script2 script3; echo '%p' | ex - oldfile</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">the results of the <CODECLASS="literal">cat</CODE> command will be sent, as usual, tostandard output, and only the results of <CODECLASS="literal">echo</CODE> will be piped to<EMCLASS="emphasis">ex</EM>.But if you type:</P><PCLASS="para"><BLOCKQUOTECLASS="screen"><PRECLASS="screen">$ <CODECLASS="userinput"><B>(cat script1 script2 script3; echo '%p') | ex -oldfile</B></CODE></PRE></BLOCKQUOTE></P><PCLASS="para">the output of the entire sequence will make it into the pipeline,which is what we want.<ACLASS="indexterm"NAME="AUTOID-8037"></A><ACLASS="indexterm"NAME="AUTOID-8038"></A><ACLASS="indexterm"NAME="AUTOID-8039"></A><ACLASS="indexterm"NAME="AUTOID-8040"></A></P></DIV><DIVCLASS="sect2"><H3CLASS="sect2"><ACLASS="title"NAME="VI6-CH-7-SECT-4.6">7.4.6 Where to Go from Here </A></H3><PCLASS="para">If this discussion has whetted your appetite for even more editing power, you should be aware that UNIX provides editors even more powerful than <EMCLASS="emphasis">ex</EM>:  the <EMCLASS="emphasis">sed</EM> stream editor and the <EMCLASS="emphasis">awk</EM> data manipulation language.  For information on these programs, see the Nutshell Handbook <EMCLASS="emphasis">Sed &amp; Awk</EM>. <ACLASS="indexterm"NAME="AUTOID-8048"></A><ACLASS="indexterm"NAME="AUTOID-8049"></A></P></DIV></DIV><DIVCLASS="htmlnav"><P></P><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><TABLEWIDTH="515"BORDER="0"CELLSPACING="0"CELLPADDING="0"><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_03.htm"TITLE="7.3 Saving Commands "><IMGSRC="../gifs/txtpreva.gif"ALT="Previous: 7.3 Saving Commands "BORDER="0"></A></TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="book"HREF="index.htm"TITLE="Learning the vi Editor"><IMGSRC="../gifs/txthome.gif"ALT="Learning the vi Editor"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172"><ACLASS="SECT1"HREF="ch07_05.htm"TITLE="7.5 Editing Program Source Code "><IMGSRC="../gifs/txtnexta.gif"ALT="Next: 7.5 Editing Program Source Code "BORDER="0"></A></TD></TR><TR><TDALIGN="LEFT"VALIGN="TOP"WIDTH="172">7.3 Saving Commands </TD><TDALIGN="CENTER"VALIGN="TOP"WIDTH="171"><ACLASS="index"HREF="index/idx_a.htm"TITLE="Book Index"><IMGSRC="../gifs/index.gif"ALT="Book Index"BORDER="0"></A></TD><TDALIGN="RIGHT"VALIGN="TOP"WIDTH="172">7.5 Editing Program Source Code </TD></TR></TABLE><HRALIGN="LEFT"WIDTH="515"TITLE="footer"><IMGSRC="../gifs/smnavbar.gif"USEMAP="#map"BORDER="0"ALT="The UNIX CD Bookshelf Navigation"><MAPNAME="map"><AREASHAPE="RECT"COORDS="0,0,73,21"HREF="../index.htm"ALT="The UNIX CD Bookshelf"><AREASHAPE="RECT"COORDS="74,0,163,21"HREF="../upt/index.htm"ALT="UNIX Power Tools"><AREASHAPE="RECT"COORDS="164,0,257,21"HREF="../unixnut/index.htm"ALT="UNIX in a Nutshell"><AREASHAPE="RECT"COORDS="258,0,321,21"HREF="index.htm"ALT="Learning the vi Editor"><AREASHAPE="RECT"COORDS="322,0,378,21"HREF="../sedawk/index.htm"ALT="sed &amp; awk"><AREASHAPE="RECT"COORDS="379,0,438,21"HREF="../ksh/index.htm"ALT="Learning the Korn Shell"><AREASHAPE="RECT"COORDS="439,0,514,21"HREF="../lrnunix/index.htm"ALT="Learning the UNIX Operating System"></MAP></DIV></BODY></HTML>