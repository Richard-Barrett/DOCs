<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 2] 2.2 Using Environment Variables</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:20:59 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_01.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 2</b></td><td width=172 align=right valign=top><A HREF="ch02_03.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-2">2.2 Using Environment Variables</A></h2><P CLASS=para>Muchof the most crucial information needed by CGI applications is madeavailable via UNIX environment variables. Programscan access this information as they would any environment variable(e.g., via the <I CLASS=emphasis>%ENV</I> associative array in Perl).<P CLASS=para>This section concentrates on showing examples of some of the moretypical uses of environment variables in CGI programs. First, however,<A HREF="ch02_02.htm#CGI-CHP-2-TBL-1">Table 2.1</A> shows a full list of environmentvariables available for CGI.<P><DIV CLASS=table><TABLE><CAPTION><A CLASS="TITLE" NAME="CGI-CHP-2-TBL-1">Table 2-1: List of CGI Environment Variables</A></CAPTION><TR CLASS=row><TH ALIGN="left"><P CLASS=para>Environment Variable</TH><TH ALIGN="left"><P CLASS=para>Description</TH></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>GATEWAY_INTERFACE</TD><TD ALIGN="left"><P CLASS=para>The revision of the Common Gateway Interfacethat the server uses.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>SERVER_NAME</TD><TD ALIGN="left"><P CLASS=para>The server's hostname or IP address.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>SERVER_SOFTWARE</TD><TD ALIGN="left"><P CLASS=para>The name and version of the server softwarethat is answering the client request.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>SERVER_PROTOCOL</TD><TD ALIGN="left"><P CLASS=para>The name and revision of the informationprotocol the request came in with.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>SERVER_PORT</TD><TD ALIGN="left"><P CLASS=para>The port number of the host on whichthe server is running.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>REQUEST_METHOD</TD><TD ALIGN="left"><P CLASS=para>The method with which the informationrequest was issued.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>PATH_INFO</TD><TD ALIGN="left"><P CLASS=para>Extra path information passed to a CGIprogram.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>PATH_TRANSLATED</TD><TD ALIGN="left"><P CLASS=para>The translated version of the path givenby the variable PATH_INFO.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>SCRIPT_NAME</TD><TD ALIGN="left"><P CLASS=para>The virtual path (e.g., <I CLASS=emphasis>/cgi-bin/program.pl</I>)of the script being executed.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>DOCUMENT_ROOT</TD><TD ALIGN="left"><P CLASS=para>The directory from which Web documentsare served.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>QUERY_STRING</TD><TD ALIGN="left"><P CLASS=para>The query information passed to the program.It is appended to the URL with a "?".</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>REMOTE_HOST</TD><TD ALIGN="left"><P CLASS=para>The remote hostname of the user makingthe request.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>REMOTE_ADDR</TD><TD ALIGN="left"><P CLASS=para>The remote IP address of the user makingthe request.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>AUTH_TYPE</TD><TD ALIGN="left"><P CLASS=para>The authentication method used to validatea user.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>REMOTE_USER</TD><TD ALIGN="left"><P CLASS=para>The authenticated name of the user.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>REMOTE_IDENT</TD><TD ALIGN="left"><P CLASS=para>The user making the request. This variablewill only be set if NCSA <I CLASS=emphasis>IdentityCheck</I> flagis enabled, and the client machine supports the RFC 931 identificationscheme (ident daemon).</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>CONTENT_TYPE</TD><TD ALIGN="left"><P CLASS=para>The MIME type of the query data, suchas "text/html".</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>CONTENT_LENGTH</TD><TD ALIGN="left"><P CLASS=para>The length of the data (in bytes or thenumber of characters) passed to the CGI program through standardinput.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>HTTP_FROM</TD><TD ALIGN="left"><P CLASS=para>The email address of the user makingthe request. Most browsers do not support this variable.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>HTTP_ACCEPT</TD><TD ALIGN="left"><P CLASS=para>A list of the MIME types that the clientcan accept.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>HTTP_USER_AGENT</TD><TD ALIGN="left"><P CLASS=para>The browser the client is using to issuethe request.</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>HTTP_REFERER</TD><TD ALIGN="left"><P CLASS=para>The URL of the document that the clientpoints to before accessing the CGI program.</TD></TR></TABLE><P></DIV><P CLASS=para>We'll use examples to demonstrate how these variables aretypically used within a CGI program.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-2.1">About This Server</A></h3><P CLASS=para>Let'sstart with a simple program that displays various information aboutthe server, such as the CGI and HTTP revisionsused and the name of the server software.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perlprint "Content-type: text/html", "\n\n";print "&lt;HTML&gt;", "\n";print "&lt;HEAD&gt;&lt;TITLE&gt;About this Server&lt;/TITLE&gt;&lt;/HEAD&gt;", "\n";print "&lt;BODY&gt;&lt;H1&gt;About this Server&lt;/H1&gt;", "\n";print "&lt;HR&gt;&lt;PRE&gt;";print "Server Name:      ", $ENV{'SERVER_NAME'}, "&lt;BR&gt;", "\n";print "Running on Port:  ", $ENV{'SERVER_PORT'}, "&lt;BR&gt;", "\n";print "Server Software:  ", $ENV{'SERVER_SOFTWARE'}, "&lt;BR&gt;", "\n";print "Server Protocol:  ", $ENV{'SERVER_PROTOCOL'}, "&lt;BR&gt;", "\n";print "CGI Revision:     ", $ENV{'GATEWAY_INTERFACE'}, "&lt;BR&gt;", "\n";print "&lt;HR&gt;&lt;/PRE&gt;", "\n";print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";exit (0);</PRE></DIV><P CLASS=para>Let's go through this program step by step. The first lineis very important. It instructs the server to use the Perl interpreterlocated in the <I CLASS=emphasis>/usr/local/bin</I> directory toexecute the CGI program. Without this line, the server won't knowhow to run the program, and will display an error stating that itcannot execute the program.<P CLASS=para>Once the CGI script is running, the first thing it needs togenerate is a valid HTTP header, ending witha blank line. The header generally contains a content type, alsoknown as a MIME type. In this case, the contenttype of the data that follows is <i CLASS=command>text/html</i>.<P CLASS=para>Afterthe MIME content type is output, we can go aheadand display output in HTML. We send the informationdirectly to standard output, which is read and processed by theserver, and then sent to the client for display. Five environmentvariables are output, consisting of the server name (the IP nameor address of the machine where the server is running), the portthe server is running on, the server software, and the HTTPand CGI revisions. In Perl, you can access the environment variablesthrough the <I CLASS=emphasis>%ENV</I> associative array, keyed byname.<P CLASS=para>A typical output of this program might look like this:<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;About this Server&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;About this Server&lt;/H1&gt;&lt;HR&gt;&lt;PRE&gt;Server Name:      bu.eduRunning on Port:  80Server Software:  NCSA/1.4.2Server Protocol:  HTTP/1.0CGI Revision:     CGI/1.1&lt;HR&gt;&lt;/PRE&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-2.2">Check the Client Browser</A></h3><P CLASS=para>Now,let's look at a slightly more complicated example. One of the moreuseful items that the server passes to the CGI program is the client(or browser) name. We can put this information to good use by checkingthe browser type, and then displaying either a text or graphic document.<P CLASS=para>DifferentWeb browsers support different HTML tags anddifferent types of information. If your CGI program generates aninline image, you need to be sensitive that some browsers support&lt;IMG&gt; extensionsthat others don't, some browsers support JPEGimages as well as GIF images, and some browsers (notably, Lynx andthe old <I CLASS=emphasis>www</I> client) don't support images atall. Using the HTTP_USER_AGENTenvironment variable, you can determine which browser is being used,and with that information you can fine-tune your CGI program togenerate output that is optimized for that browser.<P CLASS=para>Let's build a short program that delivers a different documentdepending on whether the browser supports graphics. First, identifythe browsers that you know don't support graphics. Then get thename of the browser from the HTTP_USER_AGENTvariable:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$nongraphic_browsers = 'Lynx|CERN-LineMode';$client_browser  = $ENV{'HTTP_USER_AGENT'};</PRE></DIV><P CLASS=para>The variable <I CLASS=emphasis>$nongraphic_browsers</I> containsa list of the browsers that don't support graphics. Each browseris separated by the "|" character, which represents alternationin the regular expression we use later in the program. In this instance,there are only two browsers listed, Lynx and <I CLASS=emphasis>www</I>.("CERN-LineMode" is the string the <I CLASS=emphasis>www</I> browseruses to identify itself.)<P CLASS=para>The HTTP_USER_AGENTenvironment variable contains the name of the browser. All environmentvariables that start with HTTP represent informationthat is sent by the client. The server adds the prefix and sendsthis data with the other information to the CGI program.<P CLASS=para>Now identify the files that you intend to return dependingon whether the browser supports graphics:<DIV CLASS=screen><P><PRE>$graphic_document = "full_graphics.html";$text_document = "text_only.html";</PRE></DIV><P CLASS=para>The variables <I CLASS=emphasis>$graphic_document</I> and <I CLASS=emphasis>$text_document</I>contain the names of the two documents that we will use.<P CLASS=para>The next thing to do is simply to check if the browser nameis included in the list of non-graphic browsers.<DIV CLASS=screen><P><PRE>if ($client_browser =~ /$nongraphic_browsers/) {    $html_document = $text_document;} else {    $html_document = $graphic_document;}</PRE></DIV><P CLASS=para>The conditional checks whether the client browser is one thatwe know does not support graphics. If it is, the variable <I CLASS=emphasis>$html_document</I>will contain the name of the text-only version of the HTMLfile. Otherwise, it will contain the name of the version of theHTML document that contains graphics.<P CLASS=para>Finally, print the partial header and open the file. (We needto get the document root from the DOCUMENT_ROOTvariable and prepend it to the filename, so the Perl program canlocate the document in the file system.)<DIV CLASS=screen><P><PRE>print "Content-type: text/html", "\n\n";$document_root = $ENV{'DOCUMENT_ROOT'};$html_document = join ("/", $document_root, $html_document);    if (open (HTML, "&lt;" . $html_document)) {    while (&lt;HTML&gt;) {	       print;	}    close (HTML);} else {    print "Oops! There is a problem with the configuration on this system!", "\n";    print "Please inform the Webmaster of the problem. Thanks!", "\n";}exit (0);</PRE></DIV><P CLASS=para>If the filename stored in <I CLASS=emphasis>$html_document</I>can be opened for reading (as specified by the "&lt;" character),the <I CLASS=emphasis>while</I> loop iterates through the file anddisplays it. The <I CLASS=emphasis>open</I> command creates a handle,HTML, which is then used to access the file.During the <I CLASS=emphasis>while</I> loop, as Perl reads a linefrom the HTML file handle, it places that linein its default variable <I CLASS=emphasis>$_</I>. The <I CLASS=emphasis>print</I>statement without any arguments displays the value stored in <I CLASS=emphasis>$_</I>.After the entire file is displayed, it is closed. If the file cannotbe opened, an error message is output.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-2.3">Restricting Access for Specified Domains</A></h3><P CLASS=para>Suppose you have a set of HTMLdocuments: one for users in your IP domain (e.g., bu.edu), and anotherone for users outside of your domain. Why would anyone want to dothis, you may ask? Say you have a document containing internal companyphone numbers, meeting schedules, and other company information.You certainly don't want everyone on the Internet to see this document.So you need to set up some type of security to keep your documentsaway from prying eyes.<P CLASS=para>You can configure most servers to restrict access to yourdocuments according to what domain the user connects from. For example,under the NCSA server, you can list the domains which you want toallow or deny access to certain directories by editing the access.conf configuration file. However,you can also control domain-based access in a CGI script. The advantageof using a CGI script is that you don't have to turn away otherdomains, just send them different documents. Let's look at a CGIprogram that performs pseudo authentication:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$host_address = 'bu\.edu';$ip_address = '128\.197';</PRE></DIV><P CLASS=para>These two variables hold the IP domain name and address thatare considered local. In other words, users in this domain can accessthe internal information. The period is "escaped" in both of thesevariables (by placing a "\" before the character), because the variableswill be interpolated in a regular expression later in this program.The "." character has a special significance in a regular expression;it is used to match any character other than a newline.<DIV CLASS=screen><P><PRE>$remote_address = $ENV{'REMOTE_ADDR'};$remote_host = $ENV{'REMOTE_HOST'};</PRE></DIV><P CLASS=para>The environment variable REMOTE_ADDRreturns the IP numerical address for the remote user, while REMOTE_HOSTcontains the IP alphanumeric name for the remote user. There aretimes when REMOTE_HOST will not return the name,but only the address (if the DNS server does not have an entry forthe domain). In such a case, you can use the following snippet ofcode to convert an IP address to its corresponding name:<DIV CLASS=screen><P><PRE>@subnet_numbers = split (/\./, $remote_address);$packed_address = pack ("C4", @subnet_numbers);($remote_host)  = gethostbyaddr ($packed_address, 2);</PRE></DIV><P CLASS=para>Don't worry about this code yet. We will discuss functionslike these in <A HREF="ch09_01.htm">Chapter 9, <i>Gateways, Databases, and Search/Index Utilities</i></A>. Now, let's continue with the rest of thisprogram.<DIV CLASS=screen><P><PRE>$local_users = "internal_info.html";$outside_users = "general.html";if (($remote_host =~ /\.$host_address$/) &amp;&amp; ($remote_address =~ /^$ip_address/)) {    $html_document = $local_users;} else {    $html_document = $outside_users;}</PRE></DIV><P CLASS=para>The remote host is examined to see if it ends with the domainname, as specified by the <I CLASS=emphasis>$host_address</I> variable,and the remote address is checked to make sure it starts with thedomain address stored in <I CLASS=emphasis>$ip_address</I>. Dependingon the outcome of the conditional, the <I CLASS=emphasis>$html_document</I>variable is set accordingly.<DIV CLASS=screen><P><PRE>print "Content-type: text/html", "\n\n";$document_root = $ENV{'DOCUMENT_ROOT'};$html_document = join ("/", $document_root, $html_document); if (open (HTML, "&lt;" . $html_document)) {    while (&lt;HTML&gt;) {	       print;	}    close (HTML);} else {    print "Oops! There is a problem with the configuration on this system!", "\n";    print "Please inform the Webmaster of the problem. Thanks!", "\n";}exit (0);</PRE></DIV><P CLASS=para>The specified document is opened and the information storedwithin it is displayed. </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-2.4">User Authentication and Identification</A></h3><P CLASS=para>In addition to domain-basedsecurity, most HTTP servers also support a morecomplicated method of security, known as user authentication. Whenconfigured for user authentication, specified files or directoriesare set up to allow access only by certain users. A user attemptingto open the URLs associated with these files is prompted for a nameand password.<P CLASS=para>The user name and password(which, incidentally, need have no relation to the user's real username and password on any system) is checked by the server, and iflegitimate, the user is allowed access. In addition to allowingthe user access to the protected file, the server also maintainsthe user's name and passes it to any subsequent CGI programs thatare called. The server passes the user name in the REMOTE_USER environment variable.<P CLASS=para>A CGI script can therefore use server authentication informationto identify users.[1]This isn't what user authentication was meant for, but if the informationis available, it can come in mighty handy. Here is a snippet ofcode that illustrates what you can do with the REMOTE_USERenvironment variable:<blockquote class=footnote><P CLASS=para>[1] The HTTP_FROMenvironment variable also carries information that can be used toidentify a user-generally, the user's email address.  However, thisvariable depends on the browser to make it available, and few browsersdo, so HTTP_FROM is of limited use.</blockquote><DIV CLASS=screen><P><PRE>$remote_user = $ENV{'REMOTE_USER'};if ($remote_user eq "jack") {    print "Welcome Jack, how is Jack Manufacturing doing these days?", "\n";} elsif ($remote_user eq "bob") {    print "Hey Bob, how's the wife doing? I heard she was sick.", "\n";}...</PRE></DIV><P CLASS=para>Server authentication does not provide complete security:Since the user name and password are sent unencrypted over the network,it's possible for a "snoop" to look at this data. For that reason,it's a bad idea to use your real login name and password for serverauthentication.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-2.5">Where Did You Come From?</A></h3><P CLASS=para>Companies who provide services on theWeb often want to know from what server (or document) the remoteusers came. For example, say you visit the server located at http://www.cgi.edu,and then from there you go to http://www.flowers.com. A CGI programon www.flowers.com can actually determine that you were previouslyat www.cgi.edu.<P CLASS=para>How is this useful? For advertising, of course. If a companydetermines that 90% of all users that visit them come from a certainserver, then they can perhaps work something out financially withthe webmaster at that server to provide advertising. Also, if yoursite moves or the content at your site changes dramatically, youcan help avoid frustration among your visitors by informing thewebmasters at the sites referring to yours to change their links.Here is a simple program that displays this "referral" information:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perlprint "Content-type: text/plain", "\n\n";$remote_address = $ENV{'REMOTE_ADDR'};$referral_address = $ENV{'HTTP_REFERER'};print "Hello user from $remote_address!", "\n";print "The last site you visited was: $referral_address. Am I genius or what?", "\n";exit (0);</PRE></DIV><P CLASS=para>The environment variable HTTP_REFERER,which is passed to the server by the client, contains the last sitethe user visited before accessing the current server.<P CLASS=para>Now for the caveats. There are three important things youneed to remember before using the HTTP_REFERERvariable:<P><UL CLASS=itemizedlist><li CLASS=listitem>First, not all browsers set this variable.<P><li CLASS=listitem>Second, if a user accesses your server first, rightat startup, this variable will not be set.<P><li CLASS=listitem>Third, if someone accesses your site via a bookmarkor just by typing in the URL, the referring document is meaningless.So if you are keeping some sort of count to determine where usersare coming from, it won't be totally accurate. <P></UL></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_01.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch02_03.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Introduction</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Accessing Form Input</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>