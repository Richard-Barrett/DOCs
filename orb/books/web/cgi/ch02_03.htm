<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 2] 2.3 Accessing Form Input</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:21:08 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 2</b></td><td width=172 align=right valign=top><A HREF="ch02_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-3">2.3 Accessing Form Input</A></h2><P CLASS=para>Finally, let'sget to form input. We mentioned forms briefly in <A HREF="ch02_01.htm">Chapter 2, <i>Input to the Common Gateway Interface</i></A>, and we'll coverthem in more detail in <A HREF="ch04_01.htm">Chapter 4, <i>Forms and CGI</i></A>.But here, we just want to introduce you to the basic concepts behindforms.<P CLASS=para>As we described in Chapter 1, forms provide a way to get inputfrom users and supply it to a CGI program, as shown in <A HREF="ch02_03.htm#CGI-CHP-2-FIG-1">Figure 2.1</A>.The Web browser allows the user to select or type in information,and then sends it to the server when the Submit button is pressed.In this chapter, we'll talk a little about how the CGI program accessesthe form input.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-2-FIG-1">Figure 2-1: Form interaction with CGI</A></h4><p><img align=middle src="./figs/cgi0201.gif" alt="[Graphic: Figure 2-1]" width=502 height=423></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-3.1">Query Strings</A></h3><P CLASS=para>Oneway to send form data to a CGI program is by appending the forminformation to the URL, after a question mark. You may have seenURLs like the following:<DIV CLASS=screen><P><PRE>http://some.machine/cgi-bin/name.pl?fortune</PRE></DIV><P CLASS=para>Up to the question mark (?), the URL should lookfamiliar. It is merely a CGI script being called, by the name name.pl.<P CLASS=para>What's new here is the part after the "?". The informationafter the "?" character is known as a <I CLASS=emphasis>query string</I>.When the server is passed a URL with a query string, it calls theCGI program identified in the first part of the URL (before the"?") and then stores the part after the "?" in the environment variable QUERY_STRING. Thefollowing is a CGI program called name.pl that uses query informationto execute one of three possible UNIX commands.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perlprint "Content-type: text/plain", "\n\n";$query_string = $ENV{'QUERY_STRING'};if ($query_string eq "fortune") {    print `/usr/local/bin/fortune`;} elsif ($query_string eq "finger") {    print `/usr/ucb/finger`;} else {    print `/usr/local/bin/date`;}exit (0);</PRE></DIV><P CLASS=para>You can execute this script as either:<DIV CLASS=screen><P><PRE>http://some.machine/cgi-bin/name.pl?fortunehttp://some.machine/cgi-bin/name.pl?finger</PRE></DIV><P CLASS=para>or<DIV CLASS=screen><P><PRE>http://some.machine/cgi-bin/name.pl</PRE></DIV><P CLASS=para>and you will get different output. The CGI program executesthe appropriate system command (using backtics) and the resultsare sent to standard output. In Perl, you can use backtics to capturethe output from a system command.<DIV CLASS=note><P CLASS=note><BLOCKQUOTE><P><B>NOTE:</B> <P CLASS=para>Youshould always be very careful when executing any type of systemcommands in CGI applications, because of possible security problems.You should never do something like this:</blockquote><P></DIV><DIV CLASS=screen><P><PRE>print `$query_string`;</PRE></DIV><DIV CLASS=note><P CLASS=note><BLOCKQUOTE><P><B>NOTE:</B> <P CLASS=para>The danger is that a diabolical user can enter a dangeroussystem command, such as:</blockquote><P></DIV><DIV CLASS=screen><P><PRE>rm -fr /</PRE></DIV><DIV CLASS=note><P CLASS=note><BLOCKQUOTE><P><B>NOTE:</B> <P CLASS=para>which can delete everything on your system.<P CLASS=para>Nor should you expose any system data, such as a list of systemprocesses, to the outside world.</blockquote><P></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-3.2">A Simple Form</A></h3><P CLASS=para>Although the previous example will work, the following exampleis a more realistic illustration of how forms work with CGI. Insteadof supplying the information directly as part of the URL, we'lluse a form to solicit it from the user.<P CLASS=para>(Don't worry about the HTML tags neededto create the form; they are covered in detail in <A HREF="ch04_01.htm">Chapter 4, <i>Forms and CGI</i></A>.)<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Simple Form!&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Simple Form!&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/unix.pl" METHOD="GET"&gt;Command: &lt;INPUT TYPE="text" NAME="command" SIZE=40&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Submit Form!"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear Form"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>Since this is HTML, the appearance of theform depends on what browser is being used. <A HREF="ch02_03.htm#CGI-CHP-2-FIG-2">Figure 2.2</A> shows whatthe form looks like in Netscape.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-2-FIG-2">Figure 2-2: Simple form in Netscape</A></h4><p><img align=middle src="./figs/cgi0202.gif" alt="[Graphic: Figure 2-2]" width=500 height=235></DIV><P CLASS=para>This form consists of one text field titled "Command:" andtwo buttons. The Submit Form! button is used to send the informationin the form to the CGI program specified by the ACTIONattribute. The Clear Form button clears the information in the field.<P CLASS=para>The METHOD=GET attributeto the &lt;FORM&gt; tag in part determines how the data is passedto the server. We'll talk more about different methods soon, butfor now, we'll use the default method, GET. Now,assuming that the user enters "fortune" into the text field, whenthe Submit Form! button is pressed the browser sends the followingrequest to the server:<DIV CLASS=screen><P><PRE>GET /cgi-bin/unix.pl?command=fortune HTTP/1.0.. (header information).</PRE></DIV><P CLASS=para>The server executes the script called <I CLASS=emphasis>unix.pl</I>in the cgi-bin directory, and places the string "command=fortune"into the QUERY_STRING environment variable. Thinkof this as assigning the variable "command" (specified by the NAMEattribute to the &lt;INPUT&gt; tag) with the string supplied by theuser, "fortune".<DIV CLASS=screen><P><PRE>command=fortune</PRE></DIV><P CLASS=para>Let's go through the simple unix.pl CGI program that handlesthis form:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perlprint "Content-type: text/plain", "\n\n";$query_string = $ENV{'QUERY_STRING'};($field_name, $command) = split (/=/, $query_string);</PRE></DIV><P CLASS=para>After printing the content type (<i CLASS=command>text/plain</i>in this case, since the UNIX programs are unlikelyto produce HTML output) and getting the querystring from the <I CLASS=emphasis>%ENV</I> array, we use the <I CLASS=emphasis>split</I>function to separate the query string on the "=" character intotwo parts, with the first part before the equal sign in <I CLASS=emphasis>$field_name</I>,and the second part in <I CLASS=emphasis>$command</I>. In this case,<I CLASS=emphasis>$field_name</I> will contain "command" and <I CLASS=emphasis>$command</I>will contain "fortune." Now, we're ready to execute the UNIXcommand:<DIV CLASS=screen><P><PRE>if ($command eq "fortune") {    print `/usr/local/bin/fortune`;} elsif ($command eq "finger") {    print `/usr/ucb/finger`;} else {    print `/usr/local/bin/date`;}exit (0);</PRE></DIV><P CLASS=para>Since we used the GET method, all the formdata is included in the URL. So we can directly access this programwithout the form, by using the following URL:<DIV CLASS=screen><P><PRE>http://some.machine/cgi-bin/unix.pl?command=fortune</PRE></DIV><P CLASS=para>It will work exactly as if you had filled out the form andsubmitted it.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-3.3">The GET and POST Methods</A></h3><P CLASS=para>In the previous example, we used the GETmethod to process the form. However, there is another method wecan use, called POST. Using the POST method, the server sends the dataas an input stream to the program. That is, if in the previous examplethe &lt;FORM&gt; tag had read:<DIV CLASS=screen><P><PRE>&lt;FORM ACTION="unix.pl" METHOD="POST"&gt;</PRE></DIV><P CLASS=para>the following request would be sent to the server:<DIV CLASS=screen><P><PRE>POST /cgi-bin/unix.pl HTTP/1.0.. (header information).Content-length: 15command=fortune</PRE></DIV><P CLASS=para>The version of unix.pl that handles the form with POSTdata follows. First, since the server passes information to thisprogram as an input stream, it sets the environment variable CONTENT_LENGTH to the sizeof the data in number of bytes (or characters). We can use thisto read exactly that much data from standard input.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$size_of_form_information = $ENV{'CONTENT_LENGTH'};</PRE></DIV><P CLASS=para>Second, we read the number of bytes, specified by <I CLASS=emphasis>$size_of_form_information</I>,from standard input into the variable <I CLASS=emphasis>$form_info</I>.<DIV CLASS=screen><P><PRE>read (STDIN, $form_info, $size_of_form_information);</PRE></DIV><P CLASS=para>Now we can split the <I CLASS=emphasis>$form_info</I> variableinto a <I CLASS=emphasis>$field_name</I> and <I CLASS=emphasis>$command</I>,as we did in the GET version of this example.As with the GET version, <I CLASS=emphasis>$field_name</I>will contain "command," and <I CLASS=emphasis>$command</I> will contain"fortune" (or whatever the user typed in the text field). The restof the example remains unchanged:<DIV CLASS=screen><P><PRE>($field_name, $command) = split (/=/, $form_info);print "Content-type: text/plain", "\n\n";if ($command eq "fortune") {    print `/usr/local/bin/fortune`;} elsif ($command eq "finger") {    print `/usr/ucb/finger`;} else {    print `/usr/local/bin/date`;}exit (0);</PRE></DIV><P CLASS=para>Since it's the form that determines whether the GETor POST method is used, the CGI programmer can'tcontrol which method the program will be called by. So scripts areoften written to support both methods. The following example willwork with both methods:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$request_method = $ENV{'REQUEST_METHOD'};if ($request_method eq "GET") {	      $form_info = $ENV{'QUERY_STRING'};} else {      $size_of_form_information = $ENV{'CONTENT_LENGTH'};      read (STDIN, $form_info, $size_of_form_information);}($field_name, $command) = split (/=/, $form_info);print "Content-type: text/plain", "\n\n";if ($command eq "fortune") {    print `/usr/local/bin/fortune`;} elsif ($command eq "finger") {    print `/usr/ucb/finger`;} else {    print `/usr/local/bin/date`; }exit (0);</PRE></DIV><P CLASS=para>The environment variable REQUEST_METHODcontains the request method used by the form. In this example, theonly new thing we did was check the request method and then assignthe <I CLASS=emphasis>$form_info</I> variable as needed. </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-2-SECT-3.4">Encoded Data</A></h3><P CLASS=para>So far, we'veshown an example for retrieving very simple form information. However,form information can get complicated. Since under the GETmethod the form information is sent as part of the URL, there can'tbe any spaces or other special characters that are not allowed inURLs. Therefore, some special encoding is used. We'll talk moreabout this in <A HREF="ch04_01.htm">Chapter 4, <i>Forms and CGI</i></A>, but for nowwe'll show a very simple example. First the HTMLneeded to create a form:<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;When's your birthday?&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;When's your birthday?&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/birthday.pl" METHOD="POST"&gt;Birthday (in the form of mm/dd/yy): &lt;INPUT TYPE="text" NAME="birthday" SIZE=40&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Submit Form!"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear Form"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>When the user submits the form, the client issues the followingrequest to the server (assuming the user entered 11/05/73):<DIV CLASS=screen><P><PRE>POST /cgi-bin/birthday.pl HTTP/1.0.. (information).Content-length: 21birthday=11%2F05%2F73</PRE></DIV><P CLASS=para>In the encoded form, certain characters, such as spaces andother character symbols, are replaced by their hexadecimal equivalents.In this example, our program needs to "decode" this data, by convertingthe "%2F" to "/".<P CLASS=para>Here is the CGI program-<I CLASS=emphasis>birthday.pl</I>-thathandles this form:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$size_of_form_information = $ENV{'CONTENT_LENGTH'};read (STDIN, $form_info, $size_of_form_information);</PRE></DIV><P CLASS=para>The following complicated-looking regular expression is usedto "decode" the data (see <A HREF="ch04_01.htm">Chapter 4, <i>Forms and CGI</i></A> fora comprehensive explanation of how this works).<DIV CLASS=screen><P><PRE>$form_info =~ s/%([\dA-Fa-f][\dA-Fa-f])/pack ("C", hex ($1))/eg;</PRE></DIV><P CLASS=para>In the case of this example, it will turn "%2F" into "/".The rest of the program should be easy to follow:<DIV CLASS=screen><P><PRE>($field_name, $birthday) = split (/=/, $form_info);print "Content-type: text/plain", "\n\n";print "Hey, your birthday is on: $birthday. That's what you told me, right?", "\n";  exit (0);  </PRE></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch02_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Using Environment Variables</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Extra Path Information</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>