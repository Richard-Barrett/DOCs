<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 3] 3.4 The Content-length Header</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:22:08 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch03_03.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 3</b></td><td width=172 align=right valign=top><A HREF="ch03_05.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-3-SECT-4">3.4 The Content-length Header</A></h2><P CLASS=para>Asyou've seen in previous examples, we are not limited to dealingjust with HTML text (defined by the MIME type <i CLASS=command>text/html</i>)but we can also output documents formatted in numerous ways, likeplain text, GIF or JPEG images, and even AIFF sound clips. Hereis a program that returns a GIF image:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$gif_image = join ("/", $ENV{'DOCUMENT_ROOT'}, "icons/tiger.gif");if (open (IMAGE, "&lt;" . $gif_image)) {		$no_bytes = (stat ($gif_image))[7];				print "Content-type: image/gif", "\n";		print "Content-length: $no_bytes", "\n\n";</PRE></DIV><P CLASS=para>The first thing to notice is that the content type is <i CLASS=command>image/gif</i>.This signals the browser that a GIF image will be sent, so the browserknows how to display it.<P CLASS=para>The next thing to noticeis the <i CLASS=command>Content-length</i> header. The <i CLASS=command>Content-length</i>header notifies the server of the size of the data that you intendto send. This prevents unexpected end-of-data errors from the serverwhen dealing with binary data, because the server will read thespecified number of bytes from the data stream regardless of anyspurious end-of-data characters.<P CLASS=para>To get the content length, we use the <I CLASS=emphasis>stat</I> command, which returns a 13-elementarray containing the statistics for a given file, to determine thesize of the file. The eighth element of this array (index number7, because arrays are zero-based in Perl) represents the size ofthe file in bytes. The remainder of the script follows:<DIV CLASS=screen><P><PRE>		print &lt;IMAGE&gt;;} else {		print "Content-type: text/plain", "\n\n";		print "Sorry! I cannot open the file $gif_image!", "\n";}exit (0);</PRE></DIV><P CLASS=para>As is the case with binary files, one read on the file handlewill retrieve the entire file. Compare that to text files whereone read will return only a single line. As a result, this exampleis fine when dealing with small graphic files, but is not very efficientwith larger files. Now, we'll look at an example that reads anddisplays the graphic file in small pieces:<DIV CLASS=screen><P><PRE>	#!/usr/local/bin/perl$gif_image = join ("/", $ENV{'DOCUMENT_ROOT'}, "icons/tiger.gif");if (open (IMAGE, "&lt;" . $gif_image)) {		$no_bytes = (stat ($gif_image))[7];		$piece_size = $no_bytes / 10;		print "Content-type: image/gif", "\n";		print "Content-length: $no_bytes", "\n\n";		for ($loop=0; $loop &lt;= $no_bytes; $loop += $piece_size) {       			read (IMAGE, $data, $piece_size);			print $data;		}		 close (IMAGE);} else {		print "Content-type: text/plain", "\n\n";		print "Sorry! I cannot open the file $gif_image!", "\n";}exit (0);</PRE></DIV><P CLASS=para>The loop iterates through the file reading and displayingpieces of data that are one-tenth the size of the entire binaryfile.<P CLASS=para>As you will see in the following section, you can use serverredirection to return existing files much more quickly and easilythan with CGI programs like the ones described earlier.</DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch03_03.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch03_05.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Accept Types and Content Types</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Server Redirection</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>