<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 4] 4.3 Designing Applications Using Forms in Perl</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:24:12 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 4</b></td><td width=172 align=right valign=top><A HREF="ch04_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-4-SECT-3">4.3 Designing Applications Using Forms in Perl</A></h2><P CLASS=para>Here is a simple form that prompts fora name:<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Testing a Form&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Testing a Form&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/greeting.pl" METHOD="POST"&gt;Enter your full name: &lt;INPUT TYPE="text" NAME="user" SIZE=60&gt;&lt;BR&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Submit the form"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>The form consists of an input field and the Submit and Resetbuttons.<P CLASS=para>Now, here is the Perl program to decode the information andprint a greeting:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$webmaster = "shishir\@bu.edu";&amp;parse_form_data (*simple_form);</PRE></DIV><P CLASS=para>The subroutine <I CLASS=emphasis>parse_form_data</I> decodesthe form information. Here, the main program passes the subroutinea reference to a variable named <I CLASS=emphasis>simple_form</I>.The subroutine treats it as an associative array (a common datatype in Perl) and fills it with key-value pairs sent by the browser.We will see how <I CLASS=emphasis>parse_form_data</I> works later;the important thing right now is that we can easily get the nameof the user entered into the form.<P CLASS=para>You may find it confusing, trying to track what happens tothe information entered by the user. The user fills out the forms,and the browser encodes the information into a string of key-valuepairs. If the request method is POST, the serverpasses the information as standard input to the CGI program. Ifthe request method is GET, the server storesthe information in an environment variable, QUERY_STRING.In either case, <I CLASS=emphasis>parse_form_data</I> retrieves thedata, breaks it into key-value pairs, and stores it into an associativearray. The main program can then extract any information that youwant.<DIV CLASS=screen><P><PRE>print "Content-type: text/plain", "\n\n";$user = $simple_form{'user'};if ($user) {    print "Nice to meet you ", $simple_form{'user'}, ".", "\n";    print "Please visit this Web server again!", "\n";} else {    print "You did not enter a name. Are you shy?", "\n";    print "But, you are welcome to visit this Web server again!", "\n";}exit(0);</PRE></DIV><P CLASS=para>The main program now extracts the user name from the arraythat <I CLASS=emphasis>parse_form_data</I> filled in. If you go backand look at the form, you'll find it contained an &lt;INPUT&gt; tagwith a NAME attribute of "user." The value "user"becomes the key in the array. That is why this program checks forthe key "user" and extracts the value, storing it in a variablethat also happens to be named "user."<P CLASS=para>The conditional checks to see if the user entered any information.One of two possible greetings is printed out. It is always veryimportant to check the form values to make sure there is no erroneousinformation. For example, if the user entered "John Doe" the outputwould be:<DIV CLASS=screen><P><PRE>Nice to meet you John Doe.Please visit this Web server again!</PRE></DIV><P CLASS=para>On the other hand, if the user did not enter any data intothe input field, the response would be:<DIV CLASS=screen><P><PRE>You did not enter a name. Are you shy?But, you are welcome to visit this Web server again!</PRE></DIV><P CLASS=para>Now, let's look at the core of this program: the subroutinethat does all of the work.<DIV CLASS=screen><P><PRE>sub parse_form_data{    local (*FORM_DATA) = @_;    local ( $request_method, $query_string, @key_value_pairs,		          $key_value, $key, $value);</PRE></DIV><P CLASS=para>The local variable FORM_DATA is a reference(or, in Perl terms, a glob) to the argument passed to the subroutine.In our case, FORM_DATA is a reference to the<I CLASS=emphasis>simple_form</I> associate array. Why did we passa reference with an asterisk (*<I CLASS=emphasis>simple_form</I>)instead of just naming the array (<I CLASS=emphasis>simple_form</I>)?The reasoning will be a little hard to follow if you are not familiarwith programming, but I will try to explain. If I passed <I CLASS=emphasis>simple_form</I>without the asterisk, the subroutine would not be able to pass informationback to the main program in that array (it could return it in anotherarray, but that is a different matter). This would be pretty silly,since the array is empty to start with and the only purpose of thesubroutine is to fill it.<P CLASS=para>As you can see, the first thing I do is create another referenceto the array, FORM_DATA<I CLASS=emphasis>.</I>This means that FORM_DATA and <I CLASS=emphasis>simple_form</I>share the same memory, and any data I put in FORM_DATAcan be extracted by the main program from <I CLASS=emphasis>simple_form</I>.You will see that the subroutine does all further operations onFORM_DATA; this is the same as doing them on<I CLASS=emphasis>simple_form</I>.<P CLASS=para>Now let's continue with the rest of this subroutine.<DIV CLASS=screen><P><PRE>    $request_method = $ENV{'REQUEST_METHOD'};    if ($request_method eq "GET") {        $query_string = $ENV{'QUERY_STRING'};    } elsif ($request_method eq "POST") {        read (STDIN, $query_string, $ENV{'CONTENT_LENGTH'});    } else {        &amp;return_error (500, "Server Error",                            "Server uses unsupported method");    }</PRE></DIV><P CLASS=para>The request method is obtained. If it is a GETrequest, the query string is obtained from the environment variableand stored in query_string.However, if it is a POST request, the amountof data sent by the client is read from STDINwith the <I CLASS=emphasis>read</I> command and stored in <I CLASS=emphasis>query_string</I>.If the request protocol is not one of the two discussed earlier,an error is returned. Notice the <I CLASS=emphasis>return_error</I>subroutine, which is used to return an error to the browser. Thethree parameters represent the status code, the status keyword,and the error message, respectively.<DIV CLASS=screen><P><PRE>    @key_value_pairs = split (/&amp;/, $query_string);    foreach $key_value (@key_value_pairs) {        ($key, $value) = split (/=/, $key_value);        $value =~ tr/+/ /;        $value =~ s/%([\dA-Fa-f][\dA-Fa-f])/pack ("C", hex ($1))/eg;</PRE></DIV><P CLASS=para>Since the client puts ampersands between key-value pairs, the <I CLASS=emphasis>split</I> command specifies an ampersand as thedelimiter. The result is to fill the array <I CLASS=emphasis>key_value_pairs</I>with entries, where each key-value pair is stored in a separatearray element. In the loop, each key-value pair is again split intoa separate key and value, where an equal sign is the delimiter.The <I CLASS=emphasis>tr</I>(for translate) operator replaces each "+" with the space character.The regular expression within the <P CLASS=para><I CLASS=emphasis>s</I> (for substitute) operator looks for an expressionthat starts with the "%" sign and is followed by two characters.These characters represent the hexadecimal value. The parenthesesin the regexp instruct Perl to store these characters in a variable($1). The <I CLASS=emphasis>pack</I>and <I CLASS=emphasis>hex</I> commands convert the value stored in$1 to an ASCII equivalent. Finally, the "e" <P CLASS=para>option evaluates thesecond part of the substitute command-the replacement string-asan expression, and the "g" option replaces all occurrences of thehexadecimal string. If you had remained unconvinced up to now of Perl's power as a languagefor CGI, this display of text processing (similar to what thousandsof CGI programmers do every day) should change your mind.<DIV CLASS=screen><P><PRE>        if (defined($FORM_DATA{$key})) {            $FORM_DATA{$key} = join ("\0", $FORM_DATA{$key}, $value);        } else {			        $FORM_DATA{$key} = $value;        }    }}</PRE></DIV><P CLASS=para>When multiple values are selected in a scrolled list and submitted,each value will contain the same variable name. For example, ifyou choose "One" and "Two" in a scrolled list with the variablename "Numbers," the query string would look like:<DIV CLASS=screen><P><PRE>Numbers=One&amp;Numbers=Two</PRE></DIV><P CLASS=para>The conditional statement above is used in cases like these. Ifa variable name exists-indicating a scrolled list with multipleoptions-each value is concatenated with the "\0" separator. Now,here is the <I CLASS=emphasis>return_error</I> subroutine:<DIV CLASS=screen><P><PRE>sub return_error{    local ($status, $keyword, $message) = @_;    print "Content-type: text/html", "\n";    print "Status: ", $status, " ", $keyword, "\n\n";    print &lt;&lt;End_of_Error;&lt;HTML&gt;&lt;HEAD&gt;    &lt;TITLE&gt;CGI Program - Unexpected Error&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;$keyword&lt;/H1&gt;&lt;HR&gt;$message&lt;HR&gt;Please contact $webmaster for more information.&lt;/BODY&gt;&lt;/HTML&gt;End_of_Error    exit(1);}</PRE></DIV><P CLASS=para>This subroutine can be used to return an error status.Since the program handles both GET and POSTqueries, you can send a query to it directly:<DIV CLASS=screen><P><PRE>&lt;A HREF="/cgi-bin/program.pl?user=John+Doe"&gt;Hello&lt;/A&gt;</PRE></DIV><P CLASS=para>The program will display the same output as before. <DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-4-SECT-3.1">Combining Graphics and Queries</A></h3><P CLASS=para>It's simple to return graphical output when you process a form-infact you can "bundle" the whole program up in an image, using theHTML tag IMG. Let's see how to do this. First,we'll start with a form that's just a little more complicated thanthe previous form:<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Color Text&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Color Text&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/gd_text.pl" METHOD="POST"&gt;This form makes it possible to display color text and messages.&lt;BR&gt;What message would you like to display: &lt;BR&gt;&lt;INPUT TYPE="text" NAME="message" SIZE=60&gt;&lt;BR&gt;What is your favorite color: &lt;SELECT NAME="color" SIZE=1&gt;&lt;OPTION SELECTED&gt;Red&lt;OPTION&gt;Blue&lt;OPTION&gt;Green&lt;OPTION&gt;Yellow&lt;OPTION&gt;Orange&lt;OPTION&gt;Purple&lt;OPTION&gt;Brown&lt;OPTION&gt;Black&lt;/SELECT&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Submit the form"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;	&lt;/HTML&gt;</PRE></DIV><P CLASS=para>This displays a form with one text field and a menu, alongwith the customary Submit and Reset buttons. The form and the programallow you to display color text in the browser's window. For example,if you want a red headline in your document, you can fill out theform or access the program directly:<DIV CLASS=screen><P><PRE>&lt;IMG SRC="/cgi-bin/gd_text.pl?message=Welcome+to+this+Web+server&amp;color=Red&gt;</PRE></DIV><P CLASS=para>This will place the GIF image with the message "Welcome tothis Web server" in red into your HTML document.Now, here's the program:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl5use GD;$| = 1;$webmaster = "shishir\@bu\.edu";print "Content-type: image/gif", "\n\n";&amp;parse_form_data (*color_text);$message = $color_text{'message'};$color = $color_text{'color'};if (!$message) {    $message = "This is an example of " . $color . " text";}</PRE></DIV><P CLASS=para>The form data is parsed and placed in the color_text associative array.The selected text and color are stored in <I CLASS=emphasis>$message</I>,and <I CLASS=emphasis>$color</I>, respectively. If the user did notenter any text, a default message is chosen.<P CLASS=para>This program uses the <I CLASS=emphasis>gd</I> graphics library,which we discuss more fully in <A HREF="ch06_01.htm">Chapter 6, <i>Hypermedia Documents</i></A>.<DIV CLASS=screen><P><PRE>$font_length = 8;$font_height = 16;$length = length ($message);$x = $length * $font_length;$y = $font_height;$image = new GD::Image ($x, $y);</PRE></DIV><P CLASS=para>The length of the user-specified string is determined. A newimage is created based on this length.<DIV CLASS=screen><P><PRE>$white = $image-&gt;colorAllocate (255, 255, 255);if ($color eq "Red") {    @color_index = (255, 0, 0);} elsif ($color eq "Blue") {    @color_index = (0, 0, 255);} elsif ($color eq "Green") {    @color_index = (0, 255, 0);} elsif ($color eq "Yellow") {    @color_index = (255, 255, 0);} elsif ($color eq "Orange") {    @color_index = (255, 165, 0);} elsif ($color eq "Purple") {    @color_index = (160, 32, 240);} elsif ($color eq "Brown") {    @color_index = (165, 42, 42);} elsif ($color eq "Black") {    @color_index = (0, 0, 0);}$selected_color = $image-&gt;colorAllocate (@color_index);$image-&gt;transparent ($white);</PRE></DIV><P CLASS=para>Red, Green, and Blue (RGB) values for the user-selected colorare stored in the <I CLASS=emphasis>color_index</I> array. If nocolor is selected manually, the default is Red, as specified inthe form. If you want to add more colors, look in <I CLASS=emphasis>/usr/local/X11/lib/rgb.txt</I>for a list of the common colors. The <I CLASS=emphasis>transparent</I>function makes the image background transparent.<DIV CLASS=screen><P><PRE>$image-&gt;string (gdLargeFont, 0, 0, $message, $selected_color);print $image-&gt;gif;exit(0);</PRE></DIV><P CLASS=para>The text is displayed using the <I CLASS=emphasis>string</I>operator, and the image is printed to standard output. As discussedin the previous example, you can also access this program with aGET request.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch04_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Sending Data to the Server</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Decoding Forms in Other Languages</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>