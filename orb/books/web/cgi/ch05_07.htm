<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 5] 5.7 Executing CGI Programs</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:25:53 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch05_06.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 5</b></td><td width=172 align=right valign=top><A HREF="ch05_08.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-5-SECT-7">5.7 Executing CGI Programs</A></h2><P CLASS=para>You can use Server Side Includes to embedthe results of an entire CGI program into a static HTMLdocument, using the exec cgi directive.<P CLASS=para>Why would you want to do this? There are many times when youwant to display just one piece of dynamic data, such as:<DIV CLASS=screen><P><PRE>This page has been accessed 4883 times since December 10, 1995. </PRE></DIV><P CLASS=para>Surely, you've seen this type of information in many documentsaround the Web. Obviously, this information is being generated dynamically(since it changes every time you access the document). We'll showyou a few examples of embedded CGI programs using SSI.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-5-SECT-7.1">User Access Counter</A></h3><P CLASS=para>Suppose you have a simple CGIprogram that keeps track of the number of visitors, called by the<I CLASS=emphasis>exec</I> SSI command in an HTMLdocument:<DIV CLASS=screen><P><PRE>This page has been accessed &lt;!--#exec cgi="/cgi-bin/counter.pl"--&gt; times.</PRE></DIV><P CLASS=para>The idea behind an access counter is simple. A data file onthe server contains a count of the number of visitors that haveaccessed a particular document. Whenever a user visits the document,the SSI command in that document calls a CGI program that readsthe numerical value stored in the file, increments it, and writesthe new information back to the file and outputs it. Let's lookat the program:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perlprint "Content-type: text/plain", "\n\n";$count_file = "/usr/local/bin/httpd_1.4.2/count.txt";if (open (FILE, "&lt;" . $count_file)) {		$no_accesses = &lt;FILE&gt;;		close (FILE);		if (open (FILE, "&gt;" . $count_file)) {			$no_accesses++;			print FILE $no_accesses;			close (FILE);			print $no_accesses;		} else {			print "[ Can't write to the data file! Counter not incremented! ]", "\n";		}} else {		print "[ Sorry! Can't read from the counter data file ]", "\n";}exit (0);</PRE></DIV><P CLASS=para>Since we are opening the data file from this program, we needthe full path to the file. We can then proceed to try to read fromthe file. If the file cannot be opened, an error message is returned.Otherwise, we read one line from the file using the &lt;FILE&gt;notation, and store it in the variable <I CLASS=emphasis>$no_accesses</I>.Then, the file is closed. This is very important because you cannotwrite to the file that was opened for reading.<P CLASS=para>Once that's done, the file is opened again, but this timein write mode, which creates a new file with no data. If that'snot successful, probably due to permission problems, an error messagestating that information cannot be written to the file is output.If there are no problems, we increment the value stored in <I CLASS=emphasis>$no_accesses</I>.This new value is written to the file and printed to standard output.<P CLASS=para>Notice how this program, like other CGI programs we've coveredup to this point, also outputs a <i CLASS=command>Content-type</i>HTTP header. In this case, a <i CLASS=command>text/plain</i>MIME content type is output by the program.<P CLASS=para>An important thing to note is that a CGI program called byan SSI directive cannot output anything other than text becausethis data is embedded within an HTML or plaindocument that invoked the directive. As a result, it doesn't matterwhether you output a content type of <i CLASS=command>text/plain</i>or <i CLASS=command>text/html</i>, as the browser will interpret thedata within the scope of the calling document. Needless to say,your CGI program cannot output graphic images or other binary data.<P CLASS=para>This CGI program is not as sophisticated as it should be.First, if the file does not exist, you will get an error if youopen it in read mode. So, you must put some initial value in thefile manually, and set permissions on the file so that the CGI programcan write to it:<DIV CLASS=screen><P><PRE>% echo "0" &gt; /usr/local/bin/httpd_1.4.2/count.txt% chmod 666 /usr/local/bin/httpd_1.4.2/count.txt</PRE></DIV><P CLASS=para>These shell commands write an initial value of "0" to the<I CLASS=emphasis>count.txt</I> file, and set the permissions sothat all processes can read from and write to the file. Remember,the HTTP server is usually run by a process withminimal privileges (e.g., "nobody" or "www"), so the permissionson the data file have to be set so that this process can read andwrite to it.<P CLASS=para>The other major problem with this CGI program is that it doesnot lock and unlock the counter data file. This is extremely importantwhen you are dealing with concurrent users accessing your documentat the same time. A good CGI program must try to lock a data filewhen in use, and unlock it after it is done with processing. A moreadvanced CGI program that outputs a graphic counter is presentedin <A HREF="ch06_01.htm">Chapter 6, <i>Hypermedia Documents</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-5-SECT-7.2">Random Links</A></h3><P CLASS=para>Youcan use the following CGI program to create a "random" hypertextlink. In other words, the link points to a different WWW site everytime you reload.<P CLASS=para>Why do you want to do this? Well, for kicks. Also, if thesites are actually mirrors of each other, so it doesn't matter whichone you refer people to. By changing the link each time, you'rehelping to spread out the traffic generated from your site.<P CLASS=para>Place the following line in your HTML document:<DIV CLASS=screen><P><PRE>&lt;!--#exec cgi="/cgi-bin/random.pl"--&gt;</PRE></DIV><P CLASS=para>Here's the program:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl@URL = ("http://www.ora.com",        "http://www.digital.com",        "http://www.ibm.com",        "http://www.radius.com");srand (time | $$);</PRE></DIV><P CLASS=para>The @URL array (or table) contains a list of the sites thatthe program will choose from. The <I CLASS=emphasis>srand</I> functionsets a seed based on the current time and the process identificationfor the random number generator. This ensures a truly random distribution.<DIV CLASS=screen><P><PRE>$number_of_URL = scalar (@URL);$random = int (rand ($number_of_URL));</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>$number_of_URL</I> contains the index(or position) of the last URL in the array. In Perl, arrays arezero-based, meaning that the first element has an index of zero.We then use the <I CLASS=emphasis>rand</I> function to get a randomnumber from 0 to the index number of the last URL in the array.In this case, the variable <I CLASS=emphasis>$random</I> will containa random integer from 0 to 3.<DIV CLASS=screen><P><PRE>$random_URL = $URL[$random];print "Content-type: text/html", "\n\n";print qq|&lt;A HREF="$random_URL"&gt;Click here for a random Web site!&lt;/A&gt;|, "\n";exit (0);</PRE></DIV><P CLASS=para>A random URL is retrieved from the array and displayed asa hypertext link. Users can simply click on the link to travel toa random location.<P CLASS=para>Before we finish, let's look at one final example: a CGI programthat calculates the number of days until a certain event.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-5-SECT-7.3">Counting Days Until . . .</A></h3><P CLASS=para>Remember we talkedabout query strings as a way of passing information to a CGI programin <A HREF="ch02_01.htm">Chapter 2, <i>Input to the Common Gateway Interface</i></A>? Unfortunately, you cannotpass query information as part of an SSI <I CLASS=emphasis>exec cgi</I>directive. For example, you cannot do the following:<DIV CLASS=screen><P><PRE>&lt;!--#exec cgi="/cgi-bin/count_days.pl?4/1/96"--&gt;</PRE></DIV><P CLASS=para>The server will return an error.[1]<blockquote class=footnote><P CLASS=para>[1] However, aCGI program called by the <I CLASS=emphasis>exec</I> SSI directivefrom a static HTML document has access to thequery string passed to this document. For example, if you accessan HTML document in the following manner:<DIV CLASS=screen><P><PRE>http://some.machine/test.html?name=john</PRE></DIV>andthis document contains an SSI directive, then the CGI program canaccess the query string ("name=john") by reading the QUERY_STRINGenvironment variable.</blockquote><P CLASS=para>However, we can create a regular Perl program (<I CLASS=emphasis>not</I>a CGI program) that takes a date as an argument, and calculatesthe number of days until/since that date:<DIV CLASS=screen><P><PRE>&lt;!--#exec cmd="/usr/local/bin/httpd_1.4.2/count_days.pl  4/1/96"--&gt;</PRE></DIV><P CLASS=para>In the Perl script, we can access this command-line data (i.e.,"4/1/96") through the <I CLASS=emphasis>@ARGV</I> array. Now, thescript:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perlrequire "timelocal.pl";require "bigint.pl";</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>require</I> command makes the functionswithin these two default Perl libraries available to our program.<DIV CLASS=screen><P><PRE>($chosen_date = $ARGV[0]) =~ s/\s*//g;</PRE></DIV><P CLASS=para>The variable <I CLASS=emphasis>$chosen_date</I> contains thedate passed to this program, minus any whitespace that may havebeen inserted accidently.<DIV CLASS=screen><P><PRE>if ($chosen_date =~ m|^(\d+)/(\d+)/(\d+)$|) {    ($month, $day, $year) = ($1, $2, $3);</PRE></DIV><P CLASS=para>This is another example of a regular expression, or <I CLASS=emphasis>regexp</I>.We use the regexp to make sure that the date passed to the programis in a valid format (i.e., <I CLASS=emphasis>mm/dd/yyyy</I>). Ifit is valid, then <I CLASS=emphasis>$month</I>, <I CLASS=emphasis>$day</I>,and <I CLASS=emphasis>$year</I> will contain the separated month,day, and year from the initial date.<DIV CLASS=screen><P><PRE>    $month -= 1;    if ($year &gt; 1900) {        $year -= 1900;     }    $chosen_secs = &amp;timelocal (undef, undef, undef, $day, $month, $year);</PRE></DIV><P CLASS=para>We will use the <I CLASS=emphasis>timelocal</I> subroutine (notice the&amp; in front) to convert the specified date to the number of secondssince 1970. This subroutine expects month numbers to be in the rangeof 0-11 and years to be from 00-99. This conversion makes it easyfor us to subtract dates. An important thing to remember is thatthis program will not calculate dates correctly if you pass in adate before 1970.<DIV CLASS=screen><P><PRE>    $seconds_in_day = 60 * 60 * 24;       $difference = &amp;bsub ($chosen_secs, time);    $no_days = &amp;bdiv ($difference, $seconds_in_day);    $no_days =~ s/^(\+|-)//;</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>bsub</I>subroutine subtracts the current time (in seconds since 1970) fromthe specified time. We used this subroutine because we are dealingwith very large numbers, and a regular subtraction will give incorrectresults. Then, we call the <I CLASS=emphasis>bdiv</I>subroutine to calculate the number of days until/since the specifieddate by dividing the previously calculated difference with the numberof seconds in a day. The <I CLASS=emphasis>bdiv</I> subroutine prefixesthe values with either a "+" or a "-" to indicate positive or negativevalues, respectively, so we remove the extra character.<DIV CLASS=screen><P><PRE>    print $no_days;    exit(0);</PRE></DIV><P CLASS=para>Once we're done with the calculations, we output the calculatedvalue and exit.<DIV CLASS=screen><P><PRE>} else {    print " [Error in date format] ";    exit(1);}</PRE></DIV><P CLASS=para>If the date is not in a valid format, an error message isreturned.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch05_06.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch05_08.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Executing External Programs</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Tailoring SSI Output</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>