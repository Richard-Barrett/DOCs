<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 6] 6.4 CGI Examples with gnuplot</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:27:45 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_03.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 6</b></td><td width=172 align=right valign=top><A HREF="ch06_05.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-6-SECT-4">6.4 CGI Examples with gnuplot</A></h2><P CLASS=para><I CLASS=emphasis>gnuplot</I>is a software application suited for graphing simple numerical information.It has the ability to take raw data and create various types ofgraphs, including point and line graphs and histograms. Let's takea look at an example that illustrates the ease with which we canproduce graphs, especially when compared to PostScript and the <I CLASS=emphasis>gd</I>graphics library.<P CLASS=para>You can get <I CLASS=emphasis>gnuplot</I> from <I CLASS=emphasis>ftp://prep.ai.mit.edu/pub/gnu/gnuplot-3.5.tar.gz.</I><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-6-SECT-4.1">Web Server Accesses</A></h3><P CLASS=para>The followingexample plots the number of Web server accesses for every hour asa histogram. The program parses through the server log file, keepingtrack of the accesses for each hour of the day in an array. Theinformation stored in this array is written to a file in a formatthat <I CLASS=emphasis>gnuplot</I> can understand. We then call <I CLASS=emphasis>gnuplot</I>to graph the data in the file and output the resulting graphic toa file.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$webmaster = "shishir\@bu\.edu";$gnuplot  = "/usr/local/bin/gnuplot";$ppmtogif = "/usr/local/bin/pbmplus/ppmtogif";$access_log = "/usr/local/bin/httpd_1.4.2/logs/access_log";</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>gnuplot</I> utility, as of version v3.5,cannot produce GIF images, but can output PBM (portable bitmap)format files. We'll use the <I CLASS=emphasis>ppmtogif</I> utilityto convert the output image from PBM to GIF. The <I CLASS=emphasis>$access_log</I>variable points to the NCSA server log file,which we'll parse.<DIV CLASS=screen><P><PRE>$process_id = $$;$output_ppm = join ("", "/tmp/", $process_id, ".ppm");$datafile = join ("", "/tmp/", $process_id, ".txt");</PRE></DIV><P CLASS=para>These variables are used to store the temporary files. The<I CLASS=emphasis>$$</I> variable refers to the number of the processrunning this program, as it does in a shell script. I don't carewhat process is running my program, but I can use the number tocreate a filename that I know will be unique, even if multiple instancesof my program run. (Use of the process number for this purpose isa trick that shell programmers have used for decades.) The processidentification is prefixed to each filename.<DIV CLASS=screen><P><PRE>$x = 0.6;$y = 0.6;$color = 1; </PRE></DIV><P CLASS=para>The size of the plot is defined to be 60% of the originalimage in both the x and y directions. All lines in the graph willbe red (indicated by a value of 1).<DIV CLASS=screen><P><PRE>if ( open (FILE, "&lt;" . $access_log) ) {    for ($loop=0; $loop &lt; 24; $loop++) {    $time[$loop] = 0;	}</PRE></DIV><P CLASS=para>We open the NCSA server access log forinput. The format of each entry in the log is:<DIV CLASS=screen><P><PRE>host rfc931 authuser [DD/Mon/YY:hh:mm:ss] "request" status_code bytes</PRE></DIV><P CLASS=para>where:<P><UL CLASS=itemizedlist><li CLASS=listitem><I CLASS=emphasis>host</I> is eitherthe DNS name or the IP address of the remote client<P><li CLASS=listitem><I CLASS=emphasis>rfc931</I> is the remote user (onlyif rfc931 authentication is enabled)<P><li CLASS=listitem><I CLASS=emphasis>authuser</I> is the remote user(only if NCSA server authentication is enabled)<P><li CLASS=listitem><I CLASS=emphasis>DD/Mon/YY</I> is the day, month,and year<P><li CLASS=listitem><I CLASS=emphasis>hh:mm:ss</I> is 24 hour based time<P><li CLASS=listitem><I CLASS=emphasis>"request"</I> is the first lineof the HTTP request<P><li CLASS=listitem><I CLASS=emphasis>status_code</I> is the status identificationreturned by the server<P><li CLASS=listitem><I CLASS=emphasis>bytes</I> is the total number ofbytes sent (not including the HTTP header)<P></UL><P CLASS=para>A 24-element array called <I CLASS=emphasis>@time</I> is initialized.This array will contain the number of accesses for each hour.<DIV CLASS=screen><P><PRE>	while (&lt;FILE&gt;) {		if (m|\[\d+/\w+/\d+:([^:]+)|) {			 $time[$1]++;		}	}	close (FILE);</PRE></DIV><P CLASS=para>In case you didn't believe me when I said in <A HREF="ch06_01.htm">Chapter 6, <i>Hypermedia Documents</i></A> that Perl offered superb facilities for CGI programming,this tiny loop contains some proof of what I'm talking about. Theregular expression (containing some enhancements that only Perloffers) neatly picks the hour out of the date/time string in theaccess log by searching for the pattern "[DD/Mon/YY:h:", as follows:<p><img align=middle src="./figs/cgi0605.gif" alt="[Graphic: Figure from the text]" width=414 height=368><P CLASS=para>Back to the program. If a line matches the pattern, the arrayelement corresponding to the particular hour is incremented.<DIV CLASS=screen><P><PRE>	&amp;create_output_file();</PRE></DIV><P CLASS=para>The subroutine <I CLASS=emphasis>create_output_file</I> iscalled to create and display the plot.<DIV CLASS=screen><P><PRE>} else {    &amp;return_error (500, "Server Log File Error", "Cannot open NCSA server access log!");}exit(0);</PRE></DIV><P CLASS=para>If the log file can't be opened, the return_error subroutine is calledto output an error.<P CLASS=para>The <I CLASS=emphasis>create_output_file</I> subroutine isnow defined. It creates a data file consisting of the informationin the <I CLASS=emphasis>@time</I> array.<DIV CLASS=screen><P><PRE>sub create_output_file {    local ($loop);    if ( (open (FILE, "&gt;" . $datafile)) ) {        for ($loop=0; $loop &lt; 24; $loop++) {        print FILE $loop, " ", $time[$loop], "\n";        }        close (FILE);		        &amp;send_data_to_gnuplot();    } else {        &amp;return_error (500, "Server Log File Error", "Cannot write to data file!");	}}</PRE></DIV><P CLASS=para>The file specified by the variable <I CLASS=emphasis>$datafile</I>is opened for output. The hour and the number of accesses for thathour are written to the file. The hour represents the x coordinate,while the number of accesses represents the y coordinate. The subroutine<I CLASS=emphasis>send_data_to_gnuplot</I> is called to execute <I CLASS=emphasis>gnuplot</I>.<DIV CLASS=screen><P><PRE>sub send_data_to_gnuplot{    open (GNUPLOT, "|$gnuplot");    print GNUPLOT &lt;&lt;gnuplot_Commands_Done;</PRE></DIV><P CLASS=para>We're going to use the same technique we've used throughoutthe chapter to embed a "language" within a Perl script: We'll opena pipe to a program and write out commands in the language recognizedby the program. The <I CLASS=emphasis>open</I> command starts <I CLASS=emphasis>gnuplot</I>,and the <I CLASS=emphasis>print</I> command sends the data to <I CLASS=emphasis>gnuplot</I>through the pipe.<DIV CLASS=screen><P><PRE>    set term pbm color small    set output "$output_ppm"    set size $x, $y    set title "WWW Server Usage"    set xlabel "Time (Hours)"    set ylabel "No. of Requests"     set xrange [-1:24]    set xtics 0, 2, 23    set noxzeroaxis    set noyzeroaxis    set border    set nogrid    set nokey    plot "$datafile" w boxes $colorgnuplot_Commands_Doneclose (GNUPLOT);</PRE></DIV><P CLASS=para>Let's take a closer look at the commands that we send to <I CLASS=emphasis>gnuplot</I>through the pipe. The <I CLASS=emphasis>set term</I> command setsthe format for the output file. In this case, the format is a colorPBM file with a small font for titles. You can even instruct <I CLASS=emphasis>gnuplot</I>to produce text graphs by setting the <I CLASS=emphasis>term</I>to "dumb."<P CLASS=para>The output file is set to the filename stored in the variable<I CLASS=emphasis>$output_ppm</I>. The size of the image is set usingthe <I CLASS=emphasis>size</I> command. The title of the graph andthe labels for the x and y axes are specified with the <I CLASS=emphasis>title</I>,<I CLASS=emphasis>xlabel</I>, and <I CLASS=emphasis>ylabel</I> commands,respectively. The range on the x axis is -1 to 24. Even though weare dealing with data from 0 to 23 hours, the range is increasedbecause <I CLASS=emphasis>gnuplot</I> graphs data near the axes abnormally.The tick marks on the x axis range from 0 to 23 in increments oftwo. The line representing the y axis is removed by the <I CLASS=emphasis>noyzeroaxis</I>command, which makes the graph appear neater. The same is true forthe <I CLASS=emphasis>noxzeroaxis</I> command.<P CLASS=para>The graph is drawn with a border, but without a grid or alegend. Finally, the <I CLASS=emphasis>plot</I> command graphs thedata in the file specified by the <I CLASS=emphasis>$datafile</I>variable with red boxes. Several different types of graphs are possible;instead of boxes, you can try "lines" or "points."<DIV CLASS=screen><P><PRE>		&amp;print_gif_file_and_cleanup();}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>print_gif_file_and_cleanup</I> subroutinedisplays this image, and removes the temporary files.<DIV CLASS=screen><P><PRE>sub print_gif_file_and_cleanup{	$| = 1;	print "Content-type: image/gif", "\n\n";	system ("$ppmtogif $output_ppm 2&gt; /dev/null");	unlink $output_ppm, $datafile;}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>system</I>command executes the <I CLASS=emphasis>ppmtogif</I> utility to convertthe PBM image to GIF. This utility writes the output directly tostandard output.<P CLASS=para>You might wonder what the <I CLASS=emphasis>2&gt;</I> signifies.Like most utilities, <I CLASS=emphasis>ppmtogif</I>prints some diagnostic information to standard error when transformingthe image. The <I CLASS=emphasis>2&gt;</I> redirects standard errorto the null device (<I CLASS=emphasis>/dev/null</I>), basically throwingit away.<P CLASS=para>Finally, we use the <I CLASS=emphasis>unlink</I> command toremove the temporary files that we've created.<P CLASS=para>The image produced by this program is shown in <A HREF="ch06_04.htm#CGI-CHP-6-FIG-5">Figure 6.5</A>.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-6-FIG-5">Figure 6-5: gnuplot graph</A></h4><p><img align=middle src="./figs/cgi0606.gif" alt="[Graphic: Figure 6-5]" width=414 height=368></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_03.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch06_05.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>The <I CLASS=emphasis>gd</I> Graphics Library</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>CGI Examples with pgperl</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>