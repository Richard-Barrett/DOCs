<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 6] 6.5 CGI Examples with pgperl</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:27:47 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_04.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 6</b></td><td width=172 align=right valign=top><A HREF="ch06_06.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-6-SECT-5">6.5 CGI Examples with pgperl</A></h2><P CLASS=para><I CLASS=emphasis>gnuplot</I>is concise and fun for throwing up a few charts, but for sophisticatedplotting you may want a more powerful package called <I CLASS=emphasis>pgperl</I>.This is a derivative of Perl that supports the PGPLOTFORTRAN plotting library. Typically it has beenused to plot astronomical data, but you can use it to graph anytype of data.<P CLASS=para>You can get <I CLASS=emphasis>pgperl</I> from <I CLASS=emphasis>http://www.ast.cam.ac.uk/~kgb/pgperl.html.</I><P CLASS=para>What does <I CLASS=emphasis>pgperl</I> offer that <I CLASS=emphasis>gnuplot</I>doesn't? <I CLASS=emphasis>pgperl</I> contains many powerful plottingfunctions (all beginning with the prefix "pg"), such as a varietyof histograms and mapped contours, which <I CLASS=emphasis>gnuplot</I>doesn't have. Another important consideration is that the <I CLASS=emphasis>pgperl</I>graphic routines are incorporated straight into Perl, and thus thereis no need to work with temporary files or pipes. Let's take a lookat a <I CLASS=emphasis>pgperl</I> example that graphs the informationin the NCSA server log file.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-6-SECT-5.1">Web Server Accesses</A></h3><P CLASS=para>Here is a <I CLASS=emphasis>pgperl</I> program that is similarin functionality to the <I CLASS=emphasis>gnuplot</I> example above.It is intended to show you the differences between <I CLASS=emphasis>gnuplot</I>and <I CLASS=emphasis>pgperl</I>.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/pgperlrequire "pgplot.pl";$webmaster = "shishir\@bu\.edu";$access_log = "/usr/local/bin/httpd_1.4.2/logs/access_log";</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>require</I> command includes the <I CLASS=emphasis>pgperl</I>header file that consists of various PGPLOT functions.<DIV CLASS=screen><P><PRE>$hours = 23;$maximum = 0;</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>$maximum</I> variable represents themaximum y coordinate when we plot the histogram. It sets the rangeon the y axis.<DIV CLASS=screen><P><PRE>$process_id = $$;$output_gif = join ("", "/tmp/", $process_id, ".gif");</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>output_gif</I> variable is used to storethe name of a temporary file that will contain the GIF image.<DIV CLASS=screen><P><PRE>if ( (open(FILE, "&lt;" . $access_log)) ) {	for ($loop=0; $loop &lt;= $hours; $loop++) { 		   $time[$loop] = 0; 		   $counter[$loop] = $loop;	}</PRE></DIV><P CLASS=para>Two arrays are initialized to hold the hour and access data.The <I CLASS=emphasis>@time</I> array holds the number of accessesfor each hour, and the <I CLASS=emphasis>@counter</I> array representsthe hours (0-23).<DIV CLASS=screen><P><PRE>	while (&lt;FILE&gt;){ 		if (m|\[\d+/\w+/\d+:([^:]+)|) {			 $time[$1]++;		}}</PRE></DIV><P CLASS=para>A regular expression identical to the one presented in thelast example is used to determine the number of accesses for eachhour.<DIV CLASS=screen><P><PRE>    close (FILE);    &amp;find_maximum();    &amp;prepare_graph();} else {	&amp;return_error (500, "Server Log File Error", "Cannot open NCSA server access log!");}exit(0);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>find_maximum</I> subroutine determinesthe maximum y value-or the hour that had the most accesses. Andthe <I CLASS=emphasis>prepare_graph</I> subroutine calls the various<I CLASS=emphasis>pgperl</I> routines to graph the data.<DIV CLASS=screen><P><PRE>sub find_maximum{    for ($loop=0; $loop &lt;= $hours; $loop++) {        if ($time[$loop] &gt; $maximum) {        $maximum = $time[$loop];		}    }    $maximum += 10;}</PRE></DIV><P CLASS=para>Initially, the maximum value is set to zero. The number ofaccesses for each hour is checked against the current maximum valueto determine the absolute maximum. Finally, the maximum value isincremented by 10 so the histogram doesn't look cramped. In otherwords, the range on the y axis will be 10 greater than the maximumvalue that falls on the axis.<DIV CLASS=screen><P><PRE>sub prepare_graph{	    &amp;pgbegin (0, "${output_gif}/VGIF", 1, 1);    &amp;pgscr (0, 1, 1, 1);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>pgbegin</I>function creates a portrait GIF image with a black background andstores it in the file specified by <I CLASS=emphasis>$output_gif</I>.The first argument is reserved for future use, and is currentlyignored. The third and fourth arguments specify the number of graphsthat should fit horizontally and vertically, respectively, in theimage. Finally, the <I CLASS=emphasis>pgscr</I>function remaps a color index. In this case, we are remapping colorzero (black) to one (white). Unfortunately, this is the only wayto change the background color.<DIV CLASS=screen><P><PRE>&amp;pgpap (4.0, 1.0);</PRE></DIV><P CLASS=para><I CLASS=emphasis>pgpap</I>is used to change the width and aspect ratio (width / height) ofthe image. Normally, the image size is 8.5 x 11 inches in portraitmode. An aspect ratio is the ratio between the x axis and the yaxis; 1.0 produces a square image. For example, an aspect ratioof 0.618 results in a horizontal rectangle, and a ratio of 1.618results in a vertical rectangle. This function changes the widthto four inches and the aspect ratio to one.<DIV CLASS=screen><P><PRE>&amp;pgscf (2);&amp;pgslw (3);&amp;pgsch (1.6);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>pgscf</I>function modifies the font style to Roman. Here is a list of allthe styles:<DIV CLASS=informaltable><P><A NAME="CGI-CHP-6-TBL-1"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left"><P CLASS=para>Style</TH><TH ALIGN="left"><P CLASS=para>Attribute</TH></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>1</TD><TD ALIGN="left"><P CLASS=para>Normal</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>2</TD><TD ALIGN="left"><P CLASS=para>Roman</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>3</TD><TD ALIGN="left"><P CLASS=para>Italic</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>4</TD><TD ALIGN="left"><P CLASS=para>Script</TD></TR></TABLE><P></DIV><P CLASS=para>The line width and the character height are changed with the<I CLASS=emphasis>pgslw</I>and <I CLASS=emphasis>pgsch</I> functions, respectively.<DIV CLASS=screen><P><PRE>&amp;pgsci (4);&amp;pgenv (0, $hours + 1, 0, $maximum, 2, 0);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>pgsci</I>function changes the pen color to blue. We use the <I CLASS=emphasis>pgenv</I>function to draw our axes. The range for the x axis goes from 0to (<I CLASS=emphasis>$hours</I> + 1), and the range for the y axisis from 0 to the maximum number of accesses plus 10. The fifth argumentis responsible for independently scaling the x and y axes. A valueof one is used to set equal scales for the x and y axes; any othervalues cause <I CLASS=emphasis>pgperl</I> to independently scalethe axes. The last argument controls the plotting of axes and tickmarks. A value of zero instructs <I CLASS=emphasis>pgperl</I> todraw a box around the graph, and to label the coordinates.<DIV CLASS=screen><P><PRE>	&amp;pgsci (2);	&amp;pgbin ($hours, *counter, *time, 0);	&amp;pglabel ("Time (Hours)", "No. of Requests", "WWW Server Usage");	&amp;pgend;	</PRE></DIV><P CLASS=para>The pen color is again modified to two (red). The crucialroutine here is <I CLASS=emphasis>pgbin</I>.It draws a histogram with 23 values (represented by <I CLASS=emphasis>$hours</I>).The x coordinates are specified by the counter array, and the ycoordinates-or the number of accesses-are stored in the <I CLASS=emphasis>time</I>array. Notice how the arrays are passed to the <I CLASS=emphasis>pgbin</I>function; they are passed as references-this is a requirement of<I CLASS=emphasis>pgperl</I>. The last argument instructs <I CLASS=emphasis>pgperl</I>to draw the histogram with the edge of each box located at the correspondingx coordinate.<DIV CLASS=screen><P><PRE>&amp;print_gif();}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>print_gif</I> subroutine prints the GIFimage to standard output.<DIV CLASS=screen><P><PRE>sub print_gif{       local ($content_length);       if ( (open (GIF, "&lt;" . $output_gif)) ) {            $content_length = (stat (GIF))[7];            print "Content-type: image/gif", "\n";            print "Content-length: ", $content_length, "\n\n";            print &lt;GIF&gt;;            close (GIF);            unlink $output_gif;		  } else {			  &amp;return_error (500, "Server Log File Error",                               "Cannot read from the GIF file!");		  }}</PRE></DIV><P CLASS=para>Notice that we use the <i CLASS=command>Content-length</i> header in this subroutine.Whenever you are returning binary data (such as GIF images) andit is possible to determine the size of the image, you should makeit a habit to send this header. The <I CLASS=emphasis>stat</I> commandreturns the file size of the graphic image. The file is printedto standard<P CLASS=para><P CLASS=para>output, and deleted. If you like, you can use the algorithmin <A HREF="ch03_01.htm">Chapter 3, <i>Output from the Common Gateway Interface</i></A> to return the GIF imagein small pieces.<P CLASS=para><A HREF="ch06_05.htm#CGI-CHP-6-FIG-6">Figure 6.6</A> shows the image created by this script.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-6-FIG-6">Figure 6-6: pgperl graph</A></h4><p><img align=middle src="./figs/cgi0607.gif" alt="[Graphic: Figure 6-6]" width=502 height=382></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_04.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch06_06.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>CGI Examples with gnuplot</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Animation</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>