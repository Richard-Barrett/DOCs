<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 6] 6.6 Animation</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:27:50 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_05.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 6</b></td><td width=172 align=right valign=top><A HREF="ch07_01.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-6-SECT-6">6.6 Animation</A></h2><P CLASS=para>AlthoughJava is being touted as the best way to do animation on the Web,you can also write CGI programs to produce animation. There aretwo mechanisms for creating animation: client pull and server push.In client pull, a new HTTP connection is openedevery time a document is requested. In server push, however, theconnection is kept open until all the data is received by the client.That is the main difference between the two mechanisms. As a result,you can have an animation in an otherwise static document by usingthe HTML &lt;IMG&gt; tag to access the CGI programinstead of a URL to an image, as introduced in <A HREF="ch06_02.htm#CGI-CHP-6-SECT-2.2">the section called "Inserting Multiple Dynamic Images"</A>.<P CLASS=para>Client pull requires a special directive either in the HTMLdocument header or as a part of the CGI program's HTTPresponse. This directive instructs the client to retrieve a specifieddocument after a certain amount of time. In other words, the clientopens a new connection to the server for each updated image (see<A HREF="ch06_06.htm#CGI-CHP-6-FIG-7">Figure 6.7</A>).<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-6-FIG-7">Figure 6-7: Animation using client pull</A></h4><p><img align=middle src="./figs/cgi0608.gif" alt="[Graphic: Figure 6-7]" width=502 height=332></DIV><P CLASS=para><P CLASS=para>Server push involves sending packets of data to the clientperiodically, as shown in <A HREF="ch06_06.htm#CGI-CHP-6-FIG-8">Figure 6.8</A>.The HTTP connection between the client and theserver is kept open indefinitely. Server push can be implementedin a CGI program through the use of the <i CLASS=command>multipart/x-mixed-replace</i> MIMEtype.<P CLASS=para>Both client pull and server push are supported only by NetscapeNavigator (version 1.1 and higher) and Internet Explorer.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-6-FIG-8">Figure 6-8: Animation using server push</A></h4><p><img align=middle src="./figs/exp0601.gif" alt="[Graphic: Figure 6-8]" width=502 height=203></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-6-SECT-6.1">Client Pull</A></h3><P CLASS=para>Here is a simple example of an HTML documentthat displays the time continuously:<DIV CLASS=screen><P><PRE>&lt;META HTTP-EQUIV="Refresh" CONTENT=5&gt;&lt;!--#echo var="DATE_LOCAL"--&gt;</PRE></DIV><P CLASS=para>Animationdepends on updating the browser's window at regular intervals withnew material from the server. Browsers provide a way to update theirwindows called <I CLASS=emphasis>refreshing</I>.In the example shown above, we trick the browser into issuing itsrefresh command every five seconds, so that it retrieves the document.The document simply uses server side includes to display the currenttime. (See <A HREF="ch05_01.htm">Chapter 5, <i>Server Side Includes</i></A> for more informationon Server Side Includes.)<P CLASS=para>The META tag is part ofthe HTML 3.0 specification used to simulate HTTPresponse headers in HTML documents. In this case,it is used to simulate the "Refresh:" HTTP headerwith a delay of five seconds.<P CLASS=para>The "Refresh:" header is non-repeating; it does not load thedocument repeatedly. However, in this example, "Refresh:" is specifiedon each retrieval, creating a continuous display.<P CLASS=para>Here is an example of a CGI program that performs the sameoperation as the previous HTML code:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$delay = 5;$date = "/bin/date";print "Refresh: ", $delay, "\n";print "Content-type: text/plain", "\n\n";print `$date`;exit(0);</PRE></DIV><P CLASS=para>Remember, SSI directives cannot be included in a CGI program.So, the <I CLASS=emphasis>date</I> command is used to output thecurrent date and time.<P CLASS=para>Now, let's look at the directive used to load a differentdocument after a specified time:<DIV CLASS=screen><P><PRE>&lt;META HTTP-EQUIV="Refresh" CONTENT="5; URL=http://your.machine/name.html"&gt;</PRE></DIV><P CLASS=para>This example loads the file specified by the URL after fiveseconds. If the file <I CLASS=emphasis>name.html</I> does not containanother "Refresh:" header, there is no animation, because "Refresh:"is non-repeating. The corresponding CGI statement would be:<DIV CLASS=screen><P><PRE>print "Refresh: 5; URL=http://your.machine/name.html", "\n";</PRE></DIV><P CLASS=para>As a final example of client pull, here's a CGI program thatloads a document with a random fortune message every ten seconds.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$fortune = "/usr/local/bin/fortune";$refresh_time = 10;print "Refresh: ", $refresh_time, "\n";print "Content-type: text/plain", "\n\n";print "Here is another fortune...", "\n";print `$fortune`;exit(0);</PRE></DIV><P CLASS=para>This is a repeating document, because a "Refresh:" headeris specified every time the program is executed. The program usesthe UNIX <I CLASS=emphasis>fortune</I> command,which generates a random fortune each time it is invoked.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-6-SECT-6.2">Server Push</A></h3><P CLASS=para>Server pushanimations can be created using the <i CLASS=command>multipart/x-mixed-replace</i>MIME type. The "replace" indicates that eachdata packet replaces the previous data packet. As a result, youcan make smooth animations. Here is the format in which this MIMEtype is used:<DIV CLASS=screen><P><PRE>Content-type: multipart/x-mixed-replace;boundary=End--EndContent-type: image/gif<I CLASS=emphasis>Image #1</I>--EndContent-type: image/gif<I CLASS=emphasis>Image #2</I>--EndContent-type: image/gif<I CLASS=emphasis>Image #3</I>--End--</PRE></DIV><P CLASS=para>In the first <i CLASS=command>Content-type</i> declaration,we declare the <i CLASS=command>multipart/x-mixed-replace</i> contenttypes and establish "End" as the boundary string. We then repeatedlydisplay new images (declaring new content types of <i CLASS=command>image/gif</i>),ending each image with the "--End" string. The result is that theimages are displayed one after another.<P CLASS=para>Let's look at an example that utilizes the server push mechanism.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$| = 1;$webmaster = "shishir\@bu\.edu";$boundary_string = "\n" . "--End" . "\n";$end_of_data = "\n" . "--End--" . "\n";$delay_time = 1;</PRE></DIV><P CLASS=para>First, we define the boundary strings that need to be sentto the client. We also set the delay time between images-in thiscase, one second.<DIV CLASS=screen><P><PRE>@image_list = (	"image_1.gif",                  "image_2.gif",                 "image_3.gif",                 "image_4.gif",                 "image_5.gif"	);</PRE></DIV><P CLASS=para>All of the images that will be used in the animation are storedin the <I CLASS=emphasis>@image_list</I> array. In this simple example,we use only 5 images.<DIV CLASS=screen><P><PRE>$browser = $ENV{'HTTP_USER_AGENT'};if ($browser =~ m#^Mozilla/(1\.[^0]|[2-9])#) {	print "Content-type: multipart/x-mixed-replace;boundary=End", "\n";</PRE></DIV><P CLASS=para>The name of the client browser is obtained using the environmentvariable HTTP_USER_AGENT. If the browser is Netscapeversion 1.1 or higher, the multipart MIME typeis sent to it, along with the initial boundary string. (Netscapeuses "Mozilla" as its user agent string.)<DIV CLASS=screen><P><PRE>	for ($loop=0; $loop &lt; scalar (@image_list); $loop++) {		&amp;open_and_display_GIF ($image_list[$loop]);		print $boundary_string;		sleep ($delay_time);	}	print $end_of_data;</PRE></DIV><P CLASS=para>A loop is used to iterate through the<I CLASS=emphasis> image_list</I>array. Each image is displayed using the <I CLASS=emphasis>open_and_display_GIF</I>subroutine. A boundary is then sent to the client, and the programproceeds to sleep for the specified amount of time. It is importantto print the boundary after the image <I CLASS=emphasis>and</I> beforethe <I CLASS=emphasis>sleep</I> command to ensure that the server"pushes" the entire image to the client. The process is repeatedfor all the images in the array. Finally, the terminating boundarystring is sent to the client.<DIV CLASS=screen><P><PRE>} else {	&amp;open_and_display_GIF ($image_list[0]);}exit(0);</PRE></DIV><P CLASS=para>If the browser is not Netscape version 1.1 or higher, onlythe first image stored in the array is displayed.<DIV CLASS=screen><P><PRE>sub open_and_display_GIF{		   local ($file) = @_;		   local ($content_length);	  	   if ( (open (FILE, "&lt;" . $file)) ) {		   $content_length = (stat (FILE))[7];		   print "Content-type: image/gif", "\n";		   print "Content-length: ", $content_length, "\n\n";		   print &lt;FILE&gt;;		   close (FILE);	   } else {		   &amp;return_error (500, "File Access Error", 							 "Cannot open graphic file $file!");	   }}</PRE></DIV><P CLASS=para>This routine should be very familiar to you. First, it sendsthe <i CLASS=command>image/gif</i> MIME type, alongwith the length of the image. Then, the image is printed to standardoutput.<P CLASS=para>One final note: If you are using an NCSAserver, it is better to create the CGI server push animation programas a non-parsed header ("nph") script, as described in <A HREF="ch03_01.htm">Chapter 3, <i>Output from the Common Gateway Interface</i></A>. Thatway the server will not parse the HTTP headers,and instead will send the information directly to the client. Themain advantage of this is reduced "jerkiness" in the animation.Just to refresh your memory, you need to name the script with an"nph-" prefix, and the first lines that are output from your scriptshould be:<DIV CLASS=screen><P><PRE>	print "HTTP/1.0 200 OK", "\n";	print "Content-type: multipart/x-mixed-replace;boundary=End", "\n";  </PRE></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_05.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch07_01.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>CGI Examples with pgperl</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Advanced Form Applications</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>