<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 7] Advanced Form Applications</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:30:44 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_06.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 7</b></td><td width=172 align=right valign=top><A HREF="ch07_02.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><H1 CLASS=chapter><A CLASS="TITLE" NAME="CGI-CHP-7">Advanced Form Applications</A></H1><DIV CLASS=htmltoc><p><b>Contents:</b><br>Guestbook<br><A HREF="ch07_02.htm">Survey/Poll and Pie Graphs</A><BR><A HREF="ch07_03.htm">Quiz/Test Form Application</A><BR><A HREF="ch07_04.htm">Security</A><BR></DIV><P CLASS=para>Four different CGIapplications are presented in this chapter, all of which use queriesand form information to produce some interesting documents withhypertext and graphics. These applications include:<P><UL CLASS=itemizedlist><li CLASS=listitem><I CLASS=emphasis>Guestbook</I>: Aform interface for users to leave comments on a particular Web pagefor other people to see. The concepts behind the guestbook are verysimple: Present a form to the user to fill out, process the forminformation, and store it in a file.<P><li CLASS=listitem><I CLASS=emphasis>Poll or a Survey</I>: A CGI programthat allows you to solicit opinions from users and present themwith a dynamically created pie graph illustrating the up-to-dateresults. This application involves displaying a form and manipulatingand storing the form data into a format that we can read easilyand quickly at a later time. When the user elects to see the currentresults, we simply read in all of the data and graph it.<P><li CLASS=listitem><I CLASS=emphasis>Quiz/Test</I>: A unique interfacethat shows you how to "extend" HTML by addingnew tags! This CGI application reads the specified data file consistingof tags to create quizzes (as well as regular HTML),formats it to HTML, and sends it to the browser.It will also correct the quiz once the user completes it.<P></UL><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-7-SECT-1">7.1 Guestbook</A></h2><P CLASS=para>One of the most commonapplications on the Web is a guestbook. It is simply a form thatallows visitors to enter some information about themselves. Thisinformation is placed in a file for everyone to see. Here are thesteps that need to be taken to create a guestbook:<P><UL CLASS=itemizedlist><li CLASS=listitem>Display a form with such fields asname, email address, and comments<P><li CLASS=listitem>Write a CGI program to decode the form<P><li CLASS=listitem>Place the information in a file<P></UL><P CLASS=para>The program begins as follows:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$webmaster = "shishir\@bu\.edu";$method = $ENV{'REQUEST_METHOD'};$script = $ENV{'SCRIPT_NAME'};$query  = $ENV{'QUERY_STRING'};$document_root = "/usr/local/bin/httpd_1.4.2/public";$guest_file = "/guestbook.html";$full_path = $document_root . $guest_file;</PRE></DIV><P CLASS=para>In this initialization code,the <I CLASS=emphasis>document_root</I> variable is the directorythat contains your HTML files. Set this variableto the value of <I CLASS=emphasis>DocumentRoot</I>, as defined inthe <I CLASS=emphasis>srm.conf</I> configuration file. The <I CLASS=emphasis>guest_file</I>variable contains the relative path to the guestbook file, relativeto <I CLASS=emphasis>DocumentRoot</I>. And <I CLASS=emphasis>full_path</I>represents the full path to the guestbook file. It is very importantto separate the full path from the relative path, as you will seein a moment.<DIV CLASS=screen><P><PRE>$exclusive_lock = 2;$unlock = 8;</PRE></DIV><P CLASS=para>The lock definitions are stored in the <I CLASS=emphasis>exclusive_lock</I>and <I CLASS=emphasis>unlock</I> variables, respectively.<DIV CLASS=screen><P><PRE>if ($method eq "GET") {    if ($query eq "add") {</PRE></DIV><P CLASS=para>This program is coded slightlydifferently from the programs that you have seen in this book. Let'sfirst see how this program can be accessed:<P><UL CLASS=itemizedlist><li CLASS=listitem>A URL of <I CLASS=emphasis>http://your.machine/cgi-bin/guestbook.pl?add</I>,using the <tt CLASS=literal>GET</tt> method, will present a form forvisitors to enter information.<P><li CLASS=listitem>A URL of <I CLASS=emphasis>http://your.machine/cgi-bin/guestbook.pl</I>,using the <tt CLASS=literal>GET</tt> method, will display the actualguestbook file. (The user can also see the guestbook file by openingthat file directly, e.g., by accessing <I CLASS=emphasis>http://your.machine/guestbook.html</I>.)<P><li CLASS=listitem>When the form is submitted using the <tt CLASS=literal>POST</tt>method, this program decodes the information, and outputs a thank-youmessage.<P></UL><P CLASS=para>As you can see, thisprogram is very versatile. It handles all tasks of the guestbook.You could just as easily split the program into its constituents:an <tt CLASS=literal>HTML</tt> form, a program to display the guestbook(optional), and a program to decode the form information. Thereare advantages either way. Combining all tasks into the single programensures that all components of the program are in one place, andfiles cannot be accidently misplaced. On the other hand, separatingthem ensures that each component of the guestbook is independent,and can be modified without risking the integrity of the other components.It is matter of personal preference.<DIV CLASS=screen><P><PRE>        $date_time = &amp;get_date_time();</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>get_date_time</I> subroutine displaysthe current date and time.<DIV CLASS=screen><P><PRE>        &amp;MIME_header ("text/html", "Shishir Gundavaram's Guestbook");</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>MIME_header</I>subroutine outputs a chosen <tt CLASS=literal>MIME</tt> header, andsets the title of the document to the user-specified argument. Theonly reason for the subroutine is to make the program more compact.<DIV CLASS=screen><P><PRE>        print &lt;&lt;End_Of_Guestbook_Form;This is a guestbook CGI script that allows people to leave someinformation for others to see. Please enter all requestedinformation, &lt;B&gt;and&lt;/B&gt; if you have a WWW server, enter the addressso a hypertext link can be created. &lt;P&gt;The current time is: $date_time&lt;HR&gt;</PRE></DIV><P CLASS=para>First, an introductory message is displayed, along with thecurrent date and time. (You cannot call subroutines from withinprint "blocks," so the <I CLASS=emphasis>get_date_time</I> subroutineto get the date and time was called earlier and placed in the <I CLASS=emphasis>date_time</I>variable.).<DIV CLASS=screen><P><PRE>&lt;FORM METHOD="POST"&gt;&lt;PRE&gt;&lt;EM&gt;Full Name&lt;/EM&gt;:      &lt;INPUT TYPE="text" NAME="name" SIZE=40&gt;&lt;EM&gt;Email Address&lt;/EM&gt;:  &lt;INPUT TYPE="text" NAME="from" SIZE=40&gt;&lt;EM&gt;WWW Server&lt;/EM&gt;:     &lt;INPUT TYPE="text" NAME="www"  SIZE=40&gt;&lt;/PRE&gt;&lt;P&gt;&lt;EM&gt;Please enter the information that you'd like to add:&lt;/EM&gt;&lt;BR&gt;&lt;TEXTAREA ROWS=3 COLS=60 NAME="comments"&gt;&lt;/TEXTAREA&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Add to Guestbook"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear Information"&gt;&lt;BR&gt;&lt;P&gt;&lt;/FORM&gt;&lt;HR&gt;End_Of_Guestbook_Form</PRE></DIV><P CLASS=para>As you can see, there is no <tt CLASS=literal>ACTION</tt>attribute to the <TT>&lt;FORM&gt;</TT>tag. By omitting the <tt CLASS=literal>ACTION</tt> attribute, the browserdefaults to sending the completed form to the current CGI program.The <tt CLASS=literal>METHOD</tt> is set to <tt CLASS=literal>POST</tt>-aswe'll see later, this is how the guestbook program will know theform has been completed.<P CLASS=para>The various elements that comprisea form are output. The &lt;PRE&gt; tags align the text fields. <A HREF="ch07_01.htm#CGI-CHP-7-FIG-1">Figure 7.1</A> shows how a completed form is rendered by Netscape Navigator.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-7-FIG-1">Figure 7-1: Guestbook form</A></h4><p><img align=middle src="./figs/cgi0701.gif" alt="[Graphic: Figure 7-1]"></DIV><P CLASS=para>If there was no query specified, the guestbookdata file is displayed for output.<DIV CLASS=screen><P><PRE>    } else { if ( open(GUESTBOOK, "&lt;" . $full_path) ) {            flock (GUESTBOOK, $exclusive_lock);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>full_path</I>variable contains the full path to the guestbook file. The mainreason for storing the relative path and full path separately isthat hypertext anchors need the relative path, while the full pathis needed to open the file. Before you open any file, it is alwaysa good idea to check that the file can be opened.<DIV CLASS=screen><P><PRE>            &amp;MIME_header ("text/html", "Here is my guestbook!");                        while (&lt;GUESTBOOK&gt;) {                print;            }                            flock (GUESTBOOK, $unlock);            close(GUESTBOOK);</PRE></DIV><P CLASS=para>The loop iteratesthrough each line of the file and displays it to standard output.<A HREF="ch07_01.htm#CGI-CHP-7-FIG-2">Figure 7.2</A> shows the output.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-7-FIG-2">Figure 7-2: Guestbook output</A></h4><p><img align=middle src="./figs/cgi0702.gif" alt="[Graphic: Figure 7-2]"></DIV><DIV CLASS=screen><P><PRE>        } else {            &amp;return_error (500, "Guestbook File Error",                 	              "Cannot read from the guestbook file [$full_path].");        }    }</PRE></DIV><P CLASS=para>If there wereany problems opening the file, an error message is sent to the client.The <I CLASS=emphasis>return_error</I> subroutine is the same asthe one presented in <A HREF="ch04_01.htm">Chapter 4, <i>Forms and CGI</i></A>.<P CLASS=para>Remember the "add" form, in which the <TT>&lt;FORM&gt;</TT>tag used a <tt CLASS=literal>METHOD</tt> of <tt CLASS=literal>POST</tt>?Here's where the form is processed. If the request method is <tt CLASS=literal>POST</tt>,it means that the user filled out the form, and submitted it backto this program.<DIV CLASS=screen><P><PRE>} elsif ($method eq "POST") {    if ( open (GUESTBOOK, "&gt;&gt;" . $full_path) ) {        flock (GUESTBOOK, $exclusive_lock);        $date_time = &amp;get_date_time();        &amp;parse_form_data (*FORM);</PRE></DIV><P CLASS=para>Now we add thenew entry to the guestbook. First, the program checks to see ifit can write to the guestbook file. If there are no errors, thefile is opened in append mode, and exclusively locked. The forminformation is decoded and placed in the <tt CLASS=literal>FORM</tt>associative array. The <I CLASS=emphasis>parse_form_data</I> subroutinein this program is slightly different than the one we've previouslyencountered in <A HREF="ch04_01.htm">Chapter 4, <i>Forms and CGI</i></A>; it does notcheck for <tt CLASS=literal>GET</tt> requests, since the program onlyuses it for <tt CLASS=literal>POST</tt>.<DIV CLASS=screen><P><PRE>        $FORM{'name'}  = "Anonymous User"       if !$FORM{'name'};        $FORM{'from'}  = $ENV{'REMOTE_HOST'}    if !$FORM{'from'};</PRE></DIV><P CLASS=para>Above is a constructyou might not have seen before. It is a simpler way of saying:<DIV CLASS=screen><P><PRE>if (!$FORM{'name'}) {    $FORM{'name'} = "Anonymous User";}if (!$FORM{'from'}) {    $FORM{'from'}=$ENV{'REMOTE_HOST'};}</PRE></DIV><P CLASS=para>In other words, the form variables <I CLASS=emphasis>name</I>and <I CLASS=emphasis>from</I> are checked for valid information.If the fields are empty, default information is stored.<DIV CLASS=screen><P><PRE>        $FORM{'comments'} =~ s/\n/&lt;BR&gt;/g;</PRE></DIV><P CLASS=para>The information that the user entered in the <TT>&lt;TEXTAREA&gt;</TT>field is stored in comments. Every newline character is replacedby the <tt CLASS=literal>HTML</tt> break tag. This ensures that theinformation is displayed correctly. Note that if the user enters<tt CLASS=literal>HTML</tt> code (or SSI directives) as part of thecomments, the code will be interpreted. This could be dangerous.See <A HREF="ch09_01.htm">Chapter 9, <i>Gateways, Databases, and Search/Index Utilities</i></A>, for an intricate regular expression that"escapes" <tt CLASS=literal>HTML</tt> code.<DIV CLASS=screen><P><PRE>	        print GUESTBOOK &lt;&lt;End_Of_Write;&lt;P&gt;&lt;B&gt;$date_time:&lt;/B&gt;&lt;BR&gt;Message from &lt;EM&gt;$FORM{'name'}&lt;/EM&gt; at &lt;EM&gt;$FORM{'from'}&lt;/EM&gt;:&lt;P&gt;$FORM{'comments'}End_Of_Write</PRE></DIV><P CLASS=para>The user name, host, and comments, along with the currentdate and time, are written to the guestbook file.<DIV CLASS=screen><P><PRE>        if ($FORM{'www'}) {            print GUESTBOOK &lt;&lt;End_of_Web_Address;			&lt;P&gt;$FORM{'name'} can also be reached at: &lt;A HREF="$FORM{'www'}"&gt;$FORM{'www'}&lt;/A&gt;End_of_Web_Address        }		        print GUESTBOOK "&lt;P&gt;&lt;HR&gt;";</PRE></DIV><P CLASS=para>If an <tt CLASS=literal>HTTP</tt>address was provided by the user, it is also displayed.<DIV CLASS=screen><P><PRE>        flock (GUESTBOOK, $unlock);        close(GUESTBOOK);</PRE></DIV><P CLASS=para>The file is unlockedand closed. It is very important to unlock and close the guestbookfile to ensure that other people can access it.<P CLASS=para>Finally,if all goes well, a thank-you message is displayed, as well as linksto view the guestbook.<DIV CLASS=screen><P><PRE>        &amp;MIME_header ("text/html", "Thank You!");                print &lt;&lt;End_of_Thanks;        Thanks for visiting my guestbook. If you would like to see the guestbook,click &lt;A HREF="$guest_file"&gt;here&lt;/A&gt; (actual guestbook HTML file),or &lt;A HREF="$script"&gt;here&lt;/A&gt; (guestbook script without a query).End_of_Thanks</PRE></DIV><P CLASS=para>If the program cannot write to the guestbook file, an errormessage is generated. Another error is sent if an invalid requestmethod is used to access this CGI program.<DIV CLASS=screen><P><PRE>     } else {        &amp;return_error (500, "Guestbook File Error",                    "Cannot write to the guestbook file [$full_path].")    }} else {    &amp;return_error (500, "Server Error",                        "Server uses unsupported method");}exit(0);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>MIME_header</I> subroutine simply displaysa <tt CLASS=literal>MIME</tt> header, as well as a title and headingfor the document. If the third argument is not specified, the headingwill be the same as the title.<DIV CLASS=screen><P><PRE>sub MIME_header{    local ($mime_type, $title_string, $header) = @_;    if (!$header) {        $header = $title_string;    }    print "Content-type: ", $mime_type, "\n\n";    print "&lt;HTML&gt;", "\n";    print "&lt;HEAD&gt;&lt;TITLE&gt;", $title_string, "&lt;/TITLE&gt;&lt;/HEAD&gt;", "\n";    print "&lt;BODY&gt;", "\n";    print "&lt;H1&gt;", $header, "&lt;/H1&gt;";    print "&lt;HR&gt;";}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>get_date_time</I>subroutine returns the current date and time.<DIV CLASS=screen><P><PRE>sub get_date_time {    local ($months, $weekdays, $ampm, $time_string);    $months = "January/February/March/April/May/June/July/" .               "August/September/October/November/December";    $weekdays = "Sunday/Monday/Tuesday/Wednesday/Thursday/Friday/Saturday";    local ($sec, $min, $hour, $day, $nmonth, $year, $wday, $yday, $isdst) 	          = localtime(time);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>localtime</I> function returns a nine-elementarray, which consists of the time, the date, and the present timezone. In previous examples, we were using only the first three elementsof this array; in this example, we're assigning all nine.<DIV CLASS=screen><P><PRE>    if ($hour &gt; 12) {        $hour -= 12;        $ampm = "pm";    } else {        $ampm = "am";    }    if ($hour == 0) {	       $hour = 12;    }    $year += 1900;    $week  = (split("/", $weekdays))[$wday];    $month = (split("/", $months))[$nmonth];</PRE></DIV><P CLASS=para>The weekand the numerical month returned by the <I CLASS=emphasis>localtime</I>function are zero based. The <I CLASS=emphasis>week</I> variableis set to the alphanumeric weekday name by retrieving the stringcorresponding to the numerical weekday from the variable <I CLASS=emphasis>weekdays</I>.The same process is repeated to determine the alphanumeric monthname.<DIV CLASS=screen><P><PRE>    $time_string = sprintf("%s, %s %s, %s - %02d:%02d:%02d %s",                                 $week, $month, $day, $year,                                 $hour, $min, $sec, $ampm);    return ($time_string);}</PRE></DIV><P CLASS=para>Finally, the date returned by the <I CLASS=emphasis>get_date_time</I>subroutine is in the form of:<DIV CLASS=screen><P><PRE>Friday, August 18, 1995 - 02:07:45 pm</PRE></DIV><P CLASS=para>The last subroutine in the guestbook application is <I CLASS=emphasis>parse_form_data</I>.<DIV CLASS=screen><P><PRE>sub parse_form_data{    local (*FORM_DATA) = @_;	    local ( $request_method, $post_info, @key_value_pairs,		          $key_value, $key, $value);    read (STDIN, $post_info, $ENV{'CONTENT_LENGTH'});    @key_value_pairs = split (/&amp;/, $post_info);    foreach $key_value (@key_value_pairs) {        ($key, $value) = split (/=/, $key_value);        $value =~ tr/+/ /;        $value =~ s/%([\dA-Fa-f][\dA-Fa-f])/pack ("C", hex ($1))/eg;        if (defined($FORM_DATA{$key})) {            $FORM_DATA{$key} = join ("\0", $FORM_DATA{$key}, $value);        } else {            $FORM_DATA{$key} = $value;        }    }}</PRE></DIV><P CLASS=para>As mentioned earlier,this subroutine does not check for <tt CLASS=literal>GET</tt> requests.There is no need to do so, because the loop in the main programdoes the needed checking. </DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_06.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch07_02.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Figure -: Animation using client pull</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Survey/Poll and Pie Graphs</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>