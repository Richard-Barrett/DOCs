<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 8] Multiple Form Interaction</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:32:21 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch07_04.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 8</b></td><td width=172 align=right valign=top><A HREF="ch08_02.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><H1 CLASS=chapter><A CLASS="TITLE" NAME="CGI-CHP-8">Multiple Form Interaction</A></H1><DIV CLASS=htmltoc><p><b>Contents:</b><br>Hidden Fields<br><A HREF="ch08_02.htm">CGI Side Includes</A><BR><A HREF="ch08_03.htm">Netscape Persistent Cookies</A><BR></DIV><P CLASS=para>Oneof the problems with the current HTTP protocolis its inability to maintain state. In other words, the protocolprovides no way to access data from previous requests.<P CLASS=para>Imagine an ordering (or "shopping cart") system on the Web.You present the user with several forms listing the numerous productsthat can be ordered. The system keeps track of what the user ordered.Finally, it displays all of the user's selections. This type ofsystem needs to somehow store the information-or "state"-so thatit can be accessed at a later time.<P CLASS=para>For example, suppose you ask the user for his or her addressin the first form. If you need this information in a later form,you don't want to ask all over again. Instead, you want to finda way for that address to be accessible to a later form, but transparentto the user. This is the most basic problem of using multiple forms-maintaining"state" from one form to another-and thus deserves special attentionin this book.<P CLASS=para>There are several different strategies we'll explore for maintainingstate. They include:<P><UL CLASS=itemizedlist><li CLASS=listitem>Hidden fields. Using hidden fields,you can embed information into a form that the user won't see, butwhich will be sent back to the CGI program when the form is submitted.<P><li CLASS=listitem>CGI Side Includes. This is a mechanism by whichwe embed special tags into the HTML document that pass CGI variablesinvisibly.<P><li CLASS=listitem>Netscape Persistent Cookies. The Netscape browsersupplies a method for storing and retrieving information via CGI.<P></UL><P CLASS=para>In <A HREF="ch10_01.htm">Chapter 10, <i>Gateways to Internet Information Servers</i></A>, we also discussa fourth approach, which is to develop a specialized "cookie server"to maintain information associated with a single user. In this chapter,however, we'll restrict ourselves to the more straightforward mechanisms.<DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-8-SECT-1">8.1 Hidden Fields</A></h2><P CLASS=para>As mentioned in <A HREF="ch04_01.htm">Chapter 4, <i>Forms and CGI</i></A>, hidden fields allow you to store "hidden" informationwithin a form. These fields are not displayed by the client. However,if the user selects the "View Source" option in the browser, theentire form is visible, including the hidden fields. Hidden fieldsare therefore not meant for security (since anyone can see them),but just for passing information to and from forms transparently.<P CLASS=para>Here is an example of two hidden fields that store authorinformation within a form:<DIV CLASS=screen><P><PRE>&lt;FORM ACTION="/cgi-bin/test.pl" METHOD="POST"&gt;..&lt;INPUT TYPE="hidden" NAME="author"  VALUE="Larry Bird"&gt;&lt;INPUT TYPE="hidden" NAME="company" VALUE="Boston Celtics"&gt;..&lt;/FORM&gt;</PRE></DIV><P CLASS=para>When the form is submitted, the information within the hiddenfields is encoded, as the client passes all the fields to the serverin the same exact manner. As far as the CGI program is concerned,there is no difference between hidden fields and regular, visiblefields.<P CLASS=para>One thing to note is that certain browsers may not be ableto handle hidden fields correctly.<P CLASS=para>A simple way to use hidden fields for maintaing state involveswriting the information from a form as hidden field informationinto its successive form. Here is a simple first form:<DIV CLASS=screen><P><PRE>&lt;FORM ACTION="/cgi-bin/test.pl" METHOD="POST"&gt;Name: &lt;INPUT TYPE="text"  NAME="01 Full Name" SIZE=40&gt;&lt;BR&gt;EMail: &lt;INPUT TYPE="text" NAME="02 EMail" SIZE=40&gt;&lt;BR&gt;&lt;INPUT TYPE="submit" VALUE="Submit the survey"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;&lt;/FORM&gt;</PRE></DIV><P CLASS=para>When this form is submitted, the program retrieves the informationand creates a dynamic second form, based on the first form, likethis:<DIV CLASS=screen><P><PRE>&lt;FORM ACTION="/cgi-bin/test.pl" METHOD="POST"&gt;&lt;INPUT TYPE="hidden" NAME="01 Full Name" VALUE="Shishir Gundavaram"&gt;&lt;INPUT TYPE="hidden" NAME="02 EMail" VALUE="shishir@acs.bu.edu"&gt;What is your favorite WWW browser?&lt;BR&gt;Browser: &lt;INPUT TYPE="text" NAME="03 Browser" SIZE=40&gt;&lt;BR&gt;&lt;INPUT TYPE="submit" VALUE="Submit the survey"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;&lt;/FORM&gt;</PRE></DIV><P CLASS=para>As you can see, the two fields, along with the user information,are inserted into the second form. The main advantage of such aprocess is that there is no need for magic cookies and temporaryfiles. On the other hand, the disadvantage is that the form informationis appended repeatedly to successive forms, creating large forms.This could result in possible performance problems.<P CLASS=para>Let's look at an example using this technique. Here is thefirst form:<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to the CGI Shopping Cart&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;CGI Shopping Cart&lt;/H1&gt;Welcome! Thanks for stopping by the CGI Shopping Cart. Here is a listof some of our products. We hope you like them, and please visit again.&lt;FORM ACTION="/cgi-bin/shopping.pl/catalog.html" METHOD="POST"&gt;&lt;HR&gt;What is your full name: &lt;BR&gt;&lt;INPUT TYPE="text" NAME="01 Full Name" SIZE=40&gt;&lt;P&gt;What is your e-mail address: &lt;BR&gt;&lt;INPUT TYPE="text" NAME="02 Email" SIZE=40&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Submit and Retrieve Catalog"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>The most important thing to note here is the extra pathinformation passed to the program. This filename represents thenext form to be displayed. The two fields in this form will be "hidden"in <I CLASS=emphasis>/catalog.html</I>. Now, here is the second form:<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to the CGI Shopping Cart&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;CGI Shopping Cart&lt;/H1&gt;Thanks for visiting out server. Here is a catalog of some of our books.Make your selections and press the submit buttons. Note: multipleselections are allowed.&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/shopping.pl" METHOD="POST"&gt;&lt;H2&gt;Books on Networking&lt;/H2&gt;&lt;SELECT NAME="03 Networking Books" SIZE=3 MULTIPLE&gt;&lt;OPTION SELECTED&gt;Managing Internet Information Services&lt;OPTION&gt;TCP/IP Network Administration&lt;OPTION&gt;Linux Network Administrator's Guide&lt;OPTION&gt;Managing UUCP and Usenet&lt;OPTION&gt;The USENET Handbook&lt;/SELECT&gt;&lt;HR&gt;&lt;H2&gt;UNIX related Books&lt;/H2&gt;&lt;SELECT NAME="04 UNIX Books" SIZE=3 MULTIPLE&gt;&lt;OPTION SELECTED&gt;Learning the UNIX Operating System&lt;OPTION&gt;Learning the Korn Shell&lt;OPTION&gt;UNIX Power Tools&lt;OPTION&gt;Learning Perl&lt;OPTION&gt;Programming Perl&lt;OPTION&gt;Learning the GNU Emacs&lt;/SELECT&gt;&lt;INPUT TYPE="submit" VALUE="Submit the selection"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>The ACTION attribute does not containextra path information. This represents the last form in the "shoppingcart." Also note the fact that there is a scrolled list that allowsmultiple selections. The program displays any form element thathas multiple selection in a unique way.<P CLASS=para>The program begins as follows:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$webmaster = "shishir\@bu\.edu";$document_root = "/home/shishir/httpd_1.4.2/public";$request_method = $ENV{'REQUEST_METHOD'};$form_file = $ENV{'PATH_INFO'};$full_path = $document_root . $form_file;$exclusive_lock = 2;$unlock = 8;if ($request_method eq "GET") {    if ($form_file) {        &amp;display_file ();    } else {        &amp;return_error (500, "CGI Shopping Cart Error",                            "An initial form must be specified.");    }</PRE></DIV><P CLASS=para>If the program was requested with the GETprotocol and extra path information, the <I CLASS=emphasis>display_file</I>subroutine is called to output the form. The program should be accessedwith the following URL:<DIV CLASS=screen><P><PRE>http://your.machine/cgi-bin/shopping.pl/start.html</PRE></DIV><P CLASS=para>where <I CLASS=emphasis>/start.html</I> represents the firstform. If no path information is specified, an error message is returned.<DIV CLASS=screen><P><PRE>} elsif ($request_method eq "POST") {    &amp;parse_form_data (*STATE);    if ($form_file) {        &amp;parse_file ();    } else {        &amp;thank_you ();    }</PRE></DIV><P CLASS=para>If extra path information is passed to this program with thePOST method, the <I CLASS=emphasis>parse_file</I>subroutine is invoked. This subroutine inserts the informationfrom the previous form(s) into the current form as hidden fields.Remember, the form information is stored in the <I CLASS=emphasis>STATE</I>associative array. On the other hand, if no path information isspecified, it is the end of the data collection process. The <I CLASS=emphasis>thank_you</I>subroutine displays the information from all the forms.<DIV CLASS=screen><P><PRE>} else {    &amp;return_error (500, "Server Error",                        "Server uses unsupported method");}exit (0);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>display_file</I> subroutine simply outputsthe first form to standard output.<DIV CLASS=screen><P><PRE>sub display_file{    open (FILE, "&lt;" . $full_path) ||         &amp;return_error (500, "CGI Shopping Cart Error",            "Cannot read from the form file [$full_path].");    flock (FILE, $exclusive_lock);    print "Content-type: text/html", "\n\n";    while (&lt;FILE&gt;) {        print;    }    flock (FILE, $unlock);    close (FILE);    }</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>parse_file</I> subroutine inserts informationfrom previous forms into the current form, as hidden fields.<DIV CLASS=screen><P><PRE>sub parse_file{    local ($key, $value);    open (FILE, "&lt;" . $full_path) ||        &amp;return_error (500, "CGI Shopping Cart Error",            "Cannot read from the form file [$full_path].");    flock (FILE, $exclusive_lock);    print "Content-type: text/html", "\n\n";    while (&lt;FILE&gt;) {        if (/&lt;\s*form\s*.*&gt;/i) {            print;            foreach $key (sort (keys %STATE)) {                $value = $STATE{$key};                print &lt;&lt;End_of_Hidden;&lt;INPUT TYPE="hidden" NAME="$key" VALUE="$value"&gt;    End_of_Hidden            }</PRE></DIV><P CLASS=para>The file specified by PATH_INFO is opened.The <I CLASS=emphasis>while</I> loop iterates through the file oneline at a time. The regular expression checks for the &lt;FORM&gt;tag within the document. If it is found, the line containing thetag is displayed. Also, the <I CLASS=emphasis>foreach</I> constructiterates through all of the key-value form pairs, and outputs ahidden field for each one.<DIV CLASS=screen><P><PRE>        } else {            print;        }    }    </PRE></DIV><P CLASS=para>If the &lt;FORM&gt; tag is not found, theline from the file is output verbatim.<DIV CLASS=screen><P><PRE>    flock (FILE, $unlock);    close (FILE);}</PRE></DIV><P CLASS=para>The<I CLASS=emphasis> thank_you</I> subroutine thanks the userand displays the data he or she selected.<DIV CLASS=screen><P><PRE>sub thank_you{    local ($key, $value, @all_values);    print &lt;&lt;Thanks;Content-type: text/html&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Thank You!&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Thank You!&lt;/H1&gt;Thank you again for using our service. Here are the itemsthat you selected: &lt;HR&gt;&lt;P&gt;Thanks</PRE></DIV><P CLASS=para>This subroutine formats and displays the information storedin the STATE associative array, which representsthe combined data from all the forms.<DIV CLASS=screen><P><PRE>    foreach $key (sort (keys %STATE)) {        $value = $STATE{$key};        $key =~ s/^\d+\s//;        if ($value =~ /\0/) {            print "&lt;B&gt;", $key, "&lt;/B&gt;", "&lt;BR&gt;", "\n";            $value =~ s/\0/&lt;BR&gt;\n/g;            print $value, "&lt;BR&gt;", "\n";</PRE></DIV><P CLASS=para>If a particular value contains a null string, it is replacedwith "&lt;BR&gt;" followed by a newlinecharacter. As a result, the multiple values are displayed properly.<DIV CLASS=screen><P><PRE>        } else {            print $key, ": ", $value, "&lt;BR&gt;", "\n";        }    }    print "&lt;HR&gt;", "\n";    print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>parse_form_data</I> subroutine is similarto the one used in the "survey" program above, except it does nothandle any query information.<DIV CLASS=screen><P><PRE>sub parse_form_data{    local (*FORM_DATA) = @_;        local ($query_string, @key_value_pairs, $key_value, $key, $value);        read (STDIN, $query_string, $ENV{'CONTENT_LENGTH'});    @key_value_pairs = split (/&amp;/, $query_string);    foreach $key_value (@key_value_pairs) {        ($key, $value) = split (/=/, $key_value);        $key   =~ tr/+/ /;        $value =~ tr/+/ /;        $key   =~ s/%([\dA-Fa-f][\dA-Fa-f])/pack ("C", hex ($1))/eg;        $value =~ s/%([\dA-Fa-f][\dA-Fa-f])/pack ("C", hex ($1))/eg;        if (defined($FORM_DATA{$key})) {            $FORM_DATA{$key} = join ("\0", $FORM_DATA{$key}, $value);        } else {            $FORM_DATA{$key} = $value;        }    }}  </PRE></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch07_04.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch08_02.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Security</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>CGI Side Includes</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>