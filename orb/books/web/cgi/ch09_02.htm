<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 9] 9.2 Mail Gateway</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:33:42 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch09_01.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 9</b></td><td width=172 align=right valign=top><A HREF="ch09_03.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-2">9.2 Mail Gateway</A></h2><P CLASS=para>Everwish you could send electronic mail from your web browser? Thisgateway allows you to do just that.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl$webmaster = "shishir\@bu\.edu";$gateway = "CGI Mail Gateway [v1.0]";$request_method = $ENV{'REQUEST_METHOD'};$sendmail = "/usr/lib/sendmail -t -n -oi";</PRE></DIV><P CLASS=para>This program uses the UNIX <I CLASS=emphasis>sendmail</I> utilityto actually send the message. The <I CLASS=emphasis>-t </I>optioninstructs <I CLASS=emphasis>sendmail</I> to scan the message forthe "To:" mail header, and the <I CLASS=emphasis>-n</I>option prevents the user from entering aliases for the recipient'semail address; you would not want some remote user to use your system'sinternal aliases, would you?<DIV CLASS=screen><P><PRE>$address_file = "/home/shishir/httpd_1.4.2/cgi-bin/address.dat";</PRE></DIV><P CLASS=para>The address file consists of a list of recipients' mail addressesfrom which the user is required to select one. The user cannot enteran address that is not included in the address file. The <I CLASS=emphasis>address.dat</I>file should be formatted as follows:<DIV CLASS=screen><P><PRE>Webmaster,webmaster@bu.eduAuthor,shishir@bu.edu...</PRE></DIV><P CLASS=para>I have chosen a comma to separate nicknames from addressesbecause Internet standards prohibit a comma from being used in anaddress.<P CLASS=para>When the mail form is displayed, the program inserts all ofthe descriptive names in a scrolled list. If you do not want tohave such a file, remove or comment out the line defining <I CLASS=emphasis>$address_file</I>.<DIV CLASS=screen><P><PRE>$exclusive_lock = 2;$unlock = 8;if ( defined ($address_file) &amp;&amp; (-e $address_file) ) {    &amp;load_address (*address);}</PRE></DIV><P CLASS=para>If the <I CLASS=emphasis>address_file</I> variable is definedand the file exists, the <I CLASS=emphasis>load_address</I> subroutineis called to load the list of addresses into the <I CLASS=emphasis>address</I>associative array (for easy retrieval).<DIV CLASS=screen><P><PRE>&amp;parse_form_data (*MAIL);</PRE></DIV><P CLASS=para>The form information is stored in the <I CLASS=emphasis>MAIL</I>associative array. The <I CLASS=emphasis>parse_form_data</I> subroutineis the same as the one used at the beginning of <A HREF="ch07_01.htm">Chapter 7, <i>Advanced Form Applications</i></A>. Like the guestbook application I presented in <A HREF="ch07_01.htm">Chapter 7, <i>Advanced Form Applications</i></A>, this program is two in one: Half of the programdisplays a form, and the other half retrieves the data after theuser submits the form, and sends the mail.<DIV CLASS=screen><P><PRE>if ($request_method eq "GET") {    &amp;display_form ();</PRE></DIV><P CLASS=para>If the GET method was used to access thisprogram, the display_formsubroutine displays the form. This gateway can be accessed withoutany query information:<DIV CLASS=screen><P><PRE>http://your.machine/cgi-bin/mail.pl</PRE></DIV><P CLASS=para>in which case, a mail form is displayed. Or, you can alsoaccess it by passing query information:<DIV CLASS=screen><P><PRE>http://your.machine/cgi-bin/mail.pl?to=shishir@bu.edu&amp;url=/thanks.html</PRE></DIV><P CLASS=para>In this case, the "to" and "url" fields in the form will containthe information passed to it. If an address file is being used,the address specified by the "to" field has to match one of theaddresses in the list. Instead of specifying the full email address,you can also use the descriptive title from the address file:<DIV CLASS=screen><P><PRE>http://your.machine/cgi-bin/mail.pl?to=Author&amp;url=/thanks.html</PRE></DIV><P CLASS=para>The advantage of passing queries like this is that you cancreate links within a document, such as:<DIV CLASS=screen><P><PRE>..If you want to contact me, click &lt;A HREF="/cgi-bin/mail.pl?to=Author"&gt;here.&lt;/A&gt;..</PRE></DIV><P CLASS=para>All of the fields in the form, including "to" and "url," willbe explained later in this section.<DIV CLASS=screen><P><PRE>} elsif ($request_method eq "POST") {        if ( defined (%address) ) {        $check_status = &amp;check_to_address ();        if (!$check_status) {            &amp;return_error (500, "$gateway Error",                "The address you specified is not allowed.");        }    }</PRE></DIV><P CLASS=para>This block will be executed if the POSTmethod was used to access this gateway (which means that the userfilled out the form and submitted it). If the <I CLASS=emphasis>address</I>associative array is defined, the <I CLASS=emphasis>check_to_address</I>subroutine is called to check for the validity of the user- specifiedaddress. In other words, the address has to be listed in the addressfile. This subroutine returns a TRUE or FALSEvalue. If the address is not valid, an error message is returned.<DIV CLASS=screen><P><PRE>    if ( (!$MAIL{'from'}) || (!$MAIL{'email'}) ) {        &amp;return_error (500, "$gateway Error", "Who are you ?");    } else {        &amp;send_mail ();                &amp;return_thanks ();    }</PRE></DIV><P CLASS=para>If the user failed to enter any information into the "from"and "email" fields in the form, an error message is returned (whichI will show later). Otherwise, the mail message is sent, and a thank-younote is returned.<DIV CLASS=screen><P><PRE>} else {    &amp;return_error (500, "Server Error",                    "Server uses unsupported method");}exit(0);</PRE></DIV><P CLASS=para>Now for the <I CLASS=emphasis>load_address</I> subroutine,which reads your address file:<DIV CLASS=screen><P><PRE>sub load_address{    local (*ADDRESS_DATA) = @_;    local ($name, $address);    open (FILE, $address_file) || &amp;return_error (500, "$gateway Error",            "Cannot open the address file [$address_file].");        flock (FILE, $exclusive_lock);</PRE></DIV><P CLASS=para>This subroutine opens the address file, and loads all of theentries into an associative array. Note that <I CLASS=emphasis>$exclusive_lock</I>and <I CLASS=emphasis>$unlock</I> are global variables.<DIV CLASS=screen><P><PRE>    while (&lt;FILE&gt;) {        chop if (/\n$/);        ($name, $address) = split (/,/, $_, 2);        $ADDRESS_DATA{$name} = $address;    }</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>while</I> loop iterates through the fileone line at a time. If a line ends with a newline character, itis removed with the <I CLASS=emphasis>chop</I> function. The <I CLASS=emphasis>chop</I>function removes the last character of the line. The <I CLASS=emphasis>if</I>clause is there as a precaution, because the last line of the filemay not have a newline character, in which case part of the datawould be lost. The <I CLASS=emphasis>split</I> command, which shouldbe familiar by now, separates the name from the address. Then, anentry in the associative array is created to hold the address.<DIV CLASS=screen><P><PRE>    flock (FILE, $unlock);    close (FILE);}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>display_form</I> subroutine is executedwhen the client invokes the program without a query.<DIV CLASS=screen><P><PRE>sub display_form{    local ($address_to);    print "Content-type: text/html", "\n\n";        $address_to = &amp;determine_to_field ();</PRE></DIV><P CLASS=para>The determine_to_fieldsubroutine creates a scrolled list if the address file is defined.See <A HREF="ch09_02.htm#CGI-CHP-9-FIG-4">Figure 9.4</A> for a snapshot of what this looks like. Otherwise,a simple text field is used. The HTML neededto accomplish these functions is returned by the subroutine, andis stored in the <I CLASS=emphasis>address_to</I> variable.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-9-FIG-4">Figure 9-4: Scrolled-down list of addresses</A></h4><p><img align=middle src="./figs/cgi0906.gif" alt="[Graphic: Figure 9-4]" width=502 height=293></DIV><DIV CLASS=screen><P><PRE>    print &lt;&lt;End_of_Mail_Form;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;A WWW Gateway to Mail&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;$gateway&lt;/H1&gt;This form can be used to send mail through the World Wide Web.Please fill out all the necessary information.&lt;HR&gt;&lt;FORM METHOD="POST"&gt;&lt;PRE&gt;Full Name:  &lt;INPUT TYPE="text" NAME="from" VALUE="$MAIL{'from'}" SIZE=40&gt;E-Mail:     &lt;INPUT TYPE="text" NAME="email" VALUE="$MAIL{'email'}" SIZE=40&gt;To:         $address_toCC:         &lt;INPUT TYPE="text" NAME="cc" VALUE="$MAIL{'cc'}" SIZE=40&gt;Subject:    &lt;INPUT TYPE="text" NAME="subject" VALUE="$MAIL{'subject'}" SIZE=40&gt;&lt;HR&gt;</PRE></DIV><P CLASS=para>Notice the use of the VALUE attributes in the INPUTstatements. These values represent the query information that ispassed to this program with a GET request.<DIV CLASS=screen><P><PRE>Please type the message below:&lt;TEXTAREA ROWS=10 COLS=60 NAME="message"&gt;&lt;/TEXTAREA&gt;&lt;/PRE&gt;&lt;INPUT TYPE="hidden" NAME="url" VALUE="$MAIL{'url'}"&gt;&lt;INPUT TYPE="submit" VALUE="Send the Message"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear the Message"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;End_of_Mail_Form}</PRE></DIV><P CLASS=para>The "url" field is defined as a hidden field. This consistsof the URL of the document that is displayed after the user completesthe form.<P CLASS=para>The <I CLASS=emphasis>determine_to_field</I> subroutine eithercreates a scrolled list of all the addresses in the file, or a simpletext field in which the user can enter the recipient's address.<DIV CLASS=screen><P><PRE>sub determine_to_field{    local ($to_field, $key, $selected);    if (%address) {        $to_field = '&lt;SELECT NAME="to"&gt;';        foreach $key (keys %address) {</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>keys</I> function returns a normal arrayconsisting of all of the keys of the associative array. The <I CLASS=emphasis>foreach</I>construct then iterates through each key.<DIV CLASS=screen><P><PRE>            if ( ($MAIL{'to'} eq $key) ||                 ($MAIL{'to'} eq $address{$key}) ) {                        $selected = "&lt;OPTION SELECTED&gt;";            } else {                $selected = "&lt;OPTION&gt;";            }</PRE></DIV><P CLASS=para>If the recipient specified by the user (through a query string)matches either the descriptive title in the address file-the key-orthe actual address, it is highlighted. Remember, this is how youcan access this program with a query:<DIV CLASS=screen><P><PRE>http://your.machine/cgi-bin/mail.pl?to=shishir@bu.edu&amp;url=/thanks.html</PRE></DIV><P CLASS=para>Now, the rest of the subroutine:<DIV CLASS=screen><P><PRE>            $to_field = join ("\n", $to_field,                        $selected, $key);        }        $to_field = join ("\n", $to_field, "&lt;/SELECT&gt;");</PRE></DIV><P CLASS=para>Finally, all of the &lt;OPTION&gt; tags are concatenated tocreate the kind of scrolled list shown above.<DIV CLASS=screen><P><PRE>    } else {        $to_field =         qq/&lt;INPUT TYPE="text" NAME="to" VALUE="$MAIL{'to'}" SIZE=40&gt;/;    }    return ($to_field);}</PRE></DIV><P CLASS=para>If an address fileis not used, a simple text field is displayed. The <I CLASS=emphasis>qq/../</I>construct builds a double-quoted string. It should be used whenthere are many double quotation marks within the string. The samestring can be expressed inside the traditional double quotes:<DIV CLASS=screen><P><PRE>$to_field = "&lt;INPUT TYPE=\"text\" NAME=\"to\" VALUE=\"$MAIL{'to'}\" SIZE=40&gt;";</PRE></DIV><P CLASS=para>As you can see, all of the other double quotation marks withinthe string have to be escaped by putting backslashes in front ofthem. Using the <I CLASS=emphasis>qq</I> notation in the regularexpression is much easier.<P CLASS=para>Finally, the HTML needed to display the "to" field is returned.<P CLASS=para>The <I CLASS=emphasis>check_to_address</I> subroutine checksthe user-specified recipient to make sure that it is valid. If itis valid, the variable <I CLASS=emphasis>$MAIL{' to' }</I> will beset to the corresponding email address. Finally, a status indicatingsuccess or failure is returned.<DIV CLASS=screen><P><PRE>sub check_to_address{        local ($status, $key);    $status = 0;    foreach $key (keys %address) {         if ( ($MAIL{'to'} eq $key) || ($MAIL{'to'} eq $address{$key}) ) {            $status = 1;            $MAIL{'to'} = $address{$key};         }    }    return ($status);}</PRE></DIV><P CLASS=para>In this next subroutine, the mail is sent using the UNIX sendmail utility.<DIV CLASS=screen><P><PRE>sub send_mail{    open (SENDMAIL, "| $sendmail");</PRE></DIV><P CLASS=para>A pipe to the sendmail utility is opened for input. We donot need to check any of the form values for shell metacharactersbecause none of the values are "exposed" on the command line. The<I CLASS=emphasis>sendmail</I> utility allows you to place the recipient'sname in the input stream, rather than on the command-line.<P CLASS=para>If the regular <I CLASS=emphasis>mail</I> utility is used,the form information must be checked for metacharacters. This ishow we can send mail with the <I CLASS=emphasis>mail</I> utility:<DIV CLASS=screen><P><PRE>if ($MAIL{'to'} =~ /([\w\-\+]+)@([\w\-\+\.]+)/) {    open (SENDMAIL, "/usr/ucb/mail $MAIL{'to'} |");} else {    &amp;return_error (500, "$gateway Error", "Address is not valid.");}</PRE></DIV><P CLASS=para>The regular expression is described by the figure below. Ofcourse, this allows only Internet-style mail addresses; UUCPaddresses are not recognized.<p><img align=middle src="./figs/cgi0907.gif" alt="[Graphic: Figure from the text]" width=446 height=236><DIV CLASS=screen><P><PRE>    print SENDMAIL &lt;&lt;Mail_Headers;From: $MAIL{'from'} &lt;$MAIL{'email'}&gt;To: $MAIL{'to'}Reply-To: $MAIL{'email'}Subject: $MAIL{'subject'}X-Mailer: $gatewayX-Remote-Host: $ENV{'REMOTE_ADDR'}Mail_Headers</PRE></DIV><P CLASS=para>Various mailheaders are output. Any headers starting with "X-" are user/programspecified, and are usually ignored by mail readers. The remote IPaddress of the user (the environment variable REMOTE_ADDRESS)is output for possible security reasons. Imagine a situation wheresomeone fills out a form with obnoxious information, and includesa "fake" address. This header will at least tell you where the messagecame from.<DIV CLASS=screen><P><PRE>    if ($MAIL{'cc'}) {        print SENDMAIL "Cc: ", $MAIL{'cc'}, "\n";    }    print SENDMAIL "\n", $MAIL{'message'}, "\n";          close (MAIL);}</PRE></DIV><P CLASS=para>If the user entered an address in the "Cc:" field, a mailheader is output. Finally, the body of the message is displayed,and the pipe is closed.<P CLASS=para>It is courteous to output a thank-you message:<DIV CLASS=screen><P><PRE>sub return_thanks{    if ($MAIL{'url'}) {        print "Location: ", $MAIL{'url'}, "\n\n";    } else {        print "Content-type: text/html", "\n\n";        print &lt;&lt;Thanks;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;$gateway&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Thank You!&lt;/H1&gt;&lt;HR&gt;Thanks for using the mail gateway. Please feel free to use it again.&lt;/BODY&gt;&lt;/HTML&gt;Thanks    }}</PRE></DIV><P CLASS=para>If a URL was specified as part of the GETrequest, a server redirect is done with the "Location" HTTP header.In other words, the server will get and display the specified documentafter the user submits the form. Otherwise, a simple thank-you noteis issued.</DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch09_01.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch09_03.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>UNIX Manual Page Gateway</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Relational Databases</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>