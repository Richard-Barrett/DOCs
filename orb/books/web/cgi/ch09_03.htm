<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 9] 9.3 Relational Databases</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:33:46 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch09_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 9</b></td><td width=172 align=right valign=top><A HREF="ch09_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3">9.3 Relational Databases</A></h2><P CLASS=para>So far in this chapter, wehave created pretty simple gateways by piping input to other programs.As long as we create the proper stream of data, it takes very littlecoding on our part to make these work. But the most interestinguses for gateways involve large, complex sets of data organizedinto structured databases. Piping a stream does not work for these;we need to use a language that the database understands, such asSQL. This is where we turn in this section.<P CLASS=para>By combining the power of relational database management systems(RDBMS) with the World Wide Web, one can produceimpressive results. Put yourself in the shoes of a doctor who wantsto establish an "interactive, virtual infirmary" on the Web, whereusers (patients) can simply enter their symptoms, and the CGI wouldreturn with a diagnosis. The doctor has a large database that containsextensive data, including three-dimensional graphics and multimedia,on the various diseases and ailments that affect humans. All thatneeds to be done is to write a CGI program that decodes the input,assembles a query of some sort, sends it to the database, processesthe return data from the database, and creates a hypertext document(with embedded multimedia) for the user. These types of applicationsare possible by combining databases with the Web.<P CLASS=para>Before we go any further, let's look at SQL, the query languageused to communicate with various RDBMS systems.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.1">Introduction to SQL</A></h3><P CLASS=para>SQL-pronounced "S Q L" and not"Sequel"-is a standardized sub-language to access and manipulatedata within a relational database system. The original SQL prototypedefined a "structured" language, thus the term Structured QueryLanguage, but this is no longer true of the current SQL-92 standard.SQL was designed specifically to be used in conjunction with a primaryhigh-level programming language. In fact, most of the basic constructsthat you would find in a high-level language, such as loops andconditionals, do not exist in SQL.<P CLASS=para>Most of the commercial relational database systems in usetoday, such as Oracle and Sybase, support SQL. As a result, thecode to access and manipulate a database can be ported easily andquickly to any platform. Now, let's look at SQL.<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.1.1">Creating a database</A></h4><P CLASS=para>We will start outby discussing how a database is created. Suppose you have the followinginformation:<DIV CLASS=informaltable><P><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left"><P CLASS=para>Player</TH><TH ALIGN="left"><P CLASS=para>Years</TH><TH ALIGN="left"><P CLASS=para>Points</TH><TH ALIGN="left"><P CLASS=para>Rebounds</TH><TH ALIGN="left"><P CLASS=para>Assists</TH><TH ALIGN="left"><P CLASS=para>Championships</TH></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Larry Bird</TD><TD ALIGN="left"><P CLASS=para>12</TD><TD ALIGN="left"><P CLASS=para>28</TD><TD ALIGN="left"><P CLASS=para>10</TD><TD ALIGN="left"><P CLASS=para>7</TD><TD ALIGN="left"><P CLASS=para>3</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Michael Jordan</TD><TD ALIGN="left"><P CLASS=para>10</TD><TD ALIGN="left"><P CLASS=para>33</TD><TD ALIGN="left"><P CLASS=para>6</TD><TD ALIGN="left"><P CLASS=para>5</TD><TD ALIGN="left"><P CLASS=para>3</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Magic Johnson</TD><TD ALIGN="left"><P CLASS=para>12</TD><TD ALIGN="left"><P CLASS=para>22</TD><TD ALIGN="left"><P CLASS=para>7</TD><TD ALIGN="left"><P CLASS=para>12</TD><TD ALIGN="left"><P CLASS=para>5</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>John Stockton</TD><TD ALIGN="left"><P CLASS=para>10</TD><TD ALIGN="left"><P CLASS=para>16</TD><TD ALIGN="left"><P CLASS=para>3</TD><TD ALIGN="left"><P CLASS=para>13</TD><TD ALIGN="left"><P CLASS=para>0</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Karl Malone</TD><TD ALIGN="left"><P CLASS=para>10</TD><TD ALIGN="left"><P CLASS=para>25</TD><TD ALIGN="left"><P CLASS=para>11</TD><TD ALIGN="left"><P CLASS=para>3</TD><TD ALIGN="left"><P CLASS=para>0</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Shaquille O'Neal</TD><TD ALIGN="left"><P CLASS=para>2</TD><TD ALIGN="left"><P CLASS=para>29</TD><TD ALIGN="left"><P CLASS=para>12</TD><TD ALIGN="left"><P CLASS=para>3</TD><TD ALIGN="left"><P CLASS=para>0</TD></TR></TABLE><P></DIV><P CLASS=para>The SQL code to create this database is:<DIV CLASS=screen><P><PRE>create table Player_Info(    Player            character varying (30) not null,    Years             integer,    Points            integer,    Rebounds          integer,    Assists           integer,    Championships     integer);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>create table</I> command creates a database,or a table. The <I CLASS=emphasis>Player</I> field is stored as anon-null varying character string. In other words, if the data inthe field is less than 30 characters, the database will not padit with spaces, as it would for a regular character data type. Also,the database forces the user to enter a value for the <I CLASS=emphasis>Player</I>field; it cannot be empty.<P CLASS=para>The rest of the fields are defined to be integers. Some ofthe other valid data types include <I CLASS=emphasis>date</I>, <I CLASS=emphasis>time</I>,<I CLASS=emphasis>smallint</I>, <I CLASS=emphasis>numeric</I>, and<I CLASS=emphasis>decimal</I>. The <I CLASS=emphasis>numeric</I> and<I CLASS=emphasis>decimal</I> data types allow you to specify floating-pointvalues. For example, if you want a five-digit floating-point numberwith a precision to the hundredth place, you can specify <i CLASS=command>decimal(5, 2)</i>.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.1.2">Accessing data</A></h4><P CLASS=para>Let's say you want a list of the entire database. You canuse the following code:<DIV CLASS=screen><P><PRE>select *     from Player_Info;</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>select</I> command retrieves specificinformation from the database. In this case, all columns are selectedfrom the <I CLASS=emphasis>Player_Info</I> database. The "*" shouldbe used with great caution, especially on large databases, as youmight inadvertently extract a lot of information. Notice that weare dealing only with columns, and not rows. For example, if youwanted to list all the players in the database, you could do this:<DIV CLASS=screen><P><PRE>select Player    from Player_Info;</PRE></DIV><P CLASS=para>Now, what if you want to list all the players who scored morethan 25 points? Here is the code needed to accomplish the task:<DIV CLASS=screen><P><PRE>select *    from Player_Info    where (Points &gt; 25);</PRE></DIV><P CLASS=para>This would list all the columns for the players who scoredmore than 25 points:<DIV CLASS=informaltable><P><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left"><P CLASS=para>Player</TH><TH ALIGN="left"><P CLASS=para>Years</TH><TH ALIGN="left"><P CLASS=para>Points</TH><TH ALIGN="left"><P CLASS=para>Rebounds</TH><TH ALIGN="left"><P CLASS=para>Assists</TH><TH ALIGN="left"><P CLASS=para>Championships</TH></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Larry Bird</TD><TD ALIGN="left"><P CLASS=para>12</TD><TD ALIGN="left"><P CLASS=para>28</TD><TD ALIGN="left"><P CLASS=para>10</TD><TD ALIGN="left"><P CLASS=para>7</TD><TD ALIGN="left"><P CLASS=para>3</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Michael Jordan</TD><TD ALIGN="left"><P CLASS=para>10</TD><TD ALIGN="left"><P CLASS=para>33</TD><TD ALIGN="left"><P CLASS=para>6</TD><TD ALIGN="left"><P CLASS=para>5</TD><TD ALIGN="left"><P CLASS=para>3</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Shaquille O'Neal</TD><TD ALIGN="left"><P CLASS=para>2</TD><TD ALIGN="left"><P CLASS=para>29</TD><TD ALIGN="left"><P CLASS=para>12</TD><TD ALIGN="left"><P CLASS=para>3</TD><TD ALIGN="left"><P CLASS=para>0</TD></TR></TABLE><P></DIV><P CLASS=para>But, say you wanted to list just the <I CLASS=emphasis>Player</I>and <I CLASS=emphasis>Points</I> columns:<DIV CLASS=screen><P><PRE>select Player, Points    from Player_Info    where (Points &gt; 25);</PRE></DIV><P CLASS=para>Here is an example that returns all the players who scoredmore than 25 points and won a championship:<DIV CLASS=screen><P><PRE>select Player, Points, Championships    from Player_Info    where (Points &gt; 25) and          (Championships &gt; 0);</PRE></DIV><P CLASS=para>The output of this SQL statement would be:<DIV CLASS=informaltable><P><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left"><P CLASS=para>Player</TH><TH ALIGN="left"><P CLASS=para>Points</TH><TH ALIGN="left"><P CLASS=para>Championships</TH></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Larry Bird</TD><TD ALIGN="left"><P CLASS=para>28</TD><TD ALIGN="left"><P CLASS=para>3</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Michael Jordan</TD><TD ALIGN="left"><P CLASS=para>33</TD><TD ALIGN="left"><P CLASS=para>3</TD></TR></TABLE><P></DIV><P CLASS=para>You could also use wildcards in a selectcommand. For example, the following will return all the playersthat have a last name of "Johnson":<DIV CLASS=screen><P><PRE>select *    from Player_Info    where Player LIKE '% Johnson';</PRE></DIV><P CLASS=para>This will match a string ending with "Johnson".</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.1.3">Updating a database</A></h4><P CLASS=para>Let's suppose thatShaquille O'Neal won a championship. We need to update our databaseto reflect this. This is how it can be done:<DIV CLASS=screen><P><PRE>update Player_Info    set Championships = 1    where Player = 'Shaquille O'Neal';</PRE></DIV><P CLASS=para>SQL also has methods to modify entire columns. After everybasketball season, we need to increment the <I CLASS=emphasis>Years</I>column by one:<DIV CLASS=screen><P><PRE>update Player_Info    set Years = (Years + 1);</PRE></DIV><P CLASS=para>Now, let's discuss insertion into a table. Say we need toadd another player to the database. We could do it this way:<DIV CLASS=screen><P><PRE>insert into Player_Info    values    ('Hakeem Olajuwon', 10, 27, 11, 4, 2);</PRE></DIV><P CLASS=para>As you can see, it is very simple to insert an element intothe table. However, if you have a database with a large number ofcolumns, and you want to insert a row into the table, you can manuallyspecify the columns:<DIV CLASS=screen><P><PRE>insert into Player_Info    (Player, Years, Points, Rebounds, Assists, Championships)    values    ('Hakeem Olajuwon', 10, 27, 11, 4, 2);</PRE></DIV><P CLASS=para>When used in this context, the order of the fields does notnecessarily have to match the order in the database, as long asthe fields and the values specified match each other.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.1.4">Deleting information</A></h4><P CLASS=para>If you wantedto delete "John Stockton" from the database, you could do this:<DIV CLASS=screen><P><PRE>delete from Player_Info    where Player = 'John Stockton';</PRE></DIV><P CLASS=para>SQL also allows you remove entire columns. You should be verycareful when attempting such a move. Instead, it is much safer tocreate another database, and copy only the columns you want to thenew database. Here is how you would remove a column:<DIV CLASS=screen><P><PRE>alter table Player_Info    drop column Championships;</PRE></DIV><P CLASS=para>If you want to delete all the records in the table, the followingstatement is used:<DIV CLASS=screen><P><PRE>delete from Player_Info;</PRE></DIV><P CLASS=para>And finally, the <I CLASS=emphasis>drop table</I> command deletesthe entire database:<DIV CLASS=screen><P><PRE>drop table Player_Info;</PRE></DIV><P CLASS=para>(For more information on SQL, see the reference guide on SQL-92at <A HREF="http://sunsite.doc.ic.ac.uk/packages/perl/db/refinfo/sql2/sql1992.txt">http://sunsite.doc.ic.ac.uk/packages/perl/db/refinfo/sql2/sql1992.txt</A>).</DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.2">Sprite</A></h3><P CLASS=para>Never heard of Sprite?That is because I developed it for this book. It is a Perl 5 modulethat allows you to manipulate text-delimited databases (all dataand delimiters are text) using a small but important subset of SQL-92.I offer Sprite so you can create your own databases and access themin CGI scripts, even if you do not have a database product likeSybase or Oracle. See <A HREF="appe_01.htm">Appendix E, <i>Applications, Modules, Utilities, and Documentation</i></A> for information on whereyou can get Sprite.<P CLASS=para>If you do have a commercial product, you can use techniqueslike those shown here to issue SQL commands. We will use some Perlinterfaces to Oracle and Sybase later in the chapter. Let's lookat an example.<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.2.1">Employee database</A></h4><P CLASS=para>Let's assume that you have a text file that contains a listof your company's employees, as well as some information about them:<DIV CLASS=screen><P><PRE>Last,First,Job_Title,Department,EMail,PhoneSupra,John,System Operator,Systems,jsupra,(617) 555-1578Painton,Todd,Network Engineer,Systems,tpainton,(617) 555-6530Martin,Robert,Sales Representative,Sales,martinr,(617) 555-7406Levine,Julia,Administrative Assistant,Administration,julia,(617) 555-3056Keenan,Jeff,Manager,Software,jeffk,(617) 555-7769Nets,Laurie,Group Leader,Development,lnets,(617) 555-9962</PRE></DIV><P CLASS=para>The first line of the file contains the field names (delimitedby commas). This is all you need to use the database. Unlike otherdatabases that store the data in a unique (and strange) format,Sprite operates on plain text.<P CLASS=para>Here is the form that will act as the front end to the database:<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;CGI Corporation&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Employee Database&lt;/H1&gt;Welcome to the CGI Corporations's Employee Search Form. You can usethis to find information about one of our employee. Enter as much information as possible to narrow down the search. &lt;HR&gt;&lt;FORM ACTION="/cgi-bin/db_phone.pl" METHOD="POST"&gt;&lt;PRE&gt;Last Name:      &lt;INPUT TYPE="text" NAME="Last" SIZE=40&gt;First Name:     &lt;INPUT TYPE="text" NAME="First" SIZE=40&gt;Job Title:      &lt;INPUT TYPE="text" NAME="Job_Title" SIZE=40&gt;Department:     &lt;INPUT TYPE="text" NAME="Department" SIZE=40&gt;EMail Address:  &lt;INPUT TYPE="text" NAME="EMail" SIZE=40&gt;Phone Number:   &lt;INPUT TYPE="text" NAME="Phone" SIZE=40&gt;&lt;/PRE&gt;&lt;INPUT TYPE="submit" VALUE="Submit the search"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>The form is shown in <A HREF="ch09_03.htm#CGI-CHP-9-FIG-5">Figure 9.5</A>.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-9-FIG-5">Figure 9-5: Phone form</A></h4><p><img align=middle src="./figs/cgi0908.gif" alt="[Graphic: Figure 9-5]" width=410 height=307></DIV><P CLASS=para>Now, let's build the CGI application that will decode theform information, process the user's query, and create a documentdisplaying the results, as seen in <A HREF="ch09_03.htm#CGI-CHP-9-FIG-6">Figure 9.6</A>.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-9-FIG-6">Figure 9-6: CGI gateway to database</A></h4><p><img align=middle src="./figs/cgi0909.gif" alt="[Graphic: Figure 9-6]" width=428 height=396></DIV><P CLASS=para>The program begins:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl5use Sprite;$webmaster = "shishir\@bu\.edu";$query = undef;</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>use</I>command instructs Perl to load the module (or extension). You canload more than one module at a time. For example, if we wanted tocreate dynamic GIF images from the data contained in a database,we would have to load both the <I CLASS=emphasis>GD</I> and the <I CLASS=emphasis>Sprite</I>modules:<DIV CLASS=screen><P><PRE>use GD;use Sprite;</PRE></DIV><P CLASS=para>To continue with the program:<DIV CLASS=screen><P><PRE>&amp;parse_form_data(*FORM);$fields = '(Last|First|Job_Title|Department|EMail|Phone)';</PRE></DIV><P CLASS=para>The form data is decoded. The <I CLASS=emphasis>parse_form_data</I>subroutine used in this program is the one we've been using throughoutthis book. The <I CLASS=emphasis>fields</I> variable contains a listof all the fields in the form. You might wonder why we would needto have such a list when then the <I CLASS=emphasis>parse_form_data</I>subroutine decodes all the fields in the form. The reason for thisis to make sure that only valid fields are processed, as the searchquery is dynamically created from the user-specified information.Remember, forms are very insecure; a cracker can download a form,edit it, add an extra field, and submit the form to the program.If the program is not carefully designed, we could have a majorproblem!<DIV CLASS=screen><P><PRE>foreach $key (keys %FORM) {    if ( ($key !~ /\b$fields\b/o) || ($FORM{$key} =~ /[^\w\-\(\) ]/) ) {        &amp;return_error (500, "CGI Corporation Employee Database Error",                            "Invalid Information in Form.");</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>foreach</I> construct iterates throughall of the fields stored in the FORM associative array, and checksfor two things, represented by the two expressions separated bythe || operator. First, the field is checked against the list storedin the <I CLASS=emphasis>fields</I> variable for validity. Second,it makes sure the information entered by the user is constrainedto the following characters: A-Z, a-z, 0-9, (, ), and the spacecharacter. This ensures that no shell metacharacters are passed.<DIV CLASS=screen><P><PRE>    } else {        $FORM{$key} =~ s/(\W)/\\$1/g;        if ($FORM{$key}) {            $query = join (" and ", $query, "($key =~ /$FORM{$key}/i)");        }    }}</PRE></DIV><P CLASS=para>The conditional is executed if the field is valid. It checksto see if any information was entered in the field. If there isinformation, a query is built by joining each field and value with"and". You would normally have to escape the "/" character if youare using the regular expression search in Sprite. In this case,you don't need to because the user cannot enter "/" in any searchfield.<P CLASS=para>Once the loop terminates, a query might look something likethe following:<DIV CLASS=screen><P><PRE>and (Last =~ /Martin/i) and (First =~ /Robert/i) and (Department =~ /Sales/i)</PRE></DIV><P CLASS=para>The reason the query has an "and" at the beginning has todo with the way in which the query was created. If you look backat the <I CLASS=emphasis>join</I> command, you can see that the informationstored in the <I CLASS=emphasis>query</I> variable is concatenatedto a combination of a key and a value with "and", and is finallystored in <I CLASS=emphasis>query</I>. Remember, <I CLASS=emphasis>$query</I>will be undefined the first time through the loop, and thus willend up with an "and" at the beginning. Let's remove the unwantedinitial string.<DIV CLASS=screen><P><PRE>if ($query) {    $query =~ s/^ and //;} else {    &amp;return_error (500, "CGI Corporation Employee Database Error",                        "No query was entered.");}</PRE></DIV><P CLASS=para>If the user failed to enter any information, an error messageis displayed. Otherwise, the "and" at the beginning of the queryis removed to create a normal query:<DIV CLASS=screen><P><PRE>(Last =~ /Martin/i) and (First =~ /Robert/i) and (Department =~ /Sales/i)</PRE></DIV><P CLASS=para>Note that Sprite allows you to use regular expression operatorsto search for data. If the user entered "M" in the last name field,this program instructs the database to return all records that containthe letter "M" (or "m", as the "i" flag indicates case insensitivity).There are cases when this is not desirable. In such cases, you wouldneed to modify the way the query is joined:<DIV CLASS=screen><P><PRE>$FORM{$key} = s/(['"])/\\$1/g;$query = join (" and ", $query, "($key = '$FORM{$key}')");</PRE></DIV><P CLASS=para>This will return only exact matches. Since the value in thefield is a string, you need to enclose <I CLASS=emphasis>$FORM{$key}</I>in single quotes and escape all other quotes (or Sprite will returnan error).<DIV CLASS=screen><P><PRE>$rdb = new Sprite ();$rdb-&gt;set_delimiter ("Read", ",");</PRE></DIV><P CLASS=para>This is some object-oriented Perl syntax that you saw in <A HREF="ch06_01.htm">Chapter 6, <i>Hypermedia Documents</i></A>. A new database object iscreated, and the reference to it is stored in the variable <I CLASS=emphasis>rdb</I>.The <I CLASS=emphasis>set_delimiter</I> function sets the delimiterfor the data stored in the database. The <I CLASS=emphasis>set_delimiter</I>function takes two arguments. In the first, we specify that we arereading from the database. In the second, we specify the comma asthe field delimiter (so we have to know what the data file lookslike).<DIV CLASS=screen><P><PRE>@data = $rdb-&gt;sql (&lt;&lt;End_of_Query);    select * from phone.db    where $queryEnd_of_Query</PRE></DIV><P CLASS=para>The query is passed to Sprite with the sql function. In this case,a here document is used to pass the query (so it looks readableto humans). You could just as easily do this:<DIV CLASS=screen><P><PRE>@data = $rdb-&gt;sql ("select * from phone.db where $query");</PRE></DIV><P CLASS=para>Sprite returns the matched records as an array, with all thefields in each record joined by the null character "\0". However,the first element of the array is not a record, but a flag indicatingsuccess or failure. For instance, if you passed the following query:<DIV CLASS=screen><P><PRE>select * from phone.db where (Department =~ /Systems/i)</PRE></DIV><P CLASS=para>the array would look like this:<DIV CLASS=screen><P><PRE>$data[0] = 1$data[1] = Supra\0John\0System Operator\0Systems\0jsupra\0(617) 555-1578$data[2] = Painton\0Todd\0Network Engineer\0Systems\0tpainton\0(617) 555-6530</PRE></DIV><P CLASS=para>A value of 1 indicates success, while a 0 indicates failure.<DIV CLASS=screen><P><PRE>$status = shift (@data);$no_elements = scalar (@data);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>shift</I> statement removes the firstelement of the array and stores it in the variable <I CLASS=emphasis>status</I>.Then <I CLASS=emphasis>scalar</I> is used to determine the numberof elements in the array. You can also evaluate the array in a scalarcontext, without using the <I CLASS=emphasis>scalar</I> command:<DIV CLASS=screen><P><PRE>$no_elements = @data;</PRE></DIV><P CLASS=para>This is the same as using the <I CLASS=emphasis>scalar</I>command, but different from:<DIV CLASS=screen><P><PRE>$last_element = $#data;</PRE></DIV><P CLASS=para>This returns the index of the last element of the array (soin most cases, it would have a value one less than the number ofelements, as arrays are zero-based).<DIV CLASS=screen><P><PRE>if (!$status) {    &amp;return_error (500, "CGI Corporation Employee Database Error",                        "Sprite Database Error!");} elsif (!$no_elements) {    &amp;return_error (500, "CGI Corporation Employee Database Error",                        "The record you specified does not exist.");</PRE></DIV><P CLASS=para>Two things are checked: the error status and the number ofrecords returned by Sprite. If either the status is 0 or no recordswere returned, an error is displayed.<DIV CLASS=screen><P><PRE>} else {    print &lt;&lt;End_of_HTML;Content-type: text/html&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;CGI Corporation Employee Directory&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;CGI Corporation Employee Directory&lt;/H1&gt;&lt;HR&gt;&lt;PRE&gt;End_of_HTML</PRE></DIV><P CLASS=para>This code is executed if valid records were returned by Sprite.We are now formatting the output for display. One of Perl's originalattractions was the report-generating features it offered; LarryWall even said that the "rl" in Perl stood for "Reporting Language."We will use some of those powerful features here. What we have todo is create a format and assign it to the <I CLASS=emphasis>$~</I>variable. Then, whenever we issue a <I CLASS=emphasis>write</I> statement,Perl will print the data according to the format.<DIV CLASS=screen><P><PRE>    $~ = "HEADING";    write;</PRE></DIV><P CLASS=para>The "HEADING" format is selected to display header information.<DIV CLASS=screen><P><PRE>    $~ = "EACH_ENTRY";    foreach (@data) {         s/([^\w\s\0])/sprintf ("&amp;#%d;", ord ($1))/ge;        ($last, $first, $job, $department, $email, $phone) =            split (/\0/, $_, 6);        write;    }    print "&lt;/PRE&gt;", "\n";    print "&lt;HR&gt;";		print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";}</PRE></DIV><P CLASS=para>The "EACH_ENTRY" format is selected to display each recordfrom the phone database. The <I CLASS=emphasis>foreach</I> loop iteratesthrough each record, splits it into the different fields, and issuesa <I CLASS=emphasis>write</I> to display the data. Note that no variablewas supplied as part of the <I CLASS=emphasis>foreach</I> loop. Normally,we would have something like this:<DIV CLASS=screen><P><PRE>foreach $record (@data) {    .    .    .}</PRE></DIV><P CLASS=para>Since we did not supply a variable, Perl automatically placesit in its default variable: <I CLASS=emphasis>$_</I>.<DIV CLASS=screen><P><PRE>$rdb-&gt;close ();exit (0);</PRE></DIV><P CLASS=para>Finally, the database is closed, and the script terminates.Now, let's look at the two format statements:<DIV CLASS=screen><P><PRE>format HEADING = Last       First      Job Title      Department   EMail       Phone----       -----      ---------      ----------   -----       -----.</PRE></DIV><P CLASS=para>This is a simple one! It is used as a header to display allof the fields. The period on a line by itself terminates the format.<DIV CLASS=screen><P><PRE>format EACH_ENTRY = @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;$last,     $first,    $job,          $department, $email,     $phone.</PRE></DIV><P CLASS=para>This one is a little more complex. The "@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"indicates an eight-character, left-justified field holder. The valuestored in the variable, which is listed below a field holder, isdisplayed each time a <I CLASS=emphasis>write</I> is called. Thiswill allow for a neat and clean display, as shown in <A HREF="ch09_03.htm#CGI-CHP-9-FIG-7">Figure 9.7</A>.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-9-FIG-7">Figure 9-7: Phone gateway results</A></h4><p><img align=middle src="./figs/cgi0910.gif" alt="[Graphic: Figure 9-7]" width=498 height=330></DIV></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.2.2">Student database</A></h4><P CLASS=para>A CGI program is not limited to just reading information froma database; it can also manipulate the information. Here is a CGIprogram that can read, modify, and delete a database consistingof student information. Before we go any further, let's look atthe supporting HTML documents:<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Student Database&lt;/H1&gt;You can use a combination of forms and CGI to access and modify information inthe student database. Please choose one of the following options:&lt;HR&gt;&lt;A HREF="/add.html"&gt;Add New Student&lt;/A&gt;&lt;BR&gt;&lt;A HREF="/modify.html"&gt;Modify Student Information&lt;/A&gt;&lt;BR&gt;&lt;A HREF="/view.html"&gt;View Student Information&lt;/A&gt;&lt;BR&gt;&lt;A HREF="/delete.html"&gt;Delete Student&lt;/A&gt;&lt;BR&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>This is the initial document containing links to the variousforms that allow the user to view, add, modify, and delete informationfrom the student database.<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Add New Student&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/student.pl?add" METHOD="POST"&gt;&lt;PRE&gt;Student Name:       &lt;INPUT TYPE="text" NAME="Student" SIZE=40&gt;Year of Graduation: &lt;INPUT TYPE="text" NAME="YOG" SIZE=4 MAXLENGTH=4&gt;Address (Mailing Information):&lt;TEXTAREA NAME="Address" ROWS=4 COLS=40&gt;&lt;/TEXTAREA&gt;&lt;/PRE&gt;&lt;INPUT TYPE="submit" VALUE="Add New Student"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>This is the form used to add information into the database.When the user submits this form, a query of "add" is sent to theCGI program.<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Modify Student Information&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/student.pl?modify_form" METHOD="POST"&gt;Student Name: &lt;INPUT TYPE="text" NAME="Student" SIZE=40&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Modify Student Information"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>This form allows the user to modify information for a particularstudent. When this form is submitted, the program builds and displaysanother form dynamically. Here is the form used to view the resultsof a specified query.<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;View Student Information&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/student.pl?view" METHOD="POST"&gt;Student Name: &lt;INPUT TYPE="text" NAME="Student" SIZE=40&gt;&lt;P&gt;Year of Graduation:&lt;INPUT TYPE="radio" NAME="Sign" VALUE="greater"&gt; Greater Than&lt;INPUT TYPE="radio" NAME="Sign" VALUE="equal" CHECKED&gt; Equal To&lt;INPUT TYPE="radio" NAME="Sign" VALUE="less"&gt; Less Than&lt;INPUT TYPE="text" NAME="YOG" SIZE=4 MAXLENGTH=4&gt;&lt;P&gt;Address Information: &lt;INPUT TYPE="text" NAME="Address" SIZE=40&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="View Student Information"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>This form is used to view records that match certain criteria.The user can select records based on a conditional year of graduation(either greater than, less than, or equal to a certain year). Wecould have just as easily allowed mathematical operators (&gt;, &lt;,and =) to be entered, but this can be a potential security hole,as some of them have a special meaning to the shell (i.e., shellmetacharacters). It is far better and safer to use strings like"equal", "greater", and "less", and let the CGI program convertthem to the appropriate operators when creating a query.<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Delete Student&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/student.pl?delete" METHOD="POST"&gt;&lt;PRE&gt;Student Name:       &lt;INPUT TYPE="text" NAME="Student" SIZE=40&gt;Year of Graduation: &lt;INPUT TYPE="text" NAME="YOG" SIZE=4 MAXLENGTH=4&gt;&lt;/PRE&gt;&lt;INPUT TYPE="submit" VALUE="Delete Student"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>A user can use this form to delete information from the database.In this case, only the student name and year of graduation fieldsare presented. Records for an entire class can be deleted by specifyingthe year of graduation, and leaving the <I CLASS=emphasis>name</I>field empty. You should not normally allow such a dangerous option!However, it is shown here to illustrate the power of databases andthe Web.<P CLASS=para>Now, let's look at the CGI program that works with theseforms.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perl5use Sprite;$query_string = $ENV{'QUERY_STRING'};$script = $ENV{'SCRIPT_NAME'};$request_method = $ENV{'REQUEST_METHOD'};$webmaster = "shishir\@bu\.edu";$database = "/home/shishir/student.db";$main_form = "/student.html";$commands = '(add|modify_form|modify|view|delete)';</PRE></DIV><P CLASS=para>The Sprite moduleis loaded. The full path to the student database and the relativepath to the main HTML document (the one thatcontains links to the other forms) are stored in the <I CLASS=emphasis>database</I>,and <I CLASS=emphasis>main_form</I> variables, respectively. Finally,<I CLASS=emphasis>commands</I> contains a list of the valid queriesthat forms can pass to this program. If you look carefully at thelist, you will notice that none of the forms listed above passesthe "modify" query. The form that passes this is dynamically createdby this program, as you will later see.<DIV CLASS=screen><P><PRE>$delimiter = "::";$error = "CGI Student Database Error";</PRE></DIV><P CLASS=para>Fields in the student database are delimited by the "::" characters.<DIV CLASS=screen><P><PRE>if ($query_string =~ /^\b$commands\b$/) {    &amp;parse_form_data (*DB);</PRE></DIV><P CLASS=para>If the query is valid, the POST form data is decoded and placedin the <I CLASS=emphasis>DB</I> associative array. (As always, the<I CLASS=emphasis>parse_form_data</I> subroutine used in this programis the one we've been using throughout all our examples.)<DIV CLASS=screen><P><PRE>    &amp;check_all_fields ();    &amp;check_database ();</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>check_all_fields</I> subroutine iteratesthrough the <I CLASS=emphasis>DB</I> associative array to ensurethat there are no shell metacharacters. The <I CLASS=emphasis>check_database</I>subroutine checks to see if the student database exists. If not,a new one is created.<DIV CLASS=screen><P><PRE>    $rdb = new Sprite ();    $rdb-&gt;set_delimiter ("Read",  $delimiter);    $rdb-&gt;set_delimiter ("Write", $delimiter);</PRE></DIV><P CLASS=para>A new database object is created. The <I CLASS=emphasis>set_delimiter</I>function sets the delimiter to be used when reading from and writingto a database.<DIV CLASS=screen><P><PRE>    $command_status = &amp;$query_string ();</PRE></DIV><P CLASS=para>This is a construct that you may not have seen before. Thesubroutine corresponding to the value stored in <I CLASS=emphasis>query_string</I>is called. It is equivalent to saying:<DIV CLASS=screen><P><PRE>if ($query_string eq "add") {    $command_status = &amp;add ();} elsif ($query_string eq "modify_form") {    $command_status = &amp;modify_form ();} elsif ($query_string eq "modify") {    $command_status = &amp;modify ();} elsif ($query_string eq "view") {    $command_status = &amp;view ();} elsif ($query_string eq "delete") {    $command_status = &amp;delete ();}</PRE></DIV><P CLASS=para>How convenient! Now, let's continue on with the program.<DIV CLASS=screen><P><PRE>    if ($command_status) {        $rdb-&gt;close ($database);        print "Location: ", $main_form, "\n\n";    } else {        $rdb-&gt;close ();    }</PRE></DIV><P CLASS=para>Depending on the status returned from one of the subroutinesabove, a server redirect is done with the <i CLASS=command>Location:</i>header. There is a subtle difference between the two <I CLASS=emphasis>$rdb-&gt;close</I>subroutines. If you specify a database as part of the <I CLASS=emphasis>close</I>subroutine, the modifications performed on that database are saved.Otherwise, the changes are discarded.<DIV CLASS=screen><P><PRE>} else {    &amp;return_error (500, $error,                "Invalid command passed through QUERY_STRING.");}exit (0);</PRE></DIV><P CLASS=para>If an invalid query was passed to this program, an error isreturned.<P CLASS=para>The following subroutine checks to see if the database exists.If it does not, a new database is created, and a header line containingthe field names, delimited by "::", is output.<DIV CLASS=screen><P><PRE>sub check_database{    local ($exclusive_lock, $unlock, $header);    $exclusive_lock = 2;    $unlock = 8;    if (! (-e $database) ) {        if ( open (DATABASE, "&gt;" . $database) ) {            flock (DATABASE, $exclusive_lock);            $header = join ($delimiter, "Student", "YOG", "Address");            print DATABASE $header, "\n";            flock (DATABASE, $unlock);            close (DATABASE);        } else {            &amp;return_error (500, $error, "Cannot create new student database.");        }    }}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>check_all_fields</I> subroutine makessure the form elements do not contain shell meta-characters:<DIV CLASS=screen><P><PRE>sub check_all_fields{    local ($key);    foreach $key (keys %DB) {        if ($DB{$key} =~ /[`\!;\\\*\\$[amp   ][lt    ][gt    ]]/) {\n              [amp   ]\|return_error (500, $error,                                  "Invalid characters in the [$key] field.");        }    }}</PRE></DIV><P CLASS=para>The<I CLASS=emphasis> </I>subroutine iterates through the <I CLASS=emphasis>DB</I>associative array checking to make sure that none of the elementscontains any dangerous shell metacharacters. If any are found, anerror message is displayed.<DIV CLASS=screen><P><PRE>sub build_check_condition{    local ($columns) = @_;    local ($all_fields, $loop, $key, $sign, $sql_condition);</PRE></DIV><P CLASS=para>This is a very useful subroutine that dynamically builds aquery. It expects a string in the following format:<DIV CLASS=screen><P><PRE>"Student,=,Address,=~"</PRE></DIV><P CLASS=para>From this, the following query is constructed (assuming thatthe user entered "Ed Surge" in the student field, and "Elm Street"in the address field):<DIV CLASS=screen><P><PRE>(Student = 'Ed Surge') and (Address =~ 'Elm Street')</PRE></DIV><P CLASS=para>(You might have noticed that the regular expression is notthe usual format ($string =~ /abc/). You are correct! However, Perlaccepts this format as well.)<DIV CLASS=screen><P><PRE>    @all_fields = split (/,/, $columns);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>all_fields</I> array consists of successiveelements of the field name, followed by the operator that shouldbe used to search that field. In this example, the array would looklike this:<DIV CLASS=screen><P><PRE>$all_fields[0] = "Student";$all_fields[1] = "=";$all_fields[2] = "Address";$all_fields[3] = "=~";</PRE></DIV><P CLASS=para>Now, let's look at the loop that iterates through this arrayto build the query.<DIV CLASS=screen><P><PRE>    for ($loop=0; $loop &lt;= $#all_fields; $loop = $loop + 2) {        $key  = $all_fields[$loop];        $sign = $all_fields[$loop + 1];</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>key</I> and the <I CLASS=emphasis>sign</I>variables consist of the field name and the operator, respectively.<DIV CLASS=screen><P><PRE>        if ($DB{$key}) {            $DB{$key} =~ s/([\W])/\\$1/g;            $sql_condition = join (" and ", $sql_condition,                    "( $key $sign '$DB{$key}' )", );        }    }</PRE></DIV><P CLASS=para>The query is built in nearly the same manner as in the precedingexample, except that the operator can be different for each field.<DIV CLASS=screen><P><PRE>    if ($sql_condition) {        $sql_condition =~ s/^ and //;        return ($sql_condition);    } else {        &amp;return_error (500, $error, "No query was entered.");    }}</PRE></DIV><P CLASS=para>If the user did not enter any information into the fields,an error message is displayed. Otherwise, the dynamically createdquery is returned (to the subroutine that called).<P CLASS=para>This is a very simple subroutine (if you can call it that)that returns an error.<DIV CLASS=screen><P><PRE>sub database_error{    &amp;return_error (500, $error,        "Sprite database error. Please check the log file.");}</PRE></DIV><P CLASS=para>The only reason this statement was placed in a subroutineis for convenience. For example, it is much shorter and quickerto say:<DIV CLASS=screen><P><PRE>$rdb-&gt;update (&lt;&lt;Update_Command) || &amp;database_error ();</PRE></DIV><P CLASS=para>than to say:<DIV CLASS=screen><P><PRE>$rdb-&gt;update (&lt;&lt;Update_Command) || &amp;return_error (500, $error,        "Sprite database error. Please check the log file.");</PRE></DIV><P CLASS=para>This is especially true if the same error needs to be returnedfor various problems.<P CLASS=para>The <I CLASS=emphasis>check_select_command</I> subroutine isgenerally used after an SQL "select" statement. It checks the firstelement of the returned data, as well as the number of records returned,and displays an error if either of these values equal 0. Otherwise,a status of 1 is returned.<DIV CLASS=screen><P><PRE>sub check_select_command{    local ($value, $no_elements) = @_;    if (!$value) {        &amp;database_error ();    } elsif (!$no_elements) {        &amp;return_error (500, $error,             "The record you specified does not exist.");    } else {        return (1);    }}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>add</I> subroutine inserts a record intothe database.<DIV CLASS=screen><P><PRE>sub add{    $DB{'Address'} =~ s/\n/&lt;BR&gt;/g;    $DB{'Address'} =~ s/(['"])/\\$1/g;    $DB{'Student'} =~ s/(['"])/\\$1/g;    $rdb-&gt;sql (&lt;&lt;End_of_Insert) || &amp;database_error ();        insert into $database    (Student, YOG, Address)values    ('$DB{'Student'}', '$DB{'YOG'}', '$DB{'Address'}')End_of_Insert    return (1);}</PRE></DIV><P CLASS=para>All newline characters are converted to "&lt;BR&gt;" and allsingle and double quotes are escaped. Remember, all records in atext-delimited database are delimited by newline characters! Thisensures that the data will be correctly displayed by the browserwhen the user decides to view it.<P CLASS=para>The format for the "insert" SQL statement is the same as describedin the SQL primer earlier. If the record could not be inserted intothe database, an error is returned. Otherwise, a status of 1 isreturned. This instructs the script to save the database and performa server redirect to display the main HTML document.<P CLASS=para>Now for the most complicated action-modifying a row.<DIV CLASS=screen><P><PRE>sub modify_form{    local (@info, $modify_status, $no_elements, $status);    $DB{'Student'} =~ s/(['"])/\\$1/g;    @info = $rdb-&gt;sql (&lt;&lt;End_of_Select);select * from $databasewhere (Student = '$DB{'Student'}')End_of_Select    $status = shift (@info);    $no_elements = scalar (@info);    $modify_status = &amp;check_select_command ($status, $no_elements);    if ($modify_status) {        &amp;display_modify_form ($info[0]);    }    return (0);}</PRE></DIV><P CLASS=para>This subroutine performs two actions. First, it uses the student'sname, as specified in the modify form (shown with the other formsat the beginning of this section), to retrieve the record for thatstudent. The <I CLASS=emphasis>check_select_command</I> subroutineensures that data was returned by the database. Second, <I CLASS=emphasis>display_modify_form</I>is called (with the first record in the array as an argument) todisplay a new form that contains all of the information about thestudent. The user can then modify the data in the form and submitit.<P CLASS=para>A status of 0 is returned by this subroutine. As a result,the database is not saved (which is what we want, since it was notmodified), and no server redirection is performed.<P CLASS=para>The <I CLASS=emphasis>display_modify_form</I> subroutine returnsa form for changing a student's record.<DIV CLASS=screen><P><PRE>sub display_modify_form{    local ($fields) = @_;    local ($student, $yog, $address);    ($student, $yog, $address) = split (/\0/, $fields);     $address =~ s/&lt;BR&gt;/\n/g;     $student = &amp;escape_html ($student);     $yog = &amp;escape_html ($yog);</PRE></DIV><P CLASS=para>The record that is passed to this subroutine by modify_form is split on the"\0" delimiter, and the "&lt;BR&gt;" characters are converted backto newlines. In addition, we call the <I CLASS=emphasis>escape_html</I>subroutine to "escape" characters that have a special significanceto the browser, such as the double quote, "&lt;", "&gt;", and "&amp;".We perform these steps so that the information is displayed properly.<DIV CLASS=screen><P><PRE>    print &lt;&lt;End_of_Modify_Form;Content-type: text/html&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Modify Student Information&lt;/H1&gt;&lt;HR&gt;&lt;B&gt;Student Name: $student&lt;/B&gt;&lt;P&gt;&lt;FORM ACTION="$script?modify" METHOD="POST"&gt;&lt;INPUT TYPE="hidden" NAME="Student" VALUE="$student"&gt;Year of Graduation:&lt;INPUT TYPE="text" NAME="YOG" SIZE=4 MAXLENGTH=4 VALUE="$yog"&gt;&lt;P&gt;Address (Mailing Information):&lt;TEXTAREA NAME="Address" ROWS=4 COLS=40&gt;$address&lt;/TEXTAREA&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Modify Record For: $student"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;End_of_Modify_Form}</PRE></DIV><P CLASS=para>The form containing the information for the specified studentis output. The user can now modify this form. We use <I CLASS=emphasis>$student</I>twice: once to remind the user which student was chosen, and onceto pass the name back to this CGI program so it modifies the rightrow. The form is shown in <A HREF="ch09_03.htm#CGI-CHP-9-FIG-8">Figure 9.8</A>.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-9-FIG-8">Figure 9-8: Modify form</A></h4><p><img align=middle src="./figs/cgi0911.gif" alt="[Graphic: Figure 9-8]" width=446 height=368></DIV><P CLASS=para>The <I CLASS=emphasis>escape_html</I> subroutine escapes certaincharacters so that they are displayed correctly by the browser.<DIV CLASS=screen><P><PRE>sub escape_html{    local ($string) = @_;    local (%html_chars, $html_string);        %html_chars = ('&amp;', '&amp;amp;',                   '&gt;', '&amp;gt;',                   '&lt;', '&amp;lt;',                   '"', '&amp;quot;');    $html_string = join ("", keys %html_chars);    $string =~ s/([$html_string])/$html_chars{$1}/go;    return ($string);}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>view</I> subroutine shows a student'scurrent record.<DIV CLASS=screen><P><PRE>sub view{    local ( $fields, $query, @students, $view_status, $status, $no_elements);    $fields = 'Student,=,Address,=~';    if ($DB{'YOG'}) {        if ($DB{'Sign'} eq 'greater') {            $DB{'Sign'} = '&gt;';        } elsif ($DB{'Sign'} eq 'less') {            $DB{'Sign'} = '&lt;';        } else {            $DB{'Sign'} = '=';        }        $fields = join (",", $fields, 'YOG', $DB{'Sign'});    }    $query = &amp;build_check_condition ($fields);</PRE></DIV><P CLASS=para>If the user entered information into the year of graduationfield, the search operator is determined. This is then appendedto the value stored in the fieldsvariable. The <I CLASS=emphasis>build_check_condition</I> subroutineis called to dynamically construct the search query.<DIV CLASS=screen><P><PRE>    @students = $rdb-&gt;sql (&lt;&lt;End_of_Display);select * from $database    where $queryEnd_of_Display    $status = shift (@students);    $no_elements = scalar (@students);    $view_status = &amp;check_select_command ($status, $no_elements);</PRE></DIV><P CLASS=para>The query is passed to the <I CLASS=emphasis>select</I> command.The information returned by the database is checked for possibleerrors. If there are no errors, <I CLASS=emphasis>view_status</I>contains the value of 1.<DIV CLASS=screen><P><PRE>    if ($view_status) {        &amp;display_results ("View Students", *students);    }    return (0);}</PRE></DIV><P CLASS=para>If the data returned by the database is valid, the <I CLASS=emphasis>display_results</I>subroutine is called to display the search results. The two argumentspassed to the subroutine are the header for the HTMLdocument and the reference to the array that contains the results.<DIV CLASS=screen><P><PRE>sub display_results{    local ($title, *data) = @_;    local ($student, $yog, $address);    print "Content-type: text/html", "\n";    print "Pragma: no-cache", "\n\n";		print "&lt;HTML&gt;", "\n";    print "&lt;HEAD&gt;&lt;TITLE&gt;CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;";		print "&lt;BODY&gt;", "\n";    print "&lt;H1&gt;", $title, "&lt;/H1&gt;";    print "&lt;HR&gt;";</PRE></DIV><P CLASS=para>The <i CLASS=command>Content-type:</i> and <i CLASS=command>Pragma:</i>MIME headers are output. We do not want the browserto cache the page containing the results. As a result, the displayeddata reflects the true status of the database.<DIV CLASS=screen><P><PRE>    foreach (@data) {        s/([^\w\s\0])/sprintf ("&amp;#%d;", ord ($1))/ge;        ($student, $yog, $address) = split ("\0", $_, 3);        $student = "NULL"                      if (!$student);        $yog     = "Unknown graduation date"   if (!$yog);        $address = "No address specified"      if (!$address);</PRE></DIV><P CLASS=para>If any of the fields for a record are null, certain defaultvalues are used, so as not to display empty fields.<DIV CLASS=screen><P><PRE>        $address =~ s/&amp;#60;BR&amp;#62;/&lt;BR&gt;/g;        print "&lt;BR&gt;", "\n";        print "&lt;B&gt;", $student, "&lt;/B&gt; ", "($yog)", "&lt;BR&gt;", "\n";        print $address, "&lt;BR&gt;", "\n";    }    print "&lt;HR&gt;", "\n";		print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>foreach</I> loop iterates through thematched records, and displays them.<P CLASS=para>The <I CLASS=emphasis>delete</I> subroutine removes recordsfrom the database.<DIV CLASS=screen><P><PRE>sub delete{    local ($fields, $query);    $fields = 'Student,=,YOG,=';    $query = &amp;build_check_condition ($fields);    $rdb-&gt;sql (&lt;&lt;End_of_Delete) || &amp;database_error ();delete from $database    where $queryEnd_of_Delete    return (1);}</PRE></DIV><P CLASS=para>Multiple records can be deleted by leaving the student fieldempty, but entering a valid year for the <I CLASS=emphasis>YOG</I>field. If the specified records cannot be deleted, an error messageis displayed.<P CLASS=para>Existing records are modified with the<I CLASS=emphasis> modify </I>subroutine.<DIV CLASS=screen><P><PRE>sub modify{    local (@fields, $key);    @fields = ('YOG', 'Address');    $DB{'Address'} =~ s/\n/&lt;BR&gt;/g;    $DB{'YOG'} =~ s/(['"])/\\$1/g;    $DB{'Student'} =~ s/(['"])/\\$1/g;    $DB{'Address'} =~ s/(['"])/\\$1/g;    foreach $key (@fields) {        $rdb-&gt;sql (&lt;&lt;Update_Database) || &amp;database_error ();update $databaseset $key = ('$DB{$key}') where (Student = '$DB{'Student'}');Update_Database    }    return (1);}</PRE></DIV><P CLASS=para>The current version of Sprite does not support multiple fieldsin a <I CLASS=emphasis>update</I> statement. As a result, a loopis used to update the record multiple times. If the user entered"1991" in the year of graduation field, and "Elm Street, 02215"in the address field, the two <I CLASS=emphasis>update</I> statementsare generated:<DIV CLASS=screen><P><PRE>update /home/shishir/student.dbset YOG = ('1991')where (Student = 'Ed Surge')update /home/shishir/student.dbset Address = ('Elm Street, 02215')where (Student = 'Ed Surge')</PRE></DIV><P CLASS=para>That concludes the section on Sprite.</DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.3">A Gateway to an Oracle Database</A></h3><P CLASS=para>Now, let'slook at CGI gateways to the two most popular commercial databases:Oracle and Sybase. Each of these is supported by Perl and Tcl extensionsthat make our job much easier by letting us submit SQL queries thatthe database recognizes. I will use Oracle and Sybase to illustratetwo different ways to display the results of a query. In this section,I will query an Oracle database and plot the data using <I CLASS=emphasis>gnuplot</I>(available from <I CLASS=emphasis>ftp://prep.ai.mit.edu/pub/gnu/gnuplot-3.5.tar.gz</I>).In the next section, I will use Sybase and display the results ina table using HTML.<P CLASS=para>Suppose you have a a database consisting of stock tradinghistory for various companies over an eleven-year span (from 1980through 1990). A sample table is shown below:<DIV CLASS=informaltable><P><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left"><P CLASS=para>ID</TH><TH ALIGN="left"><P CLASS=para>Company</TH><TH ALIGN="left"><P CLASS=para>1980</TH><TH ALIGN="left"><P CLASS=para>1981</TH><TH ALIGN="left"><P CLASS=para>1982</TH><TH ALIGN="left"><P CLASS=para>1983</TH><TH ALIGN="left"><P CLASS=para>1984</TH><TH ALIGN="left"><P CLASS=para>1985</TH><TH ALIGN="left"><P CLASS=para>1986</TH><TH ALIGN="left"><P CLASS=para>1987</TH><TH ALIGN="left"><P CLASS=para>1988</TH><TH ALIGN="left"><P CLASS=para>1989</TH><TH ALIGN="left"><P CLASS=para>1990</TH></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Doe</TD><TD ALIGN="left"><P CLASS=para>Doe, Inc.</TD><TD ALIGN="left"><P CLASS=para>12.1</TD><TD ALIGN="left"><P CLASS=para>12.5</TD><TD ALIGN="left"><P CLASS=para>13.0</TD><TD ALIGN="left"><P CLASS=para>12.7</TD><TD ALIGN="left"><P CLASS=para>13.2</TD><TD ALIGN="left"><P CLASS=para>14.1</TD><TD ALIGN="left"><P CLASS=para>15.7</TD><TD ALIGN="left"><P CLASS=para>13.9</TD><TD ALIGN="left"><P CLASS=para>14.6</TD><TD ALIGN="left"><P CLASS=para>19.3</TD><TD ALIGN="left"><P CLASS=para>19.0</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>FaH</TD><TD ALIGN="left"><P CLASS=para>Federal Ham.</TD><TD ALIGN="left"><P CLASS=para>37.3</TD><TD ALIGN="left"><P CLASS=para>40.4</TD><TD ALIGN="left"><P CLASS=para>38.2</TD><TD ALIGN="left"><P CLASS=para>41.1</TD><TD ALIGN="left"><P CLASS=para>42.3</TD><TD ALIGN="left"><P CLASS=para>44.4</TD><TD ALIGN="left"><P CLASS=para>45.9</TD><TD ALIGN="left"><P CLASS=para>45.3</TD><TD ALIGN="left"><P CLASS=para>47.9</TD><TD ALIGN="left"><P CLASS=para>48.1</TD><TD ALIGN="left"><P CLASS=para>50.0</TD></TR><TR CLASS=row><TD ALIGN="left"><P CLASS=para>Max</TD><TD ALIGN="left"><P CLASS=para>Max Corp.</TD><TD ALIGN="left"><P CLASS=para>73.2</TD><TD ALIGN="left"><P CLASS=para>73.9</TD><TD ALIGN="left"><P CLASS=para>74.1</TD><TD ALIGN="left"><P CLASS=para>74.0</TD><TD ALIGN="left"><P CLASS=para>74.7</TD><TD ALIGN="left"><P CLASS=para>74.7</TD><TD ALIGN="left"><P CLASS=para>76.6</TD><TD ALIGN="left"><P CLASS=para>80.3</TD><TD ALIGN="left"><P CLASS=para>71.1</TD><TD ALIGN="left"><P CLASS=para>59.6</TD><TD ALIGN="left"><P CLASS=para>70.3</TD></TR></TABLE><P></DIV><P CLASS=para>You would like to present this valuable source of informationas crisp graphs or plots to the general public. How would you goabout doing it? The first step is to create a form where the usercan enter a company's identification:<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Stock Service&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Stock Quotes&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/stocks.pl" METHOD="GET"&gt;&lt;EM&gt;Please enter the name of the stock that you would like to get a quote for:&lt;/EM&gt;&lt;P&gt;&lt;INPUT TYPE="text" NAME="Company_ID" SIZE=10 MAXLENGTH=10&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Look Up This Stock"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>The second step is to write a CGI program that sends the queryto the database, retrieves the results, and utilizes <I CLASS=emphasis>gnuplot</I>to graph the information. Here is the CGI program that interactswith the Oracle database using <I CLASS=emphasis>oraperl</I>:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/oraperlrequire "oraperl.ph";</PRE></DIV><P CLASS=para><I CLASS=emphasis>oraperl</I>is a derivative of Perl that contains functionality to access andinteract with Oracle databases. As of Perl 5, the <I CLASS=emphasis>DBperl</I>extensions (a.k.a. DBI) supersede most of the Perl 4.0 databasederivatives (such as <I CLASS=emphasis>oraperl</I> and <I CLASS=emphasis>sybperl</I>).For information on where to get <I CLASS=emphasis>oraperl</I>, <I CLASS=emphasis>syperl</I>,and <I CLASS=emphasis>DBperl</I>, see <A HREF="appe_01.htm">Appendix E, <i>Applications, Modules, Utilities, and Documentation</i></A>.<DIV CLASS=screen><P><PRE>$| = 1;$webmaster = "shishir\@bu\.edu";$gnuplot = "/usr/local/bin/gnuplot";$ppmtogif = "/usr/local/bin/pbmplus/ppmtogif";</PRE></DIV><P CLASS=para>Buffering is turned off, and the full path to the <I CLASS=emphasis>gnuplot</I>and <I CLASS=emphasis>ppmtogif</I> commands is defined. (See <A HREF="ch06_01.htm">Chapter 6, <i>Hypermedia Documents</i></A> for other examples of how these commands are used.)<DIV CLASS=screen><P><PRE>&amp;parse_form_data (*DB);($company_id = $DB{'Company_ID'}) =~ s/^\s*(.*)\b\s*$/$1/;</PRE></DIV><P CLASS=para>The form information is decoded. In this case, we are dealingwith only one field (<I CLASS=emphasis>Company_ID</I>). The informationstored in this field is equated to the <I CLASS=emphasis>company_id</I>variable, and the leading and trailing spaces are removed.<DIV CLASS=screen><P><PRE>if ($company_id =~ /^\w+$/) {</PRE></DIV><P CLASS=para>If the field value is an alphanumeric character (A-Z, a-z,0-9, _), the program continues. Otherwise, an error message is returned.We want to make sure that only the characters that we need are allowed!In this case, shell metacharacters are not allowed to pass through.<DIV CLASS=screen><P><PRE>    $process_id = $$;    $output_ppm = join ("", "/tmp/", $process_id, ".ppm");    $data_file =  join ("", "/tmp/", $process_id, ".txt");</PRE></DIV><P CLASS=para>We need two temporary files in this program. To make surethat each running instance of the program uses unique temporaryfiles, we borrow a trick from UNIX shell scripting and put our processidentification number (PID) into the names. Each time the programruns, it has to have a unique PID, so we know we will not clobberour own temporary file. The <I CLASS=emphasis>output_ppm</I> and<I CLASS=emphasis>data_file</I> variables contain the full file specificationfor the temporary files that will be created by this program. Thecurrent process id number ensures unique filenames.<DIV CLASS=screen><P><PRE>    $color_number = 1; </PRE></DIV><P CLASS=para>The color number of 1 indicates Red. This is the color ofthe plot line.<DIV CLASS=screen><P><PRE>    $system_id = "Miscellaneous";    $username = "shishir";    $password = "fnjop673e2nB";</PRE></DIV><P CLASS=para>The Oracle system identification (SID), the username,and the password are set. You might wonder if it is safe to hard-codethe database password into this program. The answer to that dependson how the database is set up. In cases like this, you should createa generic user, such as "guest," with minimal access rights (read-only),so that there is no danger to the database.<DIV CLASS=screen><P><PRE>    $lda = &amp;ora_login ($system_id, $username, $password);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>ora_login</I> subroutine is used to login to the database. The value returned is the login identifier,also referred to as the Oracle Login Data Area. This identifierwill be used to execute an SQL command.<DIV CLASS=screen><P><PRE>    $csr = &amp;ora_open ($lda, " select * from Stocks where ID = '$company_id' ");</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>ora_open</I> subroutine executes a specifiedSQL command. It requires a login identifier, and returns a statementidentifier or an Oracle Cursor.This statement identifier is needed to retrieve the actual data(resulting from the SQL command).<P CLASS=para>You are not limited to specifying the SQL command on one line;you can use the block notation:<DIV CLASS=screen><P><PRE>$csr = &amp;ora_open ($lda, &lt;&lt;End_of_Select);select * from Stockswhere ID = '$company_id'End_of_Select</PRE></DIV><P CLASS=para>Let's continue with the rest of the program.<DIV CLASS=screen><P><PRE>    if ( open (DATA, "&gt;" . $data_file) ) {        ($company_id, $company, @stock_prices) = &amp;ora_fetch ($csr);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>ora_fetch</I> subroutine retrieves theinformation returned by the SQL <I CLASS=emphasis>select</I> command.The first two fields (or columns) are stored in <I CLASS=emphasis>company_id</I>and <I CLASS=emphasis>company</I>, respectively. The rest of thecolumns, however, are stored in the <I CLASS=emphasis>stock_prices</I>array. This consists of the 11 columns representing 11 years, asshown in the previous table.<DIV CLASS=screen><P><PRE>        &amp;ora_close ($csr);        &amp;ora_logoff ($lda);</PRE></DIV><P CLASS=para>The statement identifier is released with the <I CLASS=emphasis>ora_close</I>subroutine, and the database is closed.<DIV CLASS=screen><P><PRE>        if ($company_id) {</PRE></DIV><P CLASS=para>This block of code is executed only if a database record matchedthe user's selection. Otherwise, an error message is returned.<DIV CLASS=screen><P><PRE>            $stocks_start = 1980;            $stocks_end = 1990;            $stocks_duration = $stocks_end - $stocks_start;            for ($loop=0; $loop &lt;= $stocks_duration; $loop++) {                $price = $stock_prices[$loop];                $year  = $stocks_start + $loop;                print DATA $year, " ", $price, "\n";            }            close (DATA);</PRE></DIV><P CLASS=para>The loop iterates 11 times to create a data file with allof the year/stock price pairs. For example, here is how the datafile would look like if the user selected "Fah":<DIV CLASS=screen><P><PRE>1980 37.31981 40.41982 38.2...</PRE></DIV><P CLASS=para>When we build our plot, the first column provides data forthe x axis, while the second column provides data for the y axis.<DIV CLASS=screen><P><PRE>            &amp;graph_data ("Stock History for $company", $data_file,                         "Year", "Price", $color_number, $output_ppm); </PRE></DIV><P CLASS=para>The <I CLASS=emphasis>graph_data</I> subroutine is called tocreate a PBM file (which is later converted to GIF). The argumentsto this subroutine are the title of the graph, the data file touse, the label for the X axis, the label for the Y axis, the linecolor, and the output file.<DIV CLASS=screen><P><PRE>            &amp;create_gif ($output_ppm);</PRE></DIV><P CLASS=para>The final GIF image is created by the <I CLASS=emphasis>create_gif</I>subroutine, which expects one argument: the name of the PBM filecreated by <I CLASS=emphasis>gnuplot</I>.<DIV CLASS=screen><P><PRE>        } else {            &amp;return_error (500, "Oracle Gateway CGI Error",                "The specified company could not be found.");        }</PRE></DIV><P CLASS=para>An error message is displayed if the user selected a non-existentcompany name.<DIV CLASS=screen><P><PRE>    } else {        &amp;return_error (500, "Oracle Gateway CGI Error",                    "Could not create output file.");    }</PRE></DIV><P CLASS=para>If the data file could not be created, an error is returned.<DIV CLASS=screen><P><PRE>} else {    &amp;return_error (500, "Oracle Gateway CGI Error",                "Invalid characters in company field.");}exit (0);</PRE></DIV><P CLASS=para>Finally, if the information in the form field contains anynon-alphanumeric characters, an error message is sent.<P CLASS=para>The <I CLASS=emphasis>graph_data</I> subroutine opens a pipeto the <I CLASS=emphasis>gnuplot</I> numerical analysis program,and sends a group of format commands through it. The end resultof this is a pbm graphics file, which is later converted to GIF.<DIV CLASS=screen><P><PRE>sub graph_data{    local ($title, $file, $x_label, $y_label, $color, $output) = @_;    open (GNUPLOT, "| $gnuplot");    print GNUPLOT &lt;&lt;gnuplot_Commands_Done;            set term pbm color small        set output "$output"        set title "$title"        set xlabel "$x_label"        set ylabel "$y_label"        set noxzeroaxis        set noyzeroaxis        set border        set nokey        plot "$file" w lines $colorgnuplot_Commands_Done    close (GNUPLOT);}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>create_gif</I> subroutine uses the <I CLASS=emphasis>ppmtogif</I>utility to convert the pbm file to GIF, for display on the Web (see<A HREF="ch09_03.htm#CGI-CHP-9-FIG-9">Figure 9.9</A>).<DIV CLASS=screen><P><PRE>sub create_gif{    local ($output) = @_;    print "Content-type: image/gif", "\n\n";    system ("$ppmtogif $output 2&gt; /dev/null");    unlink $output_ppm, $data_file;}</PRE></DIV><P CLASS=para>Finally, the temporary files are "unlinked," or deleted.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-9-FIG-9">Figure 9-9: Stocks graph</A></h4><p><img align=middle src="./figs/exp0901.gif" alt="[Graphic: Figure 9-9]" width=502 height=143></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-9-SECT-3.4">Accessing a Sybase Database</A></h3><P CLASS=para>In this example,the form input (from the user) is used to access a Sybase databaseto look up information on books. Our interface to Sybase is the<I CLASS=emphasis>sybperl</I> library, which provides Perl subroutinesfor giving Sybase queries in the form it can recognize. The datareturned by Sybase is converted to an HTML 3.0table format. In other words, the output, when displayed on a browserthat recognizes HTML 3.0, resembles a nice tablewith solid three-dimensional lines separating the different fields.<DIV CLASS=screen><P><PRE>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Publishing Company&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Book Search&lt;/H1&gt;&lt;HR&gt;&lt;FORM ACTION="/cgi-bin/books.pl" METHOD="GET"&gt;&lt;EM&gt;Please enter the name of the book that you would like to look up:&lt;/EM&gt;&lt;P&gt;&lt;INPUT TYPE="text" NAME="Book" SIZE=40&gt;&lt;P&gt;&lt;INPUT TYPE="submit" VALUE="Look Up This Book"&gt;&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;&lt;/FORM&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE></DIV><P CLASS=para>Above is the form that is used to retrieve the input fromthe user.<P CLASS=para>Let's look at the program:<DIV CLASS=screen><P><PRE>#!/usr/local/bin/sybperlrequire "sybperl.pl";$user = "shishir";$password = "mkhBhd9v2sK";$server = $ENV{'DSQUERY'} || "Books";</PRE></DIV><P CLASS=para>The user, password, and server name are set. If the environmentvariable DSQUERY is defined, the server is setto the value of that variable. If not, the server is set to "Books".The following statement:<DIV CLASS=screen><P><PRE>$server = $ENV{'DSQUERY'} || "Books";</PRE></DIV><P CLASS=para>is a simpler of way of doing the following:<DIV CLASS=screen><P><PRE>if ($ENV{'DSQUERY'}) {    $server = $ENV{'DSQUERY'};} else {    $server = "Books";}</PRE></DIV><P CLASS=para>Next, the <I CLASS=emphasis>dblogin</I> subroutine is usedto log in to the Sybase server.<DIV CLASS=screen><P><PRE>$dbproc = &amp;dblogin ($user, $password, $server);</PRE></DIV><P CLASS=para><I CLASS=emphasis>dblogin</I> returns the identification forthe newly created database process into the <I CLASS=emphasis>dbproc</I>variable.<DIV CLASS=screen><P><PRE>@fields = ('Author', 'Book', 'Publisher', 'Year', 'Pages');$title = "CGI Publishing Company Book Database";</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>fields</I> array holds a list of allthe fields in a record. The <I CLASS=emphasis>title</I> variablecontains the title of the HTML 3.0 table.<DIV CLASS=screen><P><PRE>&amp;parse_form_data (*DB);($book_name = $DB{'Book'}) =~ s/^\s*(.*)\b\s*$/$1/;</PRE></DIV><P CLASS=para>Leading and trailing spaces are removed from the <I CLASS=emphasis>Book</I>field.<DIV CLASS=screen><P><PRE>if ($book_name =~ /^[\w\s]+$/) {</PRE></DIV><P CLASS=para>Since we are dealing with book names, the user is allowedto enter only the following characters: A-Z, a-z, 0-9, _, and whitespace.If any other characters are entered, an error message is returned.<P CLASS=para>To retrieve data from a Sybase database, you attach to thedatabase, execute a query, and then loop through the returned dataone row at a time. These standard steps are performed in this CGIapplication.<DIV CLASS=screen><P><PRE>    &amp;dbcmd ($dbproc, " select * from Catalog where Book = '$book_name' ");    &amp;dbsqlexec ($dbproc);    $status = &amp;dbresults ($dbproc);</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>dbcmd</I> subroutine associates the SQLcommand with the current database process (dbproc). The dbsqlexec subroutine executesthe SQL command, while the <I CLASS=emphasis>dbresults</I> make thedata available to the program. The <I CLASS=emphasis>dbresults</I>subroutine returns either "$SUCCEED" or "$FAIL" (these are variablesthat are special to <I CLASS=emphasis>sybperl</I>).<DIV CLASS=screen><P><PRE>    if ($status == $SUCCEED) {        while ( (@books = &amp;dbnextrow ($dbproc)) ) {            $book_string = join ("\0", @books);            push (@all_books, $book_string);        }</PRE></DIV><P CLASS=para>If the user-specified records are found, the <I CLASS=emphasis>dbresults</I>subroutine returns "$SUCCEED". The <I CLASS=emphasis>while</I>loop iterates through all of the data by calling the <I CLASS=emphasis>dbnextrow</I>subroutine each time through the loop, in case there is more thanone book that matches the criteria. The <I CLASS=emphasis>books</I>array consists of information in the following format (for a samplebook);<DIV CLASS=screen><P><PRE>$books[0] = "Andy Oram and Steve Talbott"$books[1] = "Managing Projects with make"$books[2] = "O'Reilly &amp; Associates, Inc."$books[3] = 1991$books[4] = 152</PRE></DIV><P CLASS=para>We need to create this intermediate array because that isthe structure of the data returned by <I CLASS=emphasis>dbnextrow</I>.But what we really want is a single string, because then we couldstore all the information on a single book in one element of the<I CLASS=emphasis>@all_books</I> array. So we use the <I CLASS=emphasis>join</I>statement to form the following string:<DIV CLASS=screen><P><PRE>$book_string = "Andy Oram and Steve Talbott\0Managing Projects with make\0O'Reilly &amp; Associates, Inc.\01991\0152"</PRE></DIV><P CLASS=para>This string is then pushed into the <I CLASS=emphasis>all_books</I>array. This process is repeated for all matches.<DIV CLASS=screen><P><PRE>        &amp;dbexit ($dbproc);        &amp;display_table ($title, *fields, *all_books, "\0");</PRE></DIV><P CLASS=para>The database is closed by calling the <I CLASS=emphasis>dbexit</I>subroutine. Finally, the table is displayed by calling a genericsubroutine, <I CLASS=emphasis>display_table</I>. The subroutine expectsthe following arguments: the title of the table, the array consistingof the header (or field) names, the array consisting of the strings,and the delimiter by which these strings are concatenated.<DIV CLASS=screen><P><PRE>    } else {        &amp;return_error (500, "Sybase Database CGI Error",            "The book title(s) you specified does not exist.");    }} else {    &amp;return_error (500, "Sybase Database CGI Error",                "Invalid characters in book name.");}exit(0);</PRE></DIV><P CLASS=para>Error messages are returned if either the specified book namedoes not exist, or the input contains invalid characters.<P CLASS=para>The <I CLASS=emphasis>display_table</I> subroutine prints outthe table.<DIV CLASS=screen><P><PRE>sub display_table{    local ($title, *columns, *selected_entries, $delimiter) = @_;    local ($name, $entry);    print "Content-type: text/html", "\n\n";		print "&lt;HTML&gt;", "\n";    print "&lt;HEAD&gt;&lt;TITLE&gt;", $title, "&lt;/TITLE&gt;&lt;/HEAD&gt;", "\n";		print "&lt;BODY&gt;", "\n";    print "&lt;TABLE BORDER=2&gt;", "\n";    print "&lt;CAPTION&gt;", $title, "&lt;/CAPTION&gt;", "\n";    print "&lt;TR&gt;", "\n";</PRE></DIV><P CLASS=para>A MIME type of <i CLASS=command>text/html</i>is output, along with some HTML 3.0 tags to createa table.<DIV CLASS=screen><P><PRE>    foreach $name (@columns) {        print "&lt;TH&gt;", $name, "\n";    }</PRE></DIV><P CLASS=para>This loop iterates through and displays all of the field headers.<DIV CLASS=screen><P><PRE>    foreach $entry (@selected_entries) {        $entry =~ s/$delimiter/&lt;TD&gt;/go;        print "&lt;TR&gt;", "&lt;TD&gt;", $entry, "\n";    }    print "&lt;/TABLE&gt;", "\n";		print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";}</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>foreach</I> loop iterates through thematching records, substitutes the delimiter with the &lt;TD&gt; tag,and prints out the HTML needed to create a newrow. There is no delimiter before the first item in <I CLASS=emphasis>$entry</I>,so the print statement supplies the first &lt;TD&gt; tag. Finally,the table is closed. <A HREF="ch09_03.htm#CGI-CHP-9-FIG-10">Figure 9.10</A> shows what the table looks like.<DIV CLASS=figure><h4 CLASS=figure><A CLASS="TITLE" NAME="CGI-CHP-9-FIG-10">Figure 9-10: Results of search gateway</A></h4><p><img align=middle src="./figs/exp0902.gif" alt="[Graphic: Figure 9-10]" width=502 height=173></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch09_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch09_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Mail Gateway</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Search/Index Gateway</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>