<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 10] 10.3 Socket I/O in Perl</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:34:54 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch10_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 10</b></td><td width=172 align=right valign=top><A HREF="ch10_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-10-SECT-3">10.3 Socket I/O in Perl</A></h2><P CLASS=para>The functionsused to set up sockets in Perl have the same names as the correspondingUNIX system functions, but the arguments to thesocket functions are slightly different, because of the way Perlworks. Let's look at an example that implements a client to thefinger server.<P CLASS=para>Please note that this not a CGI script. However, it shouldbe very easy to convert this to a CGI script if so desired. It ismeant to be run from the command line and to be passed one argument,the name of the user you want information about:<DIV CLASS=screen><P><PRE>% finger_client username[@host]</PRE></DIV><P CLASS=para>As you can see, the calling format is identical to that ofthe UNIX <I CLASS=emphasis>finger</I> command.In fact, this program works in the same exact manner.<DIV CLASS=screen><P><PRE>#!/usr/local/bin/perlrequire "sys/socket.ph";</PRE></DIV><P CLASS=para>The Perl header file "socket.ph"contains definitions pertaining to different types of sockets, theiraddressing schemes, etc. We will look at some of these definitionsin a moment.<P CLASS=para>If this file is not found, you (or the system administrator)need to run the <I CLASS=emphasis>h2ph</I>Perl script that converts all the C/C++ header files into a formatthat Perl can understand. Now, let's continue.<DIV CLASS=screen><P><PRE>chop ($hostname = `bin/hostname`);$input = shift (@ARGV);</PRE></DIV><P CLASS=para>The current hostname is retrieved with the UNIX<I CLASS=emphasis>hostname</I>command. And the input to the script is stored in the <I CLASS=emphasis>input</I>variable. The <I CLASS=emphasis>shift</I>statement simply returns the first element of an array.<DIV CLASS=screen><P><PRE>($username, $remote_host) = split (/@/, $input, 2);</PRE></DIV><P CLASS=para>The specified username and remote host are split from the<I CLASS=emphasis>input</I> variable.<DIV CLASS=screen><P><PRE>unless ($remote_host) {    $remote_host = $hostname;}</PRE></DIV><P CLASS=para>If no host is specified, it defaults to the local host.<DIV CLASS=screen><P><PRE>$service = "finger";</PRE></DIV><P CLASS=para>Once you create a socket,it is usually bound (or attached) to a port on the machine. In orderto send a message-or request-to the server, you have to send itto the port the server is running on. Generally, most of the commonservers (like FTP, Archie, Gopher, HTTP, andFinger) run on specific ports, and are usually the same on nearlyall hosts across the Net. Otherwise, clients on different machineswould not be able to access the servers, because they would notknow what port the server is bound to. A list of all the ports andthe servers attached to them are listed in the <I CLASS=emphasis>/etc/services</I>file.<P CLASS=para>In this case, we are specifying the server's name, and notthe port number. In case you are curious, the <I CLASS=emphasis>finger</I>server runs on port 79. Later on, the <I CLASS=emphasis>getservbyname</I>function converts the service "finger" to the correct port number.<DIV CLASS=screen><P><PRE>$socket_template = "S n a4 x8";</PRE></DIV><P CLASS=para>This represents a 16-byte structure that is used with socketsfor interprocess communications on the Internet. The first two bytesrepresent the numeric codes for the Internet address family in thebyte order the local machine uses for short integers. The next twobytes represent the port number you want to connect to, in Internetstandard byte order (i.e., big endian-the high byte of the integeris stored in the leftmost byte, while the low byte is stored inthe rightmost byte). Bytes four through eight represent the IP address,and the last eight contain "\0" characters. We will see this inaction soon.<DIV CLASS=screen><P><PRE>$tcp = (getprotobyname("tcp"))[2];</PRE></DIV><P CLASS=para>Since the <I CLASS=emphasis>finger</I> server is set up asa TCP protocol (don't worry about what this means!), we need toget a numeric code that identifies this protocol. The <I CLASS=emphasis>getprotobyname</I>functions returns the name, alias, and number of the specified protocol.In our case, we are storing just the third element, as we do notneed the others. As a side note, the constant AF_NS (from the sockets.phheader file) can be used instead of calling the <I CLASS=emphasis>getprotobyname</I>function.<DIV CLASS=screen><P><PRE>if ($service !~ /^\d+$/) {    $service = (getservbyname ($service, "tcp"))[2];}</PRE></DIV><P CLASS=para>If the service specified in the variable is not a numericvalue, the <I CLASS=emphasis>getservbyname</I> function uses the<I CLASS=emphasis>/etc/services </I>file to retrieve the port number.<DIV CLASS=screen><P><PRE>$current_address = (gethostbyname ($hostname))[4];$remote_address  = (gethostbyname ($remote_host))[4];</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>gethostbyname</I> function converts ahost name into a packed string that represents the network location.This packed string is like a common denominator; it needs to bepassed to many functions. If you want to convert this string intothe IP address, you have to unpack the string:<DIV CLASS=screen><P><PRE>@ip_numbers = unpack ("C4", $current_address);$ip_address = join (".", @ip_numbers);unless ($remote_address) {    die "Unknown host: ", $remote_host, "\n";}</PRE></DIV><P CLASS=para>If the packed string representing the remote host is not defined,it signifies that the location does not exist.<DIV CLASS=screen><P><PRE>$current_port = pack ($socket_template, &amp;AF_INET, 0, $current_address);$remote_port  = pack ($socket_template, &amp;AF_INET, $service, $remote_address);</PRE></DIV><P CLASS=para>These two lines are very important! Using the socket templatewe discussed earlier, three values representing the Internet addressingscheme, the port number, and the host name, are packed to createthe socket structure that will be used to actually create the socket.The <I CLASS=emphasis>&amp;AF_INET</I> is a subroutine definedin the socket header file that refers to the Internet addressing(i.e., 128.197.27.7) method. You can also define other addressingschemes for sockets, such as <I CLASS=emphasis>&amp;AF_UNIX</I>,which uses UNIX pathnames to identify socketsthat are local to a particular host.<DIV CLASS=screen><P><PRE>socket (FINGER, &amp;AF_INET, &amp;SOCK_STREAM, $tcp) || die "Cannot create socket.\n";</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>socket</I>function creates a TCP/IP (Internet Protocol) socket called FINGER,which can actually be used as a file handle (as we will soon see).That is one of the simple beauties of sockets: Once you get throughthe complicated connecting tasks, you can read and write them likefiles.<P CLASS=para>The <I CLASS=emphasis>&amp;SOCK_STREAM</I>(another subroutine defined in the header file) value indicatesthat data travels across the socket as a stream of characters. Youcan also choose the <I CLASS=emphasis>&amp;SOCK_DGRAM</I>paradigm in which data travels in blocks, or datagrams. However,<I CLASS=emphasis>SOCK_STREAM</I> sockets are the easiest to use.<DIV CLASS=screen><P><PRE>bind (FINGER, $current_port)   || die "Cannot bind to port.\n";connect (FINGER, $remote_port) || die "Cannot connect to remote port.\n";</PRE></DIV><P CLASS=para>The <I CLASS=emphasis>bind</I> statement attaches the FINGERsocket to the current address and port. Finally, the <I CLASS=emphasis>connect</I>function connects the socket to the server located at the addressand port specified by <I CLASS=emphasis>remote_port</I>. If any ofthese functions fail, the script terminates.<DIV CLASS=screen><P><PRE>$current_handle = select (FINGER);$| = 1;select ($current_handle);</PRE></DIV><P CLASS=para>This group of statements is used to unbuffer the socket, sothe data coming in and going out of the socket is displayed in thecorrect order.<DIV CLASS=screen><P><PRE>print FINGER $username, "\n";</PRE></DIV><P CLASS=para>The specified username is sent to the socket. The <I CLASS=emphasis>finger</I>server expects a username only. You can test to see how the <I CLASS=emphasis>finger</I>server works by using telnet to connect to port 79 (where the serverresides):<DIV CLASS=screen><P><PRE>% telnet acs.bu.edu 79Trying 128.197.152.10 ...Connected to acs.bu.edu.Escape character is '^]'.shishir... (information returned by the server for user "shishir")..</PRE></DIV><P CLASS=para>To complete our program:<DIV CLASS=screen><P><PRE>while (&lt;FINGER&gt;) {    print;}close (FINGER);exit (0);</PRE></DIV><P CLASS=para>The while loop simply reads the information output by theserver, and displays it. Reading from the socket is just like readingfrom a file or pipe (except that network errors can occur). Finally,the socket is closed.<P CLASS=para>If you found the explanation of socket creation confusing,that is OK. You will not have to write code like this. An easierset of functions will be explained shortly.</DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch10_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch10_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>What Are Sockets?</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Socket Library</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>