<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 12] 12.2 Programming/System Errors</TITLE><META NAME="author" CONTENT="Shishir Gundavaram"><META NAME="date" CONTENT="Mon Mar 17 13:36:59 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="cgi programming"><META NAME="title" CONTENT="CGI Programming on the World Wide Web"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="CGI Programming on the World Wide Web"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch12_01.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 12</b></td><td width=172 align=right valign=top><A HREF="ch12_03.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="CGI-CHP-12-SECT-2">12.2 Programming/System Errors</A></h2><P CLASS=para>Nowthat we have looked at some of the common errors in CGI applicationdesign, let's focus on programming errors that can cause unexpectedresults. There is one extremely important point that you shouldbe aware of:<P CLASS=para><I CLASS=emphasis>Always check the return value of all the systemcommands, including eval, open, and system. </I><P CLASS=para>What does this mean? The next few sections will describe someof the programming errors that occur frequently if you are not careful.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-12-SECT-2.1">Opening, Reading, and Writing Files</A></h3><P CLASS=para>Since the server is running as a user thathas minimal privileges (usually "nobody"), you must be careful whenreading from or writing to files. Here is an example:<DIV CLASS=screen><P><PRE>open (FILE, "&lt;" . "/usr/local/httpd_1.4.2/data");while (&lt;FILE&gt;) {    print;}close (FILE);</PRE></DIV><P CLASS=para>Now, what if the file that you are trying to read is not accessible?The file handle FILE will not be created, butthe while loop tries to iterate through that file handle. Fortunately,Perl does not get upset, but you will not have any data. So, itis always better to check the status of the <I CLASS=emphasis>open</I>command, like this:<DIV CLASS=screen><P><PRE>open (FILE, "&lt;" . "/usr/local/httpd_1.4.2/data") ||     &amp;call_some_subroutine ("Oops! The read failed. We need to do something.");</PRE></DIV><P CLASS=para>This will ensure that the subroutine <I CLASS=emphasis>call_some_subroutine</I>gets called if the script cannot open the file. Now, say you wantto write to an output file:<DIV CLASS=screen><P><PRE>open (FILE, "&gt;" . "/usr/local/httpd_1.4.2/data");print FILE "Line 1", "\n;print FILE "Line 2", "\n";close (FILE);</PRE></DIV><P CLASS=para>Again, you should check for the status of the <I CLASS=emphasis>open</I>command:<DIV CLASS=screen><P><PRE>open (FILE, "&gt;" . "/usr/local/httpd_1.4.2/data") ||		&amp;call_some_subroutine ("Oops! The write failed. We need to do something.");</PRE></DIV><P CLASS=para>This is true when doing such tasks as updating a databaseor creating a counter data file. In order for the server to writeto a file, it has to have write privileges on the file as well asthe directories in which the file is located.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="CGI-CHP-12-SECT-2.2">Pipes and the open Command</A></h3><P CLASS=para>We used pipes toperform data redirection in numerous examples in this book. Unlikefiles, there is no easy way to check to see if the contents of thepipe have been successfully executed. Let's take a look at a simpleexample:<DIV CLASS=screen><P><PRE>open (FILE, "/usr/bin/cat /home/shishir/.login |") 				|| &amp;call_some_subroutine ("Error opening pipe!");while (&lt;FILE&gt;) {    print;}close (FILE);</PRE></DIV><P CLASS=para>If the <I CLASS=emphasis>cat</I>command cannot be found by the shell, you might expect that an errorstatus will be returned by the <I CLASS=emphasis>open</I> command,and thus the <I CLASS=emphasis>call_some_subroutine</I> functionwill be called. However, this is not the case. An error status willbe returned only if a pipe cannot be created (which is almost neverthe case). Due to the way the shell operates, the status of thecommand is available only after the file handle is closed. Hereis an example:<DIV CLASS=screen><P><PRE>open (FILE, "/usr/bin/cat /home/shishir/.login |")     || &amp;call_some_subroutine ("Error opening pipe!");while (&lt;FILE&gt;) {    print;}close (FILE);if ($?) {    &amp;call_some_subroutine ("Error in executing command!");} </PRE></DIV><P CLASS=para>Once the file handle is closed, Perl saves the return statusin the variable <I CLASS=emphasis>$?</I>. This is the method thatyou should use for all system commands.<P CLASS=para>There is another method for determining the status of thepipe before the file handle is closed, though it is not always 100%reliable. It involves checking the process ID (PID) of the processthat is spawned by the open command:<DIV CLASS=screen><P><PRE>$pid = open (FILE, "/usr/bin/cat /home/shishir/.login |");sleep (2);$status = kill 0, $pid;if ($status) {    while (&lt;FILE&gt;) {        print;    }    close (FILE);} else {    &amp;call_some_subroutine ("Error opening pipe!");}</PRE></DIV><P CLASS=para>This is a neat trick! The <I CLASS=emphasis>kill</I> statement with an argument of0 checks the status of the process. If the process is alive, a valueof 1 is returned. Otherwise, a 0 is returned, which indicates thatthe process is no longer alive. The <I CLASS=emphasis>sleep</I> commandensures a delay so that the value returned by <I CLASS=emphasis>kill</I>reflects the status of the process.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch12_01.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch12_03.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Common Errors</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Environment Variables</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>