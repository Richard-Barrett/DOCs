<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 6] 6.3 The Function Object</TITLE><META NAME="author" CONTENT="David Flanagan"><META NAME="date" CONTENT="Wed Apr 23 18:07:38 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="JavaScript"><META NAME="title" CONTENT="JavaScript: The Definitive Guide"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="Javascript: The Definitive Guide"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 6</b></td><td width=172 align=right valign=top><A HREF="ch06_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="ch06-SECT1-AUTOID.3">6.3 The Function Object</A></h2><P CLASS=para><A NAME="CH06.FUNOBJ"></A>      In <A HREF="ch03_01.htm">Chapter 3, <i>Variables and Data Types</i></A> we saw that each of the      primitive (i.e., non-object) JavaScript data types has a      corresponding "wrapper" object type that is used to provide      properties and methods for the data type. Recall that JavaScript      automatically converts primitive values to the corresponding      object type, when those values are used in an "object      context"--i.e., when you try to access their properties or methods.      Because the conversion is so transparent to the programmer, it can      seem as if primitive types, like strings, have properties and      methods.    <P CLASS=para>      Since, as we've seen, functions are not just a syntactic feature      of JavaScript, but also a data type, JavaScript provides the      Function object type as a wrapper. The Function object has two      properties: <tt CLASS=literal>arguments</tt>, which contains an array      of arguments passed to the function, and <tt CLASS=literal>caller</tt>      which refers to the function that called the current function.      Additionally, in Navigator 3.0, the Function object has a      constructor function that can be used (with the      <tt CLASS=literal>new</tt> keyword) to define new functions      dynamically, at run-time. The subsections below explain exactly      how these two properties and the constructor function work.    <P CLASS=para>      Before we consider the properties of the Function object, there      are a couple of important points we must note about their use.      The first point is that the <tt CLASS=literal>arguments</tt> and      <tt CLASS=literal>caller</tt> properties of the Function object are      only defined while the function is being executed. If you try to      access these properties from outside the function, their value      will be <tt CLASS=literal>null</tt>.    <P CLASS=para>      The second point to note is that in order to refer to these      Function properties from inside a function, the function must      refer to itself. It would seem logical that JavaScript would      define a special keyword that refers to "the currently running      function" to support this self-reference. There are two likely      candidates, but unfortunately, neither of them do what we want:      the <tt CLASS=literal>this</tt> keyword, when used in a function      refers to the object through which the function was invoked (we'll      see more about this when we consider methods in <A HREF="ch07_01.htm">Chapter 7, <i>Objects</i></A>), and the <tt CLASS=literal>self</tt>      keyword (really a property name, not a keyword, as we'll see in      <A HREF="ch11_01.htm">Chapter 11, <i>Windows and the JavaScript Name Space</i></A>) refers to the current browser      window, not the current function. The current version of      JavaScript simply does not have a keyword to refer to the current      function, although this may be added in a future version of the      language.     <P CLASS=para>      So, a function can refer to itself simply by using its name. As      we saw in the previous section, this name is nothing more that a      variable name or an object property, or even a numbered element of      an array. Remember that a function is just a data value--if you      can refer to this value in order to invoke the function, then you      can generally refer to it in the same way from inside the function      body. A function <tt CLASS=literal>f</tt> might refer to elements of      its <tt CLASS=literal>arguments[]</tt> array like this:      <DIV CLASS=programlisting><P><PRE>function f() { return f.arguments[0] * f.arguments[1]; }</PRE></DIV>    <P CLASS=para>      When we introduce the constructor function of the Function object,      we'll actually show a way to create unnamed functions, and you may      encounter occasional circumstances in which the body of a function      does not know how to refer to itself. If you encounter one of      these rare cases in Navigator 3.0, you can refer to the current      function by passing the string <tt CLASS=literal>"this"</tt> to the      <tt CLASS=literal>eval()</tt> method (a method of the Function object,      as it is of all objects). For example, you could refer to the      <tt CLASS=literal>caller</tt> property of the current function,      without explicitly naming it, like this:      <DIV CLASS=programlisting><P><PRE>eval("this").caller</PRE></DIV>    <P CLASS=para>      With these notes about the use of the Function object's      properties in mind, we can finally go ahead and consider the      properties themselves.    <DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch06-SECT2-AUTOID.1">The arguments[] Array</A></h3><P CLASS=para><A NAME="CH06.ARG1"></A><A NAME="CH06.ARG2"></A><A NAME="CH06.ARG3"></A>	The <tt CLASS=literal>arguments[]</tt> property of a	Function object refers to an array that contains the complete	set of argument values passed to the function for the current	invocation. JavaScript allows any number of argument values to	be passed to any function, regardless of the number of argument	names that appear in the function definition. If you define a	function named <tt CLASS=literal>f</tt> with a single argument named	<tt CLASS=literal>x</tt>, then within the function, the value of the	argument <tt CLASS=literal>x</tt> is the same as	<tt CLASS=literal>f.arguments[0]</tt>. If you invoke this function	and pass it two arguments instead of just one, then the second	argument won't have a name within the function but will be	available as <tt CLASS=literal>f.arguments[1]</tt>. Like most	arrays, the <tt CLASS=literal>arguments[]</tt> array has a	<tt CLASS=literal>length</tt> property that specifies the number of	elements. Thus, for a function <tt CLASS=literal>f</tt>,	<tt CLASS=literal>f.arguments.length</tt> specifies the number of	argument values that were passed for the current invocation.      <P CLASS=para>	The <tt CLASS=literal>arguments[]</tt> array is useful in a	number of ways. As <A HREF="ch06_03.htm#JSCRIPT-CH-FUNCTIONS-EX-3">Example 6-3</A>	shows, you can use it to check that a function is invoked with	the correct number of arguments, since JavaScript doesn't do	this for you.      <DIV CLASS=example><h4 CLASS=example><A CLASS="TITLE" NAME="JSCRIPT-CH-FUNCTIONS-EX-3">Example 6-3: Checking for the Correct Number of Arguments</A></h4><DIV CLASS=programlisting><P><PRE>function f(x, y, z){    //<tt CLASS=replaceable><i> first, check that the right # of arguments were passed.</i></tt>    if (f.arguments.length != 3) {        alert("function f called with " + f.arguments.length +              "arguments, but it expects 3 arguments.");        return null;    }    //<tt CLASS=replaceable><i> now do the actual function...</i></tt>}</PRE></DIV></DIV><P CLASS=para>	The <tt CLASS=literal>arguments[]</tt> array also opens up	an important possibility for JavaScript functions: they can be	written so that they work with any number of arguments.	<A HREF="ch06_03.htm#JSCRIPT-CH-FUNCTIONS-EX-4">Example 6-4</A>	shows how you can write a <tt CLASS=literal>max()</tt>	function that accepts any number of arguments and returns the	value of the largest argument it is passed.      <DIV CLASS=example><h4 CLASS=example><A CLASS="TITLE" NAME="JSCRIPT-CH-FUNCTIONS-EX-4">Example 6-4: A Multi-Argument max() Function</A></h4><DIV CLASS=programlisting><P><PRE>function max() {    var m = -Number.MAX_VALUE; //<tt CLASS=replaceable><i> Navigator 3.0 only. In 2.0 use -1.79E+308</i></tt>    //<tt CLASS=replaceable><i> loop through all the arguments, looking for, and</i></tt>    //<tt CLASS=replaceable><i> remembering, the biggest.</i></tt>    for(var i = 0; i &lt; max.arguments.length; i++)        if (max.arguments[i] &gt; m) m = max.arguments[i];    //<tt CLASS=replaceable><i> return the biggest.</i></tt>    return m;}var largest = max(1, 10, 100, 2, 3, 1000, 4, 5, 10000, 6);</PRE></DIV></DIV><P CLASS=para>	You can also write functions that have some named arguments,	followed by some unnamed arguments.	<A HREF="ch06_03.htm#JSCRIPT-CH-FUNCTIONS-EX-5">Example 6-5</A>	shows such a function; it is a constructor function that creates	an array, initializes a <tt CLASS=literal>size</tt> property as	specified by a named argument <tt CLASS=literal>len</tt>, and then	initializes an arbitrary number of elements, starting with	element 1, of the array to the values of any additional	arguments. (JavaScript programs in Navigator 2.0 often use a	function like this, as seen in <A HREF="ch08_01.htm">Chapter 8, <i>Arrays</i></A>.)      <DIV CLASS=example><h4 CLASS=example><A CLASS="TITLE" NAME="JSCRIPT-CH-FUNCTIONS-EX-5">Example 6-5: Creating and Initializing an Array</A></h4><DIV CLASS=programlisting><P><PRE>function InitializedArray(len){    this.size = len;  //<tt CLASS=replaceable><i> In 2.0, this sets array element 0.</i></tt>    for (var i = 1; i &lt; InitializedArray.arguments.length; i++)         this[i] = InitializedArray.arguments[i];}</PRE></DIV></DIV><P CLASS=para>	A final note about the <tt CLASS=literal>arguments[]</tt>	array: the <tt CLASS=literal>arguments</tt> property of a Function	object actually holds a copy of the Function object itself. In	other words, if <tt CLASS=literal>f</tt> is a function, and	<tt CLASS=literal>F</tt> is the corresponding Function object, then	each of the following lines of code refers to the same thing:	<DIV CLASS=programlisting><P><PRE>f.argumentsF.argumentsFF.arguments.arguments.arguments</PRE></DIV>	It is a strange implementation, but what it means is that it is	the Function object itself that maintains the array of arguments	(as we'll see in <A HREF="ch08_01.htm">Chapter 8, <i>Arrays</i></A>, arrays and	objects are the same thing in JavaScript, and an object can have	both properties and array elements.)  So, instead of writing	<tt CLASS=literal>f.arguments[i]</tt>, you can just write	<tt CLASS=literal>f[i]</tt>, and instead of	<tt CLASS=literal>f.arguments.length</tt>, you can write	<tt CLASS=literal>f.length</tt>. This feature is not guaranteed to	continue to work in future versions of JavaScript; using the	<tt CLASS=literal>arguments</tt> property is the officially	supported way to access function arguments.      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch06-SECT2-AUTOID.2">The caller Property</A></h3><P CLASS=para><A NAME="CH06.CALL1"></A><A NAME="CH06.CALL2"></A>	The other property of the Function object is	<tt CLASS=literal>caller</tt>. This property is a reference to the	function (the function value itself, not the Function object	wrapper) that invoked the current one. If the function was	invoked from the top level of the script, rather than from a	function, then this property will be	<tt CLASS=literal>null</tt>. Because <tt CLASS=literal>caller</tt> is a	reference to a function value, you can do anything with it that	you can do with any other function reference. You can call it,	or pass it to other functions, causing a kind of recursion.      <P CLASS=para>	Unfortunately, since the <tt CLASS=literal>caller</tt> property	refers to a function that is not the currently executing	function, you cannot inspect the <tt CLASS=literal>arguments</tt> or	<tt CLASS=literal>caller</tt> property of the function referred to	by the <tt CLASS=literal>caller</tt> property. That is, the	following JavaScript expressions evaluate to	<tt CLASS=literal>null</tt>:	<DIV CLASS=programlisting><P><PRE>f.caller.caller          //<tt CLASS=replaceable><i> doesn't work</i></tt>f.caller.arguments[1]    //<tt CLASS=replaceable><i> doesn't work</i></tt></PRE></DIV>	It is a shame that these kinds of expressions do not return	meaningful values, because it would allow us to write functions	that produce stack traces, for example, or a function that could	be invoked for the purpose of checking that its caller was	invoked with the correct number and type of arguments.      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch06-SECT2-AUTOID.3">The Function() Constructor</A></h3><P CLASS=para><A NAME="CH06.FUN3"></A>	We said in <A HREF="ch04_01.htm">Chapter 4, <i>Expressions and Operators</i></A> that the	<tt CLASS=literal>new</tt> operator is used to create new objects;	this object is used with a special "constructor function" that	specifies the type of object to be created. Many JavaScript	object types define constructor functions that can be used to	create objects of that type. The Function object type is no	exception--it provides the <tt CLASS=literal>Function()</tt>	constructor which allows us to create new Function objects.	This constructor works in Navigator 3.0, but not in Internet	Explorer 3.0. It will be implemented in a future version of IE.      <P CLASS=para>	The <tt CLASS=literal>Function()</tt> constructor provides a	technique for defining functions without 	using the <tt CLASS=literal>function</tt> keyword. You can create a	new Function object with the <tt CLASS=literal>Function()</tt>	constructor like this:	<DIV CLASS=programlisting><P><PRE>var f = new Function("x", "y", "return x*y;");</PRE></DIV>	This line of code creates a new function (wrapped within a new	Function object) that is equivalent (almost) to a function	defined with the syntax we're already familiar with:	<DIV CLASS=programlisting><P><PRE>function f(x, y) { return x*y; }</PRE></DIV>      <P CLASS=para>	The <tt CLASS=literal>Function()</tt> constructor expects	any number of string arguments. The last argument in the list	becomes the body of the function--it can contain arbitrary	JavaScript statements, separated from each other with	semicolons. All other arguments to the	<tt CLASS=literal>Function()</tt> constructor are strings that	specify the names of the arguments to the function being	defined. If you are defining a function that takes no	arguments, then you simply pass a single string--the	function body--to the constructor.      <P CLASS=para><A NAME="CH06.NAMFUN"></A>	There are a couple of reasons you might want to use the	<tt CLASS=literal>Function()</tt> constructor. Recall that	the <tt CLASS=literal>function</tt> keyword defines a variable, just	like the <tt CLASS=literal>var</tt> does. So the first reason to	use the <tt CLASS=literal>Function()</tt> constructor is to avoid	having to give your function a temporary variable name when you	are just going to immediately assign it to an object property	(making a method of that object, as we'll see in <A HREF="ch07_01.htm">Chapter 7, <i>Objects</i></A>). For example, consider the	following two lines of code:	<DIV CLASS=programlisting><P><PRE>function tmp_area() { return Math.PI * this.radius * this.radius; }Circle.area = tmp_area</PRE></DIV>	The <tt CLASS=literal>Function()</tt> constructor allows us	to do this in a single step without creating the temporary	<tt CLASS=literal>tmp_area</tt> variable:	<DIV CLASS=programlisting><P><PRE>Circle.area = new Function("return Math.PI * this.radius * this.radius;");</PRE></DIV>      <P CLASS=para>	Another reason you might want to use the	<tt CLASS=literal>Function()</tt> constructor is to define	temporary or "anonymous" functions that are never given a name.	Recall the <tt CLASS=literal>Array.sort()</tt> method mentioned	earlier in this chapter: it takes a function as an argument, and	that function defines how the elements of the array are sorted.	Strings and numbers already have a well-defined sort order, but	suppose we were trying to sort an array of objects each of which	represented a complex number. To do this, we might use the	magnitude of the number, or its overall "distance" from the	origin as the value which we would compare to do the sort. It	is simple enough to right an appropriate function to perform	this comparison, but if we only plan to sort this array of	complex number objects once, we might not want to bother	defining the function with the <tt CLASS=literal>function</tt>	keyword and giving it a permanent name. Instead, we might	simply use code like the following to dynamically create a	Function object and pass it to the <tt CLASS=literal>sort()</tt>	method without ever giving it a name. (Recall that just as	JavaScript automatically converts primitive types to their	corresponding wrapper objects, so to does it convert in the	other direction. So the Function object created in the example	will be automatically converted to a function value appropriate	for the <tt CLASS=literal>sort()</tt> method.	<DIV CLASS=programlisting><P><PRE>complex_nums.sort(       new Function("a", "b",                    "Math.sqrt(a.x*a.x+a.y*a.y)-Math.sqrt(b.x*b.x+b.y*b.y);"));</PRE></DIV>      <P CLASS=para>	The only difference between functions defined with the	<tt CLASS=literal>function</tt> keyword and those defined with the	<tt CLASS=literal>Function()</tt> constructor has to do with	how they are printed. (Try it!  Use	<tt CLASS=literal>document.write()</tt> or	<tt CLASS=literal>alert()</tt>.)  When a function is printed (or	otherwise converted to a string) the function name, arguments,	and body are displayed, along with the	<tt CLASS=literal>function</tt> keyword. The result of converting a	function to a string is a string that contains a legal	JavaScript function definition. When a function is defined with	<tt CLASS=literal>function</tt>, it is given a name as part of the	function definition syntax, and this name appears when the	function is printed. Functions defined with	<tt CLASS=literal>Function()</tt>, however, do not have a	name, and so are printed with the name "anonymous". For this	reason, functions defined in this way are sometimes referred to	as "anonymous functions".      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch06-SECT2-AUTOID.4">Function Properties</A></h3><P CLASS=para>	There are several interesting facts about functions that you	should be aware of. You can combine these facts into a useful	programming technique.      <DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="ch06-SECT3-AUTOID.1">Functions are objects</A></h4><P CLASS=para>	  One of the interesting features of JavaScript functions is that	  you can assign properties to them. For example:	  <DIV CLASS=programlisting><P><PRE>function f() { alert('hello world!'); }f.i = 3;</PRE></DIV>	  This code creates a function <tt CLASS=literal>f</tt>, and then	  assigns a property <tt CLASS=literal>i</tt> to it. Later, we can	  use this property just like any other:	  <DIV CLASS=programlisting><P><PRE>var i = f.i + 2;</PRE></DIV>	<P CLASS=para>	  What is unusual about this is that we are assigning a property	  to a primitive function value. JavaScript does actually allow	  us to assign properties to other primitive types, but those	  properties don't persist. Consider this code:	  <DIV CLASS=programlisting><P><PRE>n = 1;       //<tt CLASS=replaceable><i> A number</i></tt>n.i = 2;     //<tt CLASS=replaceable><i> Convert it to a Number object and give that object a property</i></tt>typeof n.i   //<tt CLASS=replaceable><i> This tells us n.i is undefined; the property is transient.</i></tt></PRE></DIV>	  When properties are assigned to primitive numbers, Booleans, and	  strings, JavaScript converts those primitive types to temporary	  Number, Boolean, and String objects, and assigns the property to	  those objects. The objects only persist while the expression is	  being evaluated, and, once discarded, the property no longer exists.	<P CLASS=para>	  The reason this doesn't happen with functions is that all	  JavaScript functions are objects. The Function object is	  obviously an object type, but even primitive function types are	  objects that can have properties assigned to them. Because	  functions are such an important and integral part of the	  language, however, they are usually treated as a special	  primitive type.	</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="ch06-SECT3-AUTOID.2">Function arguments and variables are properties</A></h4><P CLASS=para>	  In all versions of JavaScript, global variables are actually	  properties of some top-level object. In client-side	  JavaScript, as we'll see, this top-level object is the browser	  window or frame that contains the JavaScript code. This	  raises the obvious question: if global variables are	  properties of an object, what are local function variables?  It	  would make sense that they, too, are properties of some	  object. The only obvious object is the function (or Function)	  itself. The following code demonstrates:	  <DIV CLASS=programlisting><P><PRE>function f(x){   var y = 3;         //<tt CLASS=replaceable><i> a local variable</i></tt>   return f.x + f.y;  //<tt CLASS=replaceable><i> refer to the argument and variable as properties    </i></tt>}</PRE></DIV>	  If we invoke the function, we see that function arguments and	  local variables really can be accessed as properties of the	  function itself:	  <DIV CLASS=programlisting><P><PRE>result = f(2);        //<tt CLASS=replaceable><i> returns 5</i></tt></PRE></DIV>	  However, if we try to read these properties ourselves, we will	  be unable to:	  <DIV CLASS=programlisting><P><PRE>typeof f.x      //<tt CLASS=replaceable><i> yields "undefined"</i></tt>typeof f.y      //<tt CLASS=replaceable><i> yields "undefined"</i></tt></PRE></DIV>        <P CLASS=para>	  What this means is that, like the	  <tt CLASS=literal>arguments[]</tt> array and the	  <tt CLASS=literal>caller</tt> property, the local variable and	  argument properties are only accessible while the function is	  running. When the function returns, JavaScript deletes these	  properties. 	</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="ch06-SECT3-AUTOID.3">Function properties simulate static variables</A></h4><P CLASS=para>	  Knowing that local variables are implemented as transient	  properties of a function is not particularly useful in itself,	  but it does lead us to a useful programming technique. In C	  and C++, a <tt CLASS=literal>static</tt> variable in a function is	  one that is local to the function, but which has a value that	  persists across invocations of the function--that is, its	  value is not reset every time the function is called, and you	  can use it to save state so that a function could keep track	  of how many times it had been invoked, for example. A static	  variable in a function is a global variable, because it	  retains its value. And it is also like a local variable	  because it is invisible outside the function, which means that	  you do not have to give it a unique name or worry about	  collisions with other global variables or about cluttering up	  the name space. This is often a very useful combination of	  features. 	<P CLASS=para>	  JavaScript does not support static variables directly, but it	  turns out that we can simulate them with function properties.	  We've seen that function properties for local variables and	  arguments are created when a function is invoked and are	  deleted when the function returns. You can create other	  properties of a function, however, that will not be deleted	  like this. Because local variables are looked up as	  properties of the function, any properties you add will appear	  to be local variables. They differ from local variables,	  however, in that they are not deleted and reset every time the	  function is called, so they can retain their value. At the	  same time, though, they are properties of a function instead	  of global variables, so they do not clutter the name space.	  These are exactly the features we desire in a static variable.	<P CLASS=para>	  <A HREF="ch06_03.htm#JSCRIPT-CH-FUNCTIONS-EX-6">Example 6-6</A> shows a function 	  that uses a "static variable" to keep track of how many times	  it has been called. You'll probably find many more realistic	  uses for static variables in your own programming. As a rule	  of thumb, never use a global variable where a static variable	  would work as well.	<DIV CLASS=example><h4 CLASS=example><A CLASS="TITLE" NAME="JSCRIPT-CH-FUNCTIONS-EX-6">Example 6-6: Using Static Variables</A></h4><DIV CLASS=programlisting><P><PRE>function count(){    //<tt CLASS=replaceable><i> counter is a static variable, defined below.</i></tt>    //<tt CLASS=replaceable><i> Note that we use it just like a local variable.</i></tt>    alert("You've called me " + counter + " time(s).");    //<tt CLASS=replaceable><i> Increment the static variable. This incremented value</i></tt>    //<tt CLASS=replaceable><i> will be retained and will be used the next time we are called.</i></tt>    counter++;}//<tt CLASS=replaceable><i> To define the static variable, just set it as a property of the function:</i></tt>//<tt CLASS=replaceable><i> Note that the only shortcoming of this technique is that static</i></tt>//<tt CLASS=replaceable><i> variables can only be defined after they are used in the function.</i></tt>count.counter = 1;</PRE></DIV></DIV></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch06_04.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Functions as Data Types</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Built-in Functions</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>