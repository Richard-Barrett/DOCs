<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 9] 9.3 By Value vs. By Reference</TITLE><META NAME="author" CONTENT="David Flanagan"><META NAME="date" CONTENT="Wed Apr 23 18:11:48 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="JavaScript"><META NAME="title" CONTENT="JavaScript: The Definitive Guide"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="Javascript: The Definitive Guide"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch09_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 9</b></td><td width=172 align=right valign=top><A HREF="ch10_01.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="ch09-SECT1-AUTOID.3">9.3 By Value vs. By Reference</A></h2><P CLASS=para><A NAME="CH09.VALREF1"></A><A NAME="CH09.VALREF2"></A><A NAME="CH09.VALREF3"></A><A NAME="CH09.VALREF4"></A><A NAME="CH09.VALREF5"></A><A NAME="CH09.ASSIGN"></A>      In JavaScript, and all programming languages, there are three      important ways that you can manipulate a data value. First, you      can copy it, by assigning it to a new variable, for example.      Second, you can pass it as an argument to a function or method.      Third, you can compare it with another value to see if the two      values are equal. In order to understand any programming      language, you must understand how these three operations are      performed in that language.     <P CLASS=para>      There are two fundamentally distinct techniques in which data      values can be manipulated. These techniques are called "by value"      and "by reference." When a value is manipulated "by value" it is      the <I CLASS=emphasis>value</I> of the datum that matters: in an      assignment, a copy of the actual value is made and that copy is      stored in a variable or object property or array element; the copy      and the original are two totally independent values that are      stored separately. When a datum is passed "by value" to a      function, a <I CLASS=emphasis>copy</I> of the datum is passed to      the function; if the function modifies that value, the change      affects only the function's copy of the datum--it does not      affect the original datum. And when a datum is compared "by      value" to another datum, the two distinct pieces of data must      represent exactly the same value (which usually means that a      byte-by-byte comparison finds them to be equal).    <P CLASS=para>      The other way of manipulating a datum is "by reference." With      this technique, there is only one actual copy of the datum, and it      is references to that datum that are manipulated.[1]      When a datum is manipulated "by reference," there is only ever one      copy of the actual value. If a value is manipulated "by      reference," then variables do not hold that value directly; they      only hold references to it. It is these references that are      copied, passed, and compared.    <blockquote class=footnote><P CLASS=para>[1] 	  C programmers, and anyone else familiar with the concept of	  "pointers," will understand the idea of a "reference" in this	  context. Note, however, that JavaScript does not support	  pointers. 	</blockquote><P CLASS=para>      So, in an assignment made "by reference," it is the reference to      the value that is assigned, not a copy of the value, and not the      value itself. After the assignment, the new variable will contain      the same reference to the value that the original variable      contains. Both references are equally valid, and both can be used      to manipulate the value--if the value is changed through one      reference, that change will also appear through the original      reference. The situation is similar when a datum is passed to a      function "by reference:" a reference to the value is passed to the      function, and the function can use that reference to modify the      value itself; any such modifications will be visible outside the      function. And finally, when a datum is compared to another "by      reference," the two references are compared to see if they refer      to the same unique copy of a value; references to two distinct      datums that happen to have the same value (consist of the same      bytes) will not be treated as equal.    <P CLASS=para>      These are two very different ways of manipulating values,      and they have very important implications that you should      understand.      <A HREF="ch09_03.htm#JSCRIPT-CH-FURTHER-TAB-2">Table 9.2</A>      summarizes these implications. This discussion of manipulating      data "by value" and "by reference" has been a general one: the      distinctions apply to all programming languages. The subsections      that follow explain how they apply specifically to      JavaScript--which data types are manipulated by value and which      are manipulated by reference.    <P><DIV CLASS=table><TABLE><CAPTION><A CLASS="TITLE" NAME="JSCRIPT-CH-FURTHER-TAB-2">Table 9-2: By Value versus By Reference</A></CAPTION><TR CLASS=row><TH ALIGN="left">&nbsp;</TH><TH ALIGN="LEFT">By Value</TH><TH ALIGN="LEFT">By Reference</TH></TR><TR CLASS=row><TD ALIGN="left"><b>Copy</b></TD><TD ALIGN="LEFT"><P CLASS=para>      		The value is actually copied; there are two distinct,		independent copies.	      </TD><TD ALIGN="LEFT"><P CLASS=para>                Only a reference to the value is copied. If the value is                modified through the new reference, that change is also                visible through the original reference.               </TD></TR><TR CLASS=row><TD ALIGN="left"><b>Pass</b></TD><TD ALIGN="LEFT"><P CLASS=para>A distinct copy of the value is passed to the	  function; changes to it have no effect outside the	  function. </TD><TD ALIGN="LEFT"><P CLASS=para>A reference to the value is passed to the	  function. If the function modifies the value through the	  passed reference, the modification is visible outside the	  function. </TD></TR><TR CLASS=row><TD ALIGN="left"><b>Compare</b></TD><TD ALIGN="LEFT"><P CLASS=para>Two distinct values are compared (often byte by	  byte) to see if they are the same value. </TD><TD ALIGN="LEFT"><P CLASS=para>Two references are compared to see if they	  refer to the same value. Two references to distinct values are	  not equal, even if the two values consist of the same	  bytes. </TD></TR></TABLE><P></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch09-SECT2-AUTOID.11">Primitive Types and Reference Types</A></h3><P CLASS=para><A NAME="CH09.PRIM1"></A><A NAME="CH09.PRIM2"></A>	The basic rule in JavaScript is this: primitive types are	manipulated by value, and reference types, as the name suggests,	are manipulated by reference. Numbers and Booleans are	primitive types in JavaScript--primitive because the consist of	nothing more than a small fixed number of bytes, bytes that are	very easily manipulated at the low (primitive) levels of the	JavaScript interpreter. On the other hand, objects and arrays	are reference types. These data types can contain arbitrary	numbers of properties or elements, and so can be of arbitrary	size, and cannot be so easily manipulated. Since object and	array values can become quite large, it doesn't make sense to	manipulate these types by value, which could involve the	inefficient copying and comparing of large amounts of memory.      <P CLASS=para>	What about strings and functions?  These types may have	arbitrary length, and so it would seem that they would be	reference types. In fact, though, they are usually considered	to be primitive types in JavaScript, simply for the reason that	they are not objects or arrays. Strings and functions do not	follow the "primitive types by value and reference types by	reference" rule presented above, and will be discussed in a	section of their own later in this chapter.      <P CLASS=para>	Examples using primitive and reference types are the best way to	explore the differences between data manipulation by value and	data manipulation by reference. Study the following examples	carefully, paying attention to the comments. First, <A HREF="ch09_03.htm#JSCRIPT-CH-FURTHER-EX-BY-VALUE">Example 9-1</A> copies, passes, and compares	numbers. Since numbers are primitive types, this illustrates	data manipulation by value.      <DIV CLASS=example><h4 CLASS=example><A CLASS="TITLE" NAME="JSCRIPT-CH-FURTHER-EX-BY-VALUE">Example 9-1: Copying, Passing, and Comparing by Value</A></h4><DIV CLASS=programlisting><P><PRE>//<tt CLASS=replaceable><i> First we illustrate copy by value.</i></tt>n = 1;            //<tt CLASS=replaceable><i> variable n holds the value 1</i></tt>m = n;            //<tt CLASS=replaceable><i> copy by value:  variable m holds a distinct value 1</i></tt>//<tt CLASS=replaceable><i> Here's a function we'll use to illustrate pass-by-value.</i></tt>//<tt CLASS=replaceable><i> As we'll see, the function doesn't work the way we'd like it to.</i></tt>function add_to_total(total, x){    total = total + x;  //<tt CLASS=replaceable><i> this line only changes the internal copy of total</i></tt>}//<tt CLASS=replaceable><i> Now call the function, passing the numbers contained in n and m by value.</i></tt>//<tt CLASS=replaceable><i> The value of n is copied, and that copied value is named total within the</i></tt>//<tt CLASS=replaceable><i> function. The function adds a copy of m to that copy of n. But adding</i></tt>//<tt CLASS=replaceable><i> something to a copy of n doesn't affect the original value of n outside</i></tt>//<tt CLASS=replaceable><i> of the function. So calling this function doesn't accomplish anything.</i></tt>add_to_total(n, m);//<tt CLASS=replaceable><i> Now, we'll look at comparison by value. </i></tt>//<tt CLASS=replaceable><i> In the line of code below, the literal 1 is clearly a distinct numeric</i></tt>//<tt CLASS=replaceable><i> value encoded in the program. We compare it to the value held in variable</i></tt>//<tt CLASS=replaceable><i> n. In comparison by value, the bytes of the two numbers are checked to</i></tt>//<tt CLASS=replaceable><i> see if they are the same.</i></tt>if (n == 1) m = 2;      //<tt CLASS=replaceable><i> n contains the same value as the literal 1</i></tt></PRE></DIV></DIV><P CLASS=para>	Next, consider <A HREF="ch09_03.htm#JSCRIPT-CH-FURTHER-EX-BY-REFERENCE">Example 9-2</A>. This example	copies, passes, and compares an object. Since objects are	reference types, these manipulations are performed "by	reference." The example uses Date objects, which you can read	about in the reference section of this book, if necessary.      <DIV CLASS=example><h4 CLASS=example><A CLASS="TITLE" NAME="JSCRIPT-CH-FURTHER-EX-BY-REFERENCE">Example 9-2: Copying, Passing, and Comparing by Reference</A></h4><DIV CLASS=programlisting><P><PRE>//<tt CLASS=replaceable><i> Here we create an object representing the date of Christmas, 1996.</i></tt>//<tt CLASS=replaceable><i> The variable xmas contains a reference to the object, not the object itself.</i></tt>xmas = new Date(96, 11, 25); //<tt CLASS=replaceable><i> When we copy by reference, we get a new reference to the original object.</i></tt>solstice = xmas;     //<tt CLASS=replaceable><i> both variables now refer to the same object value</i></tt>//<tt CLASS=replaceable><i> Here we change the object through our new reference to it</i></tt>solstice.setDate(21);//<tt CLASS=replaceable><i> The change is visible through the original reference, as well.</i></tt>xmas.getDate();      //<tt CLASS=replaceable><i> returns 21, not the original value of 25</i></tt>//<tt CLASS=replaceable><i> The same is true when objects and arrays are passed to functions.</i></tt>//<tt CLASS=replaceable><i> The following function adds a value to each element of an array.</i></tt>//<tt CLASS=replaceable><i> A reference to the array is passed to the function, not a copy of the array.</i></tt>//<tt CLASS=replaceable><i> Therefore, the function can change the contents of the array through</i></tt>//<tt CLASS=replaceable><i> the reference, and those changes will be visible when the function returns.</i></tt>function add_to_totals(totals, x){    totals[0] = totals[0] + x;    totals[1] = totals[1] + x;    totals[2] = totals[2] + x;}//<tt CLASS=replaceable><i> Finally, we'll examine comparison by value.</i></tt>//<tt CLASS=replaceable><i> When we compare the two variables defined above, we find they are</i></tt>//<tt CLASS=replaceable><i> equal, because the refer to the same object, even though we were trying</i></tt>//<tt CLASS=replaceable><i> to make them refer to different dates:</i></tt>(xmas == solstice)           //<tt CLASS=replaceable><i> evaluates to true</i></tt>//<tt CLASS=replaceable><i> The two variables defined below refer to two distinct objects, both</i></tt>//<tt CLASS=replaceable><i> of which represent exactly the same date.</i></tt>xmas = new Date(96, 11, 25);  solstice_plus_4 = new Date(96, 11, 25);//<tt CLASS=replaceable><i> But, by the rules of "compare by reference," distinct objects not equal!</i></tt>(xmas != solstice_plus_4)    //<tt CLASS=replaceable><i> evaluates to true</i></tt></PRE></DIV></DIV><P CLASS=para>	Before we leave the topic of manipulating objects and arrays by	reference, there is a point about passing values by reference	that it is important to get straight. When an object is passed	to a function, it is a reference to the object that is passed,	not a copy of the object's actual value. As we've seen in <A HREF="ch09_03.htm#JSCRIPT-CH-FURTHER-EX-BY-REFERENCE">Example 9-2</A> this means that we can	modify the object's value through the reference, and these	modifications will be visible when the function returns. What	we cannot do, and this is where confusion can arise, is modify	the reference itself. The function is passed a copy of the	reference to the object (in a sense, the reference itself is	"passed by value"). If the function changes its copy of the	reference, that change does not affect the object value nor the	original reference to the object, and the change will not be	visible outside of the function. <A HREF="ch09_03.htm#JSCRIPT-CH-FURTHER-EX-BY-REFERENCE2">Example 9-3</A> illustrates this.      <DIV CLASS=example><h4 CLASS=example><A CLASS="TITLE" NAME="JSCRIPT-CH-FURTHER-EX-BY-REFERENCE2">Example 9-3: References Themselves Are Passed by Value</A></h4><DIV CLASS=programlisting><P><PRE>//<tt CLASS=replaceable><i> This is another version of the add_to_totals() function. It doesn't</i></tt>//<tt CLASS=replaceable><i> work, through, because instead of changing the array itself, it tries to </i></tt>//<tt CLASS=replaceable><i> change the reference to the array.</i></tt>function add_to_totals2(totals, x){    newtotals = new Array(3);    newtotals[0] = totals[0] + x;    newtotals[1] = totals[1] + x;    newtotals[2] = totals[2] + x;    totals = newtotals;  //<tt CLASS=replaceable><i> this line has no effect outside of the function.</i></tt>}</PRE></DIV></DIV><P CLASS=para>	Note that this rule applies not only to pass-by-reference, but	also copy-by-reference. You can modify an object through a copy	of a reference, but changing the copied reference itself does	not affect the object nor the original reference to the object.	This is a more intuitive and less confusing case, so we don't	illustrate it with an example.      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch09-SECT2-AUTOID.12">Copying and Passing Strings and Functions</A></h3><P CLASS=para>	As mentioned in the previous section, strings and functions in	JavaScript don't fit neatly into the primitive-type versus	reference-type dichotomy. For most purposes, strings and	functions are considered primitive types by	default--because they are not objects or arrays. If they are	primitive types, then by the rules given above, they should be	manipulated by value. But since a string can be arbitrarily	long, and a function can contain an arbitrary amount of	JavaScript code, these types do not have a fixed size, and it	would be inefficient to copy, pass, and compare these data types	byte by byte.      <P CLASS=para>	Since it is unclear whether JavaScript copies and passes	strings and functions by value or by reference, we can try to	write some JavaScript code to experiment with these data types.	If they are copied and passed by reference, then we should be	able to modify the contents of a string or function value	through a copy of the value or a through a function that takes	the value as an argument. When we set out to write the code to	perform this experiment and determine whether strings and	functions are copied and passed by reference, we run into a	major stumbling block: there is no way to modify the contents of	a string or a function. We can modify the contents of an object	or an array by setting object properties or array elements. But	strings and functions are <I CLASS=emphasis>immutable</I> in	JavaScript--that is, there is no JavaScript syntax, or	JavaScript functions, methods, or properties that allow you to	change the characters in the string or the code in the function.      <P CLASS=para>	Since strings and functions are immutable, our original	question is moot: there is no way to tell if strings and	functions are passed by value or by reference. Because of	efficiency considerations, we can assume that JavaScript is	implemented so that strings and functions are passed by	reference, but in actuality it doesn't matter, since it has no	practical bearing on the code we write.      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch09-SECT2-AUTOID.13">Comparing Strings and Functions</A></h3><P CLASS=para>	Despite the fact that we cannot determine whether strings and	functions are copied and passed by value or by reference, we can	write JavaScript code to determine whether they are compared by	value or by reference. <A HREF="ch09_03.htm#JSCRIPT-CH-FURTHER-EX-COMPARE">Example 9-4</A>	shows the code we might use to make this determination.       <DIV CLASS=example><h4 CLASS=example><A CLASS="TITLE" NAME="JSCRIPT-CH-FURTHER-EX-COMPARE">Example 9-4: Are Strings and Functions Compared by Value or by Reference?</A></h4><DIV CLASS=programlisting><P><PRE>//<tt CLASS=replaceable><i> Determining whether strings are compared by value or reference is easy.</i></tt>//<tt CLASS=replaceable><i> We compare two clearly distinct strings that happen to contain the same</i></tt>//<tt CLASS=replaceable><i> characters. If they are compared by value they will be equal, but if they</i></tt>//<tt CLASS=replaceable><i> are compared by reference, they will not be equal:</i></tt>s1 = "hello";s2 = "hell" + "o";if (s1 == s2) document.write("Strings compared by value");//<tt CLASS=replaceable><i> Determining whether functions are compared by value or reference is trickier,</i></tt>//<tt CLASS=replaceable><i> because we cannot define two functions with the same name. Therefore, we</i></tt>//<tt CLASS=replaceable><i> have to use unnamed functions. Don't feel you have to understand this code.</i></tt>//<tt CLASS=replaceable><i> We create two distinct functions that contain exactly the same code.</i></tt>//<tt CLASS=replaceable><i> If JavaScript says these two functions are equal, then functions are </i></tt>//<tt CLASS=replaceable><i> compared by value, otherwise they are compared by reference.</i></tt>F = new Function("return 1;"); //<tt CLASS=replaceable><i> F and G are Function objects that contain</i></tt>G = new Function("return 1;"); //<tt CLASS=replaceable><i>    unnamed function values.</i></tt>f = F.valueOf();               //<tt CLASS=replaceable><i> convert F and G to the actual function values</i></tt>g = G.valueOf();if (f == g)                    //<tt CLASS=replaceable><i> now compare them</i></tt>    document.write("Functions compared by value");</PRE></DIV></DIV><P CLASS=para>	The results of this experiment are surprising. Strings are	compared by value, and functions are compared by reference. The	fact that strings are compared by value may be counter-intuitive	to C, C++, and Java programmers--in those languages, strings are	reference types, and you must use a special function or method	when you want to compare them by value. JavaScript, however, is	a higher-level language, and recognizes that when you compare	strings you almost always want to compare them by value. Thus,	as a special case, it compares strings by value even though they	are (presumably) copied and passed by reference.      <P CLASS=para>	The fact that functions are compared by reference is quite	reasonable. Since it doesn't make sense to write two separate	functions that do exactly the same thing, we never really want	to compare functions by value. Comparing functions by reference	is far more useful.      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch09-SECT2-AUTOID.14">Copying Objects with the assign() Method</A></h3><P CLASS=para>	We've seen above that objects are copied by reference. There is	one exception to this rule, however. If the left-hand side of an	assignment expression refers to an object, and that object has	an <tt CLASS=literal>assign()</tt> method, then instead of	copying a reference to the right-hand value into the left-hand	variable, as usual, the <tt CLASS=literal>assign()</tt>	method is called instead, with the value of the right-hand side	as its argument. You can define this method so that an	assignment performs any sort of action you desire. <A HREF="ch09_03.htm#JSCRIPT-CH-FURTHER-EX-ASSIGN">Example 9-5</A> shows how you can use	this feature to override the "copy-by-reference" nature of an	object. The <tt CLASS=literal>assign()</tt> method is also covered	in detail in <A HREF="ch07_01.htm">Chapter 7, <i>Objects</i></A>.[2]      <blockquote class=footnote><P CLASS=para>[2]               Note that the <tt CLASS=literal>assign()</tt> method is not              supported in Internet Explorer 3.0, and may not be              supported in future versions of Navigator.            </blockquote><DIV CLASS=example><h4 CLASS=example><A CLASS="TITLE" NAME="JSCRIPT-CH-FURTHER-EX-ASSIGN">Example 9-5: The assign() Method</A></h4><DIV CLASS=programlisting><P><PRE>//<tt CLASS=replaceable><i> This is the function we'll use for the assign() method.</i></tt>function myassign(rhs) {    var i;    for (i in rhs) this[i] = rhs[i];}myobject = new Object;       //<tt CLASS=replaceable><i> create an object</i></tt>myobject.assign = myassign;  //<tt CLASS=replaceable><i> set the custom assign() method on it</i></tt>//<tt CLASS=replaceable><i> Now, when an object is assigned to "myobject", the properties</i></tt>//<tt CLASS=replaceable><i> of that object are copied, rather than overwriting the "myobject"</i></tt>//<tt CLASS=replaceable><i> variable with a reference to the other object.</i></tt>myobject = my_other_object;      //<tt CLASS=replaceable><i> After the above assignment, myobject and my_other_object still refer</i></tt>//<tt CLASS=replaceable><i> to two separate objects, but myobject has a copy of each of the </i></tt>//<tt CLASS=replaceable><i> properties of my_other_object.</i></tt></PRE></DIV></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch09-SECT2-AUTOID.15">By Value vs. By Reference: Summary</A></h3><P CLASS=para>	The sections above have been quite detailed and perhaps	somewhat confusing. <A HREF="ch09_03.htm#JSCRIPT-CH-FURTHER-TAB-SUMMARY">Table 9.3</A> summarizes these	sections.      <P><DIV CLASS=table><TABLE><CAPTION><A CLASS="TITLE" NAME="JSCRIPT-CH-FURTHER-TAB-SUMMARY">Table 9-3: Data Type Manipulation in JavaScript</A></CAPTION><TR CLASS=row><TH ALIGN="left">&nbsp;</TH><TH ALIGN="left">Copied</TH><TH ALIGN="left">Passed</TH><TH ALIGN="left">Compared</TH></TR><TR CLASS=row><TD ALIGN="left"><b>Number</b></TD><TD ALIGN="left">By value</TD><TD ALIGN="left">By value</TD><TD ALIGN="left">By value</TD></TR><TR CLASS=row><TD ALIGN="left"><b>Boolean</b></TD><TD ALIGN="left">By value</TD><TD ALIGN="left">By value</TD><TD ALIGN="left">By value</TD></TR><TR CLASS=row><TD ALIGN="left"><b>Object</b></TD><TD ALIGN="left">By reference (or <tt CLASS=literal>assign()</tt> method)</TD><TD ALIGN="left">By reference</TD><TD ALIGN="left">By reference</TD></TR><TR CLASS=row><TD ALIGN="left"><b>Array</b></TD><TD ALIGN="left">By reference (or <tt CLASS=literal>assign()</tt> method)</TD><TD ALIGN="left">By reference</TD><TD ALIGN="left">By reference</TD></TR><TR CLASS=row><TD ALIGN="left"><b>String</b></TD><TD ALIGN="left">Immutable (by reference)</TD><TD ALIGN="left">Immutable (by reference)</TD><TD ALIGN="left">By value</TD></TR><TR CLASS=row><TD ALIGN="left"><b>Function</b></TD><TD ALIGN="left">Immutable (by reference)</TD><TD ALIGN="left">Immutable (by reference)</TD><TD ALIGN="left">By reference</TD></TR></TABLE><P></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch09_02.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch10_01.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Explicit Data Type Conversions</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Client-Side Program Structure</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>