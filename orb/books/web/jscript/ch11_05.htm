<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 11] 11.5 The JavaScript Name Space</TITLE><META NAME="author" CONTENT="David Flanagan"><META NAME="date" CONTENT="Wed Apr 23 18:14:46 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="JavaScript"><META NAME="title" CONTENT="JavaScript: The Definitive Guide"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="Javascript: The Definitive Guide"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch11_04.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 11</b></td><td width=172 align=right valign=top><A HREF="ch11_06.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="ch11-SECT1-AUTOID.5">11.5 The JavaScript Name Space</A></h2><P CLASS=para><A NAME="CH10.SPACE1"></A><A NAME="CH10.SPACE2"></A>      We've said that the Window object is really the most central one      in client-side JavaScript. This is because it is the object that      defines the <I CLASS=emphasis>name space</I> of a program. We saw      earlier that every JavaScript expression implicitly refers to      the current window.  This includes expressions as simple as      <tt CLASS=literal>window</tt>, which is a reference to a property      within the current window that happens to refer to that window      itself.    <P CLASS=para>      But if every expression refers to the current window, then so does      code like this:      <DIV CLASS=programlisting><P><PRE>var i;  //<tt CLASS=replaceable><i> declare a variable i</i></tt>i = 0;  //<tt CLASS=replaceable><i> assign the variable a value</i></tt></PRE></DIV>      The assignment <tt CLASS=literal>i = 0</tt> is actually the same as writing      <DIV CLASS=programlisting><P><PRE>window.i = 0;</PRE></DIV>    <P CLASS=para>      This is an important point to understand about client-side      JavaScript: <I CLASS=emphasis>variables are nothing more than properties      of the current window.</I> (This is not true for local      variables declared within a function, however.)    <P CLASS=para>      One implication of the fact that variables are properties of the      current Window object is that two variables with the same name may      be declared in different windows or different frames, and they      will not overwrite or conflict with each other.    <P CLASS=para>      Another implication is that JavaScript code running in one window      or frame may read and write variables declared by code in another      window or frame, as long as the first window knows how to refer to      the second window.[2]      So, if a top-level window has two frames, and code in the first      frame does the following:      <DIV CLASS=programlisting><P><PRE>parent.frames[1].i = 3;</PRE></DIV>      it is equivalent to code in the second frame doing the following:      <DIV CLASS=programlisting><P><PRE>i = 3;</PRE></DIV>    <blockquote class=footnote><P CLASS=para>[2] 	  See <A HREF="ch20_01.htm">Chapter 20, <i>JavaScript Security</i></A>, however, for a	  discussion of a "security hobble" that prevents scripts from	  one web server from reading values from windows that contain	  data from other web servers.	</blockquote><P CLASS=para>      The final implication of the equivalence between variables and      window properties is that there is no such thing as a "global      variable" in client-side JavaScript--i.e., there are no      user-created variables that are global to Navigator as a whole,      across all windows and frames. Each variable is defined only      within one window.     <P CLASS=para>      Recall that the <tt CLASS=literal>function</tt> keyword that defines      functions declares a variable just like the <tt CLASS=literal>var</tt>      keyword does. Since functions are referred to by variables, they      to are defined only within the window in which they are declared.      That is, if you define a function in one window, you cannot use it      in another, unless you explicitly assign the function to a      variable in the other window.     <P CLASS=para>      Remember that constructors are also functions, so when you define      a class of objects with a constructor function and an associated      prototype object, that class is only defined for a single window.      (See <A HREF="ch07_01.htm">Chapter 7, <i>Objects</i></A>, for details on      constructor functions and prototype objects.)  This is true of      predefined constructors as well as constructors you define      yourself. The String constructor is available in all windows, but      that is because all windows automatically are given a property      that refers to this predefined constructor function. Just as      each window has its own separate reference to the constructor,      each window has a separate copy of the prototype object for a      constructor. So if you write a new method for manipulating      JavaScript strings, and make it a method of the String class by      assigning it to the <tt CLASS=literal>String.prototype</tt> object in      the current window, then all strings in that window will be able      to use the new method. But the new method will not be accessible      to strings defined in other windows.    <P CLASS=para>      Bear in mind that this discussion of variables and Window object      properties does not apply to variables declared within functions.      These "local" variables exist only within the function body and      are not accessible outside of the function. Also, note that there      is one difference between variables and properties of the current      window. This difference is revealed in the behavior of the      <tt CLASS=literal>for/in</tt> loop. Window properties that were      created by variable declarations are not returned by the      <tt CLASS=literal>for/in</tt> loop, while "regular" properties of the      Window are. See <A HREF="ch05_01.htm">Chapter 5, <i>Statements</i></A>, for      details.    <DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch11-SECT2-AUTOID.2">Variable Scope</A></h3><P CLASS=para><A NAME="CH11.SCOPE1"></A><A NAME="CH11.SCOPE2"></A>	We saw above that top-level variables are implemented as	properties of the current window or frame object. In <A HREF="ch06_01.htm">Chapter 6, <i>Functions</i></A>, we saw that local variables	in a function are implemented as transient properties of the	function object itself. From these facts, we can begin to	understand variable scoping in JavaScript; we can begin to see	how variable names are looked up.      <P CLASS=para>	Suppose a function <tt CLASS=literal>f</tt> uses the identifier	<tt CLASS=literal>x</tt> in an expression. In order to evaluate the	expression, JavaScript must look up the value of this	identifier. To do so, it first checks if <tt CLASS=literal>f</tt>	itself has a property named <tt CLASS=literal>x</tt>. If so, the	value of that property is used; it is an argument, local	variable, or static variable assigned to the function. If	<tt CLASS=literal>f</tt> does not have a property named	<tt CLASS=literal>x</tt>, then JavaScript next checks to see if the	window that <tt CLASS=literal>f</tt> is defined in has a property	named <tt CLASS=literal>x</tt>, and, if so, it uses the value of	that property. In this case <tt CLASS=literal>x</tt> would be a	top-level or "global" (to that window) variable. Note that	JavaScript looks up <tt CLASS=literal>x</tt> in the window in which	<tt CLASS=literal>f</tt> was defined, which may not be the same as	the window that is executing the script that called	<tt CLASS=literal>f</tt>. This is a subtle but important	difference that can arise in some circumstances.      <P CLASS=para>	A similar process occurs if the function <tt CLASS=literal>f</tt>	uses <tt CLASS=literal>document.title</tt> in an expression. In	order to evaluate <tt CLASS=literal>document.title</tt>, JavaScript	must first evaluate <tt CLASS=literal>document</tt>. It does this	in the same way it evaluated <tt CLASS=literal>x</tt>. First it	sees if <tt CLASS=literal>f</tt> has a property named	<tt CLASS=literal>document</tt>. If not, it checks whether its	Window object has such a property. Once it has obtained a value	for <tt CLASS=literal>document</tt>, it proceeds to look up	<tt CLASS=literal>title</tt> as a property that object--it does not	check the properties of the function or window, in this case, of	course. In this example, the code probably refers to the	<tt CLASS=literal>document</tt> property of the Window object, and	if the function inadvertently defined a local variable named	<tt CLASS=literal>document</tt>, the	<tt CLASS=literal>document.title</tt> expression might well	be evaluated incorrectly.      <P CLASS=para>	What we learn from these examples is that identifiers are	evaluated in two scopes: the current function, and the window in	which the function is defined. In <A HREF="ch05_01.htm">Chapter 5, <i>Statements</i></A> we saw that the	<tt CLASS=literal>with</tt> statement can be used to add additional	scopes. When an identifier is evaluated, it is first looked up	in the scopes specified by any containing	<tt CLASS=literal>with</tt> statements. For example, if a top-level	script runs the following code:	<DIV CLASS=programlisting><P><PRE>with(o) {  document.write(x);}</PRE></DIV>	Then the identifier <tt CLASS=literal>x</tt> is evaluated first in	the scope of the object <tt CLASS=literal>o</tt>. If no definition	is found in that object's properties, then <tt CLASS=literal>x</tt>	is evaluated in the context of the current window. If the same	code occurred within a function <tt CLASS=literal>f</tt> then	<tt CLASS=literal>x</tt> would be looked up first as a property of	<tt CLASS=literal>o</tt>, then as a property of <tt CLASS=literal>f</tt>	and finally as a property of the current window.       <P CLASS=para>	Recall that <tt CLASS=literal>with</tt> statements can be nested	arbitrarily, creating a variable "scope" of any depth.	One interesting way to use <tt CLASS=literal>with</tt> is with a	window reference:	<DIV CLASS=programlisting><P><PRE>with(parent.frames[1]) {   ...}</PRE></DIV>	This technique allows code in one window to easily read	properties of another window. Another technique that is	sometimes of interest is to place the entire body of a	function within the block of a <tt CLASS=literal>with(this)</tt>	statement.  What this does is create a method that evaluates	identifiers by looking them up first as properties of the	object that it is a method of. Note, however, that such a	method would find properties of its object	<I CLASS=emphasis>before</I> it found its own local variables	and arguments, which is unusual behavior!      <DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="ch11-SECT3-AUTOID.1">Scope of event handlers</A></h4><P CLASS=para>	  Event handlers are scoped differently than regular functions	  are. Consider the <tt CLASS=literal>onChange()</tt> event	  handler of a text input field named <tt CLASS=literal>t</tt>	  within an HTML form named <tt CLASS=literal>f</tt>. If this	  event handler wants to evaluate the identifier	  <tt CLASS=literal>x</tt>, it first uses the scope of any	  <tt CLASS=literal>with</tt> statements of course, and then looks	  at local variables and arguments, as we saw above. If the	  event handler were a standalone function, it would look in	  the scope of the containing window next and stop there. But	  because this function is an event handler, it next looks in	  the scope of the text input element <tt CLASS=literal>t</tt>. If	  the property <tt CLASS=literal>x</tt> is not defined there, it	  looks at the properties of the form object	  <tt CLASS=literal>f</tt>. If <tt CLASS=literal>f</tt> does not have	  a property named <tt CLASS=literal>x</tt>, JavaScript next	  checks to see if the Document object that contains the form	  has a definition of this property. Finally, if no definition	  of <tt CLASS=literal>x</tt> is found in any of these objects,	  the containing window is checked.	<P CLASS=para>	  If all identifiers had unique names, scope would never	  matter.  But identifiers are not always unique, and we have	  to pay attention to scope. One important case is the	  <tt CLASS=literal>Window.open()</tt> method and the	  <tt CLASS=literal>Document.open()</tt> method. If a top-level	  script of a regular function calls	  <tt CLASS=literal>open()</tt>, JavaScript's scoping rules will	  find the <tt CLASS=literal>open</tt> property of the Window	  object and use this method. On the other hand, if an event	  handler calls <tt CLASS=literal>open()</tt>, the scoping rules	  are different, and JavaScript will find the definition of	  <tt CLASS=literal>open</tt> in the Document object before it	  finds it in the Window object. The same code may work in	  different ways depending on its context. The moral of this	  particular example is to never use the	  <tt CLASS=literal>open()</tt> method without explicitly	  specifying whether you mean	  <tt CLASS=literal>document.open()</tt> or	  <tt CLASS=literal>window.open()</tt>. Be similarly cautious when	  using <tt CLASS=literal>location</tt>; it, too, is a property of	  both the Window and Document objects.	<P CLASS=para>	  Finally, note that if an event handler doesn't call	  <tt CLASS=literal>open()</tt> directly but instead calls a	  function that calls <tt CLASS=literal>open()</tt>, the function	  does <I CLASS=emphasis>not</I> inherit the scope of the	  event handler that invoked it. The function's scope would be	  the function itself, and then the window that contains it, so	  in this case, the <tt CLASS=literal>open()</tt> method would be	  interpreted as the <tt CLASS=literal>Window.open()</tt> method, not	  <tt CLASS=literal>Document.open()</tt>.	</DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch11_04.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch11_06.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Window and Frame Names</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Window and Variable Lifetime</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>