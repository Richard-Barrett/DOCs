<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 19] 19.2 LiveConnect Data Types</TITLE><META NAME="author" CONTENT="David Flanagan"><META NAME="date" CONTENT="Wed Apr 23 18:24:52 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="JavaScript"><META NAME="title" CONTENT="JavaScript: The Definitive Guide"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif" ALT="Javascript: The Definitive Guide"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch19_01.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 19</b></td><td width=172 align=right valign=top><A HREF="ch19_03.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="ch19-SECT1-AUTOID.2">19.2 LiveConnect Data Types</A></h2><P CLASS=para><A NAME="CH19.DATATYPE"></A>      In order to understand how LiveConnect does its amazing job of      connecting JavaScript to Java, you've got to understand the five      JavaScript data types that LiveConnect uses. (There is also a      Java data type that LiveConnect uses to connect Java back to      JavaScript; we'll learn about that Java class later in this      chapter.)  The following subsections explain these JavaScript      data types. Once we've explored these LiveConnect fundamentals,      the following sections will show how we can actually use      LiveConnect to connect JavaScript to Java.    <DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch19-SECT2-AUTOID.1">The JavaPackage Object</A></h3><P CLASS=para><A NAME="CH19.PACK1"></A><A NAME="CH19.PACK2"></A>	The JavaScript JavaPackage object represents a Java package,	which is a collection of related Java classes. The properties	of a JavaPackage are the classes that the package contains	(classes are represented by the JavaClass object, which we'll	see later), as well as any other packages that the package	contains. A restriction on the JavaPackage object is that you	cannot use a JavaScript <tt CLASS=literal>for/in</tt> loop to obtain	a complete list of all packages and classes that a JavaPackage	contains. The reason for this restriction will become clear in	a moment.      <P CLASS=para>	All JavaPackage objects are contained within a parent	JavaPackage, and the Window property named	<tt CLASS=literal>Packages</tt> is a top-level JavaPackage that	serves as the root of this package hierarchy. It has	<tt CLASS=literal>java</tt>, <tt CLASS=literal>sun</tt>, and	<tt CLASS=literal>netscape</tt> properties, which are JavaPackage	objects that represent the various hierarchies of Java classes	that are included with Navigator. For example, the JavaPackage	<tt CLASS=literal>Packages</tt> contains the JavaPackage	<tt CLASS=literal>Packages.java</tt>, which contains the JavaPackage	<tt CLASS=literal>Packages.java.awt</tt>. For convenience, every	Window object has <tt CLASS=literal>java</tt>,	<tt CLASS=literal>sun</tt>, and <tt CLASS=literal>netscape</tt>	properties which are shortcuts to	<tt CLASS=literal>Packages.java</tt>,	<tt CLASS=literal>Packages.sun</tt>, and	<tt CLASS=literal>Packages.netscape</tt>. Thus, instead of typing	<tt CLASS=literal>Packages.java.awt</tt>, you can simply use	<tt CLASS=literal>java.awt</tt>.      <P CLASS=para>	To continue with the example, <tt CLASS=literal>java.awt</tt> is a	JavaPackage object that contains JavaClass objects like	<tt CLASS=literal>java.awt.Button</tt>, which represents the	<I CLASS=emphasis>java.awt.Button</I> class. But it also	contains yet another JavaPackage object,	<tt CLASS=literal>java.awt.image</tt> which represents the	<I CLASS=emphasis>java.awt.image</I> package in Java.      <P CLASS=para>	As you can see, the property naming scheme for the JavaPackage	hierarchy mirrors the naming scheme for Java packages. Note	that there is one big difference between the JavaPackage object	and actual Java packages. Packages in Java are collections of	classes, not collections of other packages. That is,	<I CLASS=emphasis>java.lang</I> is the name of a Java package,	but <I CLASS=emphasis>java</I> is not. So the JavaPackage object	named <tt CLASS=literal>java</tt> does not actually represent a	package in Java, but is simply a convenient placeholder in the	package hierarchy for other JavaPackage objects that do	represent real Java packages.      <P CLASS=para>	On many systems, Java classes are installed in files in a	directory hierarchy that corresponds to the package name. For	example, the <I CLASS=emphasis>java.lang.String</I> class is	stored in the file <i CLASS=filename>java/lang/String.class</i> in	my Java implementation from Sun. In other implementations,	notably that from Netscape, the class files are actually stored	in a large uncompressed zip file. The directory hierarchy is	still there, encoded in the file; it is just not visible on the	surface. Therefore, instead of thinking of the JavaPackage	object as representing a Java package, you may find it clearer	to consider it as representing a directory in the Java class	hierarchy.      <P CLASS=para>	As we've said above, a JavaPackage object contains properties	for each of the packages and classes it contains. If you think	of a JavaPackage as representing a directory in the Java class	directory hierarchy, then the properties of the JavaPackage	are the contents of the directory. Each subdirectory of the	directory becomes a JavaPackage property, with the package	name matching the subdirectory name. Each file in the	directory becomes a JavaClass property, with the property name	matching the file name, after the <i CLASS=filename>.class</i>	extension is stripped off. When viewed in this way, it is easy	to understand why the JavaPackage object does not allow the	<tt CLASS=literal>for/in</tt> loop to list all of its	properties--those properties actually correspond to directory	contents, and they are not actually looked up and created	until they are first used. Thus, a <tt CLASS=literal>for/in</tt>	loop will only find those properties of a JavaPackage object	that have already been used at least once by the program.      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch19-SECT2-AUTOID.2">The JavaClass Object</A></h3><P CLASS=para>	The JavaClass object is a JavaScript representation of a Java	class. A JavaClass object does not have any properties of its	own--all of its properties represent (and have the same name as)	the public static fields and methods of the represented Java	class. These public static fields and	methods are sometimes called <I CLASS=emphasis>class fields</I>	and <I CLASS=emphasis>class methods</I> to indicate that they are	associated with an object class rather than an object instance.	Unlike the JavaPackage object, the JavaClass object does allow	the use of the <tt CLASS=literal>for/in</tt> loop to enumerate its	properties. Note that the JavaClass object does not have	properties representing the <I CLASS=emphasis>instance</I>	fields and methods of a Java class--individual instances of	a Java class are represented by the JavaObject object, which	will be documented below.      <P CLASS=para>	As we saw above, JavaClass objects are contained in	JavaPackage objects. For example, <tt CLASS=literal>java.lang</tt>	is a JavaPackage that contains a <tt CLASS=literal>System</tt>	property.  Thus <tt CLASS=literal>java.lang.System</tt> is a	JavaClass object, representing the Java class	<I CLASS=emphasis>java.lang.System</I>. This JavaClass object,	in turn, has properties such as <tt CLASS=literal>out</tt> and	<tt CLASS=literal>in</tt> that represent static fields of the	<I CLASS=emphasis>java.lang.System</I> class. You can use	JavaScript to refer to any of the standard Java system classes	in this same way. The <I CLASS=emphasis>java.lang.Double</I>	class is named <tt CLASS=literal>java.lang.Double</tt> (or	<tt CLASS=literal>Packages. java.lang.Double</tt>) in	JavaScript, for example, and the	<I CLASS=emphasis>java.awt.Button</I> class is	<tt CLASS=literal>java.awt.Button</tt>.      <P CLASS=para>	Another way to obtain a JavaClass object in JavaScript is to use	the <tt CLASS=literal>getClass()</tt> function. Given any	JavaObject, you can obtain a JavaClass that represents the class	of that Java object by passing the JavaObject to	<tt CLASS=literal>getClass()</tt>.      <P CLASS=para>	Once you have a JavaClass object, there are several things you	can do with it. The JavaClass object implements the LiveConnect	functionality that allows JavaScript programs to read and write	the public static fields of Java classes, and to invoke the	public static methods of Java classes. For example,	<tt CLASS=literal>java.lang.System</tt> is a JavaClass. We can read	the value of a static field of this class like this:	<DIV CLASS=programlisting><P><PRE>var java_console = java.lang.System.out;</PRE></DIV>	Similarly, we might invoke a static method of this class with a	line like this one:	<DIV CLASS=programlisting><P><PRE>var java_version = java.lang.System.getProperty("java.version");</PRE></DIV>	Recall that Java is a typed language--all fields and method	arguments have types. If you attempt to set a field or pass	an argument of the wrong type, you will cause a JavaScript	error.      <P CLASS=para>	There is one more important feature of the JavaClass object.	You can use it with the JavaScript <tt CLASS=literal>new</tt>	operator to create new instances of Java classes--i.e., to create	JavaObject objects. The syntax for doing so is just as it is in	JavaScript (and just as it is in Java):	<DIV CLASS=programlisting><P><PRE>var d = new java.lang.Double(1.23);</PRE></DIV>      <P CLASS=para>	Finally, having created a JavaObject in this way, we can return	to the <tt CLASS=literal>getClass()</tt> function and show an	example of its use:	<DIV CLASS=programlisting><P><PRE>var d = new java.lang.Double(1.23);   //<tt CLASS=replaceable><i> Create a JavaObject.</i></tt>var d_class = getClass(d);            //<tt CLASS=replaceable><i> Obtain the JavaClass of the JavaObject.</i></tt>if (d_class == java.lang.Double) ...; //<tt CLASS=replaceable><i> This comparison will be true.</i></tt></PRE></DIV>	When working with standard system classes like this, you can	usually just use the name of the system class directly rather	than calling <tt CLASS=literal>getClass()</tt>. The function is	more useful to obtain the class of other non-system objects,	such as applet instances.      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch19-SECT2-AUTOID.3">The JavaObject Object</A></h3><P CLASS=para>	The JavaObject object is a JavaScript object that represents a	Java object (that is, it represents an instance of a Java	class). The JavaObject object is, in many ways, analogous to	the JavaClass object. Like JavaClass, a JavaObject object has	no properties of its own--all of its properties represent (and	have the same names as) the public instance fields and public	instance methods of the Java object it represents. Like	JavaClass, you can use a JavaScript <tt CLASS=literal>for/in</tt>	loop to enumerate all properties of a JavaObject object. The	JavaObject object implements the LiveConnect functionality that	allows us to read and write the public instance fields and	invoke the public methods of a Java object.      <P CLASS=para>	For example, if <tt CLASS=literal>d</tt> is a JavaObject that, as	above, represents an instance of the	<I CLASS=emphasis>java.lang.Double</I> class, then we can invoke	a method of that Java object with JavaScript code like this:	<DIV CLASS=programlisting><P><PRE>n = d.doubleValue();</PRE></DIV>	Similarly, we saw above that the	<I CLASS=emphasis>java.lang.System</I> class has a static field	<I CLASS=emphasis>out</I>. This field refers to a Java object of	class <I CLASS=emphasis>java.io.PrintStream</I>. In JavaScript,	we can refer to the corresponding JavaObject as:	<DIV CLASS=programlisting><P><PRE>java.lang.System.out</PRE></DIV>	And we can invoke a method of this object like this:[1]	<DIV CLASS=programlisting><P><PRE>java.lang.System.out.println("Hello world!");</PRE></DIV>      <blockquote class=footnote><P CLASS=para>[1] 	    The output of this line of code doesn't appear in the web	    browser itself, but in the "Java Console." Select <b>Show Java Console</b> in the <b>Options</b> menu to make the console	    visible.	  </blockquote><P CLASS=para>	The JavaObject object also allows us to read and write public	instance fields of the Java object it represents. Neither the	<I CLASS=emphasis>java.lang.Double</I> class or the	<I CLASS=emphasis>java.io.PrintStream</I> class used in the	examples above has any public instance fields, however. But	suppose we use JavaScript to create an instance of the	<I CLASS=emphasis>java.awt.Rectangle</I> class:	<DIV CLASS=programlisting><P><PRE>r = new java.awt.Rectangle();</PRE></DIV>	Then we can read and write its public instance fields with	JavaScript code like the following:	<DIV CLASS=programlisting><P><PRE>r.x = r.y = 0;r.width = 4;r.height = 5;var perimeter = 2*r.width + 2*r.height;</PRE></DIV>	The beauty of LiveConnect is that it allows a Java object,	<tt CLASS=literal>r</tt>, to be used just as if it were a JavaScript	object. Some caution is required, however: <tt CLASS=literal>r</tt>	is a JavaObject, and does not behave identically to regular	JavaScript objects. The differences will be detailed later.	Also, remember that unlike JavaScript, the fields of Java	objects and the arguments of its methods are typed. If you do	not specify JavaScript values of the correct types, you will	cause a JavaScript error.      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch19-SECT2-AUTOID.4">The JavaMethod Object</A></h3><P CLASS=para>	The JavaMethod object represents a Java method. In the sections	above, we've said that the JavaClass and JavaObject objects	provide the LiveConnect functionality that allows JavaScript	programs to invoke public class methods and public instance	methods. In fact, that claim was an over-simplification. The	JavaClass and JavaObject objects contain properties that have	the same names as the class and instance fields and the class	and instance methods of a Java class or object. The properties	that represent fields allow us to read and write class and	instance fields. The properties that represent methods, on the	other hand, simply contain JavaMethod objects, and it is these	JavaMethod objects that actually implement the LiveConnect	functionality that lets us invoke Java class and instance	methods.      <P CLASS=para>	So, when we write lines of JavaScript code like this one:	<DIV CLASS=programlisting><P><PRE>java.lang.System.out.println("Hello world!");</PRE></DIV>	What is actually happening can be made clearer with code like this:	<DIV CLASS=programlisting><P><PRE>var println_method = java.lang.System.out.println;println_method("Hello world!");</PRE></DIV>      <P CLASS=para>	The LiveConnect functionality provided by the JavaMethod object	is substantial. Consider the following JavaScript code:	<DIV CLASS=programlisting><P><PRE>var r = java.awt.Rectangle(0, 0, 10, 10);   //<tt CLASS=replaceable><i> a 10x10 square at (0,0)</i></tt>var i = r.inside(5,5);                      //<tt CLASS=replaceable><i> is the point (5,5) inside?</i></tt></PRE></DIV>	In order to run this code, LiveConnect must convert the two	JavaScript numeric arguments to the Java <tt CLASS=literal>int</tt>	type. Then it must invoke the Java method, passing these	converted values. Finally, it must take the return value, a	Java <tt CLASS=literal>boolean</tt>, and convert it to a JavaScript	Boolean value and return it. This conversion is completely	transparent to the JavaScript programmer, which is what makes	LiveConnect so powerful.      <P CLASS=para>	JavaMethod objects behave much like regular JavaScript	functions, with a few important differences. Java methods,	unlike JavaScript functions, expect a fixed number of arguments	of a fixed type. If you pass the wrong number or wrong type of	arguments, you will cause a JavaScript error. There is a more	subtle difference between Java methods and JavaScript functions	as well. When a JavaScript function is assigned to an object	property, it becomes a method, and is passed a reference to that	object as the value of the <tt CLASS=literal>this</tt> keyword.	Thus, a JavaScript function may behave differently depending	upon which object it is assigned as a property of. This is not	true of JavaMethod object--they are invoked in the context of a	Java object, and they carry that context with them. A	JavaMethod will behave the same regardless of what JavaScript	object it is a property of.      </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="ch19-SECT2-AUTOID.5">The JavaArray Object</A></h3><P CLASS=para>	The final LiveConnect datatype for JavaScript is the JavaArray	object. As you might expect by now, this object represents a	Java array, and provides the LiveConnect functionality that	allows JavaScript to read the elements of a Java array. Like	JavaScript arrays (and like Java arrays), a JavaArray object has	a <tt CLASS=literal>length</tt> property that specifies the number	of elements it contains. The elements of a JavaArray object are	read with the standard JavaScript <tt CLASS=literal>[]</tt> array	index operator. They can also be enumerated with the	<tt CLASS=literal>for/in</tt> loop. You can also use JavaArray	objects to access multidimensional arrays (actually	arrays of arrays) just as you would in JavaScript or in Java.      <P CLASS=para>	For example, suppose we create an instance of the	<I CLASS=emphasis>java.awt.Polygon</I> class:	<DIV CLASS=programlisting><P><PRE>p = new java.awt.Polygon();</PRE></DIV>	Then the JavaObject <tt CLASS=literal>p</tt> has properties	<tt CLASS=literal>xpoints</tt> and <tt CLASS=literal>ypoints</tt> which	are JavaArray objects representing Java arrays of integers. (We	know the names and types of these properties because we looked	up the documentation for <I CLASS=emphasis>java.awt.Polygon</I>	in a Java reference manual.)  We can use these JavaArray objects	to them to randomly initialize the Java polygon with code like	this:	<DIV CLASS=programlisting><P><PRE>for(int i = 0; i &lt; p.xpoints.length; i++)    p.xpoints[i] = Math.round(Math.random()*100);for(int i = 0; i &lt; p.ypoints.length; i++)    p.ypoints[i] = Math.round(Math.random()*100);</PRE></DIV>      </DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch19_01.htm"><IMG SRC="gifs/txtpreva.gif" ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch19_03.htm"><IMG SRC="gifs/txtnexta.gif" ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Overview of LiveConnect</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>LiveConnect Data Conversion</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>