<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Preface 0] Preface</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 12:58:19 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top>&nbsp;</td><td width=171 align=center valign=top><b>Preface</b></td><td width=172 align=right valign=top><A HREF="ch00_02.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><H1 CLASS=preface><A CLASS="TITLE" NAME="PERL2-PREFACE">Preface</A></H1><DIV CLASS=htmltoc><p><b>Contents:</b><br>Perl in a Nutshell<br><A HREF="ch00_02.htm">The Rest of This Book</A><BR><A HREF="ch00_03.htm">Additional Resources</A><BR><A HREF="ch00_04.htm">How to Get Perl</A><BR><A HREF="ch00_05.htm">Conventions Used in This Book</A><BR><A HREF="ch00_06.htm">Acknowledgments</A><BR><A HREF="ch00_07.htm">We'd Like to Hear from You</A><BR></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-PREFACE-SECT-1">0.1 Perl in a Nutshell</A></h2><P CLASS=para>Perl is a language for getting your job done.<P CLASS=para>Of course, if your job is programming, you can get your job done withany "complete" computer language, theoretically speaking.  But we knowfrom experience that computer languages differ not so much in what theymake <I CLASS=emphasis>possible</I>, but in what they make <I CLASS=emphasis>easy</I>.  At one extreme,the so-called "fourth generation languages" make it easy to do some things,but nearly impossible to do other things.  At the other extreme, certainwell known, "industrial-strength" languages make it equally difficult todo almost everything.<P CLASS=para>Perl is different.  In a nutshell, Perl is designed to make the easyjobs easy, without making the hard jobs impossible.<P CLASS=para>And what are these "easy jobs" that ought to be easy?  The ones you doevery day, of course.  You want a language that makes it easy tomanipulate numbers and text, files and directories, computers andnetworks, and especially programs.  It should be easy to run externalprograms and scan their output for interesting tidbits.  It should beeasy to send those same tidbits off to other programs that can dospecial things with them.  It should be easy to develop, modify, anddebug your own programs too.  And, of course, it should be easy to compileand run your programs, and do it portably, on any modern operatingsystem.<P CLASS=para>Perl does all that, and a whole lot more.<P CLASS=para>Initially designed as a glue language for the UNIX operating system (orany of its myriad variants), Perl also runs on numerous other systems,including MS-DOS, VMS, OS/2, Plan 9, Macintosh, and any variety ofWindows you care to mention.  It is one of the most portable programminglanguages available today.  To program C portably, you have to put inall those strange <tt CLASS=literal>#ifdef</tt> markings for different operatingsystems.  And to program a shell portably, you have to remember thesyntax for each operating system's version of each command, and somehowfind the least common denominator that (you hope) works everywhere.Perl happily avoids both of these problems, while retaining many of thebenefits of both C and shell programming, with some additional magic ofits own.  Much of the explosive growth of Perl has been fueled by thehankerings of <I CLASS=emphasis>former</I> UNIX programmers who wanted to take alongwith them as much of the "old country" as they could.  For them, Perl isthe portable distillation of UNIX culture, an oasis in the wilderness of"can't get there from here".  On the other hand, it works in the otherdirection, too: Web programmers are often delighted to discover that theycan take their scripts from a Windows machine and run them unchanged ontheir UNIX servers.<P CLASS=para>Although Perl is especially popular with systems programmers and Webdevelopers, it also appeals to a much broader audience.  The hithertowell-kept secret is now out:  Perl is no longer just for textprocessing.  It has grown into a sophisticated, general-purposeprogramming language with a rich software development environmentcomplete with debuggers, profilers, cross-referencers, compilers,interpreters, libraries, syntax-directed editors, and all the rest of the trappingsof a "real" programming language.  (But don't let that scare you:nothing requires you to go tinkering under the hood.)  Perl is beingused daily in every imaginable field, from aerospace engineering to molecularbiology, from computer-assisted design/computer-assisted manufacturing(CAD/CAM) to document processing, from database manipulationto client-server network management.  Perl is used by people who aredesperate to analyze or convert lots of data quickly, whetheryou're talking DNA sequences, Web pages, or pork belly futures.  Indeed,one of the jokes in the Perl community is that the next big stock marketcrash will probably be triggered by a bug in a Perl script.  (On thebrighter side, any unemployed stock analysts will still have amarketable skill, so to speak.)<P CLASS=para>There are many reasons for the success of Perl.  It certainly helpsthat Perl is freely available, and freely redistributable.  Butthat's not enough to explain the Perl phenomenon, since many freewarepackages fail to thrive.  Perl is not just free; it's also fun.  Peoplefeel like they can be creative in Perl, because they have freedom ofexpression: they get to choose what to optimize for, whether that'scomputer speed or programmer speed, verbosity or conciseness,readability or maintainability or reusability or portability orlearnability or teachability.  You can even optimize for obscurity, ifyou're entering an Obfuscated Perl contest.<P CLASS=para>Perl can give you all these degrees of freedom because it's essentiallya language with a split personality.  It's both a very simple languageand a very rich language.  It has taken good ideas from nearlyeverywhere, and installed them into an easy-to-use mental framework.  Tothose who merely like it, Perl is the <I CLASS=emphasis>Practical Extraction and ReportLanguage</I>.  To those who love it, Perl is the <I CLASS=emphasis>PathologicallyEclectic Rubbish Lister</I>.  And to the minimalists in the crowd, Perlseems like a pointless exercise in redundancy.  But that's okay.  Theworld needs a few reductionists (mainly as physicists).  Reductionistslike to take things apart.  The rest of us are just trying to get ittogether.<P CLASS=para>Perl is in many ways a simple language.  You don't have to know manyspecial incantations to compile a Perl program--you can just execute itlike a shell script.  The types and structures used by Perl are easy touse and understand.  Perl doesn't impose arbitrary limitations on yourdata--your strings and arrays can grow as large as they like (so long asyou have memory), and they're designed to scale well as they grow.Instead of forcing you to learn new syntax and semantics, Perl borrowsheavily from other languages you may already be familiar with (such asC, and <I CLASS=emphasis>sed</I>, and <I CLASS=emphasis>awk</I>, and English, and Greek).  In fact, justabout any programmer can read a well-written piece of Perl code and havesome idea of what it does.<P CLASS=para>Most important, you don't have to know everything there is to knowabout Perl before you can write useful programs.  You can learn Perl"small end first".  You can program in Perl Baby-Talk, and we promisenot to laugh.  Or more precisely, we promise not to laugh any more thanwe'd giggle at a child's creative way of putting things.  Many of theideas in Perl are borrowed from natural language, and one of the bestideas is that it's okay to use a subset of the language as long as youget your point across.  Any level of language proficiency is acceptablein Perl culture.  We won't send the language police after you.  A Perlscript is "correct" if it gets the job done before your boss fires you.<P CLASS=para>Though simple in many ways, Perl is also a rich language, and there ismuch to be learned about it.  That's the price of making hard thingspossible.  Although it will take some time for you to absorb all thatPerl can do, you will be glad that you have access to the extensivecapabilities of Perl when the time comes that you need them.  We notedabove that Perl borrows many capabilities from the shells and C, butPerl also possesses a strict superset of <I CLASS=emphasis>sed</I> and <I CLASS=emphasis>awk</I>capabilities.  There are, in fact, translators supplied with Perl toturn your old <I CLASS=emphasis>sed</I> and <I CLASS=emphasis>awk</I> scripts into Perl scripts, so youcan see how the features you may already be familiar with correspond tothose of Perl.<P CLASS=para>Because of that heritage, Perl was a rich language even when it was"just" a data-reduction language, designed for navigating files,scanning large amounts of text, creating and obtaining dynamic data, andprinting easily formatted reports based on that data.  But somewherealong the line, Perl started to blossom.  It also became a language forfilesystem manipulation, process management, database administration,client-server programming, secure programming, Web-based informationmanagement, and even for object-oriented and functional programming.These capabilities were not just slapped onto the side of Perl--each newcapability works synergistically with the others, because Perlwas designed to be a glue language from the start.<P CLASS=para>But Perl can glue together more than its own features.  Perl is designedto be modularly extensible.  Perl allows you to rapidly design, program,debug, and deploy applications, but it also allows you to easilyextend the functionality of these applications as the need arises.  You can embed Perl in other languages, and you can embed other languagesin Perl.  Through the module importation mechanism, you canuse these external definitions as if they were built-in features of Perl.Object-oriented external libraries retain their object-orientedness in Perl.<P CLASS=para>Perl helps you in other ways too.  Unlike a strictly interpretedlanguage such as the shell, which compiles and executes a script onecommand at a time, Perl first compiles your whole program quickly intoan intermediate format.  Like any other compiler, it performs variousoptimizations, and gives you instant feedback on everything from syntaxand semantic errors to library binding mishaps.  Once Perl's compilerfrontend is happy with your program, it passes off the intermediatecode to the interpreter to execute (or optionally to any of severalmodular back ends that can emit C or bytecode.)  This all soundscomplicated, but the compiler and interpreter are quite efficient, andmost of us find that the typical compile-run-fix cycle is measured inmere seconds.  Together with Perl's many fail-soft characteristics, thisquick turnaround capability makes Perl a language in which you reallycan do rapid prototyping.  Then later, as your program matures, you cantighten the screws on yourself, and make yourself program with lessflair but more discipline.  Perl helps you with that too, if you asknicely.<P CLASS=para>Perl also helps you to write programs more securely.  While running inprivileged mode, you can temporarily switch your identity to somethinginnocuous before accessing system resources.  Perl also guards againstaccidental security errors through a data tracing mechanism thatautomatically determines which data was derived from insecure sourcesand prevents dangerous operations before they can happen.  Finally, Perllets you set up specially protected compartments in which you can safelyexecute Perl code of dubious lineage, masking out dangerous operations.System administrators and CGI programmers will particularly welcomethese features.<P CLASS=para>But, paradoxically, the way in which Perl helps you the most has almostnothing to do with Perl, and everything to do with the people who usePerl.  Perl folks are, frankly, some of the most helpful folks onearth.  If there's a religious quality to the Perl movement, then thisis at the heart of it.  Larry wanted the Perl community to function likea little bit of heaven, and he seems to have gotten his wish, so far.Please do your part to keep it that way.<P CLASS=para>Whether you are learning Perl because you want to save the world, or justbecause you are curious, or because your boss told you to, this handbookwill lead you through both the basics and the intricacies.  And althoughwe don't intend to teach you how to program, the perceptive reader willpick up some of the art, and a little of the science, of programming.We will encourage you to develop the three great virtues of aprogrammer: <I CLASS=emphasis>laziness</I>, <I CLASS=emphasis>impatience</I>, and <I CLASS=emphasis>hubris</I>.  Alongthe way, we hope you find the book mildly amusing in some spots (andwildly amusing in others).  And if none of this is enough to keep youawake, just keep reminding yourself that learning Perl will increase thevalue of your resume.  So keep reading.</DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top>&nbsp;</td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch00_02.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>&nbsp;</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>The Rest of This Book</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>