<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 1] 1.2 Natural and Artificial Languages</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 12:59:14 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch01_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 1</b></td><td width=172 align=right valign=top><A HREF="ch01_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-2">1.2 Natural and Artificial Languages</A></h2><P CLASS=para><A NAME="CH01.LANG"></A><A NAME="CH01.NAT"></A><A NAME="CH01.ART"></A>Languages were first invented by humans, for the benefit of humans.  Inthe annals of computer science, this fact has occasionally been forgotten.[3]Since Perl was designed (loosely speaking) by an occasional linguist, itwas designed to work smoothly in the same ways that natural languageworks smoothly.  Naturally, there are many aspects to this, since naturallanguage works well at many levels simultaneously.  We could enumeratemany of these linguistic principles here, but the most importantprinciple of language design is simply that easy things should be easy,and hard things should be possible.  That may seem obvious, but manycomputer languages fail at one or the other.<blockquote class=footnote><P CLASS=para>[3] More precisely, this fact has occasionally been remembered.</blockquote><P CLASS=para>Natural languages are good at both because people are continually tryingto express both easy things and hard things, so the language evolves tohandle both.  Perl was designed first of all to evolve, and indeed ithas evolved.  Many people have contributed to the evolution of Perl overthe years.  We often joke that a camel is a horse designed by acommittee, but if you think about it, the camel is pretty well adaptedfor life in the desert.  The camel has evolved to be relativelyself-sufficient.[4]<blockquote class=footnote><P CLASS=para>[4] On the other hand, the camel has not evolved to smell good.  Neither has Perl.</blockquote><P CLASS=para>Now when someone utters the word "linguistics", many people think of oneof two things.  Either they think of words, or they think of sentences.But words and sentences are just two handy ways to "chunk" speech.Either may be broken down into smaller units of meaning, or combinedinto larger units of meaning.  And the meaning of any unit dependsheavily on the syntactic, semantic, and pragmatic context in which theunit is located.  Natural language has words of various sorts, nouns andverbs and such.  If I say "dog" in isolation, you think of it as a noun,but I can also use the word in other ways.  That is, a noun canfunction as a verb, an adjective or an adverb when the contextdemands it.  If you dog a dog during the dog days of summer, you'll be a dogtired dogcatcher.[5]<blockquote class=footnote><P CLASS=para>[5] And you're probably dog tired of all this linguistics claptrap.But we'd like you to understand why Perl is different from the typicalcomputer language, doggone it!</blockquote><P CLASS=para>Perl also evaluates words differently in various contexts.  We will see howit does that later.  Just remember that Perl is trying to understand whatyou're saying, like any good listener does.  Perl works pretty hard to try tokeep up its end of the bargain.  Just say what you mean, and Perl willusually "get it".  (Unless you're talking nonsense, of course--the Perlparser understands Perl a lot better than either English or Swahili.)<P CLASS=para>But back to nouns.  A noun can name a particular object, or it can name aclass of objects generically without specifying which one or ones arecurrently being referred to.  Most computer languages make thisdistinction, only we call the particular thing a value and the generic onea variable.  A valuejust exists somewhere, who knows where, but a variable gets associatedwith one or more values over its lifetime.  So whoever is interpretingthe variable has to keep track of that association.  That interpreter maybe in your brain, or in your computer.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-2.1">Nouns</A></h3><P CLASS=para><A NAME="CH01.NOUNS"></A><A NAME="CH01.VAR"></A><A NAME="CH01.NV"></A>A variable is just a handy place to keep something, a place with aname, so you know where to find your special something when you comeback looking for it later.  As in real life, there are various kinds ofplaces to store things, some of them rather private, and some of themout in public.  Some places are temporary, and other places are morepermanent.  Computer scientists love to talk about the "scope" ofvariables, but that's all they mean by it.  Perl has various handyways of dealing with scoping issues, which you'll be happy to learnlater when the time is right.  Which is not yet.  (Look up the adjectives"local" and "my" in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>, when you get curious.)<P CLASS=para>But a more immediately useful way of classifying variables is by whatsort of data they can hold.  As in English, Perl's primary typedistinction is between singular and plural data.  Strings and numbers aresingular pieces of data, while lists of strings or numbers are plural.(And when we get to object-oriented programming, you'll find that anobject looks singular from the outside, but may look plural from theinside, like a class of students.)  We call a singular variable a<I CLASS=emphasis>scalar</I>, and a plural variable an <I CLASS=emphasis>array</I>.  Since a string can bestored in a scalar variable, we might write a slightly longer (andcommented) version of our first example like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$phrase = "Howdy, world!\n";          # Set a variable.print $phrase;                        # Print the variable.</PRE></DIV><P CLASS=para>Note that we did not have to predefine what kind of variable<tt CLASS=literal>$phrase</tt> is.  The <tt CLASS=literal>$</tt> charactertells Perl that <tt CLASS=literal>phrase</tt> is a scalar variable, thatis, one containing a singular value.  An array variable, by contrast,would start with an <tt CLASS=literal>@</tt> character.  (It may help youto remember that a <tt CLASS=literal>$</tt> is a stylized "S", for "scalar",while <tt CLASS=literal>@</tt> is a stylized "a", for "array".)<P CLASS=para>Perl has some other variable types, with unlikely names like "hash","handle", and "typeglob".  Like scalars and arrays, these types ofvariables are also preceded by funny characters.[6]For completeness, <A HREF="ch01_02.htm#PERL2-CH-1-TAB-1">Table 1.1</A> lists all the funny characters you'll encounter.<blockquote class=footnote><P CLASS=para>[6] Some language purists point to these funny characters as a reason toabhor Perl.  This is superficial.  These characters have many benefits:Variables can be interpolated into strings with no additional syntax.Perl scripts are easy to read (for people who have bothered to learnPerl!) because the nouns stand out from verbs, and new verbs can be addedto the language without breaking old scripts.  (We told you Perl wasdesigned to evolve.)  And the noun analogy is not frivolous--there isample precedent in various natural languages for requiring grammaticalnoun markers.  It's how we think!  (We think.)</blockquote><P><DIV CLASS=table><TABLE><CAPTION><A CLASS="TITLE" NAME="PERL2-CH-1-TAB-1">Table 1-1: Variable Syntax</A></CAPTION><TR CLASS=row><TH ALIGN="left">Type</TH><TH ALIGN="left">Character</TH><TH ALIGN="left">Example</TH><TH ALIGN="left">Is a name for:</TH></TR><TR CLASS=row><TD ALIGN="left">Scalar</TD><TD ALIGN="left"><tt CLASS=literal>$</tt></TD><TD ALIGN="left"><tt CLASS=literal>$cents</tt></TD><TD ALIGN="left">An individual value (number or string)</TD></TR><TR CLASS=row><TD ALIGN="left">Array</TD><TD ALIGN="left"><tt CLASS=literal>@</tt></TD><TD ALIGN="left"><tt CLASS=literal>@large</tt></TD><TD ALIGN="left">A list of values, keyed by number</TD></TR><TR CLASS=row><TD ALIGN="left">Hash</TD><TD ALIGN="left"><tt CLASS=literal>%</tt></TD><TD ALIGN="left"><tt CLASS=literal>%interest</tt></TD><TD ALIGN="left">A group of values, keyed by string</TD></TR><TR CLASS=row><TD ALIGN="left">Subroutine</TD><TD ALIGN="left"><tt CLASS=literal>&amp;</tt></TD><TD ALIGN="left"><tt CLASS=literal>&amp;how</tt></TD><TD ALIGN="left">A callable chunk of Perl code</TD></TR><TR CLASS=row><TD ALIGN="left">Typeglob</TD><TD ALIGN="left"><tt CLASS=literal>*</tt></TD><TD ALIGN="left"><tt CLASS=literal>*struck</tt></TD><TD ALIGN="left">Everything named <tt CLASS=literal>struck</tt></TD></TR></TABLE><P></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-2.1.1">Singularities</A></h4><P CLASS=para>From our example, you can see that scalars may be assigned a new value withthe <tt CLASS=literal>=</tt> operator, just as in many other computer languages.Scalar variables can be assignedany form of scalar value: integers, floating-point numbers, strings, andeven esoteric things like references to other variables, or to objects.There are many ways of generating these values for assignment.<P CLASS=para>As in the UNIXshell, you can use different quoting mechanisms to make different kindsof values.  Double quotation marks (double quotes) do variable interpolation[7]and backslash interpretation,[8]while single quotes suppress both interpolation and interpretation.  Andbackquotes (the ones leaning to the left) will execute an externalprogram and return the output of the program, so you can capture it asa single string containing all the lines of output.<blockquote class=footnote><P CLASS=para>[7] Sometimes called "substitution" by shell programmers, but we prefer toreserve that word for something else in Perl.  So please call itinterpolation.  We're using the term in the textual sense ("this passageis a Gnostic interpolation") rather than in the mathematical sense("this point on the graph is an interpolation between two otherpoints").<P CLASS=para>[8] Such as turning <tt CLASS=literal>\t</tt> into a tab, <tt CLASS=literal>\n</tt> into a newline,<tt CLASS=literal>\ 001</tt> into a CTRL-A,and so on, in the tradition of many UNIX programs.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>$answer = 42;               # an integer$pi = 3.14159265;           # a "real" number$avocados = 6.02e23;        # scientific notation$pet = "Camel";             # string$sign = "I love my $pet";   # string with interpolation$cost = 'It costs $100';    # string without interpolation$thence = $whence;          # another variable$x = $moles * $avocados;    # an expression$cwd = `pwd`;               # string output from a command$exit = system("vi $x");    # numeric status of a command$fido = new Camel "Fido";   # an object</PRE></DIV><P CLASS=para>Uninitialized variables automatically spring into existence as needed.Following the principle of least surprise, they are created with a nullvalue, either <tt CLASS=literal>""</tt> or <tt CLASS=literal>0</tt>.  Depending on where you use them, variableswill be interpreted automatically as strings, as numbers, or as "true"and "false" values (commonly called Boolean values).  Various operatorsexpect certain kinds of values as parameters, so we will speak of thoseoperators as "providing" or "supplying" a scalar context to those parameters.Sometimes we'll be more specific, and say it supplies a numeric context,a string context, or a Boolean context to those parameters.  (Laterwe'll also talk about list context, which is the opposite of scalarcontext.)  Perl will automatically convert the data into the formrequired by the current context, within reason.  For example, supposeyou said this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$camels = '123';print $camels + 1, "\n";</PRE></DIV><P CLASS=para>The original value of <tt CLASS=literal>$camels</tt> is a string, but it is converted to anumber to add <tt CLASS=literal>1</tt> to it, and then converted back to a string to beprinted out as <tt CLASS=literal>124</tt>.  The newline, represented by <tt CLASS=literal>"\n"</tt>, is alsoin string context, but since it's already a string, no conversion isnecessary.  But notice that we had to use double quotes there--usingsingle quotes to say <tt CLASS=literal>'\n'</tt> would result in a two-character stringconsisting of a backslash followed by an "<tt CLASS=literal>n</tt>", which is not a newline byanybody's definition.<P CLASS=para>So, in a sense, double quotes and single quotes are yet another way ofspecifying context.  The interpretation of the innards of a quotedstring depends on which quotes you use.  Later we'll see some otheroperators that work like quotes syntactically, but use the string insome special way, such as for pattern matching or substitution.  Theseall work like double-quoted strings too.  The <I CLASS=emphasis>double-quote</I> context isthe "interpolative" context of Perl, and is supplied by many operatorsthat don't happen to resemble double quotes.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-2.1.2">Pluralities</A></h4><P CLASS=para>Some kinds of variables hold multiple values that are logically tiedtogether.  Perl has two types of multivalued variables: arrays andhashes.  In many ways these behave like scalars.  They spring intoexistence with nothing in them when needed.  When you assign to them,they supply a <I CLASS=emphasis>list</I> context to the right side of the assignment.<P CLASS=para>You'd use an array when you want to look something up by number.  You'duse a hash when you want to look something up by name.  The two conceptsare complementary.  You'll often see people using an array to translatemonth numbers into month names, and a corresponding hash to translatemonth names back into month numbers.  (Though hashes aren't limited toholding only numbers.  You could have a hash that translatesmonth names to birthstone names, for instance.)<DIV CLASS=sect4><h5 CLASS=sect4><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-2.1.2.1">Arrays.</A></h5><P CLASS=para>An <I CLASS=emphasis>array</I> is an ordered list of scalars, accessed[9]by the scalar's position in the list.  The list may contain numbers, orstrings, or a mixture of both.  (In fact, it could also containreferences to other lists, but we'll get to that in <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>, when we'rediscussing multidimensional arrays.)  To assign a list value to anarray, you simply group the variables together (with a set ofparentheses):<blockquote class=footnote><P CLASS=para>[9] Or keyed, or indexed, or subscripted, or looked up.  Take your pick.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>@home = ("couch", "chair", "table", "stove");</PRE></DIV><P CLASS=para>Conversely, if you use <tt CLASS=literal>@home</tt> in a list context, such as on the rightside of a list assignment, you get back out the same list you put in.So you could set four scalar variables from the array like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($potato, $lift, $tennis, $pipe) = @home;</PRE></DIV><P CLASS=para>These are called list assignments.  They logically happen in parallel,so you can swap two variables by saying:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($alpha,$omega) = ($omega,$alpha);</PRE></DIV><P CLASS=para>As in C, arrays are zero-based, so while you would talk about thefirst through fourth elements of the array, you would get to them withsubscripts 0 through 3.[10]Array subscripts are enclosed in square brackets [like this], so ifyou want to select an individual array element, you would refer to itas<tt CLASS=literal>$home[</tt><I CLASS=emphasis>n</I><tt CLASS=literal>]</tt>,where <I CLASS=emphasis>n</I> is the subscript (one less than theelement number) you want.  See the example below.  Since the elementyou are dealing with is a scalar, you always precede it with a<tt CLASS=literal>$</tt>.<blockquote class=footnote><P CLASS=para>[10] If this seems odd to you, just think of the subscript as an offset, thatis, the count of how many array elements come before it.  Obviously, thefirst element doesn't have any elements before it, and so has an offsetof 0.  This is how computers think.  (We think.)</blockquote><P CLASS=para>If you want to assign to one array element at a time, you could write theearlier assignment as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$home[0] = "couch";$home[1] = "chair";$home[2] = "table";$home[3] = "stove";</PRE></DIV><P CLASS=para>Since arrays are ordered, there are various useful operations that youcan do on them, such as the stack operations, <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A> and <A HREF="ch03_02.htm#PERL2-CMD-POP">pop</A>.  Astack is, after all, just an ordered list, with a beginning and anend.  Especially an end.  Perl regards the end of your list as the topof a stack.  (Although most Perl programmers think of a list ashorizontal, with the top of the stack on the right.)</DIV><DIV CLASS=sect4><h5 CLASS=sect4><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-2.1.2.2">Hashes.</A></h5><P CLASS=para>A <I CLASS=emphasis>hash</I> is an unordered set of scalars, accessed[11]by some string value that is associated with each scalar.  For thisreason hashes are often called "associative arrays".  But that's too longfor lazy typists to type, and we talk about them so often that we decidedto name them something short and snappy.[12]The other reason we picked the name "hash" is to emphasize the fact thatthey're disordered.  (They are, coincidentally, implemented internallyusing a hash-table lookup, which is why hashes are so fast, and stay sofast no matter how many values you put into them.)  You can't <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A> or<A HREF="ch03_02.htm#PERL2-CMD-POP">pop</A> a hash though, because it doesn't make sense.  A hash has nobeginning or end.  Nevertheless, hashes are extremely powerful anduseful.  Until you start thinking in terms of hashes, you aren't reallythinking in Perl.<blockquote class=footnote><P CLASS=para>[11] Or keyed, or indexed, or subscripted, or looked up.  Take your pick.<P CLASS=para>[12] Presuming for the moment that we can classify <I CLASS=emphasis>any</I> sort of hash as"snappy".  Please pass the Tabasco.</blockquote><P CLASS=para>Since the keys to a hash are not automatically implied by their position,you must supply the key as well as the value when populating a hash.You can still assign a list to it like an ordinary array, but eachpair of items in the list will be interpreted as a key/value pair.Suppose you wanted to translate abbreviated day names to the correspondingfull names.  You could write the following list assignment.<P CLASS=para><DIV CLASS=programlisting><P><PRE>%longday = ("Sun", "Sunday", "Mon", "Monday", "Tue", "Tuesday",            "Wed", "Wednesday", "Thu", "Thursday", "Fri",            "Friday", "Sat", "Saturday");</PRE></DIV><P CLASS=para>Because it is sometimes difficult to read a hash that is defined likethis, Perl provides the <tt CLASS=literal>=&gt;</tt> (equal sign, greater than) sequence asan alternative separator to the comma.  Using this syntax (andsome creative formatting), it is easier to see which strings are thekeys, and which strings are the associated values.<P CLASS=para><DIV CLASS=programlisting><P><PRE>%longday = (    "Sun" =&gt; "Sunday",    "Mon" =&gt; "Monday",    "Tue" =&gt; "Tuesday",    "Wed" =&gt; "Wednesday",    "Thu" =&gt; "Thursday",    "Fri" =&gt; "Friday",    "Sat" =&gt; "Saturday",);</PRE></DIV><P CLASS=para>Not only can you assign a list to a hash, as we did above, but if you usea hash in list context, it'll convert the hash back to a list of key/valuepairs, in a weird order.  This is occasionally useful.  More often peopleextract a list of just the keys, using the (aptly named) <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> function.The key list is also unordered, but can easily be sorted if desired, usingthe (aptly named) <A HREF="ch03_02.htm#PERL2-CMD-SORT">sort</A> function.  More on that later.<P CLASS=para>Because hashes are a fancy kind of array, you select an individual hashelement by enclosing the key in braces.So, for example, if you want to find out the value associatedwith <tt CLASS=literal>Wed</tt> in the hash above, you would use <tt CLASS=literal>$longday{"Wed"}</tt>.  Noteagain that you are dealing with a scalar value, so you use <tt CLASS=literal>$</tt>, not <tt CLASS=literal>%</tt>.<P CLASS=para>Linguistically, the relationship encoded in a hash is genitiveor possessive, like the word "of " in English, or like " 's".  The wife<I CLASS=emphasis>of</I> Adam is Eve, so we write:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$wife{"Adam"} = "Eve";</PRE></DIV></DIV></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-2.2">Verbs</A></h3><P CLASS=para>As is typical of your typical imperative computer language, many of theverbs in Perl are commands: they tell the Perl interpreter to dosomething.  On the other hand, as is typical of a natural language, themeanings of Perl verbs tend to mush off in various directions, dependingon the context.  A statement starting with a verb is generally purelyimperative, and evaluated entirely for its side effects.  We often callthese verbs <I CLASS=emphasis>procedures</I>, especially when they're user-defined.  A frequentlyseen command (in fact, you've seen it already) is the <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> command:<P CLASS=para><DIV CLASS=programlisting><P><PRE>print "Adam's wife is ", $wife{'Adam'}, ".\n";</PRE></DIV><P CLASS=para>This has the side effect of producing the desired output.<P CLASS=para>But there are other "moods" besides the imperative mood.  Some verbs arefor asking questions, and are useful in conditional statements.  Otherverbs translate their input parameters into return values, just as arecipe tells you how to turn raw ingredients into something (hopefully)edible.  We tend to call these verbs <I CLASS=emphasis>functions</I>, in deference to generationsof mathematicians who don't know what the word "functional" means innatural language.<P CLASS=para>An example of a built-in function would be the exponential function:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$e = exp(1);   # 2.718281828459, or thereabouts</PRE></DIV><P CLASS=para>But Perl doesn't make a hard distinction between procedures andfunctions.  You'll find the terms used interchangeably.  Verbs are alsosometimes called subroutines (when user-defined) or operators (whenbuilt-in).  But call them whatever you like--they all return a value,which may or may not be a meaningful value, which you may or may notchoose to ignore.<P CLASS=para>As we go on, you'll see additional examples of how Perl behaves like anatural language.  But there are other ways to look at Perl too.  We'vealready sneakily introduced some notions from mathematical language,such as addition and subscripting, not to mention the exponentialfunction.  But Perl is also a control language, a glue language, aprototyping language, a text-processing language, a list-processinglanguage, and an object-oriented language.  Among other things.<P CLASS=para>But Perl is also just a plain old computer language.  And that's howwe'll look at it next.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch01_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch01_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Getting Started</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>A Grade Example</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>