<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 1] 1.4 Filehandles</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 12:59:19 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch01_03.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 1</b></td><td width=172 align=right valign=top><A HREF="ch01_05.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-4">1.4 Filehandles</A></h2><P CLASS=para><A NAME="CH01.IOF1"></A><A NAME="CH01.IOF2"></A><A NAME="CH01.FH"></A>Unless you're using artificial intelligence to model a solipsistic philosopher,your program needs some way to communicate with the outside world.  Inlines 3 and 4 of our grade example you'll see the word <tt CLASS=literal>GRADES</tt>, whichexemplifies another of Perl's data types, the <I CLASS=emphasis>filehandle</I>.  A filehandle isjust a name you give to a file, device, socket, or pipe to help youremember which one you're talking about, and to hide some of thecomplexities of buffering and such.  (Internally, filehandles aresimilar to streams from a language like C++, or I/O channels fromBASIC.) <P CLASS=para>Filehandles make it easierfor you to get input from and sendoutput to many different places.  Part of what makes Perl a good gluelanguage is that it can talk to many files and processes at once.Having nice symbolic names for various external objects is just part ofbeing a good glue language.[17]<blockquote class=footnote><P CLASS=para>[17] Some of the other things that make Perl a good glue language are: it's8-bit clean, it's embeddable, and you can embed other things in it viaextension modules.  It's concise, and networks easily.  It'senvironmentally conscious, so to speak.  You can invoke it in manydifferent ways (as we saw earlier).  But most of all, the languageitself is not so rigidly structured that you can't get it to "flow"around your problem.  It comes back to that TMTOWTDI thing again.</blockquote><P CLASS=para>You create a filehandle and attach it to a file by using the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A>function.  <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> takes two parameters: the filehandle and the filenameyou want to associate it with.  Perl also gives you some predefined (andpreopened) filehandles.  <tt CLASS=literal>STDIN</tt> is your program's normal inputchannel, while <tt CLASS=literal>STDOUT</tt> is your program's normal output channel.  And<tt CLASS=literal>STDERR</tt> is an additional output channel so that your program can makesnide remarks off to the side while it transforms (or attempts totransform) your input into your output.[18]<blockquote class=footnote><P CLASS=para>[18] These filehandles are typically attached to your terminal, so you cantype to your program and see its output, but they may also be attached tofiles (and such).  Perl can give you these predefined handles becauseyour operating system already provides them, one way or another.  UnderUNIX, processes inherit standard input, output, and error from theirparent process, typically a shell.  One of the duties of a shell is toset up these I/O streams so that the child process doesn't need to worryabout them.</blockquote><P CLASS=para>Since you can use the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> function to create filehandles for variouspurposes (input, output, piping), you need to be able to specify whichbehavior you want.  As you would do on the UNIX command line, yousimply add characters to the filename.<P CLASS=para><DIV CLASS=programlisting><P><PRE>open(SESAME, "filename");               # read from existing fileopen(SESAME, "&lt;filename");              #   (same thing, explicitly)open(SESAME, "&gt;filename");              # create file and write to itopen(SESAME, "&gt;&gt;filename");             # append to existing fileopen(SESAME, "| output-pipe-command");  # set up an output filteropen(SESAME, "input-pipe-command |");   # set up an input filter</PRE></DIV><P CLASS=para>As you can see, the name you pick is arbitrary.Once opened, the filehandle <tt CLASS=literal>SESAME</tt> can be used to access the file or pipeuntil it is explicitly closed (with, you guessed it, <tt CLASS=literal>close(SESAME)</tt>),or the filehandle is attached to another file by a subsequent <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A>on the same filehandle.[19]<blockquote class=footnote><P CLASS=para>[19] Opening an already opened filehandle implicitly closes the first file,making it inaccessible to the filehandle, and opens a different file.  Youmust be careful that this is what you really want to do.  Sometimesit happens accidentally, like when you say <tt CLASS=literal>open($handle,$file)</tt>, and<tt CLASS=literal>$handle</tt> happens to contain the null string.  Be sure to set <tt CLASS=literal>$handle</tt> tosomething unique, or you'll just open a new file on the null filehandle.</blockquote><P CLASS=para>Once you've opened a filehandle for input (or if you want to use<tt CLASS=literal>STDIN</tt>), you can read a line using the line reading operator,<tt CLASS=literal>&lt;&gt;</tt>.  This is also known as the angle operator, because of itsshape.  The angle operator encloses the filehandle (<tt CLASS=literal>&lt;SESAME&gt;</tt>)you want to read lines from.[20]An example using the <tt CLASS=literal>STDIN</tt> filehandle to read an answer suppliedby the user would look something like this:<blockquote class=footnote><P CLASS=para>[20] The empty angle operator, <tt CLASS=literal>&lt;&gt;</tt>, will read lines from all the filesspecified on the command line, or <tt CLASS=literal>STDIN</tt>, if none were specified.  (Thisis standard behavior for many UNIX filter programs.)</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>print STDOUT "Enter a number: ";          # ask for a number$number = &lt;STDIN&gt;;                        # input the numberprint STDOUT "The number is $number\n";   # print the number</PRE></DIV><P CLASS=para>Did you see what we just slipped by you?  What's the <tt CLASS=literal>STDOUT</tt> doing inthose <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> statements there?  Well, that's one of the ways you can usean output filehandle.  A filehandle may be supplied as the firstargument to the <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> statement, and if present, tells the outputwhere to go.  In this case, the filehandle is redundant, because theoutput would have gone to <tt CLASS=literal>STDOUT</tt> anyway.  Much as <tt CLASS=literal>STDIN</tt> is thedefault for input, <tt CLASS=literal>STDOUT</tt> is the default for output.  (In line 18 ofour grade example, we left it out, to avoid confusing you up till now.)<P CLASS=para>We also did something else to trick you.  If you try the aboveexample, you may notice that you get an extra blank line.  Thishappens because the read does not automatically remove the newlinefrom your input line (your input would be, for example,"<tt CLASS=literal>9\n</tt>").  For those times when you do want to removethe newline, Perl provides the <A HREF="ch03_02.htm#PERL2-CMD-CHOP">chop</A> and<A HREF="ch03_02.htm#PERL2-CMD-CHOMP">chomp</A> functions.  <A HREF="ch03_02.htm#PERL2-CMD-CHOP">chop</A> will indiscriminately remove (and return)the last character passed to it, while <A HREF="ch03_02.htm#PERL2-CMD-CHOMP">chomp</A> will only remove the end of record marker(generally, "<tt CLASS=literal>\n</tt>"), and return the number ofcharacters so removed.  You'll often see this idiom for inputting asingle line:<P CLASS=para><DIV CLASS=programlisting><P><PRE>chop($number = &lt;STDIN&gt;);    # input number and remove newline</PRE></DIV><P CLASS=para>which means the same thing as<P CLASS=para><DIV CLASS=programlisting><P><PRE>$number = &lt;STDIN&gt;;          # input numberchop($number);              # remove newline</PRE></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch01_03.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch01_05.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>A Grade Example</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Operators</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>