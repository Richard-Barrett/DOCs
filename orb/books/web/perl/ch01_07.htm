<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 1] 1.7 Regular Expressions</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 12:59:30 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch01_06.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 1</b></td><td width=172 align=right valign=top><A HREF="ch01_08.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-7">1.7 Regular Expressions</A></h2><P CLASS=para><A NAME="CH01.RE"></A><I CLASS=emphasis>Regular expressions</I> (aka regexps, regexes or REs) are used by manyUNIX programs, such as <I CLASS=emphasis>grep</I>, <I CLASS=emphasis>sed</I> and <I CLASS=emphasis>awk</I>,[24]editors like <I CLASS=emphasis>vi</I> and <I CLASS=emphasis>emacs</I>, and even some of the shells.  Aregular expression is a way of describing a set of strings withouthaving to list all the strings in your set.<blockquote class=footnote><P CLASS=para>[24] A good source of information on regular expression concepts isthe Nutshell Handbook <I CLASS=emphasis>sed &amp; awk</I> by DaleDougherty (O'Reilly &amp; Associates). You might also keep an eye outfor Jeffrey Friedl's forthcoming book, <I CLASS=emphasis>Mastering RegularExpressions</I> (O'Reilly &amp; Associates).</blockquote><P CLASS=para>Regular expressions are used several ways in Perl.  First andforemost, they're used in conditionals to determine whether a stringmatches a particular pattern.  So when you see something that looks like<tt CLASS=literal>/foo/</tt>, you know you're looking at an ordinary <I CLASS=emphasis>pattern-matching</I> operator.<P CLASS=para>Second, if you can locate patterns within a string, you can replace themwith something else.  So when you see something that looks like<tt CLASS=literal>s/foo/bar/</tt>, you know it's asking Perl to substitute "bar" for "foo", ifpossible.  We call that the <I CLASS=emphasis>substitution</I> operator.<P CLASS=para>Finally, patterns can specify not only where something is, but alsowhere it isn't.  So the <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> operator uses a regular expressionto specify where the data isn't.  That is, the regular expressiondefines the <I CLASS=emphasis>delimiters</I> that separate the fields of data.  Our gradeexample has a couple of trivial examples of this.  Lines 5 and 12 eachsplit strings on the space character in order to return a list of words.But you can split on any delimiter you can specify with a regularexpression.<P CLASS=para>(There are various modifiers you can use in each of these situations to doexotic things like ignore case when matching alphabetic characters, butthese are the sorts of gory details that we'll cover in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.)<P CLASS=para>The simplest use of regular expressions is to match a literalexpression.  In the case of the splits we just mentioned, we matched ona single space.  But if you match on several characters in a row, theyall have to match sequentially.  That is, the pattern looks for asubstring, much as you'd expect.  Let's say we want to show all thelines of an HTML file that are links to other HTML files (as opposed toFTP links).  Let's imagine we're working with HTML for the first time,and we're being a little naive yet.  We know that these links willalways have "http:" in them somewhere.  We could loop through our filewith this:[25]<blockquote class=footnote><P CLASS=para>[25] This is very similar to what the UNIX command <tt CLASS=literal>grep 'http:' file</tt> woulddo.  On MS-DOS you could use the <I CLASS=emphasis>find</I> command, but it doesn't knowhow to do more complicated regular expressions.  (However, the misnamed<I CLASS=emphasis>findstr</I> program of Windows NT does know about regular expressions.)</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>while ($line = &lt;FILE&gt;) {    if ($line =~ /http:/) {        print $line;    }}</PRE></DIV><P CLASS=para>Here, the <tt CLASS=literal>=~</tt> (pattern binding operator) is tellingPerl to look for a match ofthe regular expression <tt CLASS=literal>http:</tt> in the variable <tt CLASS=literal>$line</tt>.  If it finds theexpression, the operator returns a true value and the block (a <B>print</B>command) is executed.  By the way, if you don't use the <tt CLASS=literal>=~</tt> bindingoperator, then Perl will search a default variable instead of <tt CLASS=literal>$line</tt>.This default space is really just a special variable that goes bythe odd name of <B>$_</B>.  In fact, many of the operators in Perldefault to using the <B>$_</B> variable, so an expert Perl programmer mightwrite the above as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>while (&lt;FILE&gt;) {    print if /http:/;}</PRE></DIV><P CLASS=para>(Hmm, another one of those statement modifiers seems to have snuck inthere.  Insidious little beasties.)<P CLASS=para>This stuff is pretty handy, but what if we wanted to find all the links,not just the HTTP links?  We could give a list of links, like "<tt CLASS=literal>http:</tt>","<tt CLASS=literal>ftp:</tt>", "<tt CLASS=literal>mailto:</tt>", and so on.  But that list could get long, and what would wedo when a new kind of link was added?<P CLASS=para><DIV CLASS=programlisting><P><PRE>while (&lt;FILE&gt;) {    print if /http:/;    print if /ftp:/;    print if /mailto:/;    # What next?}</PRE></DIV><P CLASS=para>Since regular expressions are descriptive of a set of strings, we canjust describe what we are looking for: a number of alphabetic charactersfollowed by a colon.  In regular expression talk (Regexpese?), thatwould be <tt CLASS=literal>/[a-zA-Z]+:/</tt>, where the brackets define a <I CLASS=emphasis>characterclass</I>.  The <tt CLASS=literal>a-z</tt> and <tt CLASS=literal>A-Z</tt> represent all alphabetic characters (thedash means the range of all characters between the starting and endingcharacter, inclusive).  And the <tt CLASS=literal>+</tt> is a special character which says"one or more of whatever was before me".  It's what we call a<I CLASS=emphasis>quantifier</I>, meaning a gizmo that says how many times something isallowed to repeat.  (The slashes aren't really part of the regularexpression, but rather part of the pattern match operator.   The slashesare acting like quotes that just happen to contain a regularexpression.)<P CLASS=para>Because certain classes like the alphabetics are so commonly used, Perldefines special cases for them.  See <A HREF="ch01_07.htm#PERL2-CH-1-TAB-7">Table 1.7</A> for these special cases.<P><DIV CLASS=table><TABLE><CAPTION><A CLASS="TITLE" NAME="PERL2-CH-1-TAB-7">Table 1-7: Regular Expression Character Classes</A></CAPTION><TR CLASS=row><TH ALIGN="left">Name</TH><TH ALIGN="left">Definition</TH><TH ALIGN="left">Code</TH></TR><TR CLASS=row><TD ALIGN="left">Whitespace</TD><TD ALIGN="left"><tt CLASS=literal>[ \t\n\r\f]</tt></TD><TD ALIGN="left"><tt CLASS=literal>\s</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Word character</TD><TD ALIGN="left"><tt CLASS=literal>[a-zA-Z_0-9]</tt></TD><TD ALIGN="left"><tt CLASS=literal>\w</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Digit</TD><TD ALIGN="left"><tt CLASS=literal>[0-9]</tt></TD><TD ALIGN="left"><tt CLASS=literal>\d</tt></TD></TR></TABLE><P></DIV><P CLASS=para>Note that these match <I CLASS=emphasis>single</I> characters.  A <tt CLASS=literal>\w</tt> will match any singleword character, not an entire word.  (Remember that <tt CLASS=literal>+</tt> quantifier?  Youcan say <tt CLASS=literal>\w+</tt> to match a word.)  Perl also provides the negation ofthese classes by using the uppercased character, such as <tt CLASS=literal>\D</tt> for anon-digit character.<P CLASS=para>(We should note that <tt CLASS=literal>\w</tt> is not always equivalent to <tt CLASS=literal>[a-zA-Z_0-9]</tt>.Some locales define additional alphabetic characters outside the ASCIIsequence, and <tt CLASS=literal>\w</tt> respects them.)<P CLASS=para>There is one other very special character class, written with a "<tt CLASS=literal>.</tt>",that will match any character whatsoever.[26]For example, <tt CLASS=literal>/a./</tt> will match any string containing an "<tt CLASS=literal>a</tt>" that is notthe last character in the string.  Thus it will match "<tt CLASS=literal>at</tt>" or "<tt CLASS=literal>am</tt>" oreven "<tt CLASS=literal>a+</tt>", but not "<tt CLASS=literal>a</tt>", since there's nothing after the "<tt CLASS=literal>a</tt>" for the dotto match.  Since it's searching for the pattern anywhere in the string,it'll match "<tt CLASS=literal>oasis</tt>" and "<tt CLASS=literal>camel</tt>", but not "<tt CLASS=literal>sheba</tt>".  It matches "<tt CLASS=literal>caravan</tt>"on the first "<tt CLASS=literal>a</tt>".  It could match on the second "<tt CLASS=literal>a</tt>", but it stops afterit finds the first suitable match, searching from left to right.<blockquote class=footnote><P CLASS=para>[26] Except that it won't normally match a newline.  When you think about it,a "<tt CLASS=literal>.</tt>" doesn't normally match a newline in <I CLASS=emphasis>grep</I> (1) either.</blockquote><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-7.1">Quantifiers</A></h3><P CLASS=para>The characters and character classes we've talked about all match singlecharacters.  We mentioned that you could match multiple "word"characters with <tt CLASS=literal>\w+</tt> in order to match an entire word.  The <tt CLASS=literal>+</tt>is one kind of quantifier, but there are others.  (All of them are placedafter the item being quantified.)<P CLASS=para>The most general form of quantifier specifies both the minimum andmaximum number of times an item can match.  You put the two numbers inbraces, separated by a comma.  For example, if you were tryingto match North American phone numbers, <tt CLASS=literal>/ \d{7,11}/</tt> would match at least seven digits,but no more than eleven digits.  If you put a single number in the braces,the number specifies both the minimum and the maximum; that is, thenumber specifies the exact number of times the item can match.  (If youthink about it, all unquantified items have an implicit <tt CLASS=literal>{1}</tt>quantifier.)<P CLASS=para>If you put the minimum and the comma but omit the maximum, then themaximum is taken to be infinity.  In other words, it will match at leastthe minimum number of times, plus as many as it can get after that.For example, <tt CLASS=literal>/ \d{7}/</tt> will only match a local (North American) phone number (sevendigits), while <tt CLASS=literal>/ \d{7,}/</tt> will match any phone number, even aninternational one (unless it happens to be shorter than seven digits).  There is nospecial way of saying "at most" a certain number of times.  Justsay <tt CLASS=literal>/.{0,5}/</tt>, for example, to find at most five arbitrary characters.<P CLASS=para>Certain combinations of minimum and maximum occur frequently, so Perldefines special quantifiers for them.  We've already seen <tt CLASS=literal>+</tt>, which isthe same as <tt CLASS=literal>{1,}</tt>, or "at least one of the preceding item".  There isalso <tt CLASS=literal>*</tt>, which is the same as <tt CLASS=literal>{0,}</tt>, or "zero or more of thepreceding item", and <tt CLASS=literal>?</tt>, which is the same as <tt CLASS=literal>{0,1}</tt>, or "zero orone of the preceding item" (that is, the preceding item is optional).<P CLASS=para>There are a couple things about quantification that you needto be careful of.  First of all, Perl quantifiers are by default<I CLASS=emphasis>greedy</I>.  This means that they will attempt to match as much as theycan as long as the entire expression still matches.  For example, if youare matching <tt CLASS=literal>/ \d+/</tt> against "<tt CLASS=literal>1234567890</tt>", it will match the entirestring.  This is something to especially watch out for when you are using"<tt CLASS=literal>.</tt>", any character.  Often, someone will have a string like:<P CLASS=para><DIV CLASS=programlisting><P><PRE>spp:Fe+H20=FeO2;H:2112:100:Stephen P Potter:/home/spp:/bin/tcsh</PRE></DIV><P CLASS=para>and try to match "<tt CLASS=literal>spp</tt>" with<tt CLASS=literal>/.+:/</tt>.  However, since the <tt CLASS=literal>+</tt>quantifier is greedy, this pattern will match everything up to andincluding "<tt CLASS=literal>/home/spp</tt>".  Sometimes you can avoidthis by using a negated character class, that is, by saying <tt CLASS=literal>/[^:]+:/</tt>, which saysto match one or more non-colon characters (as many as possible), up tothe first colon.  It's that little caret in there that negates the senseof the character class.[27]The other point to be careful about is that regular expressions will tryto match as <I CLASS=emphasis>early</I> as possible.  This even takes precedence over beinggreedy.  Since scanning happens left-to-right, this means that thepattern will match as far left as possible, even if there is some otherplace where it could match longer.  (Regular expressions are greedy, butthey aren't into delayed gratification.)  For example, suppose you'reusing the substitution command (<tt CLASS=literal>s///</tt>) on the default variable space(variable <B>$_</B>, that is), and you want to remove a string of x's fromthe middle of the string.  If you say:<blockquote class=footnote><P CLASS=para>[27] Sorry, we didn't pick that notation, so don't blame us.  That's just howregular expressions are customarily written in UNIX culture.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>$_ = "fred xxxxxxx barney";s/x*//;</PRE></DIV><P CLASS=para>it will have absolutely no effect.  This is because the <tt CLASS=literal>x*</tt> (meaning zero ormore "<tt CLASS=literal>x</tt>" characters) will be able to match the "nothing" at the beginning of thestring, since the null string happens to be zero characters wide and there'sa null string just sitting there plain as day before the "<tt CLASS=literal>f</tt>" of "<tt CLASS=literal>fred</tt>".[28]<blockquote class=footnote><P CLASS=para>[28] Even the authors get caught by this from time to time.</blockquote><P CLASS=para>There's one other thing you need to know.  By default quantifiers applyto a single preceding character, so <tt CLASS=literal>/bam{2}/</tt> will match "<tt CLASS=literal>bamm</tt>" but not"<tt CLASS=literal>bambam</tt>".  To apply a quantifier to more than one character, use parentheses.So to match "<tt CLASS=literal>bambam</tt>", use the pattern <tt CLASS=literal>/(bam){2}/</tt>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-7.2">Minimal Matching</A></h3><P CLASS=para>If you were using an ancient version of Perl and you didn't want greedymatching, you had to use a negated character class.  (And really,you were still getting greedy matching of a constrained variety.)<P CLASS=para>In modern versions of Perl, you can force nongreedy, minimalmatching by use of a question mark after any quantifier.  Our sameusername match would now be <tt CLASS=literal>/.*?:/</tt>.  That <tt CLASS=literal>.*?</tt> will now try tomatch as few characters as possible, rather than as many as possible,so it stops at the first colon rather than the last.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-7.3">Nailing Things Down</A></h3><P CLASS=para>Whenever you try to match a pattern, it's going to try to match in everylocation till it finds a match.  An <I CLASS=emphasis>anchor</I> allows you to restrictwhere the pattern can match.  Essentially, an anchor is something thatmatches a "nothing", but a special kind of nothing that depends on itssurroundings.  You could also call it a rule, or a constraint, or anassertion.  Whatever you care to call it, it tries to match something ofzero width, and either succeeds or fails.  (If it fails, it merely meansthat the pattern can't match that particular way.  The pattern will goon trying to match some other way, if there are any other ways to try.)<P CLASS=para>The special character string <tt CLASS=literal>\b</tt> matches at a word boundary, which isdefined as the "nothing" between a word character (<tt CLASS=literal>\w</tt>) and a non-wordcharacter (<tt CLASS=literal>\W</tt>), in either order.  (The characters that don't exist off thebeginning and end of your string are considered to be non-word characters.)For example,<P CLASS=para><DIV CLASS=programlisting><P><PRE>/\bFred\b/</PRE></DIV><P CLASS=para>would match both "<tt CLASS=literal>The Great Fred</tt>" and"<tt CLASS=literal>Fred the Great</tt>", but would not match"<tt CLASS=literal>Frederick the Great</tt>" because the "<tt CLASS=literal>de</tt>" in "<tt CLASS=literal>Frederick</tt>" does not contain aword boundary.<P CLASS=para>In a similar vein, there are also anchors for the beginning of thestring and the end of the string.  If it is the first character of apattern, the caret (<tt CLASS=literal>^</tt>) matches the "nothing" at the beginning of thestring.  Therefore, the pattern <tt CLASS=literal>/^Fred/</tt> would match "Frederick theGreat" and not "The Great Fred", whereas <tt CLASS=literal>/Fred^/</tt> wouldn't matcheither.  (In fact, it doesn't even make much sense.)  The dollar sign(<tt CLASS=literal>$</tt>) works like the caret, except that it matches the "nothing" at theend of the string instead of the beginning.[29]<blockquote class=footnote><P CLASS=para>[29] This is a bit oversimplified, since we're assuming here that your stringcontains only one line.  <tt CLASS=literal>^</tt> and <tt CLASS=literal>$</tt> are actually anchors for thebeginnings and endings of lines rather than strings.  We'll try tostraighten this all out in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A> (to the extent that it canbe straightened out).</blockquote><P CLASS=para>So now you can probably figure out that when we said:<P CLASS=para><DIV CLASS=programlisting><P><PRE>next LINE if $line =~ /^#/;</PRE></DIV><P CLASS=para>we meant "Go to the next iteration of <tt CLASS=literal>LINE</tt> loop if this line happens tobegin with a <tt CLASS=literal>#</tt> character."</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-7.4">Backreferences</A></h3><P CLASS=para>We mentioned earlier that you can use parentheses to group thingsfor quantifiers, but you can also use parentheses to remember bits andpieces of what you matched.  A pair of parentheses around a part of aregular expression causes whatever was matched by that part to beremembered for later use.  It doesn't change what the part matches, so<tt CLASS=literal>/ \d+/</tt> and <tt CLASS=literal>/(\d+)/</tt> will still match as many digits as possible, butin the latter case they will be remembered in a special variable to bebackreferenced later.<P CLASS=para>How you refer back to the remembered part of the string depends on whereyou want to do it from.  Within the same regular expression, youuse a backslash followed by an integer.  The integer corresponding to agiven pair of parentheses is determined by counting left parenthesesfrom the beginning of the pattern, starting with one.  So for example, tomatch something similar to an HTML tag (like "<tt CLASS=literal>&lt;B&gt;Bold&lt;/B&gt;</tt>", you mightuse <tt CLASS=literal>/&lt;(.*?)&gt;.*?&lt;\/\1&gt;/</tt>.  This forces the two parts of thepattern to match the exact same string, such as the "<tt CLASS=literal>B</tt>" above.<P CLASS=para>Outside the regular expression itself, such as in the replacementpart of a substitution, the special variable is used as if it were anormal scalar variable named by the integer.  So, if you wanted to swapthe first two words of a string, for example, you could use:<P CLASS=para><DIV CLASS=programlisting><P><PRE>s/(\S+)\s+(\S+)/$2 $1/</PRE></DIV><P CLASS=para>The right side of the substitution is really just a funny kind ofdouble-quoted string, which is why you can interpolate variables there,including backreference variables.  This is a powerful concept:interpolation (under controlled circumstances) is one of the reasonsPerl is a good text-processing language.  The other reason is the patternmatching, of course.  Regular expressions are good for picking things apart,and interpolation is good for putting things back together again.  Perhapsthere's hope for Humpty Dumpty after all.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch01_06.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch01_08.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Control Structures</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>List Processing</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>