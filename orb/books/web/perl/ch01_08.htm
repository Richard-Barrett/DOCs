<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 1] 1.8 List Processing</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 12:59:37 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch01_07.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 1</b></td><td width=172 align=right valign=top><A HREF="ch01_09.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-1-SECT-8">1.8 List Processing</A></h2><P CLASS=para><A NAME="CH01.LC"></A>Much earlier in this chapter, we mentioned that Perl has two maincontexts, scalar context (for dealing with singular things) and listcontext (for dealing with plural things).  Many of the traditionaloperators we've described so far have been strictly scalar in theiroperation.  They always take singular arguments (or pairs of singulararguments for binary operators), and always produce a singular result,even in a list context.  So if you write this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@array = (1 + 2, 3 - 4, 5 * 6, 7 / 8);</PRE></DIV><P CLASS=para>you know that the list on the right side contains exactly four values,because the ordinary math operators always produce scalar values, evenin the list context provided by the assignment to an array.<P CLASS=para>However, other Perl operators can produce either a scalar or alist value, depending on their context.  They just "know" whether ascalar or a list is expected of them.  But how will you know that?It turns out to be pretty easy to figure out, once you get your mindaround a few key concepts.<P CLASS=para>First, list context has to be provided by something in the"surroundings".  In the example above, the list assignment provides it.If you look at the various syntax summaries scattered throughout<A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A> and <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>, you'll see various operators that are defined to takea <tt CLASS=replaceable><i>LIST</i></tt> as an argument.Those are the operators that <I CLASS=emphasis>provide</I> a listcontext.  Throughout this book, <tt CLASS=replaceable><i>LIST</i></tt> is used as a specific technicalterm to mean "a syntactic construct that provides a list context".For example, if you look up <A HREF="ch03_02.htm#PERL2-CMD-SORT">sort</A>, you'll find the syntax summary:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sort <I CLASS=emphasis>LIST</I></PRE></DIV><P CLASS=para>That means that <A HREF="ch03_02.htm#PERL2-CMD-SORT">sort</A> provides a list context to its arguments.<P CLASS=para>Second, at compile time, any operator that takes a <tt CLASS=replaceable><i>LIST</i></tt> provides a listcontext to each syntactic element of that <tt CLASS=replaceable><i>LIST</i></tt>.  So every top-leveloperator or entity in the <tt CLASS=replaceable><i>LIST</i></tt> knows that it's supposed to produce thebest list it knows how to produce.  This means that if you say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sort @guys, @gals, other();</PRE></DIV><P CLASS=para>then each of <tt CLASS=literal>@guys</tt>, <tt CLASS=literal>@gals</tt>, and <tt CLASS=literal>other()</tt> knows that it's supposedto produce a list value.<P CLASS=para>Finally, at run-time, each of those <tt CLASS=replaceable><i>LIST</i></tt> elements produces its list inturn, and then (this is important) all the separate lists are joinedtogether, end to end, into a single list.  And that squashed-flat,one-dimensional list is what is finally handed off to thefunction that wanted a <tt CLASS=replaceable><i>LIST</i></tt> in the first place.  So if <tt CLASS=literal>@guys</tt>contains <tt CLASS=literal>(Fred,Barney)</tt>, <tt CLASS=literal>@gals</tt> contains <tt CLASS=literal>(Wilma,Betty)</tt>,and the <tt CLASS=literal>other()</tt> function returns the single-element list<tt CLASS=literal>(Dino)</tt>, then the <tt CLASS=replaceable><i>LIST</i></tt> thatsort sees is<P CLASS=para><DIV CLASS=programlisting><P><PRE>(Fred,Barney,Wilma,Betty,Dino)</PRE></DIV><P CLASS=para>and the <tt CLASS=replaceable><i>LIST</i></tt> that <B>sort</B> returns is<P CLASS=para><DIV CLASS=programlisting><P><PRE>(Barney,Betty,Dino,Fred,Wilma)</PRE></DIV><P CLASS=para>Some operators produce lists (like <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A>), some consume them (like<A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>), and some transform lists into other lists (like <A HREF="ch03_02.htm#PERL2-CMD-SORT">sort</A>).Operators in the last category can be considered filters; only, unlikein the shell, the flow of data is from right to left, since listoperators operate on their arguments passed in from the right.  You canstack up several list operators in a row:<P CLASS=para><DIV CLASS=programlisting><P><PRE>print reverse sort map {lc} keys %hash;</PRE></DIV><P CLASS=para>That takes the keys of <tt CLASS=literal>%hash</tt> and returns them to the <A HREF="ch03_02.htm#PERL2-CMD-MAP">map</A> function,which lowercases all the keys by applying the <A HREF="ch03_02.htm#PERL2-CMD-LC">lc</A> operator to each ofthem, and passes them to the <A HREF="ch03_02.htm#PERL2-CMD-SORT">sort</A> function, which sorts them, andpasses them to the <B>reverse</B> function, which reverses the order of thelist elements, and passes them to the <B>print</B> function, which prints them.<P CLASS=para>As you can see, that's much easier to describe in Perl than in English.</DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch01_07.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch01_09.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Regular Expressions</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>What You Don't Know Won't Hurt You (Much)</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>