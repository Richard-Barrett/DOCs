<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 2] 2.3 Terms</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:02:20 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_02.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 2</b></td><td width=172 align=right valign=top><A HREF="ch02_04.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3">2.3 Terms</A></h2><P CLASS=para>Now that we've talked about the kinds of data you can represent in Perl,we'd like to introduce you to the various kinds of terms you can useto pull that data into expressions.  We'll use the technical term<I CLASS=emphasis>term</I> when we want to talk in terms of these syntactic units.  (Hmm,this could get confusing.)  The first terms we'll talk about are<I CLASS=emphasis>variables</I>.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.1">Variables</A></h3><P CLASS=para><A NAME="CH02.VAR"></A>There are variable types corresponding to each of the three data typeswe mentioned. Each of these is introduced (grammatically speaking) bywhat we call a "funny character". Scalar variables are always namedwith an initial <tt CLASS=literal>$</tt>,even when referring to a scalar that is part of an array or hash.  It worksa bit like the English word "the". Thus, we have:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-1"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Construct</TH><TH ALIGN="LEFT">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>$days</tt></TD><TD ALIGN="LEFT">Simple scalar value <tt CLASS=literal>$days</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>$days[28]</tt></TD><TD ALIGN="LEFT">29th element of array <tt CLASS=literal>@days</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>$days{'Feb'}</tt></TD><TD ALIGN="LEFT">"<tt CLASS=literal>Feb</tt>" value from hash <tt CLASS=literal>%days</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>$#days</tt></TD><TD ALIGN="LEFT">Last index of array <tt CLASS=literal>@days</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>$days-&gt;[28]</tt></TD><TD ALIGN="LEFT"><P CLASS=para>29th element of array pointed to by reference <tt CLASS=literal>$days</tt></TD></TR></TABLE><P></DIV><P CLASS=para>Entire arrays or array slices (and also slices of hashes) are named with<tt CLASS=literal>@</tt>, which works much like the words "these" or "those":<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-2"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Construct</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>@days</tt></TD><TD ALIGN="left">Same as <tt CLASS=literal>($days[0], $days[1],... $days[n])</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>@days[3..5]</tt></TD><TD ALIGN="left">Same as <tt CLASS=literal>($days[3], $days[4], $days[5])</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>@days[3..5]</tt></TD><TD ALIGN="left">Same as <tt CLASS=literal>@days[3,4,5]</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>@days{'Jan','Feb'}</tt></TD><TD ALIGN="left">Same as <tt CLASS=literal>($days{'Jan'},$days{'Feb'})</tt></TD></TR></TABLE><P></DIV><P CLASS=para>Entire hashes are named by <tt CLASS=literal>%</tt>:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-3"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Construct</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>%days</tt></TD><TD ALIGN="left"><tt CLASS=literal>(Jan =&gt; 31, Feb =&gt; $leap ? 29 : 28, ...)</tt></TD></TR></TABLE><P></DIV><P CLASS=para>Any of these nine constructs may serve as an <I CLASS=emphasis>lvalue</I>,that is, they specify a location that you could assign a value to,among other things.[2]<blockquote class=footnote><P CLASS=para>[2]  Assignment itself is an <I CLASS=emphasis>lvalue</I>in certain contexts--see examples under <B>s///</B>, <A HREF="ch03_02.htm#PERL2-CMD-TR">tr///</A>,<B>chop</B>, and <B>chomp</B> in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.  </blockquote><P CLASS=para>In addition, subroutine calls are named with an initial <tt CLASS=literal>&amp;</tt>,although this is optional when it's otherwise unambiguous (just as "do" isoften redundant in English).  Symbol table entries can be named with aninitial <tt CLASS=literal>*</tt>, but you don't really care about that yet.<P CLASS=para>Every variable type has its own namespace.  You can, without fear ofconflict, use the same name for a scalar variable, an array, or a hash(or, for that matter, a filehandle, a subroutine name, a label, or yourpet llama).  This means that <tt CLASS=literal>$foo</tt> and <tt CLASS=literal>@foo</tt> are twodifferent variables.  It also means that <tt CLASS=literal>$foo[1]</tt> is an elementof <tt CLASS=literal>@foo</tt>, not a part of <tt CLASS=literal>$foo</tt>.  This may seem a bit weird,but that's okay, because it is weird.<P CLASS=para>Since variable names always start with <tt CLASS=literal>$</tt>, <tt CLASS=literal>@</tt>, or<tt CLASS=literal>%</tt>, the reserved words can't conflict with variable names.  Butthey can conflict with nonvariable identifiers, such as labels andfilehandles, which don't have aninitial funny character.  Since reserved words are always entirelylowercase, we recommend that you pick label and filehandle names that do notappear all in lowercase.  For example, you could say<tt CLASS=literal>open(LOG,'logfile')</tt> ratherthan the regrettable <tt CLASS=literal>open(log,'logfile')</tt>.[3]Using uppercase filehandles also improves readability and protects you fromconflict with future reserved words.<blockquote class=footnote><P CLASS=para>[3] Regrettable because <tt CLASS=literal>log</tt> is a predefined function returning the base <I CLASS=emphasis>e</I> logarithm of its argument, or of <tt CLASS=literal>$_</tt> if its argument is missing, as it is in this case.</blockquote><P CLASS=para>Case <I CLASS=emphasis>is</I> significant--<tt CLASS=literal>FOO</tt>,<tt CLASS=literal>Foo</tt> and <tt CLASS=literal>foo</tt> are all differentnames.  Names that start with a letter or underscore may be of anylength (well, 255 characters, at least) and may contain letters, digits, andunderscores.  Names that start with a digit may only contain moredigits.  Names that start with anything else are limited to that onecharacter (like <B>$?</B> or <B>$$</B>), and generally have a predefined significanceto Perl.  For example, just as in the Bourne shell, <B>$$</B> is the current process ID and <B>$?</B> the exit status of your last child process.<P CLASS=para>Sometimes you want to name something indirectly.  It is possible toreplace an alphanumeric name with an expression that returns a referenceto the actual variable (see <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>).</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.2">Scalar Values</A></h3><P CLASS=para><A NAME="CH02.SCALAR"></A>Whether it's named directly or indirectly, or is just a temporary valueon a stack, a scalar always contains a single value.  This value may bea number,[4]a string,[5]or a reference to another piece of data.  (Or there may be no value atall, in which case the scalar is said to be <I CLASS=emphasis>undefined</I>.) While we mightspeak of a scalar as "containing" a number or a string, scalars areessentially typeless; there's no way to declare a scalar to be of type"number" or "string".  Perl converts between the various subtypes asneeded, so you can treat a number as a string or a string as a number,and Perl will do the Right Thing.[6]<blockquote class=footnote><P CLASS=para>[4] Perl stores numbers as signed integers if possible, or as double-precisionfloating-point values in the machine's native format otherwise.Floating-point values are not infinitely precise.  This is veryimportant to remember, since comparisons like <tt CLASS=literal>(10/3 == 1/3*10)</tt> tend tofail mysteriously.<P CLASS=para>[5] Perl stores strings as sequences of bytes, with no arbitrary constraintson length or content.  In human terms, you don't have to decide inadvance how long your strings are going to get, and you can include anycharacters including null characters within your string.<P CLASS=para>[6] To convert from string to number, Perl uses C's <I CLASS=emphasis>atof</I> (3) function.  Toconvert from number to string, it does the equivalent of an<I CLASS=emphasis>sprintf</I> (3) with a format of <tt CLASS=literal>"%.14g"</tt> on most machines.</blockquote><P CLASS=para>While strings and numbers are interchangeable for nearly all intents and purposes, references are a bit different.  They're strongly typed,uncastable[7]pointers with built-in reference-counting and destructor invocation.You can use them to create complex data types, including user-definedobjects.  But they're still scalars, for all that.  See <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A> formore on references.<blockquote class=footnote><P CLASS=para>[7] By which we mean that you can't, for instance, convert a reference to anarray into a reference to a hash.  References are not castable to otherpointer types.  However, if you use a reference as a number or a string,you will get a numeric or string value, which is guaranteed to retain theuniqueness of the reference even though the "referenceness" of the valueis lost when the value is copied from the real reference.  You can comparesuch values or test whether they are defined.  But you can't do much else withthe values, since there's no way to convert numbers or strings intoreferences.  In general this is not a problem, since Perl doesn't force youto do pointer arithmetic--or even allow it.</blockquote><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.2.1">Numeric literals</A></h4><P CLASS=para>Numeric literals are specified in any of several customary[8]floating point or integer formats:<blockquote class=footnote><P CLASS=para>[8] Customary in UNIX culture, that is.  If you're from a different culture,welcome to ours!</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>12345               # integer12345.67            # floating point6.02E23             # scientific notation0xffff              # hexadecimal0377                # octal4_294_967_296       # underline for legibility</PRE></DIV><P CLASS=para>Since Perl uses the comma as a list separator, you cannot use it to delimitthe triples in a large number.  To improve legibility, Perl does allow youto use an underscore character instead.  The underscore onlyworks within literal numbers specified in your program, not for stringsfunctioning as numbers or data read from somewhere else.  Similarly, theleading <tt CLASS=literal>0x</tt> for hex and <tt CLASS=literal>0</tt> for octal work only for literals.The automatic conversion of a string to a number does not recognize theseprefixes--you must do an explicit conversion[9]with the <A HREF="ch03_02.htm#PERL2-CMD-OCT">oct</A> function (which works for hex-looking data, too, as ithappens).<blockquote class=footnote><P CLASS=para>[9] Sometimes people think Perl should convert all incoming data for them.  Butthere are far too many decimal numbers with leading zeroes in the worldto make Perl do this automatically.  For example, the zip code for O'Reilly&amp; Associates' office in Cambridge, MA is <tt CLASS=literal>02140</tt>.  The postmaster wouldget upset if your mailing label program turned <tt CLASS=literal>02140</tt> into <tt CLASS=literal>1120</tt>decimal.</blockquote></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.2.2">String literals</A></h4><P CLASS=para><A NAME="CH02.STRING"></A>String literals are usually delimited by either single or double quotes.They work much like UNIX shell quotes: double-quoted string literalsare subject to backslash and variable interpolation; single-quotedstrings are not (except for <tt CLASS=literal>\'</tt> and <tt CLASS=literal>\\</tt>, so that youcan put single quotes and backslashes into single-quoted strings).<P CLASS=para>You can also embed newlines directly in your strings; that is, they canbegin and end on different lines.  This is nice for many reasons,but it also means that if you forget a trailing quote, the error willnot be reported until Perl finds another line containing the quotecharacter, which may be much further on in the script.  Fortunately,this usually causes an immediate syntax error on the same line, and Perlis then smart enough to warn you that you might have a runaway string.<P CLASS=para>Note that a single-quoted string must be separated from a preceding word bya space, since a single quote is a valid (though deprecated) character inan identifier; see <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>.<P CLASS=para>With double-quoted strings, the usual C-style backslash rules apply forinserting characters such as newline, tab, and so on.  You may also specifycharacters in octal and hexadecimal, or as control characters:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-4"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Code</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\n</tt></TD><TD ALIGN="left">Newline</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\r</tt></TD><TD ALIGN="left">Carriage return</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\t</tt></TD><TD ALIGN="left">Horizontal tab</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\f</tt></TD><TD ALIGN="left">Form feed</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\b</tt></TD><TD ALIGN="left">Backspace</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\a</tt></TD><TD ALIGN="left">Alert (bell)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\e</tt></TD><TD ALIGN="left">ESC character</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\033</tt></TD><TD ALIGN="left">ESC in octal</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\x7f</tt></TD><TD ALIGN="left">DEL in hexadecimal</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\cC</tt></TD><TD ALIGN="left">Control-C</TD></TR></TABLE><P></DIV><P CLASS=para>In addition, there are escape sequences to modify the case of subsequentcharacters, as with the substitution operator in the <I CLASS=emphasis>vi</I> editor:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-5"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Code</TH><TH ALIGN="LEFT">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\u</tt></TD><TD ALIGN="LEFT">Force next character to uppercase.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\l</tt></TD><TD ALIGN="LEFT">Force next character to lowercase.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\U</tt></TD><TD ALIGN="LEFT">Force all following characters to uppercase.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\L</tt></TD><TD ALIGN="LEFT">Force all following characters to lowercase.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\Q</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Backslash all following non-alphanumeric characters.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\E</tt></TD><TD ALIGN="LEFT"><P CLASS=para>End <tt CLASS=literal>\U</tt>, <tt CLASS=literal>\L</tt>, or <tt CLASS=literal>\Q</tt>.</TD></TR></TABLE><P></DIV><P CLASS=para><P CLASS=para>Besides the backslash escapes listed above, double-quoted strings aresubject to <I CLASS=emphasis>variable interpolation</I> of scalar and list values.  This means that you can insert the values of certain variables directlyinto a string literal.  It's really just a handy form of stringconcatenation.Variable interpolation may only be done for scalar variables, entire arrays (but nothashes), single elements from an array or hash, or slices (multiplesubscripts) of an array or hash.  In other words, you may only interpolateexpressions that begin with <tt CLASS=literal>$</tt> or <tt CLASS=literal>@</tt>, because those are thetwo characters (along with backslash) that the string parser looks for.[10]Although a complete hash specified with a <tt CLASS=literal>%</tt> may not be interpolatedinto the string, single hash values and hash slices are okay, because theybegin with <tt CLASS=literal>$</tt> and <tt CLASS=literal>@</tt> respectively.<blockquote class=footnote><P CLASS=para>[10] Inside strings a literal <tt CLASS=literal>@</tt> that is not part of an array or sliceidentifier must be escaped with a backslash (<tt CLASS=literal>\@</tt>), or else acompilation errorwill result.  See <A HREF="ch09_01.htm">Chapter 9, <i>Diagnostic Messages</i></A>.</blockquote><P CLASS=para>The following code segment prints out: "<tt CLASS=literal>The price is $100.</tt>"<P CLASS=para><DIV CLASS=programlisting><P><PRE>$Price = '$100';                    # not interpolatedprint "The price is $Price.\n";     # interpolated</PRE></DIV><P CLASS=para>As in some shells, you can put braces around the identifier todistinguish it from following alphanumerics: <tt CLASS=literal>"How ${verb}able!"</tt>.In fact, an identifier within such braces isforced to be a string, as is any single identifier within a hash subscript.For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$days{'Feb'}</PRE></DIV><P CLASS=para>can be written as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$days{Feb}</PRE></DIV><P CLASS=para>and the quotes will be assumed automatically.  But anything more complicatedin the subscript will be interpreted as an expression.<P CLASS=para>Apart from the subscripts of interpolated array and hash variables,there are no multiple levels of interpolation.  In particular, contraryto the expectations of shell programmers, backquotes do notinterpolate within double quotes, nor do single quotes impede evaluationof variables when used within double quotes.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.2.3">Pick your own quotes</A></h4><P CLASS=para><A NAME="CH02.QUOTE"></A>While we usually think of quotes as literal values, in Perl theyfunction more like operators, providing various kinds of interpolatingand pattern matching capabilities.  Perl provides the customary quotecharacters for these behaviors, but also provides a way for you tochoose your quote character for any of them.<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-5A"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Customary</TH><TH ALIGN="left">Generic</TH><TH ALIGN="left">Meaning</TH><TH ALIGN="left">Interpolates</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>''</tt></TD><TD ALIGN="left"><tt CLASS=literal>q//</tt></TD><TD ALIGN="left">Literal</TD><TD ALIGN="left">No</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>""</tt></TD><TD ALIGN="left"><tt CLASS=literal>qq//</tt></TD><TD ALIGN="left">Literal</TD><TD ALIGN="left">Yes</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>``</tt></TD><TD ALIGN="left"><tt CLASS=literal>qx//</tt></TD><TD ALIGN="left">Command</TD><TD ALIGN="left">Yes</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>()</tt></TD><TD ALIGN="left"><tt CLASS=literal>qw//</tt></TD><TD ALIGN="left">Word list</TD><TD ALIGN="left">No</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>//</tt></TD><TD ALIGN="left"><tt CLASS=literal>m//</tt></TD><TD ALIGN="left">Pattern match</TD><TD ALIGN="left">Yes</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>s///</tt></TD><TD ALIGN="left"><tt CLASS=literal>s///</tt></TD><TD ALIGN="left">Substitution</TD><TD ALIGN="left">Yes</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>y///</tt></TD><TD ALIGN="left"><tt CLASS=literal>tr///</tt></TD><TD ALIGN="left">Translation</TD><TD ALIGN="left">No</TD></TR></TABLE><P></DIV><P CLASS=para>Some of these are simply forms of "syntactic sugar" to let you avoidputting too many backslashes into quoted strings.  Any non-alphanumeric,non-whitespace delimiter can be used in place of <tt CLASS=literal>/</tt>.[11]If the delimiters are single quotes, no variable interpolation is doneon the pattern. If the opening delimiter is a parenthesis, bracket, brace, or anglebracket, the closing delimiter will be the matching construct.(Embedded occurrences of the delimiters must match in pairs.)Examples:<blockquote class=footnote><P CLASS=para>[11] In particular, the newline and space characters are not allowed asdelimiters.  (Ancient versions of Perl allowed this.)</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>$single = q!I said, "You said, 'She said it.'"!;$double = qq(Can't we get some "good" $variable?);$chunk_of_code = q {    if ($condition) {        print "Gotcha!";    }};</PRE></DIV><P CLASS=para>Finally, for two-string constructs like <tt CLASS=literal>s///</tt> and <tt CLASS=literal>tr///</tt>, if thefirst pair of quotes is a bracketing pair, then the second part gets itsown starting quote character, which needn't be the same as the firstpair.  So you can write things like <tt CLASS=literal>s{foo}(bar)</tt> or <tt CLASS=literal>tr[a-z][A-Z]</tt>.Whitespace is allowed between the two inner quote characters, so youcould even write that last one as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>tr [a-z]   [A-Z];</PRE></DIV></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.2.4">Or leave the quotes out entirely</A></h4><P CLASS=para>A word that has no other interpretation in the grammar will be treated asif it were a quoted string.  These are known as <I CLASS=emphasis>barewords</I>.[12]For example:<blockquote class=footnote><P CLASS=para>[12] As with filehandles and labels, a bareword that consists entirely oflowercase letters risks conflict with future reserved words.  If you usethe <B>-w</B> switch, Perl will warn you about barewords.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>@days = (Mon,Tue,Wed,Thu,Fri);print STDOUT hello, ' ', world, "\n";</PRE></DIV><P CLASS=para>sets the array <tt CLASS=literal>@days</tt> to the short form of the weekdays and prints<tt CLASS=literal>hello world</tt> followed by a newline on <tt CLASS=literal>STDOUT</tt>.  If you leave thefilehandle out, Perl tries to interpret <tt CLASS=literal>hello</tt> as a filehandle,resulting in a syntax error.  Because this is so error-prone, some peoplemay wish to outlaw barewords entirely.  If you say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use strict 'subs';</PRE></DIV><P CLASS=para>then any bareword that would not be interpreted as a subroutine callproduces a compile-time error instead.  The restriction lasts to theend of the enclosing block.  An inner block may countermand this by saying:<P CLASS=para><DIV CLASS=programlisting><P><PRE>no strict 'subs';</PRE></DIV><P CLASS=para>Note that the bare identifiers in constructs like:<P CLASS=para><DIV CLASS=programlisting><P><PRE>"${verb}able"$days{Feb}</PRE></DIV><P CLASS=para>are not considered barewords, since they're allowed by explicit rulerather than by having "no other interpretation in the grammar".</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.2.5">Interpolating array values</A></h4><P CLASS=para>Array variables are interpolated into double-quoted strings by joining allthe elements of the array with the delimiter specified in the<B>$"</B> variable[13](which is a space by default).  The following are equivalent:<blockquote class=footnote><P CLASS=para>[13] <tt CLASS=literal>$LIST_SEPARATOR</tt> if you use the English library module.See <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>$temp = join($",@ARGV);print $temp;print "@ARGV";</PRE></DIV><P CLASS=para>Within search patterns (which also undergo double-quotish interpolation)there is a bad ambiguity:  Is <tt CLASS=literal>/$foo[bar]/</tt> to be interpreted as<tt CLASS=literal>/${foo}[bar]/</tt> (where <tt CLASS=literal>[bar]</tt> is a character class for the regularexpression) or as <tt CLASS=literal>/${foo[bar]}/</tt> (where <tt CLASS=literal>[bar]</tt> is thesubscript to array <tt CLASS=literal>@foo</tt>)?  If <tt CLASS=literal>@foo</tt> doesn't otherwise exist,then it's obviously a character class.  If <tt CLASS=literal>@foo</tt> exists, Perl takesa good guess about <tt CLASS=literal>[bar]</tt>, and is almost always right.[14]If it does guess wrong, or if you're just plain paranoid, you can force thecorrect interpretation with braces as above.  Even if you're merelyprudent, it's probably not a bad idea.<blockquote class=footnote><P CLASS=para>[14] The guesser is too boring to describe in full, but basically takes aweighted average of all the things that look like character classes(<tt CLASS=literal>a-z, \w,</tt> initial <tt CLASS=literal>^</tt>) versus things that look like expressions(variables or reserved words).</blockquote></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.2.6">"Here" documents</A></h4><P CLASS=para>A line-oriented form of quoting is based on the shell's <I CLASS=emphasis>here-document</I>syntax.[15]Following a <tt CLASS=literal>&lt;&lt;</tt> you specify a string to terminate thequoted material, and all lines following the current line down to theterminating string are quoted.  The terminating stringmay be either an identifier (a word), or some quoted text.  If quoted,the type of quote you use determines the treatment of the text, just asin regular quoting.  An unquoted identifier works like double quotes.There must be no space between the <tt CLASS=literal>&lt;&lt;</tt> and the identifier.  (Ifyou insert a space, it will be treated as a null identifier, which is validbut deprecated, and matches the first blank line--see the first <tt CLASS=literal>Hurrah!</tt>example below.)  The terminating string must appear by itself (unquotedand with no surrounding whitespace) on the terminating line.<blockquote class=footnote><P CLASS=para>[15] It's line-oriented in the sense that delimiters are lines rather thancharacters.  The starting delimiter is the current line, and the terminatingdelimiter is a line consisting of the string you specify.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>    print &lt;&lt;EOF;    # same as earlier example    The price is $Price.EOF    print &lt;&lt;"EOF";  # same as above, with explicit quotesThe price is $Price.EOF    print &lt;&lt;'EOF';    # single-quoted quoteAll things (e.g. a camel's journey throughA needle's eye) are possible, it's true.But picture how the camel feels, squeezed outIn one long bloody thread, from tail to snout.                                -- C.S. LewisEOF    print &lt;&lt; x 10;    # print next line 10 timesThe camels are coming!  Hurrah!  Hurrah!    print &lt;&lt;"" x 10;  # the preferred way to write thatThe camels are coming!  Hurrah!  Hurrah!    print &lt;&lt;`EOC`;    # execute commandsecho hi thereecho lo thereEOC    print &lt;&lt;"dromedary", &lt;&lt;"camelid"; # you can stack themI said bactrian.dromedaryShe said llama.camelid</PRE></DIV><P CLASS=para>Just don't forget that you have to put a semicolon on the end to finish the statement, as Perl doesn't know you're not going to try to do this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>print &lt;&lt;ABC179231ABC    + 20;   # prints 179251</PRE></DIV></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.2.7">Other literal tokens</A></h4><P CLASS=para>Two special literals are _ _<tt CLASS=literal>LINE</tt>_ _ and _ _<tt CLASS=literal>FILE</tt>_ _, which representthe current line number and filename at that point in your program.They may only be used as separate tokens; they will not be interpolatedinto strings.  In addition, the token _ _<tt CLASS=literal>END</tt>_ _ may be used to indicatethe logical end of the script before the actual end of file.  Anyfollowing text is ignored, but may be read via the <tt CLASS=literal>DATA</tt> filehandle.<P CLASS=para>The _ _<tt CLASS=literal>DATA</tt>_ _ token functions similarly to the _ _<tt CLASS=literal>END</tt>_ _ token, butopens the <tt CLASS=literal>DATA</tt> filehandle within the current package's namespace, so that<A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>d files can each have their own <tt CLASS=literal>DATA</tt> filehandles opensimultaneously.  For more information, see <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>.</DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.3">Context</A></h3><P CLASS=para><A NAME="CH02.CON"></A>Until now we've seen a number of terms that can produce scalar values.Before we can discuss terms further, though, we must come to termswith the notion of <I CLASS=emphasis>context</I>.<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.3.1">Scalar and list context</A></h4><P CLASS=para><P CLASS=para><A NAME="CH02.LCON"></A><A NAME="CH02.SCON"></A>Every operation[16]that you invoke in a Perl script is evaluated in aspecific context, and how that operation behaves may depend onthe requirements of that context.  There are two major contexts:<I CLASS=emphasis>scalar</I> and <I CLASS=emphasis>list</I>.  For example, assignment to a scalar variableevaluates the right-hand side in a scalar context, while assignment to anarray or a hash (or slice of either) evaluates the right-hand side in alist context.  Assignment to a list of scalars would also provide a listcontext to the right-hand side.<blockquote class=footnote><P CLASS=para>[16] Here we use the term "operation" loosely to mean either an operator or a term.The two concepts fuzz into each other when you start talking aboutfunctions that parse like terms but look like unary operators.</blockquote><P CLASS=para>You will be miserable until you learn the difference between scalar andlist context, because certain operators know which context they are in,and return lists in contexts wanting a list, and scalar values incontexts wanting a scalar.  (If this is true of an operation, it will bementioned in the documentation for that operation.)  In computer lingo,the functions are <I CLASS=emphasis>overloaded</I> on the type of their return value.  Butit's a very simple kind of overloading, based only on thedistinction between singular and plural values, and nothing else.<P CLASS=para>Other operations <I CLASS=emphasis>supply</I> the list contexts to their operands, and youcan tell which ones they are because they all have <tt CLASS=replaceable><i>LIST</i></tt> in theirsyntactic descriptions.  Generally it's quite intuitive.[17]If necessary, you can force a scalar context in the middle of a <tt CLASS=replaceable><i>LIST</i></tt> byusing the <A HREF="ch03_02.htm#PERL2-CMD-SCALAR">scalar</A> function.  (Perl provides no way to force a listcontext in a scalar context, because anywhere you would want a listcontext it's already provided by the <tt CLASS=replaceable><i>LIST</i></tt> of some controlling function.)<blockquote class=footnote><P CLASS=para>[17] Note, however, that the list context of a <tt CLASS=replaceable><i>LIST</i></tt> can propagate down through subroutine calls, so it's not always obvious by inspection whether agiven simple statement is going to be evaluated in a scalar or listcontext.  The program can find out its context within a subroutine byusing the <A HREF="ch03_02.htm#PERL2-CMD-WANTARRAY">wantarray</A> function.</blockquote><P CLASS=para>Scalar context can be further classified into string context, numericcontext, and don't-care context.  Unlike the scalar versus listdistinction we just made, operations never know which scalar contextthey're in.  They simply return whatever kind of scalar value they want to,and let Perl translate numbers to strings in string context, and strings tonumbers in numeric context.Some scalar contexts don't care whether a string or number is returned,so no conversion will happen.  (This happens, for example, when you areassigning the value to another variable.  The new variable just takeson the same subtype as the old value.)</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.3.2">Boolean context</A></h4><P CLASS=para>One special scalar context is called <I CLASS=emphasis>Boolean context</I>.  Boolean context issimply any place where an expression is being evaluated to see whether it'strue or false.  We sometimes write true and false when we meanthe technical definition that Perl uses: a scalar value istrue if it is not the null string or the number 0 (or its stringequivalent, <tt CLASS=literal>"0"</tt>).  References are always true.<P CLASS=para>A Boolean context is a don't-care context in the sense that it nevercauses any conversions to happen (at least, no conversions beyond whatscalar context would impose).<P CLASS=para>We said that a null string is false, but there are actuallytwo varieties of null scalars: defined and undefined.Boolean context doesn't distinguish between defined and undefinedscalars.  Undefined null scalars are returned when there is no realvalue for something, such as when there was an error, or at end offile, or when you refer to an uninitialized variable or element of anarray.  An undefined null scalar may become defined the first time youuse it as if it were defined, but prior to that you can use the<A HREF="ch03_02.htm#PERL2-CMD-DEFINED">defined</A> operator to determine whether the value is defined or not.(The return value of <A HREF="ch03_02.htm#PERL2-CMD-DEFINED">defined</A> is always defined, but not always true.)</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.3.3">Void context</A></h4><P CLASS=para>Another peculiar kind of scalar context is the <I CLASS=emphasis>void</I> context.  Thiscontext not only doesn't care what the return value is, it doesn't even<I CLASS=emphasis>want</I> a return value.  From the standpoint of how functions work, it'sno different from an ordinary scalar context.  But if you use the <B>-w</B>command-line switch, the Perl compiler will warn you if you use anexpression with no side effects in a place that doesn't want a value,such as in a statement that doesn't return a value.  For example, if youuse a string as a statement:<P CLASS=para><DIV CLASS=programlisting><P><PRE>"Camel Lot";</PRE></DIV><P CLASS=para>you may get a warning like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>Useless use of a constant in void context in myprog line 123;</PRE></DIV></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.3.4">Interpolative context</A></h4><P CLASS=para>We mentioned that double-quoted literal strings do backslashinterpretation and variable interpolation, but the interpolative context(often called "double-quote context") applies to more than justdouble-quoted strings.  Some other double-quotish constructs are thegeneralized backtick operator <tt CLASS=literal>qx//</tt>, the pattern match operator<tt CLASS=literal>m//</tt>, and the substitution operator <tt CLASS=literal>s///</tt>.  In fact, thesubstitution operator does interpolation on its left side before doing apattern match, and then does interpolation on its right side each timethe left side matches.<P CLASS=para>The interpolative context only happens inside quotes, or things thatwork like quotes, so perhaps it's not fair to call it a context inthe same sense as scalar and list context.  (Then again, maybe it is.)</DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.4">List Values and Arrays</A></h3><P CLASS=para><A NAME="CH02.LISTS"></A><A NAME="CH02.LVAL"></A><A NAME="CH02.ARRAY"></A>Now that we've talked about context, we can talk about list values, andhow they behave in context.List values are denoted by separating individual values by commas(and enclosing the list in parentheses where precedence requires it):<P CLASS=para><DIV CLASS=programlisting><P><PRE>(<tt CLASS=replaceable><i>LIST</i></tt>)</PRE></DIV><P CLASS=para>In a list context, the value of the list literal is all the values ofthe list in order.  In a scalar context, the value of a list literal isthe value of the final element, as with the C comma operator, whichalways throws away the value on the left and returns the value on theright.  (In terms of what we discussed earlier, the left side of thecomma operator provides a void context.)  For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@stuff = ("one", "two", "three");</PRE></DIV><P CLASS=para>assigns the entire list value to array <tt CLASS=literal>@stuff</tt>, but:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$stuff = ("one", "two", "three");</PRE></DIV><P CLASS=para>assigns only the value <tt CLASS=literal>three</tt> to variable <tt CLASS=literal>$stuff</tt>.  The comma operatorknows whether it is in a scalar or a list context.  An actualarray variable also knows its context.  In a list context, itwould return its entire contents, but in a scalar context it returns onlythe length of the array (which works out nicely if you mention thearray in a conditional).  The following assigns to <tt CLASS=literal>$stuff</tt> the value 3:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@stuff = ("one", "two", "three");$stuff = @stuff;      # $stuff gets 3, not "three"</PRE></DIV><P CLASS=para>Until now we've pretended that <tt CLASS=replaceable><i>LIST</i></tt>&nbsp;s are just lists of literals.But in fact, any expressions that return values may be used withinlists.  The values so used may either be scalar values or list values.<tt CLASS=replaceable><i>LIST</i></tt>&nbsp;s do automatic interpolation of sublists.That is, when a <tt CLASS=replaceable><i>LIST</i></tt> isevaluated, each element of the list is evaluated in a list context, andthe resulting list value is interpolated into <tt CLASS=replaceable><i>LIST</i></tt> just as if eachindividual element were a member of <tt CLASS=replaceable><i>LIST</i></tt>.  Thus arrays lose theiridentity in a <tt CLASS=replaceable><i>LIST</i></tt>.  The list:<P CLASS=para><DIV CLASS=programlisting><P><PRE>(@foo,@bar,&amp;SomeSub)</PRE></DIV><P CLASS=para>contains all the elements of <tt CLASS=literal>@foo</tt>, followed by all the elements of<tt CLASS=literal>@bar</tt>, followed by all the elements returned by the subroutine named<tt CLASS=literal>SomeSub</tt> when it's called in a list context.  You can use a referenceto an array if you do not want it to interpolate.  See <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>, yet again.<P CLASS=para>The null list is represented by <tt CLASS=literal>()</tt>.  Interpolating it in a list hasno effect.  Thus, <tt CLASS=literal>((),(),())</tt> is equivalent to <tt CLASS=literal>()</tt>.  Similarly, interpolatingan array with no elements is the same as if no array had been interpolatedat that point.<P CLASS=para>You may place an optional comma at the end of any list value.This makes it easy to come back later and add more elements.<P CLASS=para><DIV CLASS=programlisting><P><PRE>@numbers = (    1,    2,    3,);</PRE></DIV><P CLASS=para>Another way to specify a literal list is with the <B>qw</B> (quote words)syntax we mentioned earlier.  This construct is equivalent to splittinga single-quoted string on whitespace.  For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@foo = qw(    apple       banana      carambola    coconut     guava       kumquat    mandarin    nectarine   peach    pear        persimmon   plum);</PRE></DIV><P CLASS=para>(Note that those parentheses are behaving as quote characters, notordinary parentheses.  We could just as easily have picked anglebrackets or braces or slashes.)<P CLASS=para>A list value may also be subscripted like a normal array.  You must put thelist in parentheses (real ones) to avoid ambiguity.  Examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE># Stat returns list value.$modification_time = (stat($file))[8];# SYNTAX ERROR HERE.$modification_time = stat($file)[8];  # OOPS, FORGOT PARENS# Find a hex digit.$hexdigit = ('a','b','c','d','e','f')[$digit-10];# A "reverse comma operator".return (pop(@foo),pop(@foo))[0];</PRE></DIV><P CLASS=para>Lists may be assigned to if and only if each element of the listis legal to assign to:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($a, $b, $c) = (1, 2, 3);($map{red}, $map{green}, $map{blue}) = (0x00f, 0x0f0, 0xf00);</PRE></DIV><P CLASS=para>List assignment in a scalar context returns the number of elementsproduced by the expression on the right side of the assignment:<DIV CLASS=programlisting><P><PRE>$x = ( ($foo,$bar) = (7,7,7) );       # set $x to 3, not 2$x = ( ($foo,$bar) = f() );           # set $x to f()'s return count</PRE></DIV><P CLASS=para>This is handy when you want to do a list assignment in a Booleancontext, since most list functions return a null list when finished, whichwhen assigned produces a 0, which is interpreted as false. The final list element may be an array or a hash:<DIV CLASS=programlisting><P><PRE>($a, $b, @rest) = split;my ($a, $b, %rest) = @arg_list;</PRE></DIV><P CLASS=para>You can actually put an array or hash anywhere in the list you assignto, but the first one in the list will soak up all the values, andanything after it will get an undefined value.  This may be useful in a<A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> or <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>, where you probably want the arrays initializedto be empty anyway.<P CLASS=para>You may find the number of elements in the array <tt CLASS=literal>@days</tt> by evaluating <tt CLASS=literal>@days</tt> in a scalar context, such as:<DIV CLASS=programlisting><P><PRE>@days + 0;      # implicitly force @days into a scalar contextscalar(@days)   # explicitly force @days into a scalar context</PRE></DIV><P CLASS=para>Note that this only works for arrays.  It does not work for list valuesin general.  A comma-separated list evaluated in a scalar context will return the lastvalue, like the C comma operator.<P CLASS=para>Closely related to the scalar evaluation of <tt CLASS=literal>@days</tt> is <tt CLASS=literal>$#days</tt>.This will return the subscript of the last element of the array, or oneless than the length, since there is (ordinarily) a 0th element.[18]Assigning to <tt CLASS=literal>$#days</tt> changes the length of the array.  Shortening anarray by this method destroys intervening values.  You can gain somemeasure of efficiency by pre-extending an array that is going to get big.(You can also extend an array by assigning to an element that is off theend of the array.) You can truncate an array down to nothing by assigningthe null list <tt CLASS=literal>()</tt> to it.[19]The following two statements are equivalent:<blockquote class=footnote><P CLASS=para>[18] For historical reasons, the special variable <B>$[</B> can be used to changethe array base.  Its use is not recommended, however.  In fact, this isthe last we'll even mention it.  Just don't use it.<P CLASS=para>[19] In the current version of Perl, re-extending a truncated array doesnot recover the values in the array.  (It did in earlier versions.)</blockquote><DIV CLASS=programlisting><P><PRE>@whatever = ();$#whatever = -1;</PRE></DIV><P CLASS=para>And the following is always true:[20]<blockquote class=footnote><P CLASS=para>[20] Unless you've diddled the deprecated <B>$[</B>variable. Er, <I CLASS=emphasis>this</I> is the last time we'll mentionit . . .</blockquote><DIV CLASS=programlisting><P><PRE>scalar(@whatever) == $#whatever + 1;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.5">Hashes (Associative Arrays)</A></h3><P CLASS=para>As we indicated previously, a hash is just a funny kind of array in whichyou look values up using key strings instead of numbers.  It definesassociations between keys and values, so hashes are often calledassociative arrays.<P CLASS=para>There really isn't any such thing as a hash literal in Perl, butif you assign an ordinary list to a hash, each pair of values in thelist will be taken to indicate one key/value association:<P CLASS=para><DIV CLASS=programlisting><P><PRE>%map = ('red',0x00f,'green',0x0f0,'blue',0xf00);</PRE></DIV><P CLASS=para>This has the same effect as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>%map = ();            # clear the hash first$map{red}   = 0x00f;$map{green} = 0x0f0;$map{blue}  = 0xf00;</PRE></DIV><P CLASS=para>It is often more readable to use the <tt CLASS=literal>=&gt;</tt> operator between key/valuepairs.  The <tt CLASS=literal>=&gt;</tt> operator is just a synonym for a comma, but it'smore visually distinctive, and it also quotes any bare identifiers tothe left of it (just like the identifiers in braces above), which makesit nice for initializing hash variables:<P CLASS=para><DIV CLASS=programlisting><P><PRE>%map = (    red   =&gt; 0x00f,    green =&gt; 0x0f0,    blue  =&gt; 0xf00,);</PRE></DIV><P CLASS=para>or for initializing anonymous hash references to be used as records:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$rec = {    witch =&gt; 'Mable the Merciless',    cat   =&gt; 'Fluffy the Ferocious',    date  =&gt; '10/31/1776',};</PRE></DIV><P CLASS=para>or for using call-by-named-parameter to invoke complicated functions:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$field = $query-&gt;radio_group(                     NAME      =&gt; 'group_name',                    VALUES    =&gt; ['eenie','meenie','minie'],                    DEFAULT   =&gt; 'meenie',                    LINEBREAK =&gt; 'true',                    LABELS    =&gt; \%labels,                );</PRE></DIV><P CLASS=para>But we're getting ahead of ourselves.  Back to hashes.<P CLASS=para>You can use a hash variable (<tt CLASS=literal>%hash</tt>) in a list context, in which case itinterpolates all the key/value pairs into the list.  But just becausethe hash was initialized in a particular order doesn't mean that thevalues come back in that order.  Hashes are implemented internally usinghash tables for speedy lookup, which means that the order in whichentries are stored is dependent on the nature of the hash function usedto calculate positions in the hash table, and not on anythinginteresting.  So the entries come back in a seemingly random order.(The two elements of each key/value pair come out in the right order, ofcourse.)  For examples of how to arrange for an output ordering, see the <B>keys</B> entry in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>, or <tt CLASS=literal>DB_BTREE</tt>description in the DB_File documentation in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.<P CLASS=para>If you evaluate a hash variable in a scalar context, it returns a valuethat is true if and only if the hash contains any key/value pairs.  (Ifthere are any key/value pairs, the value returned is a string consistingof the number of used buckets and the number of allocated buckets,separated by a slash.  This is pretty much only useful to find outwhether Perl's (compiled in) hashing algorithm is performing poorly onyour data set.  For example, you stick 10,000 things in a hash, butevaluating <tt CLASS=literal>%HASH</tt> in scalar context reveals "<tt CLASS=literal>1/8</tt>", which means onlyone out of eight buckets has been touched, and presumably that onebucket contains all 10,000 of your items.  This isn't supposed tohappen.)</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.6">Typeglobs and Filehandles</A></h3><P CLASS=para>Perl uses an internal type called a <I CLASS=emphasis>typeglob</I> to hold an entiresymbol table entry.  The type prefix of a typeglob is a <tt CLASS=literal>*</tt>, becauseit represents all types.  This used to be the preferred way to pass arrays and hashes by reference into a function, but now thatwe have real references, this mechanism is seldom needed.<P CLASS=para>Typeglobs (or references thereto) are still usedfor passing or storing filehandles.  If you want to save awaya filehandle, do it this way:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$fh = *STDOUT;</PRE></DIV><P CLASS=para>or perhaps as a real reference, like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$fh = \*STDOUT;</PRE></DIV><P CLASS=para>This is also the way to create a local filehandle.  For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub newopen {    my $path = shift;    local *FH;  # not my!    open (FH, $path) || return undef;    return *FH;}$fh = newopen('/etc/passwd');</PRE></DIV><P CLASS=para>See the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> entry in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A> andthe FileHandle module in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>, for how togenerate new filehandles.<P CLASS=para>But the main use of typeglobs nowadays is to alias one symbol tableentry to another symbol table entry.  If you say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>*foo = *bar;</PRE></DIV><P CLASS=para>it makes everything named "<tt CLASS=literal>foo</tt>" a synonym for every correspondingthing named "<tt CLASS=literal>bar</tt>".  You can alias just one of the variables in atypeglob by assigning a reference instead:<P CLASS=para><DIV CLASS=programlisting><P><PRE>*foo = \$bar;</PRE></DIV><P CLASS=para>makes <tt CLASS=literal>$foo</tt> an alias for <tt CLASS=literal>$bar</tt>,but doesn't make <tt CLASS=literal>@foo</tt> an alias for<tt CLASS=literal>@bar</tt>, or <tt CLASS=literal>%foo</tt> an alias for<tt CLASS=literal>%bar</tt>.  Aliasing variables like this may seem like asilly thing to want to do, but it turns out that the entire moduleexport/import mechanism is built around this feature, since there'snothing that says the symbol you're aliasing has to be in yournamespace.  See <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A> and <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A> for more discussion on typeglobs.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.7">Input Operators</A></h3><P CLASS=para><A NAME="CH02.IO"></A>There are several input operators we'll discuss here because they parseas terms.  In fact, sometimes we call them pseudo-literals because theyact like quoted strings in many ways.  (Output operators like <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>parse as list operators and are discussed in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.)<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.7.1">Command input (backtick) operator</A></h4><P CLASS=para>First of all, we have the command input operator, also known as thebackticks operator, because it looks like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$info = `finger $user`;</PRE></DIV><P CLASS=para>A string enclosed by backticks (grave accents) first undergoesvariable interpolation just like a double-quoted string.  The result ofthat is then interpreted as a command by the shell, and the output ofthat command becomes the value of the pseudo-literal.  (This is modeledafter a similar operator in some of the UNIX shells.)  In scalarcontext, a single string consisting of all the output is returned.  Inlist context, a list of values is returned, one for each line of output.(You can set <B>$/</B> to use a different line terminator.)<P CLASS=para>The command is executed each time the pseudo-literal is evaluated.The numeric status value of the command is saved in <B>$?</B> (see the section"Special Variables" later in this chapter for the interpretation of <B>$?</B>).  Unlike the <I CLASS=emphasis>csh</I> versionof this command, no translation is done on the returndata--newlines remain newlines.  Unlike any of the shells, singlequotes do not hide variable names in the command from interpretation.To pass a <tt CLASS=literal>$</tt> through to the shell you need to hideit with a backslash.  The <tt CLASS=literal>$user</tt> in our exampleabove is interpolated by Perl, not by the shell.  (Because the commandundergoes shell processing, see <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>, forsecurity concerns.)<P CLASS=para>The generalized form of backticks is <tt CLASS=literal>qx//</tt> (for "quoted execution"), butthe operator works exactly the same way as ordinary backticks.  You justget to pick your quote characters.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.7.2">Line input (angle) operator</A></h4><P CLASS=para><A NAME="CH02.AB1"></A><A NAME="CH02.AB2"></A><A NAME="CH02.AO"></A>The most heavily used input operator is the line input operator, alsoknown as the angle operator.Evaluating a filehandle in angle brackets (<tt CLASS=literal>&lt;STDIN&gt;</tt>, for example)yields the next line from the associatedfile.  (The newline is included, so according to Perl's criteria fortruth, a freshly input line is always true, up until end of file, atwhich point an undefined value is returned, which is false.)  Ordinarilyyou would assign the input value to a variable, but there is one situationwhere an automatic assignment happens.  If and only if the line inputoperator is the only thing inside the conditional of a <B>while</B> loop, thevalue is automatically assigned to the special variable <B>$_</B>.  The assignedvalue isthen tested to see whether it is defined.  (This may seem like an odd thing toyou, but you'll use the construct in almost every Perl script you write.)Anyway, the following lines are equivalent to each other:<P CLASS=para><DIV CLASS=programlisting><P><PRE>while (defined($_ = &lt;STDIN&gt;)) { print $_; }   # the long waywhile (&lt;STDIN&gt;) { print; }                    # the short wayfor (;&lt;STDIN&gt;;) { print; }                    # while loop in disguiseprint $_ while defined($_ = &lt;STDIN&gt;);         # long statement modifierprint while &lt;STDIN&gt;;                          # short statement modifier</PRE></DIV><P CLASS=para>Remember that this special magic requires a <B>while</B> loop.  If you usethe input operator anywhere else, you must assign the result explicitlyif you want to keep the value:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if (&lt;STDIN&gt;)      { print; }   # WRONG, prints old value of $_if ($_ = &lt;STDIN&gt;) { print; }   # okay</PRE></DIV><P CLASS=para>The filehandles <tt CLASS=literal>STDIN</tt>, <tt CLASS=literal>STDOUT</tt>, and <tt CLASS=literal>STDERR</tt>are predefined and pre-opened.[21]Additional filehandles may be created with the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> function.  Seethe <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> entry in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A> for details on this.  Someobject modules also create object references that can be used as filehandles.See the FileHandle module in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.<blockquote class=footnote><P CLASS=para>[21] The filehandles <tt CLASS=literal>stdin</tt>, <tt CLASS=literal>stdout</tt>, and <tt CLASS=literal>stderr</tt>will also work except in packages, where they would be interpreted aslocal identifiers rather than global.  They're only there forcompatibility with very old scripts, so use the uppercase versions.</blockquote><P CLASS=para>In the <B>while</B> loops above, we were evaluating the line input operator ina scalar context, so it returned each line separately.  However,if you use it in a list context, alist consisting of all the remaining input lines is returned, one lineper list element.  It's easy to make a <I CLASS=emphasis>large</I> data space this way, souse this feature with care:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$one_line = &lt;MYFILE&gt;;   # Get first line.@all_lines = &lt;MYFILE&gt;;  # Get the rest of the lines.</PRE></DIV><P CLASS=para>There is no <B>while</B> magic associated with the list form of the inputoperator, because the condition of a <B>while</B> loop is always a scalarcontext (as is any conditional).<P CLASS=para>Using the null filehandle within the angle operator is special and can be used toemulate the command-line behavior of typical UNIX filter programs such as<I CLASS=emphasis>sed</I> and <I CLASS=emphasis>awk</I>.  When you readlines from <tt CLASS=literal>&lt;&gt;</tt>, it magically gives you all thelines from all the files mentioned on the command line.  If no fileswere mentioned, it gives you standard input instead, so your programis easy to insert into the middle of a pipeline of processes.<P CLASS=para>Here's how it works: the first time <tt CLASS=literal>&lt;&gt;</tt> isevaluated, the <B>@ARGV</B> array is checked,and if it is null, <tt CLASS=literal>$ARGV[0]</tt> is set to "<tt CLASS=literal>-</tt>", whichwhen opened gives you standard input.  The <B>@ARGV</B> array is then processed as a list offilenames.  The loop:<P CLASS=para><DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    ...                     # code for each line}</PRE></DIV><P CLASS=para>is equivalent to the following Perl-like pseudocode:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@ARGV = ('-') unless @ARGV;while ($ARGV = shift) {    open(ARGV, $ARGV) or warn "Can't open $ARGV: $!\n";    while (&lt;ARGV&gt;) {        ...         # code for each line    }}</PRE></DIV><P CLASS=para>except that it isn't so cumbersome to say, and will actually work.  Itreally does shift array <B>@ARGV</B> and putthe current filename into variable <tt CLASS=literal>$ARGV</tt>.  It alsouses filehandle <B>ARGV</B>internally--<tt CLASS=literal>&lt;&gt;</tt> is just a synonym for<tt CLASS=literal>&lt;ARGV&gt;</tt>, which is magical.  (The pseudocodeabove doesn't work because it treats <tt CLASS=literal>&lt;ARGV&gt;</tt>as non-magical.)<P CLASS=para>You can modify <B>@ARGV</B> before the first<tt CLASS=literal>&lt;&gt;</tt> as long as the array ends up containingthe list of filenames you really want.  Line numbers (<B>$.</B>) continue as if the input were one big happyfile.  (But see the example under <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A> forhow to reset line numbers on each file.)<P CLASS=para>If you want to set <B>@ARGV</B> to your own list of files, go right ahead.If you want to pass switches into your script, you can use one of theGetopts modules or put a loop on the front like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>while ($_ = $ARGV[0], /^-/) {    shift;    last if /^--$/;    if (/^-D(.*)/) { $debug = $1 }    if (/^-v/)     { $verbose++  }    ...             # other switches}while (&lt;&gt;) {    ...             # code for each line}</PRE></DIV><P CLASS=para>The <tt CLASS=literal>&lt;&gt;</tt> symbol will return false only once.  If you call it again afterthis it will assume you are processing another <B>@ARGV</B> list, and if youhaven't set <B>@ARGV</B>, it will input from <tt CLASS=literal>STDIN</tt>.<P CLASS=para>If the string inside the angle brackets is a scalarvariable (for example, <tt CLASS=literal>&lt;$foo&gt;</tt>),then that variable contains the name of thefilehandle to input from, or a reference to the same.  For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$fh = \*STDIN;$line = &lt;$fh&gt;;</PRE></DIV></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-3.7.3">Filename globbing operator</A></h4><P CLASS=para><A NAME="CH02.GF"></A><A NAME="CH02.GO"></A><A NAME="CH02.ABG1"></A><A NAME="CH02.ABG2"></A>You might wonder what happens to a line input operator if you put somethingfancier inside the angle brackets.  What happens is that it mutates intoa different operator.If the string inside the angle brackets is anything other than afilehandle name or a scalar variable (even if there are just extra spaces),it is interpreted as a filename pattern to be "globbed".[22]The pattern is matched against the files in the current directory (orthe directory specified as part of the glob pattern), and the filenamesso matched are returned by the operator.  As with line input, thenames are returned one at a time in scalar context, or all at oncein list context.  In fact, the latter usage is more prevalent.  Yougenerally see things like:<blockquote class=footnote><P CLASS=para>[22] This has nothing to do with the previously mentioned typeglobs, other thanthat they both use the <tt CLASS=literal>*</tt> character in a wildcard fashion.  The<tt CLASS=literal>*</tt> character has the nickname "glob" when used like this.  With typeglobsyou're globbing symbols with the same name from the symbol table.  Witha filename glob, you're doing wildcard matching on the filenames ina directory, just as the various shells do.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>my @files = &lt;*.html&gt;;</PRE></DIV><P CLASS=para>As with other kinds of pseudo-literals, one level of variableinterpolation is done first, but you can't say <tt CLASS=literal>&lt;$foo&gt;</tt> becausethat's an indirect filehandle as explained earlier.(In older version of Perl, programmers would insert braces toforce interpretation as a filename glob: <tt CLASS=literal>&lt;${foo}&gt;</tt>.  These days,it's considered cleaner to call the internal function directly as<tt CLASS=literal>glob($foo)</tt>, which is probably the right way to have invented it in thefirst place.)<P CLASS=para>Whether you use the <A HREF="ch03_02.htm#PERL2-CMD-GLOB">glob</A> function orthe old angle-bracket form, the globbing operator also does <B>while</B> magic like the line input operator, andassigns the result to <B>$_</B>.  For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>while (&lt;*.c&gt;) {    chmod 0644, $_;}</PRE></DIV><P CLASS=para>is equivalent to:<P CLASS=para><DIV CLASS=programlisting><P><PRE>open(FOO, "echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|");while (&lt;FOO&gt;) {    chop;    chmod 0644, $_;}</PRE></DIV><P CLASS=para>In fact, it's currently implemented that way, more or less.  (Whichmeans it will not work on filenames with spaces in them unless you have<I CLASS=emphasis>csh</I> (1) on your machine.)  Of course, the shortest way to do theabove is:<P CLASS=para><DIV CLASS=programlisting><P><PRE>chmod 0644, &lt;*.c&gt;;</PRE></DIV><P CLASS=para>Because globbing invokes a subshell, it's often faster to call<A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A> yourself and just do your own<A HREF="ch03_02.htm#PERL2-CMD-GREP">grep</A> on the filenames.  Furthermore,due to its current implementation of using a shell, the <A HREF="ch03_02.htm#PERL2-CMD-GLOB">glob</A> routine may get "<tt CLASS=literal>Arg list too long</tt>" errors(unless you've installed <I CLASS=emphasis>tcsh</I> (1) as<I CLASS=emphasis>/bin/csh</I>).<P CLASS=para>A glob evaluates its (embedded) argument only when it is starting a newlist.  All values must be read before it will start over.  In a listcontext this isn't important, because you automatically get them allanyway.  In a scalar context, however, the operator returns the next valueeach time it is called, or a false value if you've just run out.  Again,false is returned only once.  So if you're expecting a single value froma glob, it is much better to say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($file) = &lt;blurch*&gt;;  # list context</PRE></DIV><P CLASS=para>than to say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$file = &lt;blurch*&gt;;    # scalar context</PRE></DIV><P CLASS=para>because the former slurps all the matched filenames and resets theoperator, while the latter will alternate between returning a filenameand returning false.<P CLASS=para>It you're trying to do variable interpolation, it's definitely betterto use the <A HREF="ch03_02.htm#PERL2-CMD-GLOB">glob</A> operator, because theolder notation can cause people to become confused with the indirectfilehandle notation.  But with things like this, it begins to becomeapparent that the borderline between terms and operators is a bitmushy:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@files = glob("$dir/*.[ch]");   # call glob as function@files = glob $some_pattern;    # call glob as operator</PRE></DIV><P CLASS=para>We left the parentheses off of the second example to illustrate that<A HREF="ch03_02.htm#PERL2-CMD-GLOB">glob</A> can be used as a<I CLASS=emphasis>unary</I> operator; that is, a prefix operator thattakes a single argument.  The <A HREF="ch03_02.htm#PERL2-CMD-GLOB">glob</A>operator is an example of a <I CLASS=emphasis>named unary operator</I>,which is just one of the kinds of operators we'll talk about in thesection "Operators" later in this chapter.  But first we're going to talk about patternmatching operations, which also parse like terms but operate likeoperators.</DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_02.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch02_04.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Built-in Data Types</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Pattern Matching</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>