<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 2] 2.4 Pattern Matching</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:02:38 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_03.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 2</b></td><td width=172 align=right valign=top><A HREF="ch02_05.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-4">2.4 Pattern Matching</A></h2><P CLASS=para><A NAME="CH02.PAT"></A>The two main pattern matching operators are <tt CLASS=literal>m//</tt>,the match operator, and <tt CLASS=literal>s///</tt>, the substitutionoperator.  There is also a <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A>operator, which takes an ordinary match operator as its first argumentbut otherwise behaves like a function, and is therefore documented in<A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.<P CLASS=para>Although we write <tt CLASS=literal>m//</tt> and <tt CLASS=literal>s///</tt> here, you'll recall that you canpick your own quote characters.  On the other hand, for the <tt CLASS=literal>m//</tt>operator only, the <tt CLASS=literal>m</tt> may be omitted if the delimiters you pick are infact slashes.  (You'll often see patterns written this way, forhistorical reasons.)<P CLASS=para>Now that we've gone to all the trouble of enumerating these weird,quote-like operators, you mightwonder what it is we've gone to all the trouble of quoting.  The answeris that the string inside the quotes specifies a <I CLASS=emphasis>regular expression</I>.We'll discuss regular expressions in the next section, because there's a lotto discuss.<P CLASS=para>The matching operations can have various modifiers, some of which affectthe interpretation of the regular expression inside:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-6"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Modifier</TH><TH ALIGN="LEFT">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>i</tt></TD><TD ALIGN="LEFT">Do case-insensitive pattern matching.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>m</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Treat string as multiple lines (<tt CLASS=literal>^</tt>and <tt CLASS=literal>$</tt> match internal <tt CLASS=literal>\n</tt>).</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>s</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Treat string as single line (<tt CLASS=literal>^</tt> and <tt CLASS=literal>$</tt> ignore <tt CLASS=literal>\n</tt>, but <tt CLASS=literal>.</tt>matches <tt CLASS=literal>\n</tt>).</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>x</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Extend your pattern's legibility with whitespace and comments.</TD></TR></TABLE><P></DIV><P CLASS=para>These are usually written as "the <B>/x</B> modifier", even though thedelimiter in question might not actually be a slash.  In fact, any ofthese modifiers may also be embedded within the regular expressionitself using the <tt CLASS=literal>(?...)</tt> construct.  See the section"Regular Expression Extensions" later in this chapter.<P CLASS=para>The <B>/x</B> modifier itself needs a little more explanation.  It tellsthe regular expression parser to ignore whitespace that is notbackslashed or within a character class.  You can use this modifier to break upyour regular expression into (slightly) more readable parts.  The <tt CLASS=literal>#</tt>character is also treated as a metacharacter introducing a comment,just as in ordinary Perl code.  Taken together, these features go along way toward making Perl a readable language.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-4.1">Regular Expressions</A></h3><P CLASS=para><A NAME="CH02.RE"></A>The regular expressions used in the pattern matching and substitutionoperators are syntactically similar to those used by the UNIX <I CLASS=emphasis>egrep</I> program.  Whenyou write a regular expression, you're actually writing a grammar for alittle language.  The regular expression interpreter (which we'll callthe Engine) takes your grammar and compares it to the string you'redoing pattern matching on.  If some portion of the string can be parsedas a sentence of your little language, it says "yes".  If not, it says"no".<P CLASS=para>What happens after the Engine has said "yes" depends on how you invokedit.  An ordinary pattern match is usually used as a conditionalexpression, in which case you don't care <I CLASS=emphasis>where</I> it matched, only<I CLASS=emphasis>whether</I> it matched.  (But you can also find out where it matched ifyou need to know that.)  A substitution command will take the part thatmatched and replace it with some other string of your choice.  And the<A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> operator will return (as alist) all the places your pattern didn't match.<P CLASS=para>Regular expressions are powerful, packing a lot of meaning into ashort space.  They can therefore be quite daunting if you try tointuit the meaning of a large regular expression as a whole.  But if youbreak it up into its parts, and if you know how the Engine interpretsthose parts, you can understand any regular expression.<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-4.1.1">The regular expression bestiary</A></h4><P CLASS=para>Before we dive into the rules for interpreting regular expressions,let's take a look at some of the things you'll see in regular expressions.First of all, you'll see literal strings.  Most characters[23]in a regular expression simply match themselves.  If you string severalcharacters in a row, they must match in order, just as you'd expect.  Soif you write the pattern match:<blockquote class=footnote><P CLASS=para>[23] In this section we are misusing the term "character" to mean "byte".So far, Perl only knows about byte-sized characters, but this willchange someday, at which point "character" will be a more appropriateword.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>/Fred/</PRE></DIV><P CLASS=para>you can know that the pattern won't match unless the string containsthe substring "<tt CLASS=literal>Fred</tt>" somewhere.<P CLASS=para>Other characters don't match themselves, but are <I CLASS=emphasis>metacharacters</I>.(Before we explain what metacharacters do, we should reassureyou that you can always match such a character literally by putting abackslash in front of it.  For example, backslash is itself ametacharacter, so to match a literal backslash, you'd backslash thebackslash: <tt CLASS=literal>\\</tt>.)  The list of metacharacters is:<P CLASS=para><DIV CLASS=programlisting><P><PRE>\ | ( ) [  {  ^ $ * + ? .</PRE></DIV><P CLASS=para>We said that backslash turns a metacharacter into a literal character,but it does the opposite to an alphanumeric character: it turnsthe literal character into a sort of metacharacter or sequence.  Sowhenever you see a two-character sequence:<DIV CLASS=programlisting><P><PRE>\b \D \t \3 \s</PRE></DIV><P CLASS=para>you'll know that the sequence matches something strange.  A <tt CLASS=literal>\b</tt>matches a word boundary, for instance, while <tt CLASS=literal>\t</tt> matches an ordinarytab character.  Notice that a word boundary is zero characters wide,while a tab character is one character wide.  Still, they're alike inthat they both assert that something is true about a particular spotin the string.  Most of the things in a regular expression fall into theclass of assertions, including the ordinary characters that simplyassert that they match themselves.  (To be precise, they also assertthat the next thing will match one character later in the string, whichis why we talk about the tab character being "one character wide".  Someassertions eat up some of the string as they match, and others don't.But we usually reserve the term "assertion" for the zero-widthassertions.  We'll call these assertions with nonzero width <I CLASS=emphasis>atoms</I>.)You'll also see some things that aren't assertions.  Alternation is indicatedwith a vertical bar:<DIV CLASS=programlisting><P><PRE>/Fred|Wilma|Barney|Betty/</PRE></DIV><P CLASS=para>That means that any of those strings can trigger a match.Grouping of various sorts is done with parentheses, including groupingof alternating substrings within a longer regular expression:<DIV CLASS=programlisting><P><PRE>/(Fred|Wilma|Pebbles) Flintstone/</PRE></DIV><P CLASS=para>Another thing you'll see are what we call quantifiers.  They say how manyof the previous thing should match in a row.  Quantifiers look like:<DIV CLASS=programlisting><P><PRE>* + ? *? {2,5}</PRE></DIV><P CLASS=para>Quantifiers only make sense when attached to atoms, that is, assertionsthat have width.  Quantifiers attach only to the previous atom, which inhuman terms means they only quantify one character.  So if you want tomatch three copies of "<tt CLASS=literal>moo</tt>" in a row, you need to group the"<tt CLASS=literal>moo</tt>" withparentheses, like this:<DIV CLASS=programlisting><P><PRE>/(moo){3}/</PRE></DIV><P CLASS=para>That will match "<tt CLASS=literal>moomoomoo</tt>".  If you'd said <tt CLASS=literal>/moo{3}/</tt>, itwould only have matched "<tt CLASS=literal>moooo</tt>".<P CLASS=para>Since patterns are processed as double-quoted strings, the normaldouble-quoted interpolations will work.  (See "String Literals" earlier inthis chapter.)  These are applied before the string is interpreted asa regular expression.  One caveat though: any <tt CLASS=literal>$</tt> immediately followedby a vertical bar, closing parenthesis, or the end of the string willbe interpreted as an end-of-line assertion rather than a variableinterpolation.  So if you say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$foo = "moo";/$foo$/;</PRE></DIV><P CLASS=para>it's equivalent to saying:<P CLASS=para><DIV CLASS=programlisting><P><PRE>/moo$/;</PRE></DIV><P CLASS=para>You should also know that interpolating variables into a pattern slowsdown the pattern matcher considerably, because it feels it needs to recompile thepattern each time through, since the variable might have changed.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-4.1.2">The rules of regular expression matching</A></h4><P CLASS=para><A NAME="CH02.OREM"></A><A NAME="CH02.REMO"></A><A NAME="CH02.PMO"></A>Now that you've seen some of the things you'll be seeing, we'll lay outthe rules that the Engine uses to match your pattern against the string.The Perl Engine uses a nondeterministic finite-state automaton (NFA) tofind a match.  That just means that it keeps track of what it has triedand what it hasn't, and when something doesn't pan out, it backs up andtries something else.  This is called<I CLASS=emphasis>backtracking</I>.  The Perl Engine is capable oftrying a million things at one spot, then giving up on all those,backing up to within one choice of the beginning, and trying the millionthings again at a different spot.  If you're cagey, you can writeefficient patterns that don't do a lot of silly backtracking.<P CLASS=para>The order of the rules below specifies which order the Engine triesthings.  So when someone trots out a stock phrase like "left-most,longest match", you'll know that overall Perl prefers left-most overlongest.  But the Engine doesn't realize it's preferring anything atthat level.  The global preferences result from a lot of localizedchoices.  The Engine thinks locally and acts globally.<P CLASS=para><B>Rule 1.</B>  The Engine tries to match as far left in the stringas it can, such that the entire regular expression matches under Rule 2.<P CLASS=para>In order to do this, its first choice is to start just before the firstcharacter (it could have started anywhere), and to try to match theentire regular expression at that point.  The regular expression matchesif and only if Engine reaches the end of the regular expression beforeit runs off the end of the string.  If it matches, it quitsimmediately--it doesn't keep looking for a "better" match, even thoughthe regular expression could match in many different ways.  The matchonly has to reach the end of the regular expression; it doesn't have toreach the end of the string, unless there's an assertion in the regularexpression that says it must.  If it exhausts all possibilities at thefirst position, it realizes that its very first choice was wrong, andproceeds to its second choice.  It goes to the second position in thestring (between the first and second characters), and tries all thepossibilities again.  If it succeeds, it stops.  If it fails, itcontinues on down the string.  The pattern match as a whole doesn't failuntil it has tried to match the entire regular expression at everyposition in the string, including after the last character in thestring.<P CLASS=para>Note that the positions it's trying to match at are <I CLASS=emphasis>between</I> thecharacters of the string.  This rule sometimes surprises people whenthey write a pattern like <tt CLASS=literal>/x*/</tt> that can match zero or more <tt CLASS=literal>x</tt>'s.If you try the pattern on a string like "<tt CLASS=literal>fox</tt>", it will match the nullstring before the "<tt CLASS=literal>f</tt>" in preference to the "<tt CLASS=literal>x</tt>" that's later in thestring.  If you want it to match one or more <tt CLASS=literal>x</tt>'s, you need to tellit that by using <tt CLASS=literal>/x+/</tt> instead.  See the quantifiers under Rule 5.<P CLASS=para>A corollary to this rule is that any regular expression that can matchthe null string is guaranteed to match at the leftmost position in the string.<P CLASS=para><B>Rule 2.</B>  For this rule, the wholeregular expression is regarded as a set of alternatives (where thedegenerate case is just a set with one alternative). If there are twoor more alternatives, they are syntactically separated by the<tt CLASS=literal>|</tt> character (usually called a vertical bar). A set of alternatives matches a string if any of thealternatives match under Rule 3.  It tries the alternativesleft-to-right (according to their position in the regular expression),and stops on the first match that allows successful completion of theentire regular expression.  If none of the alternatives matches, itbacktracks to the Rule that invoked this Rule, which is usually Rule 1,but could be Rule 4 or 6.  That rule will then look for a new positionat which to apply Rule 2.<P CLASS=para>If there's onlyone alternative, then it either it matches or doesn't, and the rulestill applies.  (There's no such thing as zero alternatives, because anull string can always match something of zero width.)<P CLASS=para><B>Rule 3.</B>  Any particular alternative matches if every item in thealternative matches sequentially according to Rules 4 and 5 (such that theentire regular expression can be satisfied).  An item consists of eitheran assertion, which is covered in Rule 4, or a quantified atom, which iscovered by Rule 5.  Items that have choices on how to match are given"pecking order" from left to right.  If the items cannot be matched inorder, the Engine backtracks to the next alternative under Rule 2.<P CLASS=para>Items that must be matched sequentially aren't separated in the regularexpression by anythingsyntactic--they're merely juxtaposed in the order they must match.When you ask to match <tt CLASS=literal>/^foo/</tt>, you're actually asking for four itemsto be matched one after the other.  The first is a zero-width assertion,and the other three are ordinary letters that must match themselves, oneafter the other.<P CLASS=para>The left-to-right pecking order means that in a pattern like:<DIV CLASS=programlisting><P><PRE>/x*y*/</PRE></DIV><P CLASS=para><tt CLASS=literal>x</tt> gets to pick one way to match, and then <tt CLASS=literal>y</tt> tries all its ways.  If thatfails, then <tt CLASS=literal>x</tt> gets to pick its second choice, and make <tt CLASS=literal>y</tt> try all of itsways again.  And so on.  The items to the right vary faster, to borrowa phrase from multi-dimensional arrays.<P CLASS=para><B>Rule 4.</B>  An assertion must match according to this table.  If theassertion does not match at the current position, the Engine backtracks toRule 3 and retries higher-pecking-order items with different choices.<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-7"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Assertion</TH><TH ALIGN="LEFT">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>^</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Matches at the beginning of the string (or line, if <B>/m</B> used)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>$</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Matches at the end of the string (or line, if <B>/m</B> used)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\b</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Matches at word boundary (between <tt CLASS=literal>\w</tt> and <tt CLASS=literal>\W</tt>)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\B</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Matches except at word boundary</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\A</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Matches at the beginning of the string</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\Z</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Matches at the end of the string</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\G</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Matches where previous <tt CLASS=literal>m//g</tt> left off</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>(?=...)</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Matches if engine would match <tt CLASS=literal>...</tt> next</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>(?!...)</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Matches if engine wouldn't match <tt CLASS=literal>...</tt> next</TD></TR></TABLE><P></DIV><P CLASS=para>The <tt CLASS=literal>$</tt> and <tt CLASS=literal>\Z</tt> assertions can match not only at the end of thestring, but also one character earlier than that, if the last characterof the string happens to be a newline.<P CLASS=para>The positive <tt CLASS=literal>(?=...)</tt> and negative <tt CLASS=literal>(?!...)</tt> lookahead assertions arezero-width themselves, but assert that the regular expressionrepresented above by <tt CLASS=literal>...</tt> would (or would not) match at this point,were we to attempt it.  In fact, the Engine does attempt it.  The Enginegoes back to Rule 2 to test the subexpression, and then wipes out anyrecord of how much string was eaten, returning only the success orfailure of the subexpression as the value of the assertion.  We'll showyou some examples later.<P CLASS=para><A NAME="CH02.ATOMS"></A><B>Rule 5.</B>  A quantified atom matches only if the atom itself matchessome number of times allowed by the quantifier.  (The atom is matchedaccording to Rule 6.) Different quantifiers require different numbers ofmatches, and most of them allow a range of numbers of matches.  Multiplematches must all match in a row, that is, they must be adjacent withinthe string.  An unquantified atom is assumed to have a quantifierrequiring exactly one match.  Quantifiers constrain and control matchingaccording to the table below.  If no match can be found at the currentposition for any allowed quantity of the atom in question, the Enginebacktracks to Rule 3 and retries higher-pecking-order items withdifferent choices.<P CLASS=para>Quantifiers are:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-8"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left"><B>Maximal</B></TH><TH ALIGN="left"><B>Minimal</B></TH><TH ALIGN="LEFT"><B>Allowed Range</B></TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>{</tt><I CLASS=emphasis>n</I>,<I CLASS=emphasis>m</I><tt CLASS=literal>}</tt></TD><TD ALIGN="left"><tt CLASS=literal>{</tt><I CLASS=emphasis>n</I>,<I CLASS=emphasis>m</I><tt CLASS=literal>}?</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Must occur at least <I CLASS=emphasis>n</I> times but no more than <I CLASS=emphasis>m</I> times</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>{</tt><I CLASS=emphasis>n</I><tt CLASS=literal>,}</tt></TD><TD ALIGN="left"><tt CLASS=literal>{</tt><I CLASS=emphasis>n</I><tt CLASS=literal>,}?</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Must occur at least <I CLASS=emphasis>n</I> times</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>{</tt><I CLASS=emphasis>n</I><tt CLASS=literal>}</tt></TD><TD ALIGN="left"><tt CLASS=literal>{</tt><I CLASS=emphasis>n</I><tt CLASS=literal>}?</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Must match exactly <I CLASS=emphasis>n</I> times</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>*</tt></TD><TD ALIGN="left"><tt CLASS=literal>*?</tt></TD><TD ALIGN="LEFT"><P CLASS=para>0 or more times (same as <tt CLASS=literal>{0,}</tt>)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>+</tt></TD><TD ALIGN="left"><tt CLASS=literal>+?</tt></TD><TD ALIGN="LEFT"><P CLASS=para>1 or more times (same as <tt CLASS=literal>{1,}</tt>)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>?</tt></TD><TD ALIGN="left"><tt CLASS=literal>??</tt></TD><TD ALIGN="LEFT"><P CLASS=para>0 or 1 time (same as <tt CLASS=literal>{0,1}</tt>)</TD></TR></TABLE><P></DIV><P CLASS=para>If a brace occurs in any other context, it is treated as a regularcharacter.  <I CLASS=emphasis>n</I> and <I CLASS=emphasis>m</I> arelimited to integral values less than 65,536.<P CLASS=para>If you use the<tt CLASS=literal>{</tt><I CLASS=emphasis>n</I><tt CLASS=literal>}</tt> form,then there is no choice, and the atom must match exactly that numberof times or not at all.  Otherwise, the atom can match over a range ofquantities, and the Engine keeps track of all the choices so that itcan backtrack if necessary.  But then the question arises as to whichof these choices to try first.  One could start with the maximalnumber of matches and work down, or the minimal number of matches andwork up.<P CLASS=para>The quantifiers in the left column above try the biggest quantity first.This is often called "greedy" matching.  To find the greediest match,the Engine doesn't actually count down from the maximum value, whichafter all could be infinity.   What actually happens in this case isthat the Engine first counts up to find out how many atoms it'spossible to match in a row in the current string, and then itremembers all the shorter choices and starts out from the longest one.  This could fail, of course, in which case it backtracksto a shorter choice.<P CLASS=para>If you say <tt CLASS=literal>/.*foo/</tt>, for example, it will try to match the maximalnumber of "any" characters (represented by the dot) clear out to the endof the line before it ever tries looking for "<tt CLASS=literal>foo</tt>", and then when the"<tt CLASS=literal>foo</tt>" doesn't match there (and it can't, because there's not enough roomfor it at the end of the string), the Engine will back off one characterat a time until it finds a "<tt CLASS=literal>foo</tt>".  If there is more than one "<tt CLASS=literal>foo</tt>" inthe line, it'll stop on the last one, and throw away all the shorterchoices it could have made.<P CLASS=para>By placing a question mark after any of the greedy quantifiers, theycan be made to choose the smallest quantity for the first try.  So ifyou say <tt CLASS=literal>/.*?foo/</tt>, the <tt CLASS=literal>.*?</tt> firsttries to match 0 characters, then 1 character, then 2, and so on untilit can match the "<tt CLASS=literal>foo</tt>".  Instead of backtracking backward, itbacktracks forward, so to speak, and ends up finding the first "<tt CLASS=literal>foo</tt>"on the line instead of the last.<P CLASS=para><B>Rule 6.</B> Each atom matches according toits type, listed below.  If the atom doesn't match (or doesn't allow amatch of the rest of the regular expression), the Engine backtracks toRule 5 and tries the next choice for the atom's quantity.<P CLASS=para>Atoms match according to the following types:<P><UL CLASS=itemizedlist><li CLASS=listitem>A regular expression in parentheses, <tt CLASS=literal>(...)</tt>, matches whatever theregular expression (represented by <tt CLASS=literal>...</tt>) matches according to Rule 2.Parentheses therefore serve as a grouping operator for quantification.Parentheses also have the side effect of remembering the matchedsubstring for later use in a <I CLASS=emphasis>backreference</I> (to bediscussed later).  This sideeffect can be suppressed by using <tt CLASS=literal>(?:...)</tt> instead, which has onlythe grouping semantics--it doesn't store anything in <B>$1</B>, <B>$2</B>, and so on.<P><li CLASS=listitem>A "<tt CLASS=literal>.</tt>" matches any character except <tt CLASS=literal>\n</tt>.  (It also matches<tt CLASS=literal>\n</tt> if you use the <B>/s</B> modifier.)  The main use ofdot is as a vehicle for a minimal or maximal quantifier.  A<tt CLASS=literal>.*</tt> matches a maximal number of don't-care characters, while a<tt CLASS=literal>.*?</tt> matches a minimal number of don't-care characters.  But it'salso sometimes used within parentheses for its width:<tt CLASS=literal>/(..):(..):(..)/</tt> matches three colon-separated fields, each ofwhich is two characters long.<P><li CLASS=listitem>A list of characters in square brackets (called a <I CLASS=emphasis>character class</I>) matchesany one of the characters in the list.A caret at the front of the list causes it to match only characters thatare <I CLASS=emphasis>not</I> in the list.  Character ranges may be indicated using the<tt CLASS=literal>a-z</tt> notation.  You may also use any of <tt CLASS=literal>\d</tt>, <tt CLASS=literal>\w</tt>,<tt CLASS=literal>\s</tt>, <tt CLASS=literal>\n</tt>, <tt CLASS=literal>\r</tt>, <tt CLASS=literal>\t</tt>, <tt CLASS=literal>\f</tt>, or<tt CLASS=literal>\</tt><I CLASS=emphasis>nnn</I>, as listed below.  A <tt CLASS=literal>\b</tt> means a backspacein a character class.  You may use a backslash to protect a hyphen thatwould otherwise be interpreted as a range delimiter.  To match a rightsquare bracket, either backslash it or place it first in the list.  Tomatch a caret, <I CLASS=emphasis>don't</I> put it first.  Note that most othermetacharacters lose their meta-ness inside square brackets.  Inparticular, it's meaningless to specify alternation in a characterclass, since the characters are interpreted individually.  For example,<tt CLASS=literal>[fee|fie|foe]</tt> means the same thing as <tt CLASS=literal>[feio|]</tt>.<P><li CLASS=listitem>A backslashed letter matches a special character or character class:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-9"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Code</TH><TH ALIGN="left">Matches</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\a</tt></TD><TD ALIGN="left">Alarm (beep)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\n</tt></TD><TD ALIGN="left">Newline</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\r</tt></TD><TD ALIGN="left">Carriage return</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\t</tt></TD><TD ALIGN="left">Tab</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\f</tt></TD><TD ALIGN="left">Formfeed</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\e</tt></TD><TD ALIGN="left">Escape</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\d</tt></TD><TD ALIGN="left">A digit, same as <tt CLASS=literal>[0-9]</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\D</tt></TD><TD ALIGN="left">A nondigit</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\w</tt></TD><TD ALIGN="left">A word character (alphanumeric), same as <tt CLASS=literal>[a-zA-Z_0-9]</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\W</tt></TD><TD ALIGN="left">A nonword character</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\s</tt></TD><TD ALIGN="left">A whitespace character, same as <tt CLASS=literal>[ \t\n\r\f]</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>\S</tt></TD><TD ALIGN="left">A non-whitespace character</TD></TR></TABLE><P></DIV><P CLASS=para>Note that <tt CLASS=literal>\w</tt> matches a character of a word, not a whole word.  Use<tt CLASS=literal>\w+</tt> to match a word.<P><li CLASS=listitem>A backslashed single-digit number matches whatever the correspondingparentheses actually matched (except that <tt CLASS=literal>\0</tt> matches a nullcharacter).  This is called a <I CLASS=emphasis>backreference</I> to a substring.  Abackslashed multi-digit number such as <tt CLASS=literal>\10</tt> will be considered abackreference if the pattern contains at least that many substringsprior to it, and the number does not start with a <tt CLASS=literal>0</tt>.  Pairs ofparentheses are numbered by counting left parentheses from the left.<P><li CLASS=listitem>A backslashed two- or three-digit octal number such as <tt CLASS=literal>\033</tt> matches thecharacter with the specified value, unless it would be interpreted as abackreference.<P><li CLASS=listitem>A backslashed <tt CLASS=literal>x</tt> followed by one or two hexadecimal digits, such as<tt CLASS=literal>\x7f</tt>, matches the character having that hexadecimal value.<P><li CLASS=listitem>A backslashed <tt CLASS=literal>c</tt> followed by a single character, such as <tt CLASS=literal>\cD</tt>,matches the corresponding control character.<P><li CLASS=listitem>Any other backslashed character matches that character.<P><li CLASS=listitem>Any character not mentioned above matches itself.<P></UL></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-4.1.3">The fine print</A></h4><P CLASS=para>As mentioned above, <tt CLASS=literal>\1</tt>, <tt CLASS=literal>\2</tt>, <tt CLASS=literal>\3</tt>, and so on, areequivalent to whatever the corresponding set of parentheses matched,counting opening parentheses from left to right.  (If the particularpair of parentheses had a quantifier such as <tt CLASS=literal>*</tt> after it, suchthat it matched a series of substrings, then only the last match countsas the backreference.) Note that such a backreference matches whateveractually matched for the subpattern in the string being examined;it's not just a shorthand for the rules of that subpattern.  Therefore,<tt CLASS=literal>(0|0x)\d*\s\1\d*</tt> will match "<tt CLASS=literal>0x1234 0x4321</tt>", but not "<tt CLASS=literal>0x123401234</tt>", since subpattern <tt CLASS=literal>1</tt> actually matched "<tt CLASS=literal>0x</tt>", even though the rule<tt CLASS=literal>0|0x</tt> could potentially match the leading <tt CLASS=literal>0</tt> in the second number.<P CLASS=para>Outside of the pattern (in particular, in the replacement of asubstitution operator) you can continue to refer to backreferences byusing <tt CLASS=literal>$</tt> instead of <tt CLASS=literal>\</tt> in front ofthe number.  The variables <B>$1</B>,<B>$2</B>, <B>$3</B> . . . are automatically localized, and theirscope (and that of <B>$</B>&nbsp;<tt CLASS=literal>`</tt>, <B>$&amp;</B>, and <B>$</B>&nbsp;<tt CLASS=literal>'</tt> below) extends to the end of the enclosing block or <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> string, or to the next successful patternmatch, whichever comes first.(The <tt CLASS=literal>\1</tt> notation sometimes works outside the current pattern, butshould not be relied upon.) <B>$+</B> returns whatever the last bracketmatch matched.  <B>$&amp;</B> returns the entire matched string. <B>$</B><tt CLASS=literal>`</tt> returns everything before the matched string.[24]<B>$</B><tt CLASS=literal>'</tt> returns everything after the matched string.  For more explanationof these magical variables (and for a way to write them in English), seethe section "Special Variables" at the end of this chapter.<blockquote class=footnote><P CLASS=para>[24] In the case of something like<tt CLASS=literal>s/pattern/length($`)/eg</tt>, which doesmultiple replacements if the pattern occurs multiple times, the value of<B>$</B><tt CLASS=literal>`</tt> does not include any modifications done by previous replacementiterations.  To get the other effect, say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>1 while s/pattern/length($`)/e;</PRE></DIV><P CLASS=para>For example, to change all tabs to the corresponding number of spaces,you could say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>1 while s/\t+/' ' x (length($&amp;) * 8 - length($`) % 8)/e;</PRE></DIV></blockquote><P CLASS=para>You may have as many parentheses as you wish.  If you have morethan nine pairs, the variables <B>$10</B>, <B>$11</B>, . . . refer to thecorresponding substring.  Within the pattern, <tt CLASS=literal>\10</tt>, <tt CLASS=literal>\11</tt>, and so on, refer backto substrings if there have been at least that many left parentheses beforethe backreference.  Otherwise (for backward compatibility) <tt CLASS=literal>\10</tt> is thesame as <tt CLASS=literal>\010</tt>, a backspace, and <tt CLASS=literal>\11</tt> the same as <tt CLASS=literal>\011</tt>, a tab.  And soon.  (<tt CLASS=literal>\1</tt> through <tt CLASS=literal>\9</tt> are always backreferences.)<P CLASS=para>Examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE>s/^([^ ]+) +([^ ]+)/$2 $1/;   # swap first two words/(\w+)\s*=\s*\1/;             # match "foo = foo"/.{80,}/;                     # match line of at least 80 chars/^(\d+\.?\d*|\.\d+)$/;        # match valid numberif (/Time: (..):(..):(..)/) { # pull fields out of a line        $hours   = $1;        $minutes = $2;        $seconds = $3;}</PRE></DIV><P CLASS=para>Hint: instead of writing patterns like <tt CLASS=literal>/(...)(..)(.....)/</tt>, use the<A HREF="ch03_02.htm#PERL2-CMD-UNPACK">unpack</A> function.  It's more efficient.<P CLASS=para>A word boundary (<tt CLASS=literal>\b</tt>) is defined as a spot between twocharacters that has a <tt CLASS=literal>\w</tt> on one side of it and a<tt CLASS=literal>\W</tt> on the other side of it (in either order), counting theimaginary characters off the beginning and end of the string as matchinga <tt CLASS=literal>\W</tt>.  (Within character classes <tt CLASS=literal>\b</tt> representsbackspace rather than a word boundary.)<P CLASS=para>Normally, the <tt CLASS=literal>^</tt> character is guaranteed to match only at thebeginning of the string, the <tt CLASS=literal>$</tt> character only at the end (orbefore the newline at the end), and Perl does certain optimizations withthe assumption that the string contains only one line.  Embeddednewlines will not be matched by <tt CLASS=literal>^</tt> or <tt CLASS=literal>$</tt>.  However, you maywish to treat a string as a multi-line buffer, such that the<tt CLASS=literal>^</tt> will also match after any newline within the string, and <tt CLASS=literal>$</tt>will also match before any newline.  At the cost of a little more overhead,you can do this by using the <B>/m</B> modifier on the pattern matchoperator.  (Older programs did this by setting <B>$*</B>, but thispractice is now deprecated.)  <tt CLASS=literal>\A</tt> and <tt CLASS=literal>\Z</tt> are justlike <tt CLASS=literal>^</tt> and <tt CLASS=literal>$</tt> except that they won't match multiple timeswhen the <B>/m</B> modifier is used, while <tt CLASS=literal>^</tt> and <tt CLASS=literal>$</tt> willmatch at every internal line boundary.  To match the actual end of thestring, not ignoring newline, you can use <tt CLASS=literal>\Z(?!\n)</tt>.  There'san example of a negative lookahead assertion.<P CLASS=para>To facilitate multi-line substitutions, the <tt CLASS=literal>.</tt> character never matches anewline unless you use the <B>/s</B> modifier, which tells Perl to pretendthe string is a single line--even if it isn't.  (The <B>/s</B> modifier alsooverrides the setting of <B>$*</B>, in case you have some (badly behaved) oldercode that sets it in another module.)In particular, the following leaves a newline on the <B>$_</B> string:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$_ = &lt;STDIN&gt;;s/.*(some_string).*/$1/;</PRE></DIV><P CLASS=para>If the newline is unwanted, use any of these:<P CLASS=para><DIV CLASS=programlisting><P><PRE>s/.*(some_string).*/$1/s;s/.*(some_string).*\n/$1/;s/.*(some_string)[^\0]*/$1/;s/.*(some_string)(.|\n)*/$1/;chop; s/.*(some_string).*/$1/;/(some_string)/ &amp;&amp; ($_ = $1);</PRE></DIV><P CLASS=para>Note that all backslashed metacharacters in Perl arealphanumeric, such as <tt CLASS=literal>\b</tt>, <tt CLASS=literal>\w</tt>,and <tt CLASS=literal>\n</tt>.  Unlike some regular expression languages, there are no backslashedsymbols that aren't alphanumeric.  So anything that looks like<tt CLASS=literal>\\</tt>, <tt CLASS=literal>\(</tt>, <tt CLASS=literal>\)</tt>, <tt CLASS=literal>\&lt;</tt>, <tt CLASS=literal>\&gt;</tt>,<tt CLASS=literal>\{</tt>, or <tt CLASS=literal>\}</tt> is always interpreted as a literalcharacter, not a metacharacter.  This makes it simple to quote a stringthat you want to use for a pattern but that you are afraid might containmetacharacters.Just quote all the non-alphanumeric characters:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$pattern =~ s/(\W)/\\$1/g;</PRE></DIV><P CLASS=para>You can also use the built-in <A HREF="ch03_02.htm#PERL2-CMD-QUOTEMETA">quotemeta</A> function to do this.An even easier way to quote metacharacters right in the match operatoris to say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>/$unquoted\Q$quoted\E$unquoted/</PRE></DIV><P CLASS=para>Remember that the first and last alternatives (before the first <tt CLASS=literal>|</tt> andafter the last one) tend to gobble up the other elements of the regularexpression on either side, outto the ends of the expression, unless there are enclosing parentheses.  Acommon mistake is to ask for:<P CLASS=para><DIV CLASS=programlisting><P><PRE>/^fee|fie|foe$/</PRE></DIV><P CLASS=para>when you really mean:<P CLASS=para><DIV CLASS=programlisting><P><PRE>/^(fee|fie|foe)$/</PRE></DIV><P CLASS=para>The first matches "<tt CLASS=literal>fee</tt>" at the beginning of the string, or"<tt CLASS=literal>fie</tt>" anywhere, or "<tt CLASS=literal>foe</tt>" at the end of the string.  The secondmatches any string consisting solely of "<tt CLASS=literal>fee</tt>" or "<tt CLASS=literal>fie</tt>" or"<tt CLASS=literal>foe</tt>".</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-4.1.4">Regular expression extensions</A></h4><P CLASS=para>Perl defines a consistent extension syntax for regular expressions.You've seen some of them already.The syntax is a pair of parentheses with a question mark as the first thingwithin the parentheses.[25]The character after the question mark gives the function of the extension.Several extensions are already supported:<blockquote class=footnote><P CLASS=para>[25] This was a syntax error in older versions of Perl.  If you try to use thisand have problems, upgrade to the newest version.</blockquote><P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>(?#text)</tt><DD><P CLASS=para>A comment.  The text is ignored.  If the <B>/x</B> switch is used to enablewhitespace formatting, a simple <tt CLASS=literal>#</tt> will suffice.<p><DT CLASS=varlistentry><tt CLASS=literal>(?:...)</tt><DD><P CLASS=para>This groups things like "<tt CLASS=literal>(...)</tt>" but doesn't make backreferences like "<tt CLASS=literal>(...)</tt>" does.  So:<P CLASS=para><DIV CLASS=programlisting><P><PRE>split(/\b(?:a|b|c)\b/)</PRE></DIV><P CLASS=para>is like:<P CLASS=para><DIV CLASS=programlisting><P><PRE>split(/\b(a|b|c)\b/)</PRE></DIV><P CLASS=para>but doesn't actually save anything in <B>$1</B>, which meansthat the first <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> doesn't spit out extra delimiter fieldsas the second one does.<p><DT CLASS=varlistentry><tt CLASS=literal>(?=...)</tt><DD><P CLASS=para>A zero-width positive lookahead assertion.  For example, <tt CLASS=literal>/\w+(?=\t)/</tt>matches a word followed by a tab, without including the tab in <B>$&amp;</B>.<p><DT CLASS=varlistentry><tt CLASS=literal>(?!...)</tt><DD><P CLASS=para>A zero-width negative lookahead assertion.  For example <tt CLASS=literal>/foo(?!bar)/</tt>matches any occurrence of "<tt CLASS=literal>foo</tt>" that isn't followed by "<tt CLASS=literal>bar</tt>".  Note,however, that lookahead and lookbehind are <I CLASS=emphasis>not</I> the same thing.  You cannotuse this for lookbehind: <tt CLASS=literal>/(?!foo)bar/</tt> will not find an occurrence of"<tt CLASS=literal>bar</tt>" that is preceded by something that is not "<tt CLASS=literal>foo</tt>".  That's becausethe <tt CLASS=literal>(?!foo)</tt> is just saying that the next thing cannot be "<tt CLASS=literal>foo</tt>"--andit's not, it's a "<tt CLASS=literal>bar</tt>", so "<tt CLASS=literal>foobar</tt>" will match.  You would have to dosomething like <tt CLASS=literal>/(?!foo)</tt>...<tt CLASS=literal>bar/</tt> for that.   We say "like" because there'sthe case of your "<tt CLASS=literal>bar</tt>" not having three characters before it.  You couldcover that this way: <tt CLASS=literal>/(?:(?!foo)</tt>. . .<tt CLASS=literal>|^</tt>. .<tt CLASS=literal>?)bar/</tt>.  Sometimes it's stilleasier just to say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if (/bar/ and $` !~ /foo$/)</PRE></DIV><p><DT CLASS=varlistentry><tt CLASS=literal>(?imsx)</tt><DD><P CLASS=para>One or more embedded pattern-match modifiers.  This is particularlyuseful for patterns that are specified in a table somewhere, some ofwhich want to be case-sensitive, and some of which don't.  The case-insensitive ones merely need to include <tt CLASS=literal>(?i)</tt> at the front of thepattern.  For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE># hardwired case insensitivity$pattern = "buffalo";if ( /$pattern/i )# data-driven case insensitivity$pattern = "(?i)buffalo";if ( /$pattern/ )</PRE></DIV></DL><P CLASS=para>We chose to use the question mark for this (and for the new minimalmatching construct) because (1) question mark is pretty rare in olderregular expressions, and (2) whenever you see one, you should stopand <I CLASS=emphasis>question</I> exactly what is going on.  That's psychology.</DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-4.2">Pattern-Matching Operators</A></h3><P CLASS=para>Now that we've got all that out of the way, here finally are thequotelike operators (er, terms) that perform pattern matching and relatedactivities.<A NAME="CH02.MO1"></A><A NAME="CH02.MO2"></A><P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>m/</tt><tt CLASS=replaceable><i>PATTERN</i></tt><tt CLASS=literal>/gimosx</tt> <tt CLASS=literal>/</tt><tt CLASS=replaceable><i>PATTERN</i></tt><tt CLASS=literal>/gimosx</tt><DD><P CLASS=para>This operator searches a string for a pattern match, and in a scalar contextreturns true (<tt CLASS=literal>1</tt>) or false (<tt CLASS=literal>"&nbsp;"</tt>).  If no string is specified viathe <tt CLASS=literal>=~</tt> or <tt CLASS=literal>!~</tt> operator, the<B>$_</B> string is searched.  (The stringspecified with <tt CLASS=literal>=~</tt> need not be an lvalue--itmay be the result of an expression evaluation, but remember the<tt CLASS=literal>=~</tt> binds rather tightly, so you may needparentheses around your expression.)</DL><P CLASS=para>Modifiers are:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-9A"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Modifier</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>g</tt></TD><TD ALIGN="left">Match globally, that is, find all occurrences.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>i</tt></TD><TD ALIGN="left">Do case-insensitive pattern matching.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>m</tt></TD><TD ALIGN="left">Treat string as multiple lines.      <I CLASS=emphasis>(continued)</I></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>o</tt></TD><TD ALIGN="left">Only compile pattern once.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>s</tt></TD><TD ALIGN="left">Treat string as single line.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>x</tt></TD><TD ALIGN="left">Use extended regular expressions.</TD></TR></TABLE><P></DIV><P CLASS=para>If <tt CLASS=literal>/</tt> is the delimiter then the initial <tt CLASS=literal>m</tt> is optional.  With the <tt CLASS=literal>m</tt>you can use any pair of non-alphanumeric, non-whitespace characters asdelimiters.  This is particularly useful for matching filenamesthat contain "<tt CLASS=literal>/</tt>", thus avoiding LTS (leaning toothpick syndrome).<P CLASS=para><tt CLASS=replaceable><i>PATTERN</i></tt> may contain variables, which will be interpolated (and thepattern recompiled) every time the pattern search is evaluated.  (Notethat <B>$)</B> and <B>$|</B> will not be interpolated because they looklike end-of-line tests.)  If you want such a pattern to be compiled onlyonce, add a <B>/o</B> after the trailing delimiter.  This avoidsexpensive run-time recompilations, and is useful when the value you areinterpolating won't change during execution.  However,mentioning <B>/o</B> constitutes a promise that you won't change thevariables in the pattern.  If you do change them, Perl won't evennotice.<P CLASS=para>If the <tt CLASS=replaceable><i>PATTERN</i></tt> evaluates to a null string, the last successfullyexecuted regular expression not hidden within an inner block (including<A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A>, <A HREF="ch03_02.htm#PERL2-CMD-GREP">grep</A>, and <A HREF="ch03_02.htm#PERL2-CMD-MAP">map</A>) is used instead.<P CLASS=para>If used in a context that requires a list value, a pattern match returnsa list consisting of the subexpressions matched by the parentheses inthe pattern--that is, (<B>$1</B>, <B>$2</B>, <B>$3</B> . . . ). (The variables arealso set.)  If the match fails, a null list is returned.  If the matchsucceeds, but there were no parentheses, a list value of (1) isreturned.<P CLASS=para>Examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE># case insensitive matchingopen(TTY, '/dev/tty');&lt;TTY&gt; =~ /^y/i and foo();    # do foo() if they want it# pulling a substring out of a lineif (/Version: *([0-9.]+)/) { $version = $1; }# avoiding Leaning Toothpick Syndromenext if m#^/usr/spool/uucp#;# poor man's grep$arg = shift;while (&lt;&gt;) {    print if /$arg/o;       # compile only once}# get first two words and remainder as a listif (($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/))</PRE></DIV><P CLASS=para>This last example splits <tt CLASS=literal>$foo</tt> into the first two words and theremainder of the line, and assigns those three fields to <tt CLASS=literal>$F1</tt>,<tt CLASS=literal>$F2</tt>, and <tt CLASS=literal>$Etc</tt>.  The conditional is true if any variableswere assigned, that is, if the pattern matched.  Usually, though, one wouldjust write the equivalent <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A>:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if (($F1, $F2, $Etc) = split(' ', $foo, 3))</PRE></DIV><P CLASS=para>The <B>/g</B> modifier specifies global pattern matching--that is, matchingas many times as possible within the string.  How it behaves depends onthe context.  In a list context, it returns a list of all thesubstrings matched by all the parentheses in the regular expression.If there are no parentheses, it returns a list of all the matchedstrings, as if there were parentheses around the whole pattern.<P CLASS=para>In a scalar context, <B>m//g</B> iterates through the string, returning trueeach time it matches, and false when it eventually runs out ofmatches.  (In other words, it remembers where it left off last time andrestarts the search at that point.  You can find the currentmatch position of a string using the <A HREF="ch03_02.htm#PERL2-CMD-POS">pos</A> function--see <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.)If you modify the string in any way, the match position is reset to thebeginning.  Examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE># list context--extract three numeric fields from uptime command($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);# scalar context--count sentences in a document by recognizing# sentences ending in [.!?], perhaps with quotes or parens on # either side.  Observe how dot in the character class is a literal# dot, not merely any character.$/ = "";  # paragraph modewhile ($paragraph = &lt;&gt;) {    while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {        $sentences++;    }}print "$sentences\n";# find duplicate words in paragraphs, possibly spanning line boundaries.#   Use /x for space and comments, /i to match the both `is' #   in "Is is this ok?", and use /g to find all dups.$/ = "";        # paragrep mode againwhile (&lt;&gt;) {    while ( m{                \b            # start at a word boundary                (\w\S+)       # find a wordish chunk                (                     \s+       # separated by some whitespace                    \1        # and that chunk again                ) +           # repeat ad lib                \b            # until another word boundary             }xig         )     {        print "dup word `$1' at paragraph $.\n";    } }</PRE></DIV><P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>?</tt><tt CLASS=replaceable><i>PATTERN</i></tt><tt CLASS=literal>?</tt><DD><P CLASS=para>This is just like the<tt CLASS=literal>/</tt><tt CLASS=replaceable><i>PATTERN</i></tt><tt CLASS=literal>/</tt>search, except that it matches only once between calls to the<A HREF="ch03_02.htm#PERL2-CMD-RESET">reset</A> operator.  This is a usefuloptimization when you only want to see the first occurrence ofsomething in each file of a set of files, for instance.  Only<tt CLASS=literal>??</tt> patterns local to the current package are reset.</DL><P CLASS=para>This usage is vaguely deprecated, and may be removed in some futureversion of Perl.  Most people just bomb out of the loop when theyget the match they want.<P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>s/</tt><tt CLASS=replaceable><i>PATTERN</i></tt><tt CLASS=literal>/</tt><tt CLASS=replaceable><i>REPLACEMENT</i></tt><tt CLASS=literal>/egimosx</tt><DD><P CLASS=para><A NAME="CH02.SO1"></A><A NAME="CH02.SO2"></A>This operator searches a string for <tt CLASS=replaceable><i>PATTERN</i></tt>, and if found, replacesthat match with the <tt CLASS=replaceable><i>REPLACEMENT</i></tt> text and returns the number ofsubstitutions made, which can be more than one with the <B>/g</B> modifier.Otherwise it returns false (0).</DL><P CLASS=para>If no string is specified via the <tt CLASS=literal>=~</tt> or <tt CLASS=literal>!~</tt> operator, the<B>$_</B> variable is searched and modified.  (The string specified with<tt CLASS=literal>=~</tt> must be a scalar variable, an array element, a hash element,or an assignment to one of those, that is, an lvalue.)<P CLASS=para>If the delimiter you choose happens to be a single quote, no variableinterpolation is done on either the <tt CLASS=replaceable><i>PATTERN</i></tt> or the <tt CLASS=replaceable><i>REPLACEMENT</i></tt>.Otherwise, if the <tt CLASS=replaceable><i>PATTERN</i></tt> contains a <tt CLASS=literal>$</tt> that looks like a variable ratherthan an end-of-string test, the variable will be interpolated into the<tt CLASS=replaceable><i>PATTERN</i></tt> at run-time.  If you want the <tt CLASS=replaceable><i>PATTERN</i></tt>compiled only once, when thevariable is first interpolated, use the <B>/o</B> option.  If the<tt CLASS=replaceable><i>PATTERN</i></tt> evaluates to a null string, thelast successfully executedregular expression is used instead.  The <tt CLASS=replaceable><i>REPLACEMENT</i></tt> pattern alsoundergoes variable interpolation, but it does so each time the <tt CLASS=replaceable><i>PATTERN</i></tt>matches, unlike the <tt CLASS=replaceable><i>PATTERN,</i></tt> which just gets interpolated once whenthe operator is evaluated.  (The <tt CLASS=replaceable><i>PATTERN</i></tt> can match multiple times in oneevaluation if you use the <B>/g</B> option below.)<P CLASS=para>Modifiers are:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-9B"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Modifier</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>e</tt></TD><TD ALIGN="left">Evaluate the right side as an expression.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>g</tt></TD><TD ALIGN="left">Replace globally, that is, all occurrences.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>i</tt></TD><TD ALIGN="left">Do case-insensitive pattern matching.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>m</tt></TD><TD ALIGN="left">Treat string as multiple lines.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>o</tt></TD><TD ALIGN="left">Only compile pattern once.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>s</tt></TD><TD ALIGN="left">Treat string as single line.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>x</tt></TD><TD ALIGN="left">Use extended regular expressions.</TD></TR></TABLE><P></DIV><P CLASS=para>Any non-alphanumeric, non-whitespace delimiter may replace the slashes.If single quotes are used, no interpretation is done on the replacementstring (the <B>/e</B> modifier overrides this, however). If the <tt CLASS=replaceable><i>PATTERN</i></tt> is containedwithin naturally paired delimiters (such as parentheses), the<tt CLASS=replaceable><i>REPLACEMENT</i></tt> has its own pair of delimiters, which may or may not bethe same ones used for <tt CLASS=replaceable><i>PATTERN</i></tt>--for example, <tt CLASS=literal>s(foo)(bar)</tt> or<tt CLASS=literal>s&lt;foo&gt;/bar/</tt>.  A <B>/e</B> will cause the replacement portion to beinterpreted as a full-fledged Perl expression instead of as adouble-quoted string.  (It's kind of like an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, but itssyntax is checked at compile-time.)<P CLASS=para>Examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE># don't change wintergreens/\bgreen\b/mauve/g;# avoid LTS with different quote characters$path =~ s(/usr/bin)(/usr/local/bin);# interpolated pattern and replacements/Login: $foo/Login: $bar/;# modifying a string "en passant"($foo = $bar) =~ s/this/that/;# counting the changes$count = ($paragraph =~ s/Mister\b/Mr./g);# using an expression for the replacement$_ = 'abc123xyz';s/\d+/$&amp;*2/e;               # yields 'abc246xyz's/\d+/sprintf("%5d",$&amp;)/e;  # yields 'abc  246xyz's/\w/$&amp; x 2/eg;             # yields 'aabbcc  224466xxyyzz'# how to default things with /es/%(.)/$percent{$1}/g;            # change percent escapes; no /es/%(.)/$percent{$1} || $&amp;/ge;     # expr now, so /es/^=(\w+)/&amp;pod($1)/ge;            # use function call# /e's can even nest; this will expand simple embedded variables in $_s/(\$\w+)/$1/eeg;# delete C comments$program =~ s {    /\*     # Match the opening delimiter.    .*?     # Match a minimal number of characters.    \*/     # Match the closing delimiter.} []gsx;# trim white spaces/^\s*(.*?)\s*$/$1/;# reverse 1st two fieldss/([^ ]*) *([^ ]*)/$2 $1/;</PRE></DIV><P CLASS=para>Note the use of <tt CLASS=literal>$</tt> instead of <tt CLASS=literal>\</tt> in the last example.Some people get a little too used to writing things like:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$pattern =~ s/(\W)/\\\1/g;</PRE></DIV><P CLASS=para>This is grandfathered for the right-hand side of a substitution to avoidshocking the <I CLASS=emphasis>sed</I> addicts, but it's a dirty habit to get into.[26]That's because in PerlThink, the right-hand side of a <tt CLASS=literal>s///</tt> is adouble-quoted string.  In an ordinary double-quoted string, <tt CLASS=literal>\1</tt>would mean a control-A, but for <tt CLASS=literal>s///</tt> the customary UNIX meaningof <tt CLASS=literal>\1</tt> is kludged in.  (The lexer actually translates it to<B>$1</B> on the fly.)  If you start to rely on that, however, you getyourself into trouble if you then add an <B>/e</B> modifier:<blockquote class=footnote><P CLASS=para>[26] Or to not get out of, depending on how you look at it.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>s/(\d+)/ \1 + 1 /eg;   # a scalar reference plus one?</PRE></DIV><P CLASS=para>Or if you try to do:<P CLASS=para><DIV CLASS=programlisting><P><PRE>s/(\d+)/\&nbsp;1000/;        # "\&nbsp;100" . "0" == "@0"?</PRE></DIV><P CLASS=para>You can't disambiguate that by saying <tt CLASS=literal>\{1}000</tt>, whereas you<I CLASS=emphasis>can</I> fix it with <tt CLASS=literal>${1}000</tt>.  Basically, the operation ofinterpolation should not be confused with the operation of matching abackreference.  Certainly, interpolation and matching mean two differentthings on the <I CLASS=emphasis>left</I> side of the <tt CLASS=literal>s///</tt>.<P CLASS=para>Occasionally, you can't just use a <B>/g</B> to get all the changes tooccur, either because the substitutions have to happen right-to-left, orbecause you need the length of <B>$</B><tt CLASS=literal>`</tt> to change between matches.  In thiscase you can usually do what you want by calling the substitutionrepeatedly.  Here are two common cases:<P CLASS=para><DIV CLASS=programlisting><P><PRE># put commas in the right places in an integer1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/;# expand tabs to 8-column spacing1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;</PRE></DIV><P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>tr/</tt><tt CLASS=replaceable><i>SEARCHLIST</i></tt><tt CLASS=literal>/</tt><tt CLASS=replaceable><i>REPLACEMENTLIST</i></tt><tt CLASS=literal>/cds</tt> <tt CLASS=literal>y/</tt><tt CLASS=replaceable><i>SEARCHLIST</i></tt><tt CLASS=literal>/</tt><tt CLASS=replaceable><i>REPLACEMENTLIST</i></tt><tt CLASS=literal>/cds</tt><DD><P CLASS=para>Strictly speaking, this operator doesn't belong in a section on patternmatching because it doesn't use regular expressions.  Rather, it scansa string character by character, and replacesall occurrences of the characters found in the <tt CLASS=replaceable><i>SEARCHLIST</i></tt> with the corresponding character in the <tt CLASS=replaceable><i>REPLACEMENTLIST</i></tt>.  It returnsthe number of characters replaced or deleted.  If no string isspecified via the <tt CLASS=literal>=~</tt> or <tt CLASS=literal>!~</tt> operator, the <B>$_</B> string is translated.  (Thestring specified with <tt CLASS=literal>=~</tt> must be a scalar variable, an array element,or an assignment to one of those, that is, an lvalue.)  For <I CLASS=emphasis>sed</I> devotees,<B>y</B> is provided as a synonym for <A HREF="ch03_02.htm#PERL2-CMD-TR">tr///</A>.  If the <tt CLASS=replaceable><i>SEARCHLIST</i></tt> iscontained within naturally paired delimiters (such as parentheses), the<tt CLASS=replaceable><i>REPLACEMENTLIST</i></tt> has its own pair of delimiters, which may or maynot be naturally paired ones--for example, <tt CLASS=literal>tr[A-Z][a-z]</tt>or <tt CLASS=literal>tr(+-*/)/ABCD/</tt>.</DL><P CLASS=para>Modifiers:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-9C"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Modifier</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>c</tt></TD><TD ALIGN="left">Complement the <tt CLASS=replaceable><i>SEARCHLIST</i></tt>.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>d</tt></TD><TD ALIGN="left">Delete found but unreplaced characters.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>s</tt></TD><TD ALIGN="left">Squash duplicate replaced characters.</TD></TR></TABLE><P></DIV><P CLASS=para>If the <B>/c</B> modifier is specified, the<tt CLASS=replaceable><i>SEARCHLIST</i></tt> character set is complemented; thatis, the effective search list consists of all the characters<I CLASS=emphasis>not</I> in <tt CLASS=replaceable><i>SEARCHLIST</i></tt>.  If the<B>/d</B> modifier is specified, anycharacters specified by <tt CLASS=replaceable><i>SEARCHLIST</i></tt> but not givena replacement in <tt CLASS=replaceable><i>REPLACEMENTLIST</i></tt> are deleted.(Note that this is slightly more flexible than the behavior of some<A HREF="ch03_02.htm#PERL2-CMD-TR">tr///</A> programs, which delete anything theyfind in the <tt CLASS=replaceable><i>SEARCHLIST</i></tt>, period.)  If the<B>/s</B> modifier is specified, sequences ofcharacters that were translated to the same character are squasheddown to a single instance of the character.<P CLASS=para>If the <B>/d</B> modifier is used, the<tt CLASS=replaceable><i>REPLACEMENTLIST</i></tt> is always interpreted exactly asspecified.  Otherwise, if the <tt CLASS=replaceable><i>REPLACEMENTLIST</i></tt> isshorter than the <tt CLASS=replaceable><i>SEARCHLIST</i></tt>, the final characteris replicated until it is long enough.  If the<tt CLASS=replaceable><i>REPLACEMENTLIST</i></tt> is null, the<tt CLASS=replaceable><i>SEARCHLIST</i></tt> is replicated.  This latter is usefulfor counting characters in a class or for squashing charactersequences in a class.<P CLASS=para>Examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$ARGV[1] =~ tr/A-Z/a-z/;    # canonicalize to lower case$cnt = tr/*/*/;             # count the stars in $_$cnt = $sky =~ tr/*/*/;     # count the stars in $sky$cnt = tr/0-9//;            # count the digits in $_tr/a-zA-Z//s;               # bookkeeper -&gt; bokeper($HOST = $host) =~ tr/a-z/A-Z/;tr/a-zA-Z/ /cs;             # change non-alphas to single spacetr [\200-\377]   [\000-\177];             # delete 8th bit</PRE></DIV><P CLASS=para>If multiple translations are given for a character, only the first one is used:<P CLASS=para><DIV CLASS=programlisting><P><PRE>tr/AAA/XYZ/</PRE></DIV><P CLASS=para>will translate any A to X.<P CLASS=para>Note that because the translation table is built at compile time, neitherthe <tt CLASS=replaceable><i>SEARCHLIST</i></tt> nor the <tt CLASS=replaceable><i>REPLACEMENTLIST</i></tt>are subject to double quoteinterpolation.  That means that if you want to use variables, you must usean <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>:<P CLASS=para><DIV CLASS=programlisting><P><PRE>eval "tr/$oldlist/$newlist/";die $@ if $@;eval "tr/$oldlist/$newlist/, 1" or die $@;</PRE></DIV><P CLASS=para>One more note: if you want to change your text to uppercase orlowercase, it's better to use the <tt CLASS=literal>\U</tt> or <tt CLASS=literal>\L</tt> sequencesin a double-quoted string, since they will pay attention to localeinformation, but <tt CLASS=literal>tr/a-z/A-Z/</tt> won't.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_03.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch02_05.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Terms</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Operators</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>