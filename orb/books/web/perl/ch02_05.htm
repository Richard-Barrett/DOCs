<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 2] 2.5 Operators</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:02:58 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_04.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 2</b></td><td width=172 align=right valign=top><A HREF="ch02_06.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5">2.5 Operators</A></h2><P CLASS=para><A NAME="CH02.OPERATORS"></A>The terms of an expression often need to be combined and modifiedin various ways, and that's what operators are for.  The tightnesswith which operators bind is controlled by the <I CLASS=emphasis>precedence</I> ofthe operators.Perl operators have the following associativity and precedence,listed from highest precedence to lowest.[27]<blockquote class=footnote><P CLASS=para>[27] Classic Camel readers will note that we reversed this table from the oldedition.  The higher precedence operators are now higher on the page,which makes some kind of metaphorical sense.</blockquote><DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-10"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Associativity</TH><TH ALIGN="left">Operators</TH></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left">Terms and list operators (leftward)</TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>-&gt;</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Nonassociative</TD><TD ALIGN="left"><tt CLASS=literal>++ - -</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Right</TD><TD ALIGN="left"><tt CLASS=literal>**</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Right</TD><TD ALIGN="left"><tt CLASS=literal>! ~ \</tt> and unary <tt CLASS=literal>+</tt> and <tt CLASS=literal>-</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>=~ !~ </tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>* / % x</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>+ - .</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>&lt;&lt; &gt;&gt;</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Nonassociative</TD><TD ALIGN="left">Named unary operators</TD></TR><TR CLASS=row><TD ALIGN="left">Nonassociative</TD><TD ALIGN="left"><tt CLASS=literal>&lt; &gt; &lt;= &gt;= lt gt le ge</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Nonassociative</TD><TD ALIGN="left"><tt CLASS=literal>== != &lt;=&gt; eq ne cmp</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>&amp;</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>| ^</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>&amp;&amp;</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>||</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Nonassociative</TD><TD ALIGN="left"><tt CLASS=literal>.</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Right</TD><TD ALIGN="left"><tt CLASS=literal>?:</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Right</TD><TD ALIGN="left"><tt CLASS=literal>= += -= *=</tt> and so on</TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>, =&gt;</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Nonassociative</TD><TD ALIGN="left">List operators (rightward)</TD></TR><TR CLASS=row><TD ALIGN="left">Right</TD><TD ALIGN="left"><tt CLASS=literal>not</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>and</tt></TD></TR><TR CLASS=row><TD ALIGN="left">Left</TD><TD ALIGN="left"><tt CLASS=literal>or xor</tt></TD></TR></TABLE><P></DIV><P CLASS=para>It may seem like there are too many precedence levels.  Well, you'reright, there are.  Fortunately, there are two things going for you here.First, the precedence levels as they're defined usually follow yourintuition, presuming you're not psychotic.  And second, if you're merelyneurotic, you can always put in extra parentheses to relieve youranxiety.<P CLASS=para>Note that any operators borrowed from C keep the same precedencerelationship with each other, even where C's precedence is slightly screwy.(This makes learning Perl easier for C folks.)<P CLASS=para>In the following sections, these operators are covered in precedenceorder.  With very few exceptions, these all operate on scalar valuesonly, not list values.  We'll mention the exceptions as they come up.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.1">Terms and List Operators (Leftward)</A></h3><P CLASS=para><A NAME="CH02.TERMS1"></A><A NAME="CH02.TERMS2"></A>Any <I CLASS=emphasis>term</I> is of highest precedence in Perl.  These include variables,quote and quotelike operators, any expression in parentheses, and anyfunction whose arguments are parenthesized.  Actually, there aren't reallyany functions in this sense, just list operators and unary operators behavingas functions because you put parentheses around their arguments.These operators areall covered in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.<P CLASS=para>Now, listen carefully.  Here are a couple of rules that are very importantand simplify things greatly, but may occasionally produce counterintuitiveresults for the unwary.  If any list operator (such as <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>) or anynamed unary operator (such as <A HREF="ch03_02.htm#PERL2-CMD-CHDIR">chdir</A>) is followed by a left parenthesis asthe next token on the same line,[28]the operator and its arguments within parentheses are taken to be ofhighest precedence, just like a normal function call.  The rule is: Ifit <I CLASS=emphasis>looks</I> like a function call, it is a function call.You canmake it look like a non-function by prefixing the arguments with a unaryplus, which does absolutely nothing, semantically speaking--it doesn'teven convert the argument to numeric.  <blockquote class=footnote><P CLASS=para>[28] And we nearly had you convinced Perl was a free-form language.</blockquote><P CLASS=para>For example, since || has lowerprecedence than <A HREF="ch03_02.htm#PERL2-CMD-CHDIR">chdir</A>, we get:<P CLASS=para><DIV CLASS=programlisting><P><PRE>chdir $foo    || die;       # (chdir $foo) || diechdir($foo)   || die;       # (chdir $foo) || diechdir ($foo)  || die;       # (chdir $foo) || diechdir +($foo) || die;       # (chdir $foo) || die</PRE></DIV><P CLASS=para>but, because <tt CLASS=literal>*</tt> has higher precedence than <A HREF="ch03_02.htm#PERL2-CMD-CHDIR">chdir</A>, we get:<P CLASS=para><DIV CLASS=programlisting><P><PRE>chdir $foo * 20;            # chdir ($foo * 20)chdir($foo) * 20;           # (chdir $foo) * 20chdir ($foo) * 20;          # (chdir $foo) * 20chdir +($foo) * 20;         # chdir ($foo * 20)</PRE></DIV><P CLASS=para>Likewise for numeric operators:<P CLASS=para><DIV CLASS=programlisting><P><PRE>rand 10 * 20;               # rand (10 * 20)rand(10) * 20;              # (rand 10) * 20rand (10) * 20;             # (rand 10) * 20rand +(10) * 20;            # rand (10 * 20)</PRE></DIV><P CLASS=para>In the absence of parentheses, the precedence of list operators suchas <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>, <A HREF="ch03_02.htm#PERL2-CMD-SORT">sort</A>, or <A HREF="ch03_02.htm#PERL2-CMD-CHMOD">chmod</A> iseither very high or very low depending on whether you look at the leftside of the operator or the right side of it.  (That's what the"Leftward" is doing in the title of this section.)  For example, in:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@ary = (1, 3, sort 4, 2);print @ary;         # prints 1324</PRE></DIV><P CLASS=para>the commas on the right of the <B>sort</B> are evaluated before the <B>sort</B>, butthe commas on the left are evaluated after.  In other words, a listoperator tends to gobble up all the arguments that follow it, andthen act like a simple term with regard to the preceding expression.Note that you have to be careful with parentheses:<P CLASS=para><DIV CLASS=programlisting><P><PRE># These evaluate exit before doing the print:print($foo, exit);  # Obviously not what you want.print $foo, exit;   # Nor is this.# These do the print before evaluating exit:(print $foo), exit; # This is what you want.print($foo), exit;  # Or this.print ($foo), exit; # Or even this.</PRE></DIV><P CLASS=para>Also note that:<P CLASS=para><DIV CLASS=programlisting><P><PRE>print ($foo &amp; 255) + 1, "\n";   # prints ($foo &amp; 255)</PRE></DIV><P CLASS=para>probably doesn't do what you expect at first glance.  Fortunately,mistakes of this nature generally produce warnings like "<tt CLASS=literal>Useless useof addition in a void context</tt>" when you use the <B>-w</B> command-line switch.<P CLASS=para>Also parsed as terms are the <tt CLASS=literal>do {}</tt> and <tt CLASS=literal>eval {}</tt> constructs,as well as subroutine and method calls, the anonymous array and hashcomposers <tt CLASS=literal>[]</tt> and <tt CLASS=literal>{}</tt>, and the anonymous subroutinecomposer <tt CLASS=literal>sub {}</tt>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.2">The Arrow Operator</A></h3><P CLASS=para>Just as in C and C++, <tt CLASS=literal>-&gt;</tt> is an infix dereference operator.  If theright side is either a <tt CLASS=literal>[...]</tt> or <tt CLASS=literal>{...}</tt> subscript, then the leftside must be either a hard or symbolic reference to an array or hash (ora location capable of holding a hard reference, if it's an lvalue(assignable)).  More on this in <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>.<P CLASS=para>Otherwise, the right side must be a method name or a simple scalarvariable containing the method name, and the value of the left side musteither be an object (a blessed reference) or a class name (that is, apackage name).  See <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.3">Autoincrement and Autodecrement</A></h3><P CLASS=para>The <tt CLASS=literal>++</tt> and <tt CLASS=literal>- -</tt> operators work as in C.That is, if placed before a variable, theyincrement or decrement the variable before returning the value, and ifplaced after, they increment or decrement the variable after returning thevalue.  For example, <tt CLASS=literal>$a++</tt> increments the value of scalar variable<tt CLASS=literal>$a</tt>, returning the value <I CLASS=emphasis>before</I> it performs the increment.Similarly, <tt CLASS=literal>- -$b{(/(\w+)/)[0]}</tt> decrements the element of thehash <tt CLASS=literal>%b</tt> indexed by the first "word" in the default searchvariable (<B>$_</B> ) and returns the value <I CLASS=emphasis>after</I> the decrement.[29]<blockquote class=footnote><P CLASS=para>[29] OK, so that wasn't exactly fair.  We just wanted to make sure you werepaying attention.  Here's how that expression works.  First the patternmatch finds the first word in <B>$_</B> using the regular expression<tt CLASS=literal>\w+</tt>.  The parentheses around that causes the word to be returned asa single-element list value, because the pattern match is in a listcontext.  The list context is supplied by the list slice operator,<tt CLASS=literal>(...)[0]</tt>, which returns the first (and only) element of the list.That value is then used as the key for the hash, and the hash entry (value) isdecremented and returned.  In general, when confronted with a complexexpression, analyze it from the inside out to see what order things happen in.</blockquote><P CLASS=para>The autoincrement operator has a little extra built-in magic to it.  Ifyou increment a variable that is numeric, or that has ever been used ina numeric context, you get a normal increment.  If, however, thevariable has only been used in string contexts since it was set, andhas a value that is not null and matches the pattern<tt CLASS=literal>/^[a-zA-Z]*[0-9]*$/</tt>, the increment is done as a string, preserving eachcharacter within its range, with carry:<P CLASS=para><DIV CLASS=programlisting><P><PRE>print ++($foo = '99');      # prints '100'print ++($foo = 'a0');      # prints 'a1'print ++($foo = 'Az');      # prints 'Ba'print ++($foo = 'zz');      # prints 'aaa'</PRE></DIV><P CLASS=para>The autodecrement operator, however, is not magical.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.4">Exponentiation</A></h3><P CLASS=para>Binary <tt CLASS=literal>**</tt> is the exponentiation operator.  Note that it binds evenmore tightly than unary minus, so <tt CLASS=literal>-2**4</tt> is <tt CLASS=literal>-(2**4)</tt>, not<tt CLASS=literal>(-2)**4</tt>.  The operator is implemented using C's <I CLASS=emphasis>pow</I> (3) function,which works with doubles internally.  It calculates usinglogarithms, which means that it works with fractional powers, but yousometimes get results that aren't as exact as a straight multiplicationwould produce.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.5">Ideographic Unary Operators</A></h3><P CLASS=para>Most unary operators just have names (see "Named Unary and File Test Operators"below), but some operators are deemed important enough to merit theirown special symbolic representation.  Most of these operators seem tohave something to do with negation.  Blame the mathematicians.<P CLASS=para>Unary ! performs logical negation, that is, "not".  See also <B>not</B>for a lower precedence version of this.  The value of a negatedoperation is 1 if the operand is false (numeric 0, string <tt CLASS=literal>"0"</tt>, nullstring, or undefined); otherwise, the value is that of the null string.<P CLASS=para>Unary <tt CLASS=literal>-</tt> performs arithmetic negation if the operand is numeric.  Ifthe operand is an identifier, a string consisting of a minus signconcatenated with the identifier is returned.  Otherwise, if the stringstarts with a plus or minus, a string starting with the opposite signis returned.  One effect of these rules is that <tt CLASS=literal>-bareword</tt> isequivalent to <tt CLASS=literal>`-bareword`</tt>.  This is most useful for Tk and CGI programmers.<P CLASS=para>Unary <tt CLASS=literal>~</tt> performs bitwise negation, that is, 1's complement.For example, on a 32-bit machine, <tt CLASS=literal>~123</tt> is <tt CLASS=literal>4292967172</tt>.  But you knewthat already.<P CLASS=para>(What you perhaps didn't know is that if the argument to <tt CLASS=literal>~</tt> happens tobe a string instead of a number, a string of identical length isreturned, but with all the bits of the string complemented.  This isa fast way to flip a lot of bits all at once.  See also the bitwiselogical operators, which also have stringish variants.)<P CLASS=para>Unary <tt CLASS=literal>+</tt> has no semantic effect whatsoever, even on strings.  It issyntactically useful for separating a function name from a parenthesizedexpression that would otherwise be interpreted as the complete list offunction arguments.  (See examples above under the section "Termsand ListOperators".)<P CLASS=para>Unary <tt CLASS=literal>\</tt> creates a reference to whatever follows it (see <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>).Do not confuse this behavior with the behavior of backslash within astring, although both forms do convey the notion of protecting the nextthing from interpretation.  This resemblance is not entirely accidental.<P CLASS=para>The <tt CLASS=literal>\</tt> operator may also be used on a parenthesized list value in a listcontext, in which case it returns references to each element of the list.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.6">Binding Operators</A></h3><P CLASS=para>Binary <tt CLASS=literal>=~</tt> binds a scalar expression to a pattern match, substitution,or translation.  These operations search or modify the string <B>$_</B> bydefault.  The binding operator makes those operations work on some otherstring instead.  The argument on the right is the search pattern, substitution,or translation.  The left argument is what is supposed to be searched,substituted, or translated instead of the default <B>$_</B>.  The returnvalue indicates the success of the operation.  If the right argument isan expression rather than a search pattern, substitution, ortranslation, it is interpreted as a search pattern at run-time.  Thatis, <tt CLASS=literal>$_ =~ $pat</tt> is equivalent to <tt CLASS=literal>$_ =~ /$pat/</tt>.  This is lessefficient than an explicit search, since the pattern must be compiledevery time the expression is evaluated.  (But <tt CLASS=literal>/$pat/o</tt> doesn'trecompile it because of the <B>/o</B> modifier.)<P CLASS=para>Binary <tt CLASS=literal>!~</tt> is just like <tt CLASS=literal>=~</tt> except the return value is negated inthe logical sense.  The following expressions are functionally equivalent:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$string !~ /pattern/not $string =~ /pattern/</PRE></DIV><P CLASS=para>We said that the return value indicates success, but there are manykinds of success.  Substitutions return the number of successfulsubstitutions, as do translations.  (In fact, the translation operatoris often used to count characters.)  Since any non-zero result is true,it all works out.  The most spectacular kind of true value is a listvalue: in a list context, pattern matches can return substrings matchedby the parentheses in the pattern.  But again, according to the rules oflist assignment, the list assignment itself will return true if anythingmatched and was assigned, and false otherwise.  So you sometimes seethings like:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if ( ($k,$v) = $string =~ m/(\w+)=(\w*)/ ) {    print "KEY $k VALUE $v\n";}</PRE></DIV><P CLASS=para>Let's pick that apart.  The <tt CLASS=literal>=~</tt> binds <tt CLASS=literal>$string</tt> to thepattern match on the right, which is scanning for occurrences of thingsthat look like <tt CLASS=replaceable><i>KEY=VALUE</i></tt> in your string.  It's in a list context becauseit's on the right side of a list assignment.  If it matches, itdoes a list assignment to <tt CLASS=literal>$k</tt> and <tt CLASS=literal>$v</tt>.  The listassignment itself is in a scalar context, so it returns <tt CLASS=literal>2</tt>, the number ofvalues on the right side of the assignment.  And <tt CLASS=literal>2</tt> happens to be true,since our scalar context is also a Boolean context.  When the matchfails, no values are assigned, which returns 0, which is false.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.7">Multiplicative Operators</A></h3><P CLASS=para>Perl provides the C-like operators <tt CLASS=literal>*</tt> (multiply),<tt CLASS=literal>/</tt> (divide),and <tt CLASS=literal>%</tt> (modulus).The <tt CLASS=literal>*</tt> and <tt CLASS=literal>/</tt> work exactly as you might expect, multiplying ordividing their two operands.  Division is done in floating-point,unless you've used the integer library module.<P CLASS=para>The <tt CLASS=literal>%</tt> operator converts its operands to integers before finding theremainder according to integer division.  For the same operation infloating-point, you may prefer to use the <tt CLASS=literal>fmod( )</tt> function from thePOSIX module (see <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>).<P CLASS=para>Binary <B>x</B> is the repetition operator.  In scalar context, itreturns a concatenated string consisting of the left operand repeatedthe number of times specified by the right operand.<P CLASS=para><DIV CLASS=programlisting><P><PRE>print '-' x 80;             # print row of dashesprint "\t" x ($tab/8), ' ' x ($tab%8);      # tab over</PRE></DIV><P CLASS=para>In list context, if the left operand is a list in parentheses, the <B>x</B>works as a list replicator rather than a string replicator.  This isuseful for initializing all the elements of an array of indeterminatelength to the same value:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@ones = (1) x 80;           # a list of 80 1's@ones = (5) x @ones;        # set all elements to 5</PRE></DIV><P CLASS=para>Similarly, you can also use <B>x</B> to initialize array and hash slices:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@keys = qw(perls before swine);@hash{@keys} = ("") x @keys;</PRE></DIV><P CLASS=para>If this mystifies you, note that <tt CLASS=literal>@keys</tt> is beingused both as a list on the left side of the assignment, and as a scalarvalue (returning the array length) on the right side of the assignment.The above has the same effect on <tt CLASS=literal>%hash</tt> as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$hash{perls}  = "";$hash{before} = "";$hash{swine}  = "";</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.8">Additive Operators</A></h3><P CLASS=para>Strangely enough, Perl also has the customary <tt CLASS=literal>+</tt> (addition) and <tt CLASS=literal>-</tt>(subtraction) operators.  Both operators convert their argumentsfrom strings to numeric values if necessary, and return a numeric result.<P CLASS=para>Additionally, Perl provides a string concatenation operator "<tt CLASS=literal>.</tt>".  Forexample:<DIV CLASS=programlisting><P><PRE>$almost = "Fred" . "Flintstone";    # returns FredFlintstone</PRE></DIV><P CLASS=para>Note that Perl does not place a space between the strings beingconcatenated.  If you want the space, or if you have more than twostrings to concatenate, you can use the <A HREF="ch03_02.htm#PERL2-CMD-JOIN">join</A> operator, described in<A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.  Most often, though, people do theirconcatenation implicitly inside a double-quoted string:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$fullname = "$firstname $lastname";</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.9">Shift Operators</A></h3><P CLASS=para>The bit-shift operators (<tt CLASS=literal>&lt;&lt;</tt> and <tt CLASS=literal>&gt;&gt;</tt>) return the value of theleft argument shifted to the left (<tt CLASS=literal>&lt;&lt;</tt>) or to the right(<tt CLASS=literal>&gt;&gt;</tt>) by the number ofbits specified by the right argument.  The arguments should be integers.For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>1 &lt;&lt; 4;     # returns 1632 &gt;&gt; 4;    # returns 2</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.10">Named Unary and File Test Operators</A></h3><P CLASS=para><A NAME="CH02.UNARY1"></A><A NAME="CH02.UNARY2"></A><A NAME="CH02.UNARY3"></A>Some of "functions" described in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A> are really unary operators,including:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-11"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TD ALIGN="LEFT">-X (file tests)</TD><TD ALIGN="LEFT">gethostbyname</TD><TD ALIGN="LEFT">localtime</TD><TD ALIGN="LEFT">rmdir</TD></TR><TR CLASS=row><TD ALIGN="LEFT">alarm</TD><TD ALIGN="LEFT">getnetbyname</TD><TD ALIGN="LEFT">log</TD><TD ALIGN="LEFT">scalar</TD></TR><TR CLASS=row><TD ALIGN="LEFT">caller</TD><TD ALIGN="LEFT">getpgrp</TD><TD ALIGN="LEFT">lstat</TD><TD ALIGN="LEFT">sin</TD></TR><TR CLASS=row><TD ALIGN="LEFT">chdir</TD><TD ALIGN="LEFT">getprotobyname</TD><TD ALIGN="LEFT">my</TD><TD ALIGN="LEFT">sleep</TD></TR><TR CLASS=row><TD ALIGN="LEFT">chroot</TD><TD ALIGN="LEFT">glob</TD><TD ALIGN="LEFT">oct</TD><TD ALIGN="LEFT">sqrt</TD></TR><TR CLASS=row><TD ALIGN="LEFT">cos</TD><TD ALIGN="LEFT">gmtime</TD><TD ALIGN="LEFT">ord</TD><TD ALIGN="LEFT">srand</TD></TR><TR CLASS=row><TD ALIGN="LEFT">defined</TD><TD ALIGN="LEFT">goto</TD><TD ALIGN="LEFT">quotemeta</TD><TD ALIGN="LEFT">stat</TD></TR><TR CLASS=row><TD ALIGN="LEFT">delete</TD><TD ALIGN="LEFT">hex</TD><TD ALIGN="LEFT">rand</TD><TD ALIGN="LEFT">uc</TD></TR><TR CLASS=row><TD ALIGN="LEFT">do</TD><TD ALIGN="LEFT">int</TD><TD ALIGN="LEFT">readlink</TD><TD ALIGN="LEFT">ucfirst</TD></TR><TR CLASS=row><TD ALIGN="LEFT">eval</TD><TD ALIGN="LEFT">lc</TD><TD ALIGN="LEFT">ref</TD><TD ALIGN="LEFT">umask</TD></TR><TR CLASS=row><TD ALIGN="LEFT">exists</TD><TD ALIGN="LEFT">lcfirst</TD><TD ALIGN="LEFT">require</TD><TD ALIGN="LEFT">undef</TD></TR><TR CLASS=row><TD ALIGN="LEFT">exit</TD><TD ALIGN="LEFT">length</TD><TD ALIGN="LEFT">reset</TD><TD ALIGN="LEFT">&nbsp;</TD></TR><TR CLASS=row><TD ALIGN="LEFT">exp</TD><TD ALIGN="LEFT">local</TD><TD ALIGN="LEFT">return</TD><TD ALIGN="LEFT">&nbsp;</TD></TR></TABLE><P></DIV><P CLASS=para>These are all unary operators, with a higher precedence than some of theother binary operators.  For example:<DIV CLASS=programlisting><P><PRE>sleep 4 | 3;</PRE></DIV><P CLASS=para>does not sleep for 7 seconds; it sleeps for 4 seconds, and then takes thereturn value of <A HREF="ch03_02.htm#PERL2-CMD-SLEEP">sleep</A> (typically zero) and ORs that with 3, as ifthe expression were parenthesized as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>(sleep 4) | 3;</PRE></DIV><P CLASS=para>Compare this with:<P CLASS=para><DIV CLASS=programlisting><P><PRE>print 4 | 3;</PRE></DIV><P CLASS=para>which <I CLASS=emphasis>does</I> take the value of 4 ORed with 3 before printing it (7 inthis case), as if it were written:<P CLASS=para><DIV CLASS=programlisting><P><PRE>print (4 | 3);</PRE></DIV><P CLASS=para>This is because <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> is a list operator, not a simple unaryoperator.  Once you've learned which operators are list operators, you'llhave no trouble telling them apart.  When in doubt, you can always useparentheses to turn a named unary operator into a function.  Remember, if itlooks like a function, it is a function.<P CLASS=para>Another funny thing about named unary operators is that many of themdefault to <B>$_</B> if you don't supply an argument.  However.  If thething following the named unary operator looks like it might be thestart of an argument, Perl will get confused.  When the next character inyour program is one of the following characters, the Perl tokener returnsdifferent token types depending on whether a term or operator is expected:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-12"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Char</TH><TH ALIGN="left">Operator</TH><TH ALIGN="left">Term</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>+</tt></TD><TD ALIGN="left">Addition</TD><TD ALIGN="left">Unary plus</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-</tt></TD><TD ALIGN="left">Subtraction</TD><TD ALIGN="left">Unary minus</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>*</tt></TD><TD ALIGN="left">Multiplication</TD><TD ALIGN="left"><tt CLASS=literal>*typeglob</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>/</tt></TD><TD ALIGN="left">Division</TD><TD ALIGN="left"><tt CLASS=literal>/pattern/</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>&lt;</tt></TD><TD ALIGN="left">Less than, left shift</TD><TD ALIGN="left"><tt CLASS=literal>&lt;HANDLE&gt;, &lt;&lt;END</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>.</tt></TD><TD ALIGN="left">Concatenation</TD><TD ALIGN="left"><tt CLASS=literal>.3333</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>?</tt></TD><TD ALIGN="left"><tt CLASS=literal>?:</tt></TD><TD ALIGN="left"><tt CLASS=literal>?pattern?</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>%</tt></TD><TD ALIGN="left">Modulo</TD><TD ALIGN="left"><tt CLASS=literal>%assoc</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>&amp;</tt></TD><TD ALIGN="left"><tt CLASS=literal>&amp;, &amp;&amp;</tt></TD><TD ALIGN="left"><tt CLASS=literal>&amp;subroutine</tt></TD></TR></TABLE><P></DIV><P CLASS=para>So a typical boo-boo is:<P CLASS=para><DIV CLASS=programlisting><P><PRE>next if length &lt; 80;</PRE></DIV><P CLASS=para>in which the <tt CLASS=literal>&lt;</tt> looks to the parser like the beginning of the<tt CLASS=literal>&lt;&gt;</tt> input symbol (a term) instead of the "less than" (an operator) youwere thinking of.  There's really no way to fix this, and still keep Perlpathologically eclectic.  If you're so incredibly lazy that you cannotbring yourself to type the two characters <B>$_</B>, then say one of theseinstead:<P CLASS=para><DIV CLASS=programlisting><P><PRE>next if length() &lt; 80;next if (length) &lt; 80;next if 80 &gt; length;next unless length &gt;= 80;</PRE></DIV><P CLASS=para>A file test operator is a unary operator that takes one argument, either afilename or a filehandle, and tests the associated file to see if somethingis true about it.  If the argument is omitted, it tests <B>$_</B>, except for<tt CLASS=literal>-t</tt>, which tests <tt CLASS=literal>STDIN</tt>.  Unless otherwise documented, it returns<tt CLASS=literal>1</tt> for true and <tt CLASS=literal>``</tt> for false, or the undefinedvalue if the file doesn't exist.  The operator may be any of the following:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-12A"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Operator</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-r</tt></TD><TD ALIGN="left">File is readable by effective uid/gid.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-w</tt></TD><TD ALIGN="left">File is writable by effective uid/gid.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-x</tt></TD><TD ALIGN="left">File is executable by effective uid/gid.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-o</tt></TD><TD ALIGN="left">File is owned by effective uid.</TD></TR><TR CLASS=row><TD ALIGN="left">&nbsp;</TD><TD ALIGN="left">&nbsp;</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-R</tt></TD><TD ALIGN="left">File is readable by real uid/gid.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-W</tt></TD><TD ALIGN="left">File is writable by real uid/gid.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-X</tt></TD><TD ALIGN="left">File is executable by real uid/gid.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-O</tt></TD><TD ALIGN="left">File is owned by real uid.</TD></TR><TR CLASS=row><TD ALIGN="left">&nbsp;</TD><TD ALIGN="left">&nbsp;</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-e</tt></TD><TD ALIGN="left">File exists.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-z</tt></TD><TD ALIGN="left">File has zero size.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-s</tt></TD><TD ALIGN="left">File has non-zero size (returns size).</TD></TR><TR CLASS=row><TD ALIGN="left">&nbsp;</TD><TD ALIGN="left">&nbsp;</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-f</tt></TD><TD ALIGN="left">File is a plain file.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-d</tt></TD><TD ALIGN="left">File is a directory.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-l</tt></TD><TD ALIGN="left">File is a symbolic link.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-p</tt></TD><TD ALIGN="left">File is a named pipe (FIFO).</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-S</tt></TD><TD ALIGN="left">File is a socket.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-b</tt></TD><TD ALIGN="left">File is a block special file.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-c</tt></TD><TD ALIGN="left">File is a character special file.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-t</tt></TD><TD ALIGN="left">Filehandle is opened to a tty.</TD></TR><TR CLASS=row><TD ALIGN="left">&nbsp;</TD><TD ALIGN="left">&nbsp;</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-u</tt></TD><TD ALIGN="left">File has setuid bit set.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-g</tt></TD><TD ALIGN="left">File has setgid bit set.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-k</tt></TD><TD ALIGN="left">File has sticky bit set.</TD></TR><TR CLASS=row><TD ALIGN="left">&nbsp;</TD><TD ALIGN="left">&nbsp;</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-T</tt></TD><TD ALIGN="left">File is a text file.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-B</tt></TD><TD ALIGN="left">File is a binary file (opposite of <tt CLASS=literal>-T</tt>).</TD></TR><TR CLASS=row><TD ALIGN="left">&nbsp;</TD><TD ALIGN="left">&nbsp;</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-M</tt></TD><TD ALIGN="left">Age of file (at startup) in days since modification.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-A</tt></TD><TD ALIGN="left">Age of file (at startup) in days since last access.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>-C</tt></TD><TD ALIGN="left">Age of file (at startup) in days since inode change.</TD></TR></TABLE><P></DIV><P CLASS=para>The interpretation of the file permission operators<tt CLASS=literal>-r</tt>, <tt CLASS=literal>-R</tt>, <tt CLASS=literal>-w</tt>,<tt CLASS=literal>-W</tt>, <tt CLASS=literal>-x</tt>, and <tt CLASS=literal>-X</tt>is based solely on the mode of the file and the user and group IDs ofthe user.  There may be other reasons you can't actually read, write,or execute the file, such as Andrew File System (AFS) access control lists.  Also note thatfor the superuser, <tt CLASS=literal>-r</tt>, <tt CLASS=literal>-R</tt>,<tt CLASS=literal>-w</tt>, and <tt CLASS=literal>-W</tt> always return 1, and<tt CLASS=literal>-x</tt>, and <tt CLASS=literal>-X</tt> return 1 if anyexecute bit is set in the mode.  Scripts run by the superuser may thusneed to do a <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A> in order to determinethe actual mode of the file, or temporarily set the uid to somethingelse. Example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    chomp;    next unless -f $_;      # ignore "special" files    ...}</PRE></DIV><P CLASS=para>Note that <tt CLASS=literal>-s/a/b/</tt> does not do a negated substitution.  Saying<tt CLASS=literal>-exp($foo)</tt> still works as expected, however--only single lettersfollowing a minus are interpreted as file tests.<P CLASS=para>The <tt CLASS=literal>-T</tt> and <tt CLASS=literal>-B</tt> switches work as follows.  The first block or soof the file is examined for odd characters such as strange control codes orcharacters with the high bit set.  If too many odd characters (&gt;30%) arefound, it's a <tt CLASS=literal>-B</tt> file, otherwise it's a <tt CLASS=literal>-T</tt> file.  Also, anyfile containing null in the first block is considered a binary file.  If<tt CLASS=literal>-T</tt> or <tt CLASS=literal>-B</tt> is used on afilehandle, the current input (standard I/O or "stdio")buffer is examined rather than the first block of the file.Both <tt CLASS=literal>-T</tt> and <tt CLASS=literal>-B</tt> returntrue on a null file, or on a file at EOF (end of file) when testing afilehandle.  Because you have to read a file to do the <tt CLASS=literal>-T</tt> test, onmost occasions you want to use a <tt CLASS=literal>-f</tt> against the file first, as in:<P CLASS=para><DIV CLASS=programlisting><P><PRE>next unless -f $file &amp;&amp; -T _;</PRE></DIV><P CLASS=para>If any of the file tests (or either the <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A> or <A HREF="ch03_02.htm#PERL2-CMD-LSTAT">lstat</A> operators)are given the special filehandle consisting of a solitary underline,then the <I CLASS=emphasis>stat</I> structure of the previous file test (or <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A> operator) isused, thereby saving a system call.  (This doesn't work with <tt CLASS=literal>-t</tt>, andyou need to remember that <A HREF="ch03_02.htm#PERL2-CMD-LSTAT">lstat</A> and <tt CLASS=literal>-l</tt> will leave values in the<I CLASS=emphasis>stat</I> structure for the symbolic link, not the real file.)[30]Example:<blockquote class=footnote><P CLASS=para>[30] Likewise, <tt CLASS=literal>-l _</tt> will always be false after a normal <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A>.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>print "Can do.\n" if -r $a || -w _ || -x _;stat($filename);print "Readable\n" if -r _;print "Writable\n" if -w _;print "Executable\n" if -x _;print "Setuid\n" if -u _;print "Setgid\n" if -g _;print "Sticky\n" if -k _;print "Text\n" if -T _;print "Binary\n" if -B _;</PRE></DIV><P CLASS=para>File ages for <tt CLASS=literal>-M</tt>, <tt CLASS=literal>-A</tt>, and <tt CLASS=literal>-C</tt> are returned in days(including fractional days) since the time when the script started running.(This time is stored inthe special variable <B>$^T</B>.)  Thus, if the file changed after thescript started, you would get a negative time.Note that most times (86,399 out of 86,400, on average) are fractional,so testing for equality with an integer without using the <A HREF="ch03_02.htm#PERL2-CMD-INT">int</A>function is usually futile.  Examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE>next unless -M $file &gt; .5;      # files older than 12 hours&amp;newfile if -M $file &lt; 0;       # file is newer than process&amp;mailwarning if int(-A) == 90;  # file ($_) accessed 90 days ago today</PRE></DIV><P CLASS=para>To reset the script's start time to the current time, change <B>$^T</B>as follows:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$^T = time;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.11">Relational Operators</A></h3><P CLASS=para>Perl has two classes of relational operators.  One class operates onnumeric values, and the other class operates on string values.  Torepeat the table given in the overview:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-13"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Numeric</TH><TH ALIGN="left">String</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>&gt;</tt></TD><TD ALIGN="left"><tt CLASS=literal>gt</tt></TD><TD ALIGN="left">Greater than</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>&gt;=</tt></TD><TD ALIGN="left"><tt CLASS=literal>ge</tt></TD><TD ALIGN="left">Greater than or equal to</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>&lt;</tt></TD><TD ALIGN="left"><tt CLASS=literal>lt</tt></TD><TD ALIGN="left">Less than</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>&lt;=</tt></TD><TD ALIGN="left"><tt CLASS=literal>le</tt></TD><TD ALIGN="left">Less than or equal to</TD></TR></TABLE><P></DIV><P CLASS=para>These operators return <tt CLASS=literal>1</tt> for true, and <tt CLASS=literal>``</tt> for false.  Stringcomparisons are based on the ASCII collating sequence, and unlike in somelanguages, trailing spaces count in the comparison. Note that relational operators are non-associating, which means that<tt CLASS=literal>$a &lt; $b &lt; $c</tt> is a syntax error.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.12">Equality Operators</A></h3><P CLASS=para>The equality operators are much like the relational operators.<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-14"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Numeric</TH><TH ALIGN="left">String</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>==</tt></TD><TD ALIGN="left"><tt CLASS=literal>eq</tt></TD><TD ALIGN="left">Equal to</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>!=</tt></TD><TD ALIGN="left"><tt CLASS=literal>ne</tt></TD><TD ALIGN="left">Not equal to</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>&lt;=&gt;</tt></TD><TD ALIGN="left"><tt CLASS=literal>cmp</tt></TD><TD ALIGN="left">Comparison, with signed result</TD></TR></TABLE><P></DIV><P CLASS=para>The equal and not-equal operators return 1 for true, and <tt CLASS=literal>``</tt> for false (just asthe relational operators do).  The <tt CLASS=literal>&lt;=&gt;</tt> and <B>cmp</B> operators return-1 if the left operand is less than the right operand, 0 if they areequal, and +1 if the left operand is greater than the right.  Althoughthese appear to be very similar to the relational operators, they dohave a different precedence level, so <tt CLASS=literal>$a &lt; $b &lt;=&gt; $c &lt; $d</tt> issyntactically valid.<P CLASS=para>For reasons that are apparent to anyone who has seen <I CLASS=emphasis>Star Wars</I>, the <tt CLASS=literal>&lt;=&gt;</tt>operator is known as the "spaceship" operator.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.13">Bitwise Operators</A></h3><P CLASS=para>Like C, Perl has bitwise AND, OR, and XOR (exclusiveOR) operators: <tt CLASS=literal>&amp;</tt>, <tt CLASS=literal>|</tt>, and <tt CLASS=literal>^</tt>.  Note from the table at thestart of this section that bitwise-AND has a higher precedence.  Theseoperators work differently on numeric values than they do on strings.(This is one of the few places where Perl cares about the difference.)If either operand is a number (or has been used as a number), then bothoperands are converted to type integer, and the bitwise operation isperformed between the two integers.  These integers are guaranteed tobe at least 32 bits long, but may be 64 bits on some machines.  The pointis that there's an arbitrary limit imposed by the machine's architecture.<P CLASS=para>If both operands are strings (and have not been used as numbers sincebeing set), these operators do bitwise operations between correspondingbits from the two strings.  In this case, there's no arbitrary limit,since strings aren't arbitrarily limited in size.  If one string islonger than the other, the shorter string is considered to have a sufficientnumber of 0 bits on the end to make up the difference.<P CLASS=para>For example, if you AND together two strings:<DIV CLASS=programlisting><P><PRE>"123.45" &amp; "234.56"</PRE></DIV><P CLASS=para>you get another string:<DIV CLASS=programlisting><P><PRE>"020.44"</PRE></DIV><P CLASS=para>But if you AND together a string and a number:<DIV CLASS=programlisting><P><PRE>"123.45" &amp; 234.56</PRE></DIV><P CLASS=para>The string is first converted to a number, giving:<DIV CLASS=programlisting><P><PRE>123.45 &amp; 234.56</PRE></DIV><P CLASS=para>The numbers are then converted to integer:<DIV CLASS=programlisting><P><PRE>123 &amp; 234</PRE></DIV><P CLASS=para>which evaluates to 106.<P CLASS=para>Note that all bit strings are true(unless they come out to being the string "<tt CLASS=literal>0</tt>").  This meansthat tests of the form:<DIV CLASS=programlisting><P><PRE>if ( "fred" &amp; "\1\2\3\4" ) { ... }</PRE></DIV><P CLASS=para>would need to be written instead as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if ( ("fred" &amp; "\1\2\3\4") !~ /^\0+$/ ) { ... }</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.14">C-style Logical (Short Circuit) Operators</A></h3><P CLASS=para>Like C, Perl provides the <tt CLASS=literal>&amp;&amp;</tt> (logical AND)and <tt CLASS=literal>||</tt> (logical OR) operators.  They evaluate fromleft to right (with <tt CLASS=literal>&amp;&amp;</tt> having slightlyhigher precedence than <tt CLASS=literal>||</tt>) testing the truth of thestatement.  These operators are known as short-circuit operatorsbecause they determine the truth of the statement by evaluating thefewest number of operands possible.  For example, if the left operandof an <tt CLASS=literal>&amp;&amp;</tt> operator is false, the right operandis never evaluated because the result of the operator is falseregardless of the value of the right operand.<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-15"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Example</TH><TH ALIGN="left">Name</TH><TH ALIGN="left">Result</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>$a &amp;&amp; $b</tt></TD><TD ALIGN="left">And</TD><TD ALIGN="left"><tt CLASS=literal>$a</tt> if <tt CLASS=literal>$a</tt> is false, <tt CLASS=literal>$b</tt> otherwise</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>$a || $b</tt></TD><TD ALIGN="left">Or</TD><TD ALIGN="left"><tt CLASS=literal>$a</tt> if <tt CLASS=literal>$a</tt> is true, <tt CLASS=literal>$b</tt> otherwise</TD></TR></TABLE><P></DIV><P CLASS=para>Such short circuits are not only time savers, but are frequently usedto control the flow of evaluation.  For example, an oft-appearing idiomin Perl programs is:<P CLASS=para><DIV CLASS=programlisting><P><PRE>open(FILE, "somefile") || die "Cannot open somefile: $!\n";</PRE></DIV><P CLASS=para>In this case, Perl first evaluates the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> function.  If the valueis true (because <I CLASS=emphasis>somefile</I> was successfully opened), the executionof the <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> function is unnecessary, and is skipped.  You can readthis literally as "Open some file or die!"<P CLASS=para>The <tt CLASS=literal>||</tt> and <tt CLASS=literal>&amp;&amp;</tt> operators differ from C's in that, rather thanreturning 0 or 1, they return the last value evaluated.  This has thedelightful result that you can select the first of a series of valuesthat happens to be true.  Thus, a reasonably portable way to find outthe home directory might be:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$home = $ENV{HOME}      || $ENV{LOGDIR}      || (getpwuid($&lt;))[7]      || die "You're homeless!\n";</PRE></DIV><P CLASS=para>Perl also provides lower precedence <B>and</B> and <B>or</B> operators that aremore readable and don't force you to use parentheses as much.  They alsoshort-circuit.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.15">Range Operator</A></h3><P CLASS=para><A NAME="CH02.RANGE1"></A><A NAME="CH02.RANGE2"></A>The <tt CLASS=literal>..</tt> range operator is really two differentoperators depending on the context.  In a list context, it returns alist of values counting (by ones) from the left value to the rightvalue.  This is useful for writing <tt CLASS=literal>for (1..10)</tt> loops and for doingslice operations on arrays.[31]<blockquote class=footnote><P CLASS=para>[31] Be aware that under the current implementation,a temporary array is created, so you'll burn a <I CLASS=emphasis>lot</I> of memory if you write something like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>for (1 .. 1_000_000) {    # code}</PRE></DIV></blockquote><P CLASS=para>In a scalar context, <tt CLASS=literal>..</tt> returns a Boolean value.  The operatoris bi-stable, like an electronic flip-flop, and emulates the line-range(comma) operator of <I CLASS=emphasis>sed</I>, <I CLASS=emphasis>awk</I>, and various editors.  Eachscalar <tt CLASS=literal>..</tt> operator maintains its own Boolean state.  It is falseas long as its left operand is false.  Once the left operand is true,the range operator stays true until the right operand is true,<I CLASS=emphasis>after</I> which the range operator becomes false again.  (The operator doesn'tbecome false until the next time it is evaluated.  It can test the right operandand become false on the same evaluation as the one where it became true (the way<I CLASS=emphasis>awk</I>'s range operator behaves), but it still returns true once.  If youdon't want it to test the right operand until the next evaluation (which is how<I CLASS=emphasis>sed</I>'s range operator works), just use three dots (<tt CLASS=literal>. . .</tt>) instead oftwo.)  The right operand is not evaluated while the operator is in the falsestate, and the left operand is not evaluated while the operator is in the truestate.<P CLASS=para>The precedence is a little lower than <tt CLASS=literal>||</tt> and <tt CLASS=literal>&amp;&amp;</tt>.The value returned iseither the null string for false, or a sequence number (beginning with<tt CLASS=literal>1</tt>) for true.  The sequence number is reset for each range encountered.The final sequence number in a range has the string "E0" appended to it,which doesn't affect its numeric value, but gives you something tosearch for if you want to exclude the endpoint.  You can exclude thebeginning point by waiting for the sequence number to be greater than 1.If either operand of scalar <tt CLASS=literal>..</tt> is a numeric literal, that operand isevaluated by comparing it to the <B>$.</B> variable, which contains the currentline number for your input file.  Examples:<P CLASS=para>As a scalar operator:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if (101 .. 200) { print; }  # print 2nd hundred linesnext line if (1 .. /^$/);   # skip header liness/^/&gt; / if (/^$/ .. eof()); # quote body</PRE></DIV><P CLASS=para>As a list operator:<P CLASS=para><DIV CLASS=programlisting><P><PRE>for (101 .. 200) { print; }            # prints 101102...199200@foo = @foo[0 .. $#foo];               # an expensive no-op@foo = @foo[ -5 .. -1];                # slice last 5 items</PRE></DIV><P CLASS=para>The range operator (in a list context) makes use of the magicalautoincrement algorithm if the operands are strings.[32]So you can say:<blockquote class=footnote><P CLASS=para>[32] If the final value specified is not in the sequence that the magical incrementwould produce, the sequence goes until the next value would be longer thanthe final value specified.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>@alphabet = ('A' .. 'Z');</PRE></DIV><P CLASS=para>to get all the letters of the alphabet, or:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$hexdigit = (0 .. 9, 'a' .. 'f')[$num &amp; 15];</PRE></DIV><P CLASS=para>to get a hexadecimal digit, or:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@z2 = ('01' .. '31');  print $z2[$mday];</PRE></DIV><P CLASS=para>to get dates with leading zeros.  You can also say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@combos = ('aa' .. 'zz');</PRE></DIV><P CLASS=para>to get all combinations of two lowercase letters. However, be careful ofsomething like:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@bigcombos = ('aaaaaa' .. 'zzzzzz');</PRE></DIV><P CLASS=para>since that will require lots of memory.  More precisely, it'll needspace to store 308,915,776 scalars.  Let's hope you allocated a <I CLASS=emphasis>large</I>swap partition.  Perhaps you should consider an iterative approach instead.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.16">Conditional Operator</A></h3><P CLASS=para>Trinary <tt CLASS=literal>?:</tt> is the conditional operator, just as in C.  It works as:<P CLASS=para><DIV CLASS=programlisting><P><PRE><tt CLASS=replaceable><i>TEST_EXPR</i></tt> ? <tt CLASS=replaceable><i>IF_TRUE_EXPR</i></tt> : <tt CLASS=replaceable><i>IF_FALSE_EXPR</i></tt></PRE></DIV><P CLASS=para>much like an if-then-else, except that it can safely be embedded within otheroperations and functions.  If the <tt CLASS=replaceable><i>TEST_EXPR</i></tt> is true, only the<tt CLASS=replaceable><i>IF_TRUE_EXPR</i></tt> is evaluated, and the value of that expression becomesthe value of the entire expression.  Otherwise, only the <tt CLASS=replaceable><i>IF_FALSE_EXPR</i></tt>is evaluated, and its value becomes the value of the entireexpression.<P CLASS=para><DIV CLASS=programlisting><P><PRE>printf "I have %d dog%s.\n", $n,         ($n == 1) ? "" : "s";</PRE></DIV><P CLASS=para>Scalar or list context propagates downward into the secondor third argument, whichever is selected. (The first argument is alwaysin scalar context, since it's a conditional.)<P CLASS=para><DIV CLASS=programlisting><P><PRE>$a = $ok ? $b : $c;  # get a scalar@a = $ok ? @b : @c;  # get an array$a = $ok ? @b : @c;  # get a count of elements in one of the arrays</PRE></DIV><P CLASS=para>You can assign to the conditional operator[33]if both the second and thirdarguments arelegal lvalues (meaning that you can assign to them), provided that both arescalars or both are lists (or Perl won't know which context to supply tothe right side of the assignment):<blockquote class=footnote><P CLASS=para>[33] This is not necessarily guaranteed to contribute to the readability of your program.  But it can be used to create some cool entries in an ObfuscatedPerl contest.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>($a_or_b ? $a : $b) = $c;  # sets either $a or $b to equal $c</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.17">Assignment Operators</A></h3><P CLASS=para>Perl recognizes the C assignment operators, as well as providing some of itsown.  There are quite a few of them:<P CLASS=para><DIV CLASS=programlisting><P><PRE>=    **=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=            -=    /=    |=    &gt;&gt;=    ||=            .=    %=    ^=                  x=</PRE></DIV><P CLASS=para>Each operator requires an lvalue (a variable or array element) on the leftside, and some expression on the right side.  For the simple assignmentoperator, <tt CLASS=literal>=</tt>, the value of the expression is stored into the designatedvariable.  For the other operators, Perl evaluates the expression:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$var <tt CLASS=replaceable><i>OP</i></tt>= $value</PRE></DIV><P CLASS=para>as if it were written:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$var = $var <tt CLASS=replaceable><i>OP</i></tt> $value</PRE></DIV><P CLASS=para>except that <tt CLASS=literal>$var</tt> is evaluated only once.  Compare the following twooperations:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$var[$a++] += $value;               # $a is incremented once$var[$a++] = $var[$a++] + $value;   # $a is incremented twice</PRE></DIV><P CLASS=para>Unlike in C, the assignment operator produces a valid lvalue.  Modifyingan assignment is equivalent to doing the assignment and then modifyingthe variable that was assigned to.  This is useful for modifyinga copy of something, like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($tmp = $global) += $constant;</PRE></DIV><P CLASS=para>which is the equivalent of:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$tmp = $global + $constant;</PRE></DIV><P CLASS=para>Likewise:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($a += 2) *= 3;</PRE></DIV><P CLASS=para>is equivalent to:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$a += 2;$a *= 3;</PRE></DIV><P CLASS=para>That's not actually very useful, but you often see this idiom:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($new = $old) =~ s/foo/bar/g;</PRE></DIV><P CLASS=para>In all cases, the value of the assignment is the new value of the variable.Since assignment operators associate right-to-left, this can be used to assignmany variables the same value, as in:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$a = $b = $c = 0;</PRE></DIV><P CLASS=para>which assigns <tt CLASS=literal>0</tt> to <tt CLASS=literal>$c</tt>, and the result of that (still <tt CLASS=literal>0</tt>) to<tt CLASS=literal>$b</tt>, and the result of that (<I CLASS=emphasis>still</I> <tt CLASS=literal>0</tt>) to <tt CLASS=literal>$a</tt>.<P CLASS=para>List assignment may be done only with the plain assignment operator, <tt CLASS=literal>=</tt>.In a list context, list assignment returns the list of new values just asscalar assignment does.  In a scalar context, list assignment returns thenumber of values that were available on the right side of the assignment,as we mentioned earlier in "List Values and Arrays".  This makes ituseful for testing functions that return a null list when they're"unsuccessful", as in:<P CLASS=para><DIV CLASS=programlisting><P><PRE>while (($key, $value) = each %gloss) { ... }next unless ($dev, $ino, $mode) = stat $file;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.18">Comma Operators</A></h3><P CLASS=para>Binary "<tt CLASS=literal>,</tt>" is the comma operator.  In a scalar context it evaluatesits left argument, throws that value away, then evaluates its rightargument and returns that value.  This is just like C's comma operator.For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$a = (1, 3);</PRE></DIV><P CLASS=para>assigns <tt CLASS=literal>3</tt> to <tt CLASS=literal>$a</tt>.  Do not confuse the scalar context use with the listcontext use.  In a list context, it's just the list argument separator, and inserts both its arguments into the <tt CLASS=replaceable><i>LIST</i></tt>.  It does not throw any valuesaway.  <P CLASS=para>For example, if you change the above to:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@a = (1, 3);</PRE></DIV><P CLASS=para>you are constructing a two-element list, while:<P CLASS=para><DIV CLASS=programlisting><P><PRE>atan2(1, 3);</PRE></DIV><P CLASS=para>is calling the function <A HREF="ch03_02.htm#PERL2-CMD-ATAN2">atan2</A> with two arguments.<P CLASS=para>The <tt CLASS=literal>=&gt;</tt> digraph is mostly just a synonym for the comma operator.It's useful for documenting arguments that come in pairs.  It alsoforces any identifier to the left of it to be interpreted as a string.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.19">List Operators (Rightward)</A></h3><P CLASS=para>The right side of a list operator governs all the list operator'sarguments, which are comma separated, so the precedence of list operators islooser than comma if you're looking to the right.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.20">Logical and, or, not, and xor</A></h3><P CLASS=para>As more readable alternatives to <tt CLASS=literal>&amp;&amp;</tt>, <tt CLASS=literal>||</tt>, and <tt CLASS=literal>!</tt>,Perl provides the <B>and</B>, <B>or</B> and <B>not</B> operators.  Thebehavior of these operators is identical--in particular, theyshort-circuit the same way.[34]<blockquote class=footnote><P CLASS=para>[34] Obviously the unary <B>not</B> doesn't short circuit, just as <tt CLASS=literal>!</tt> doesn't.</blockquote><P CLASS=para>The precedence of these operators is much lower, however, so you cansafely use them after a list operator without the need forparentheses:<P CLASS=para><DIV CLASS=programlisting><P><PRE>unlink "alpha", "beta", "gamma"        or gripe(), next LINE;</PRE></DIV><P CLASS=para>With the C-style operators that would have to be written like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>unlink("alpha", "beta", "gamma")        || (gripe(), next LINE);</PRE></DIV><P CLASS=para>There is also a logical <B>xor</B> operator that has no exact counterpart inC or Perl, since the other XOR operator (<tt CLASS=literal>^</tt>) works on bits.  Thebest equivalent for <tt CLASS=literal>$a xor $b</tt> is perhaps <tt CLASS=literal>!$a != !$b</tt>.[35]This operator can't short-circuit either, since both sides must be evaluated.<blockquote class=footnote><P CLASS=para>[35] One could also write <tt CLASS=literal>!$a ^ !$b</tt> or even <tt CLASS=literal>$a ? !$b : !!$b</tt>,of course.  The point is that both <tt CLASS=literal>$a</tt> and <tt CLASS=literal>$b</tt> have toevaluate to true or false in a Boolean context, and the existing bitwiseoperator doesn't provide a Boolean context.</blockquote></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-5.21">C Operators Missing from Perl</A></h3><P CLASS=para>Here is what C has that Perl doesn't:<P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>unary &amp;</tt><DD><P CLASS=para>The address-of operator.  Perl's <tt CLASS=literal>\</tt> operator (for taking a reference)fills the same ecological niche, however:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$ref_to_var = \$var;</PRE></DIV><P CLASS=para>But references are much safer than addresses.<p><DT CLASS=varlistentry><tt CLASS=literal>unary *</tt><DD><P CLASS=para>The dereference-address operator.  Since Perl doesn't have addresses, itdoesn't need to dereference addresses.  It does have references though,so Perl's variable prefix characters serve as dereference operators,and indicate type as well: <tt CLASS=literal>$</tt>, <tt CLASS=literal>@</tt>, <tt CLASS=literal>%</tt> and<tt CLASS=literal>&amp;</tt>.  Oddly enough, there actually is a <tt CLASS=literal>*</tt> dereferenceoperator, but since <tt CLASS=literal>*</tt> is the funny characterindicating a typeglob, you wouldn't use it the same way.<p><DT CLASS=varlistentry><tt CLASS=literal>(TYPE)</tt><DD><P CLASS=para>The typecasting operator.  Nobody likes to be typecast anyway.</DL></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_04.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch02_06.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Pattern Matching</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Statements and Declarations</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>