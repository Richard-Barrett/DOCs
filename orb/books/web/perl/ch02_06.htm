<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 2] 2.6 Statements and Declarations</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:03:22 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_05.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 2</b></td><td width=172 align=right valign=top><A HREF="ch02_07.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6">2.6 Statements and Declarations</A></h2><P CLASS=para><A NAME="CH02.SD"></A><A NAME="CH02.DS"></A>A Perl program consists of a sequence of declarations and statements.A declaration may be placed anywhere a statement may be placed, but ithas its primary (or only) effect at compile time. (Some declarations do doubleduty as ordinary statements, while others are totally transparent at run-time.)After compilation,the main sequence of statements is executed just once, unlike in <I CLASS=emphasis>sed</I> and<I CLASS=emphasis>awk</I> scripts, where the sequence of statements is executed for eachinput line.  While this means that you must explicitly loop over the linesof your input file (or files), it also means you have much more controlover which files and which lines you look at.[36]Unlike many high-level languages, Perl requires only subroutines andreport formats to be explicitly declared.  All other user-createdobjects spring into existence with a null or 0 value unless they aredefined by some explicit operation such as assignment.[37]<blockquote class=footnote><P CLASS=para>[36] Actually, I'm lying--it is possible to do an implicit loop witheither the <B>-n</B> or <B>-p</B> command-line switch.  It's just not themandatory default like it is in <I CLASS=emphasis>sed</I> and<I CLASS=emphasis>awk</I>.<P CLASS=para>[37] The <B>-w</B> command-line switch will warnyou about using undefined values.  </blockquote><P CLASS=para>You <I CLASS=emphasis>may</I> declare your variables though, if you like.  You may evenmake it an error to use an undeclared variable.  This kind of disciplineis fine, but you have to declare that you want the discipline.  (Thisseems appropriate, somehow.)  See <tt CLASS=literal>use strict</tt> in the section on"Pragmas" later in this chapter.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.1">Simple Statements</A></h3><P CLASS=para>A simple statement is an expression evaluated for its side effects.  Everysimple statement must end in a semicolon, unless it is the final statement in ablock.  In this case, the semicolon is optional (but strongly encouraged inany multiline block, since you may eventually add another line).  <P CLASS=para>Even though some operators (like <tt CLASS=literal>eval {}</tt> and <tt CLASS=literal>do {}</tt>) look like compoundstatements, they aren't. True, they allow multiple statements on theinside, but that doesn't count. From the outside those statements arejust terms in anexpression, and thus need an explicit semicolon if used as the last itemin a statement.<P CLASS=para>Any simple statement may optionally be followed by a single modifier, justbefore the terminating semicolon (or block ending).  The possible modifiersare:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if <tt CLASS=replaceable><i>EXPR</i></tt>unless <tt CLASS=replaceable><i>EXPR</i></tt>while <tt CLASS=replaceable><i>EXPR</i></tt>until <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>The <B>if</B> and <B>unless</B> modifiers work pretty much as you'd expect ifyou speak English:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$trash-&gt;take('out') if $you_love_me;shutup() unless $you_want_me_to_leave;</PRE></DIV><P CLASS=para>The <B>while</B> and <B>until</B> modifiers evaluate repeatedly as long asthe modifier is true:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$expression++ while -e "$file$expression";kiss('me') until $I_die;</PRE></DIV><P CLASS=para>The <B>while</B> and <B>until</B> modifiers also have the usual while-loopsemantics (conditional evaluated first), except when applied to a<tt CLASS=literal>do {}</tt> (or to the now-deprecated <tt CLASS=literal>do-SUBROUTINE</tt> statement), inwhich case the block executes once before the conditional is evaluated.This is so that you can write loops like:<P CLASS=para><DIV CLASS=programlisting><P><PRE>do {    $line = &lt;STDIN&gt;;    ...} until $line eq ".\n";</PRE></DIV><P CLASS=para>See the <A HREF="ch03_02.htm#PERL2-CMD-DO">do</A> entry in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.  Note also that the loop-controlstatements described later will not work in this construct, since modifiers don't take loop labels.  Sorry.  You can always wrapanother block around it to do that sort of thing.  Or write a realloop with multiple loop-control commands inside.  Speaking ofreal loops, we'll talk about compound statements next.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.2">Compound Statements</A></h3><P CLASS=para>A sequence of statements that defines a scope is called a <I CLASS=emphasis>block</I>.Sometimes a block is delimited by the file containing it (in thecase of either a "<A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>d" file, or the program as a whole), andsometimes it's delimited by the extent of a string (in the case of an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>).  Butgenerally, a block is delimited by braces (<tt CLASS=literal>{}</tt>).  When we mean ablock with braces, we'll use the term <tt CLASS=replaceable><i>BLOCK</i></tt>.<P CLASS=para>Compound statements are built out of expressions and <tt CLASS=replaceable><i>BLOCK</i></tt>s.The expressionsare built out of the terms and operators we've already discussed.  In oursyntax diagrams, we'll use the word <tt CLASS=replaceable><i>EXPR</i></tt> to indicate a place whereyou canuse an expression.<P CLASS=para>The following conditionals and loops may be used to control flow:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if (<tt CLASS=replaceable><i>EXPR</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt>if (<tt CLASS=replaceable><i>EXPR</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt> else <tt CLASS=replaceable><i>BLOCK</i></tt>if (<tt CLASS=replaceable><i>EXPR</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt> elsif (<tt CLASS=replaceable><i>EXPR</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt> ...if (<tt CLASS=replaceable><i>EXPR</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt> elsif (<tt CLASS=replaceable><i>EXPR</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt> ... else <tt CLASS=replaceable><i>BLOCK</i></tt><tt CLASS=replaceable><i>LABEL</i></tt> while (<tt CLASS=replaceable><i>EXPR</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt><tt CLASS=replaceable><i>LABEL</i></tt> while (<tt CLASS=replaceable><i>EXPR</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt> continue <tt CLASS=replaceable><i>BLOCK</i></tt><tt CLASS=replaceable><i>LABEL</i></tt> for (<tt CLASS=replaceable><i>EXPR</i></tt>; <tt CLASS=replaceable><i>EXPR</i></tt>; <tt CLASS=replaceable><i>EXPR</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt><tt CLASS=replaceable><i>LABEL</i></tt> foreach <tt CLASS=replaceable><i>VAR</i></tt> (<tt CLASS=replaceable><i>LIST</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt><tt CLASS=replaceable><i>LABEL</i></tt> foreach <tt CLASS=replaceable><i>VAR</i></tt> (<tt CLASS=replaceable><i>LIST</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt> continue <tt CLASS=replaceable><i>BLOCK</i></tt><tt CLASS=replaceable><i>LABEL</i></tt> <tt CLASS=replaceable><i>BLOCK</i></tt><tt CLASS=replaceable><i>LABEL</i></tt> <tt CLASS=replaceable><i>BLOCK</i></tt> continue <tt CLASS=replaceable><i>BLOCK</i></tt></PRE></DIV><P CLASS=para>Note that unlike in C and Pascal, these are defined in terms of<tt CLASS=replaceable><i>BLOCK</i></tt>s, not statements.  This means thatthe braces are required--no dangling statements allowed.  If you want to writeconditionals without braces there are several other ways to do it.  Thefollowing all do the same thing:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if (!open(FOO, $foo)) { die "Can't open $foo: $!"; } die "Can't open $foo: $!" unless open(FOO, $foo);open(FOO, $foo) or die "Can't open $foo: $!";     # FOO or bust!open(FOO, $foo) ? 'hi mom' : die "Can't open $foo: $!";                    # a bit exotic, that last one</PRE></DIV><P CLASS=para>Your authors would tend to prefer the third of those under mostcircumstances.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.3">If Statements</A></h3><P CLASS=para>The <B>if</B> statement is straightforward.  Since <tt CLASS=replaceable><i>BLOCK</i></tt>sare always boundedby braces, there is never any ambiguity about which <B>if</B> an <B>else</B> oran <B>elsif</B> goes with.  In any particular sequence of<B>if</B>/<B>elsif</B>/<B>else</B> <tt CLASS=replaceable><i>BLOCK</i></tt>s,only the first one that has a truecondition will be executed.  If none of them is true, then the<B>else</B> <tt CLASS=replaceable><i>BLOCK</i></tt>, if there is any, is executed.<P CLASS=para>If you use <B>unless</B> in place of <B>if</B>, the sense of the test isreversed.  That is:<P CLASS=para><DIV CLASS=programlisting><P><PRE>unless ($OS_ERROR) ...</PRE></DIV><P CLASS=para>is equivalent to:[38]<blockquote class=footnote><P CLASS=para>[38] <tt CLASS=literal>$OS_ERROR</tt> is the same as <B>$!</B> if you <tt CLASS=literal>use English</tt>.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>if (not $OS_ERROR) ...</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.4">Loop Statements</A></h3><P CLASS=para><A NAME="CH02.LOOPS"></A>All compound loop statements have an optional <tt CLASS=replaceable><i>LABEL</i></tt>.  If present, thelabel consists of an identifier followed by a colon.  It's customary tomake the label upper case to avoid potential conflict with reservedwords, and so it stands out better.  (But don't use <tt CLASS=literal>BEGIN</tt>or <tt CLASS=literal>END</tt>!)<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.4.1">While statements</A></h4><P CLASS=para>The <B>while</B> statement repeatedly executes the block as long as the<tt CLASS=replaceable><i>EXPR</i></tt>is true.  If the word <B>while</B> is replaced by the word <B>until</B>, thesense of the test is reversed.  The conditional is still tested beforethe first iteration, though.<P CLASS=para>The <B>while</B> statement has an optional extra block on the end called a<B>continue</B> block.  This is a block that is executed every time theblock is continued, either by falling off the end of the first block, orby an explicit loop-control command that goes to the next iteration.The <B>continue</B> block is not heavily used in practice, but it's in thereso we can define the <B>for</B> loop rigorously.  So let's do that.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.4.2">For loops</A></h4><P CLASS=para><A NAME="CH02.FOR"></A>The C-style <B>for</B> loop has three semicolon-separated expressions withinits parentheses.  These three expressions function respectively as theinitialization, the condition, and the re-initialization expressions ofthe loop.  (All three expressions are optional, and the condition, ifomitted, is assumed to be true.)  The <B>for</B> loop can be defined in termsof the corresponding <B>while</B> loop.  <P CLASS=para>Thus, the following:<P CLASS=para><DIV CLASS=programlisting><P><PRE>for ($i = 1; $i &lt; 10; $i++) {    ...}</PRE></DIV><P CLASS=para>is the same as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$i = 1;while ($i &lt; 10) {    ...}continue {    $i++;}</PRE></DIV><P CLASS=para>(Defining the <B>for</B> loop in terms of a <B>continue</B> block allows us topreserve the correct semantics even when the loop is continued via a<A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A> statement.  This is unlike C, in which there is no way to writethe exact equivalent of a continued <B>for</B> loop without chicanery.)<P CLASS=para>If you want to iterate through two variables simultaneously, just separatethe parallel expressions with commas:<P CLASS=para><DIV CLASS=programlisting><P><PRE>for ($i = 0, $bit = 1; $mask &amp; $bit; $i++, $bit &lt;&lt; 1) {    print "Bit $i is set\n";}</PRE></DIV><P CLASS=para>Besides the normal array index looping, <B>for</B> can lend itself to manyother interesting applications.  There doesn't even have to be anexplicit loop variable.  Here's one example that avoids the problem youget into if you explicitly test for end-of-file on an interactive filedescriptor, causing your program to appear to hang.<P CLASS=para><DIV CLASS=programlisting><P><PRE>$on_a_tty = -t STDIN &amp;&amp; -t STDOUT;sub prompt { print "yes? " if $on_a_tty }for ( prompt(); &lt;STDIN&gt;; prompt() ) {    # do something}</PRE></DIV><P CLASS=para>One final application for the <B>for</B> loop results from the fact thatall three expressions are optional.  If you do leave allthree expressions out, you have written an "infinite" loop in away that is customary in the culture of both Perl and C:<P CLASS=para><DIV CLASS=programlisting><P><PRE>for (;;) {    ...}</PRE></DIV><P CLASS=para>If the notion of infinite loops bothers you, we should point out thatyou can always terminate such a loop from the inside with an appropriateloop-control command.  Of course, if you're writing the code tocontrol a cruise missile, you may not actually need to write a loop exit.The loop will be terminated automatically at the appropriate moment.[39]<blockquote class=footnote><P CLASS=para>[39] That is, the fallout from the loop tends to occur automatically.</blockquote></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.4.3">Foreach loops</A></h4><P CLASS=para>The <B>foreach</B> loop iterates over a list value and sets thecontrol variable (<tt CLASS=replaceable><i>VAR</i></tt>) to be each element of the list in turn:<P CLASS=para><DIV CLASS=programlisting><P><PRE>foreach <tt CLASS=replaceable><i>VAR</i></tt> (<tt CLASS=replaceable><i>LIST</i></tt>) {    ...}</PRE></DIV><P CLASS=para>The variable is implicitly local to the loop and regains its former valueupon exiting the loop.  If the variable was previously declared with<A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>, that variable instead of the global one is used, but it's stilllocalized to the loop.<P CLASS=para>The <B>foreach</B> keyword is actually a synonym for the <B>for</B> keyword, soyou can use <B>foreach</B> for readability or <B>for</B> for brevity.  If<tt CLASS=replaceable><i>VAR</i></tt> isomitted, <B>$_</B> is used.  If <tt CLASS=replaceable><i>LIST</i></tt> is an actual array (as opposed to anexpression returning a list value), you can modify each element of thearray by modifying <tt CLASS=replaceable><i>VAR</i></tt> inside the loop.  That's because the <B>foreach</B>loop index variable is an implicit alias for each item in the list thatyou're looping over.  Our first two examples modify an array in place:<P CLASS=para><DIV CLASS=programlisting><P><PRE>for (@ary) { s/ham/turkey/ }                # substitutionforeach $elem (@elements) {                 # multiply by 2    $elem *= 2;}for $count (10,9,8,7,6,5,4,3,2,1,'BOOM') {  # do a countdown    print $count, "\n"; sleep(1);}for $count (reverse 'BOOM', 1..10) {        # same thing    print $count, "\n"; sleep(1);}for $item (split /:[\\\n:]*/, $TERMCAP) {   # any <tt CLASS=replaceable><i>LIST</i></tt> expression    print "Item: $item\n";}foreach $key (sort keys %hash) {            # sorting keys    print "$key =&gt; $hash{$key}\n";}</PRE></DIV><P CLASS=para>That last one is the canonical way to print out the values of a hashin sorted order.<P CLASS=para>Note that there is no way with <B>foreach</B> to tell where you are in alist.  You can compare adjacent elements by remembering the previous one ina variable, but sometimes you just have to break down and write an ordinary<B>for</B> loop with subscripts.  That's what <B>for</B> is there for, afterall.<P CLASS=para>Here's how a C programmer might code up a particular algorithm in Perl:<P CLASS=para><DIV CLASS=programlisting><P><PRE>for ($i = 0; $i &lt; @ary1; $i++) {    for ($j = 0; $j &lt; @ary2; $j++) {        if ($ary1[$i] &gt; $ary2[$j]) {            last; # can't go to outer :-(        }        $ary1[$i] += $ary2[$j];    }    # this is where that last takes me}</PRE></DIV><P CLASS=para>Whereas here's how a Perl programmer more comfortable with list processingmight do it:<P CLASS=para><DIV CLASS=programlisting><P><PRE>WID: foreach $this (@ary1) {     JET: foreach $that (@ary2) {        next WID if $this &gt; $that;        $this += $that;    } }</PRE></DIV><P CLASS=para>See how much easier this is?  It's cleaner, safer, and faster.  It'scleaner because it's less noisy.  It's safer because if code gets addedbetween the inner and outer loops later on, the new code won't beaccidentally executed: <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A> explicitly iterates the other looprather than merely terminating the inner one.  And it's faster becausePerl executes a <B>foreach</B> statement more rapidly than it would theequivalent <B>for</B> loop because the elements are accesseddirectly instead of through subscripting.<P CLASS=para>Like the <B>while</B> statement, the <B>foreach</B> statement can also take a <B>continue</B> block.<P CLASS=para>We keep dropping hints about <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A>, but now we're going to explain it.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.4.4">Loop control</A></h4><P CLASS=para><A NAME="CH02.LAB1"></A><A NAME="CH02.LAB2"></A>We mentioned that you can put a <tt CLASS=replaceable><i>LABEL</i></tt> on a loop to give it a name.  Theloop's <tt CLASS=replaceable><i>LABEL</i></tt>identifies the loop for the loop-control commands <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A>,<A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A>, and <A HREF="ch03_02.htm#PERL2-CMD-REDO">redo</A>.  The <tt CLASS=replaceable><i>LABEL</i></tt> names the loop as a whole, not just thetop of the loop.  Hence, a loop-control command referring to the loopdoesn't actually "go to" the loop label itself.  As far as the computeris concerned, the label could just as easily have been placed at the endof the loop.  But people like things labeled at the top, for somereason.<P CLASS=para>Loops are typically named for the item the loop is processing on eachiteration.  This interacts nicely with the loop-control commands, whichare designed to read like English when used with an appropriate labeland a statement modifier.  The archetypical loop processes lines, so thearchetypical loop label is <tt CLASS=literal>LINE:</tt>, and the archetypical loop-controlcommand is something like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>next LINE if /^#/;      # discard comments</PRE></DIV><P CLASS=para>The syntax for the loop-control commands is:<P CLASS=para><DIV CLASS=programlisting><P><PRE>last <tt CLASS=replaceable><i>LABEL</i></tt>next <tt CLASS=replaceable><i>LABEL</i></tt>redo <tt CLASS=replaceable><i>LABEL</i></tt></PRE></DIV><P CLASS=para>The <tt CLASS=replaceable><i>LABEL</i></tt> is optional, and if omitted,the loop-control command refers to the innermost enclosing loop.  If youwant to break out more than one level, though, you must use a <tt CLASS=replaceable><i>LABEL</i></tt>.You may have as many loop-control commands in a loop as you like.[40]<blockquote class=footnote><P CLASS=para>[40] In the early days of structured programming, some people insisted thatloops and subroutines have only one entry and one exit.  The one-entrynotion is still a good idea, but the one-exit notion has led people towrite a lot of unnatural code.  Much of programming consists oftraversing decision trees.  A decision tree naturally starts with asingle trunk but ends with many leaves.  Write your code with the numberof loop exits (and function returns) that is natural to the problem you'retrying to solve.  If you've declared your local variables withreasonable scopes, things will automatically get cleaned up at theappropriate moment, whichever way you leave the block.</blockquote><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A> command is like the <tt CLASS=literal>break</tt> statement in C (as used inloops); it immediately exits the loop in question.  The <B>continue</B>block, if any, is not executed.  The following example bombs out ofthe loop on the first blank line:<P CLASS=para><DIV CLASS=programlisting><P><PRE>LINE: while (&lt;STDIN&gt;) {    last LINE if /^$/;      # exit when done with header    ...}</PRE></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A> command is like the <tt CLASS=literal>continue</tt> statement in C; it skipsthe rest of the current iteration and starts the next iteration of theloop.  If there is a <B>continue</B> <tt CLASS=replaceable><i>BLOCK</i></tt>on the loop, it is always executedjust before the conditional is about to be evaluated again, just like thethird part of a C-style <B>for</B> loop.  Thus it can be used to increment aloop variable, even when a particular iteration of the loop has beeninterrupted by a <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A>:<P CLASS=para><DIV CLASS=programlisting><P><PRE>LINE: while (&lt;STDIN&gt;) {    next LINE if /^#/;      # skip comments    next LINE if /^$/;      # skip blank lines    ...} continue {    $count++;}</PRE></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-REDO">redo</A> command restarts the loop block without evaluating theconditional again.  The <B>continue</B> block,if any, is not executed.This command is normally used by programs that want to lie to themselvesabout what was just input.<P CLASS=para>Suppose you are processing a file like <I CLASS=emphasis>/etc/termcap</I>. Ifyour input line ends with a backslash to indicate continuation, skip aheadand get the next record.<P CLASS=para><DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    chomp;    if (s/\\$//) {         $_ .= &lt;&gt;;         redo;    }    # now process $_}</PRE></DIV><P CLASS=para>which is Perl shorthand for the more explicitly written version:<P CLASS=para><DIV CLASS=programlisting><P><PRE>LINE: while ($line = &lt;ARGV&gt;) {    chomp($line);    if ($line =~ s/\\$//) {         $line .= &lt;ARGV&gt;;         redo LINE;    }    # now process $line}</PRE></DIV><P CLASS=para>One more point about loop-control commands.  You may have noticed thatwe are not calling them "statements".  That's because they aren'tstatements, though they can be used for statements.  (This is unlike C,where <tt CLASS=literal>break</tt> and <tt CLASS=literal>continue</tt> are allowed <I CLASS=emphasis>only</I> as statements.)You can almost think of them as unary operators that just happen tocause a change in control flow.  So you can use them anywhere it makessense to use them in an expression.  In fact, you can even use themwhere it doesn't make sense.  One sometimes sees this coding error:<P CLASS=para><DIV CLASS=programlisting><P><PRE>open FILE, $file     or warn "Can't open $file: $!\n", next FILE;   # WRONG</PRE></DIV><P CLASS=para>The intent is fine, but the <tt CLASS=literal>next FILE</tt> is being parsed as one of thearguments to <A HREF="ch03_02.htm#PERL2-CMD-WARN">warn</A>, which is a list operator.  So the <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A> executesbefore the <A HREF="ch03_02.htm#PERL2-CMD-WARN">warn</A> gets a chance to emit the warning.  In this case,it's easily fixed by turning the <A HREF="ch03_02.htm#PERL2-CMD-WARN">warn</A> list operator into the <A HREF="ch03_02.htm#PERL2-CMD-WARN">warn</A>function call with some suitably situated parentheses:<P CLASS=para><DIV CLASS=programlisting><P><PRE>open FILE, $file     or warn("Can't open $file: $!\n"), next FILE;   # okay</PRE></DIV></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.5">Bare Blocks and Case Structures</A></h3><P CLASS=para><A NAME="CH02.BLOCK1"></A><A NAME="CH02.BLOCK2"></A>A <tt CLASS=replaceable><i>BLOCK</i></tt> by itself (labeled or not) is semantically equivalent to aloop that executes once.  Thus you can use <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A> to leave the block or<A HREF="ch03_02.htm#PERL2-CMD-REDO">redo</A> to restart the block.[41]Note that this is not true of the blocks in <tt CLASS=literal>eval {}</tt>, <tt CLASS=literal>sub{}</tt>, or <tt CLASS=literal>do {}</tt> commands, which are not loop blocks and cannot belabeled.  They can't be labeled because they're just terms in anexpression.  Loop control commands may only be used on true loops, justas the <A HREF="ch03_02.htm#PERL2-CMD-RETURN">return</A> command may only be used within a subroutine or<A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>.  But you can always introduce an extra set of braces to giveyourself a bare block, which counts as a loop.<blockquote class=footnote><P CLASS=para>[41] For reasons that may (or may not) become clear upon reflection, a<A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A> also exits the once-through block.  There is a slight difference, however, inthat a <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A> will execute a <B>continue</B> block, while a <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A> won't.</blockquote><P CLASS=para>The bare block is particularly nice for doing case structures(multiway switches).<P CLASS=para><DIV CLASS=programlisting><P><PRE>SWITCH: {    if (/^abc/) { $abc = 1; last SWITCH; }    if (/^def/) { $def = 1; last SWITCH; }    if (/^xyz/) { $xyz = 1; last SWITCH; }    $nothing = 1;}</PRE></DIV><P CLASS=para>There is no official switch statement in Perl, because there are alreadyseveral ways to write the equivalent.  In addition to the above, you couldwrite: [42]<blockquote class=footnote><P CLASS=para>[42] This code is actually not as strange as it looks once you realize thatyou can use loop-control operators within an expression.  That's justthe normal scalar (C-style) comma operator between the assignment andthe <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A>.  It evaluates the assignment for its side-effect, andthen exits the loop in question, which happens to be a bare block named<tt CLASS=literal>SWITCH</tt>.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>SWITCH: {    $abc = 1, last SWITCH  if /^abc/;    $def = 1, last SWITCH  if /^def/;    $xyz = 1, last SWITCH  if /^xyz/;    $nothing = 1;}</PRE></DIV><P CLASS=para>or:<P CLASS=para><DIV CLASS=programlisting><P><PRE>SWITCH: {    /^abc/ &amp;&amp; do { $abc = 1; last SWITCH; };    /^def/ &amp;&amp; do { $def = 1; last SWITCH; };    /^xyz/ &amp;&amp; do { $xyz = 1; last SWITCH; };    $nothing = 1;}</PRE></DIV><P CLASS=para>or, formatted so it stands out more as a "proper" switch statement:<P CLASS=para><DIV CLASS=programlisting><P><PRE>SWITCH: {    /^abc/      &amp;&amp; do {                         $abc = 1;                         last SWITCH;                    };    /^def/      &amp;&amp; do {                         $def = 1;                         last SWITCH;                    };    /^xyz/      &amp;&amp; do {                         $xyz = 1;                         last SWITCH;                     };    $nothing = 1;}</PRE></DIV><P CLASS=para>or:<P CLASS=para><DIV CLASS=programlisting><P><PRE>SWITCH: {    /^abc/      and $abc = 1, last SWITCH;    /^def/      and $def = 1, last SWITCH;    /^xyz/      and $xyz = 1, last SWITCH;    $nothing = 1;}</PRE></DIV><P CLASS=para>or even, horrors:<P CLASS=para><DIV CLASS=programlisting><P><PRE>if    (/^abc/) { $abc = 1 }elsif (/^def/) { $def = 1 }elsif (/^xyz/) { $xyz = 1 }else           { $nothing = 1 }</PRE></DIV><P CLASS=para>You might think it odd to write a loop over a single value, but a commonidiom for a switch statement is to use <B>foreach</B>'s aliasing capabilityto make a temporary assignment to <B>$_</B> for convenient matching:<P CLASS=para><DIV CLASS=programlisting><P><PRE>for ($some_ridiculously_long_variable_name) {    /In Card Names/     and do { push @flags, '-e'; last; };    /Anywhere/          and do { push @flags, '-h'; last; };    /In Rulings/        and do {                    last; };    die "unknown value for form variable where: `$where'";}</PRE></DIV><P CLASS=para>Notice how the <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A> commands in that example ignore the<tt CLASS=literal>do {}</tt> blocks, which aren't loops, and exit the main loop instead.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.6">Goto</A></h3><P CLASS=para>Although not for the faint of heart (or the pure of heart, for thatmatter), Perl does support a <A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A> command.  There are three forms:<tt CLASS=literal>goto</tt> <tt CLASS=replaceable><i>LABEL</i></tt>, <tt CLASS=literal>goto</tt> <tt CLASS=replaceable><i>EXPR</i></tt>, and <tt CLASS=literal>goto</tt> <tt CLASS=literal>&amp;</tt><tt CLASS=replaceable><i>NAME</i></tt>.<P CLASS=para>The <tt CLASS=literal>goto</tt> <tt CLASS=replaceable><i>LABEL</i></tt> form finds the statement labeled with<tt CLASS=replaceable><i>LABEL</i></tt> andresumes execution there.  It may not be used to go inside any constructthat requires initialization, such as a subroutine or a <B>foreach</B>loop.  It also can't be used to go into a construct that is optimizedaway.  It can be used to go almost anywhere else within the current blockor one you were called from, including out of subroutines, but it'susually better to use some other construct.  The author of Perl has neverfelt the need to use this form of <A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A> (in Perl, that is--C isanother matter).<P CLASS=para>The <tt CLASS=literal>goto</tt> <tt CLASS=replaceable><i>EXPR</i></tt>form is just a generalization of <tt CLASS=literal>goto</tt> <tt CLASS=replaceable><i>LABEL</i></tt>.It expects the expression to return a label name, whose locationobviously has to be resolved dynamically by the interpreter.  (Don'texpect this to work in compiled Perl.) This allows for computed gotosper FORTRAN, but isn't necessarily recommended if you're optimizing formaintainability:<P CLASS=para><DIV CLASS=programlisting><P><PRE>goto ("FOO", "BAR", "GLARCH")[$i];</PRE></DIV><P CLASS=para>In almost all cases like this, it's usually a far, far better idea to usethe structured control flow mechanisms of <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A>, <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A>, or<A HREF="ch03_02.htm#PERL2-CMD-REDO">redo</A> instead of resorting to a <A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A>.  For certainapplications, a hash of function pointers or the catch-and-throw pair of<A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> and <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> for exception processing can also beprudent approaches.<P CLASS=para>The <tt CLASS=literal>goto &amp;NAME</tt> form is highly magical, and quite different from anordinary <A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A>.  It substitutes a call to the named subroutine for the currently running subroutine.  This is used by<tt CLASS=literal>AUTOLOAD</tt> subroutines that wish to load another subroutineandthen pretend that the other subroutine had been called in the first place.After the <A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A>, not even <A HREF="ch03_02.htm#PERL2-CMD-CALLER">caller</A> will be able to tell that thisroutine was called first.  See <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A> for adiscussion of <A HREF="ch03_02.htm#PERL2-CMD-CALLER">caller</A> and <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>for AutoLoader.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.7">Global Declarations</A></h3><P CLASS=para><A NAME="CH02.DEC"></A>Subroutine and format declarations are global declarations.  No matterwhere you place them, they declare global thingies (actually, packagethingies, but packages are global) that are visible from everywhere.Global declarations can be put anywhere a statement can, but have noeffect on the execution of the primary sequence of statements--thedeclarations take effect at compile time.  Typically the declarationsare put at the beginning or the end of your program, or off in someother file.  However, if you're using lexically scoped privatevariables created with <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>, you'll want to make sure your format orsubroutine definition is within the same block scope as the <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> if youexpect to be able to access those private variables.[43]<blockquote class=footnote><P CLASS=para>[43] For esoteric reasons related to closures, lexicals, and the <B>foreach</B>aliasing mechanism, these <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> variables must not be the index variableof a <B>foreach</B> loop, because any named subroutine or format will only have been compiledwith the first binding.</blockquote><P CLASS=para>Formats are bound to a filehandle and accessed implicitly via the <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A>function.  For more on formats, see "Formats" later in thischapter.<P CLASS=para>Subroutines are generally accessed directly, but don't actually have tobe defined before calls to them can be compiled.  The difference betweena subroutine definition and a mere declaration is that the definitionsupplies a <tt CLASS=replaceable><i>BLOCK</i></tt> containing the code to be executed, while thedeclaration doesn't.  A subroutine definition can function as adeclaration if the subroutine hasn't previously been declared.<P CLASS=para>Declaring a subroutine allows a subroutine name to be used as if it were alist operator from that point forward in the compilation.  You can declare asubroutine without defining it by just saying:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub myname;$me = myname $0             or die "can't get myname";</PRE></DIV><P CLASS=para>Note that it functions as a list operator, though, not as a unaryoperator, so be careful to use <B>or</B> instead of <tt CLASS=literal>||</tt>.The <tt CLASS=literal>||</tt> binds too tightly to use after a list operator (at least,not without using extra parentheses to turn the list operator back intoa function call).[44]You also need to define the subroutine at some point, or you'll getan error at run-time indicating that you've called an undefined subroutine.<blockquote class=footnote><P CLASS=para>[44] Alternately, turn the subroutine into a unary operator with a prototype.  Butwe haven't talked about that yet.</blockquote><P CLASS=para>Subroutine definitions can be loaded from other files with the<A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> statement, but there are two problems with that.First, the other file will typically insert the subroutine names intoa package (a namespace) of its own choosing, not your package.  Second,a <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> happens at run-time, so the declaration occurs too lateto serve as a declaration in the file invoking the <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>.<P CLASS=para>A more useful way to pull in declarations and definitions is via the<A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> declaration, which essentially performs a <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> at compiletime and then lets you import declarations into your own namespace.Because it is importing names into your own (global) package at compiletime, this aspect of <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> can be considered a kind of globaldeclaration.  See <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A> fordetails on this.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.8">Scoped Declarations</A></h3><P CLASS=para><A NAME="CH02.SCOPE1"></A><A NAME="CH02.SCOPE2"></A>Like global declarations, lexically scoped declarations have an effectat the time of compilation.  Unlike global declarations, lexicallyscoped declarations have an effect only from the point of thedeclaration to the end of the innermost enclosing block.  That's why wecall them lexically scoped, though perhaps "textually scoped" would bemore accurate, since lexical scoping has nothing to do with lexicons.But computer scientists the world around know what "lexically scoped"means, so we perpetuate the usage here.<P CLASS=para>We mentioned that some aspects of <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> could be considered globaldeclarations, but there are other aspects that are lexically scoped.In particular, <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> is not only used to perform symbol importation but also to implement various magical <I CLASS=emphasis>pragmas</I> (compiler hints). Most such pragmas are lexically scoped, including the <tt CLASS=literal>use strict vars</tt> pragma that forces you to use lexically declared variables.  See the section "Pragmas" below.<P CLASS=para>A <B>package</B> declaration, oddly enough, is lexically scoped, despite thefact that a package is a global entity.  But a <B>package</B> declarationmerely declares the identity of the default package for the rest ofthe enclosing block.  Undeclared, unqualified variable names will belooked up in that package.  In a sense, a package isn't declared at all,but springs into existence when you refer to a variable that belongs in thepackage.  It's all very Perlish.<P CLASS=para>The most frequently seen form of lexically scoped declaration is thedeclaration of <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> variables.  A related form of scoping known as<I CLASS=emphasis>dynamic scoping</I> applies to <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> variables, which are reallyglobal variables in disguise.If you refer to a variable that has not been declared, its visibility isglobal by default, and its lifetime is forever.  A variable used atone point in your program is accessible from anywhere else in theprogram.[45]If this were all there were to the matter, Perl programs would quicklybecome unwieldy as they grew in size.  Fortunately, you can easily createprivate variables using <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>, and semi-private values of global variablesusing <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A>.A <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> or a <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> declares the listed variables (in the case of<A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>), or the values of the listed global variables (in the case of<A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A>), to be confined to the enclosing block, subroutine, <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>,or file.  If more than one variable is listed, the list must be placedin parentheses.  All listed elements must be legal lvalues.  (For <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>the constraints are even tighter: the elements must be simple scalar,array, or hash variables, and nothing else.)  Here are some examples ofdeclarations of lexically scoped variables:<blockquote class=footnote><P CLASS=para>[45] To reiterate, even apparently global variables aren't reallyglobal--they're actually <I CLASS=emphasis>package variables</I>.  These work a bit likeC's file static variables, or C++'s class static variables.  Packagesare used by libraries, modules, and classes to store their own privatedata so it doesn't conflict with data in your main program.  If you seesomeone write <tt CLASS=literal>$Some::stuff</tt> or <tt CLASS=literal>$Some'stuff</tt>, they're using the<tt CLASS=literal>$stuff</tt> scalar variable from the package <tt CLASS=literal>Some</tt>. See <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>.</blockquote><P CLASS=para><DIV CLASS=programlisting><P><PRE>my $name = "fred";my @stuff = ("car", "house", "club");my ($vehicle, $home, $tool) = @stuff;</PRE></DIV><P CLASS=para>(These declarations also happen to perform an initializing assignment atrun-time.)<P CLASS=para>A <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> variable is <I CLASS=emphasis>dynamically scoped</I>, whereas a <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> variableis <I CLASS=emphasis>lexically scoped</I>.  The difference is that any dynamic variables are also visible tofunctions called from within the block in which those variables aredeclared.  Lexical variables are not.  They are totally hidden from theoutside world, including any called subroutines (even if it's the samesubroutine called from itself or elsewhere--every instance of thesubroutine gets its own copy of the variables).[46]In either event, the variable (or local value) disappears when the programexits thelexical scope in which the <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> or <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> finds itself.  By andlarge, you should prefer to use <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> over <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> because it's fasterand safer.  But you have to use <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> if you want to temporarilychange the value of an existing global variable, such as any of thespecial variables listed at the end of this chapter.  Only alphanumericidentifiers may be lexically scoped.  We won't talk much more about thesemantics of <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> here.  See<A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A> for more information.<blockquote class=footnote><P CLASS=para>[46] An <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, however, can see the lexical variables of the scope it isbeing evaluated in, so long as the names aren't hidden by declarations withinthe <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> itself.  Likewise, any anonymous subroutine (closure)created within the scope will also see such lexical variables.  See<A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A> for more on closures.</blockquote><P CLASS=para>Syntactically, <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> and <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> are simply modifiers (adjectives)on an lvalue expression.  When you assign to a modifiedlvalue, the modifier doesn't change whether the lvalue is viewed as ascalar or a list.  To figure how the assignment will work, just pretendthat the modifier isn't there.  So:<DIV CLASS=programlisting><P><PRE>my ($foo) = &lt;STDIN&gt;;my @FOO = &lt;STDIN&gt;;</PRE></DIV><P CLASS=para>both supply a list context to the right-hand side, while:<DIV CLASS=programlisting><P><PRE>my $foo = &lt;STDIN&gt;;</PRE></DIV><P CLASS=para>supplies a scalar context.<P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> binds more tightly (withhigher precedence) than the comma does.The following only declares one variable because the list following<A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> is not enclosed in parentheses:<DIV CLASS=programlisting><P><PRE>my $foo, $bar = 1;</PRE></DIV><P CLASS=para>This has the same effect as:<DIV CLASS=programlisting><P><PRE>my $foo;$bar = 1;</PRE></DIV><P CLASS=para>(You'll get a warning about the mistake if you use <B>-w</B>.)<P CLASS=para>The declared variable is not introduced (is not visible) until afterthe current statement.  Thus:<DIV CLASS=programlisting><P><PRE>my $x = $x;</PRE></DIV><P CLASS=para>can be used to initialize the new inner <tt CLASS=literal>$x</tt> with the value of theold outer <tt CLASS=literal>$x</tt>.  (Not that we recommend this style.)  On the other hand,the expression:<DIV CLASS=programlisting><P><PRE>my $x = 123 and $x == 123</PRE></DIV><P CLASS=para>is false unless the old <tt CLASS=literal>$x</tt> just happened to have the value 123.<P CLASS=para>Declaring a lexical variable of a particular name hides any previouslydeclared lexical variable of the same name. It also hides anyunqualified global variable of the same name, but you can always get tothe global variable by explicitly qualifying it with the name of thepackage the global is in.<P CLASS=para>For example:<DIV CLASS=programlisting><P><PRE><tt CLASS=literal>$PackageName::varname</tt></PRE></DIV><P CLASS=para>A statement sequence may contain declarations of lexically scopedvariables, but apart from declaring variable names, the declarations actlike ordinary statements, and each of them is elaborated within thesequence of statements as if it were an ordinary statement.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-6.9">Pragmas</A></h3><P CLASS=para>Many languages allow you to give hints to the compiler.  In Perl thesehints are conveyed to the compiler withthe <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> declaration.  Some of the pragmasare:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use integeruse strictuse libuse sigtrapuse subsuse vars</PRE></DIV><P CLASS=para>All the Perl pragmas are described in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>, but we'll talk about someof the more useful ones here.<P CLASS=para>By default, Perl assumes that it must do much of its arithmetic infloating point.  But by saying:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use integer;</PRE></DIV><P CLASS=para>you may tell the compiler that it's okay to use integer operationsfrom here to the end of the enclosing block.  An inner block maycountermand this by saying:<P CLASS=para><DIV CLASS=programlisting><P><PRE>no integer;</PRE></DIV><P CLASS=para>which lasts until the end of that inner block.<P CLASS=para>Some users may wish to encourage the use of lexical variables.  As an aidto catching implicit references to package variables, if you say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use strict 'vars';</PRE></DIV><P CLASS=para>then any variable reference from there to the end of the enclosingblock must either refer to a lexical variable, or must be fullyqualified with the package name.  A compilation error resultsotherwise.  An inner block may countermand this with:<P CLASS=para><DIV CLASS=programlisting><P><PRE>no strict 'vars'</PRE></DIV><P CLASS=para>You can also turn on strict checking of symbolic references andbarewords with this pragma.  Often people say <tt CLASS=literal>use strict;</tt> toturn on all three strictures.<P CLASS=para>Subroutines and variables that are imported from other modules havespecial privileges in Perl.  Imported subroutines can <I CLASS=emphasis>override</I> manybuilt-in operators, and imported variables are exempt from <tt CLASS=literal>use strict'vars'</tt>, since importation is considered a form of declaration.Sometimes you want to confer these privileges on your own subroutinesand variables.  You can do this with:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use subs qw(&amp;read &amp;write);</PRE></DIV><P CLASS=para>and:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use vars qw($fee $fie $foe $foo @sic);</PRE></DIV><P CLASS=para>Finally, Perl searches for modules in a standard list of locations.  Youneed to be able to add to that list at compile time, because when you<A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> modules they're loaded at compile time, and adding to the listat run-time would be too late.  So you can put:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use lib "/my/own/lib/directory";</PRE></DIV><P CLASS=para>at the front of your program to do this.  Note that these last threepragmas all modify global structures, and can therefore have effectsoutside of the current lexical scope.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_05.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch02_07.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Operators</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Subroutines</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>