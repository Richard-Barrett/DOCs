<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 2] 2.7 Subroutines</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:03:35 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_06.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 2</b></td><td width=172 align=right valign=top><A HREF="ch02_08.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-7">2.7 Subroutines</A></h2><P CLASS=para><A NAME="CH02.SUB"></A>Like many languages, Perl provides for user-defined subroutines.  (We'llalso call them <I CLASS=emphasis>functions</I>, but functions are thesame thing as subroutines in Perl.)These subroutines may be defined anywhere in the main program, loaded infrom other files via the <A HREF="ch03_02.htm#PERL2-CMD-DO">do</A>, <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>, or <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> keywords, or evengenerated on the fly using <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>.  You can generate anonymoussubroutines, accessible only through references.  You can even call asubroutine indirectly using a variable containing either its name or areference to the routine.<P CLASS=para>To declare a subroutine, use one of these forms:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub <tt CLASS=replaceable><i>NAME</i></tt>;              # A "forward" declaration.sub <tt CLASS=replaceable><i>NAME</i></tt> (<tt CLASS=replaceable><i>PROTO</i></tt>);      # Ditto, but with prototype.</PRE></DIV><P CLASS=para>To declare and define a subroutine, use one of these forms:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub <tt CLASS=replaceable><i>NAME</i></tt> <tt CLASS=replaceable><i>BLOCK</i></tt>         # A declaration and a definition.sub <tt CLASS=replaceable><i>NAME</i></tt> (<tt CLASS=replaceable><i>PROTO</i></tt>) <tt CLASS=replaceable><i>BLOCK</i></tt> # Ditto, but with prototype.</PRE></DIV><P CLASS=para>To define an anonymous subroutine or closure at run-time, use a statementlike:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$subref = sub <tt CLASS=replaceable><i>BLOCK</i></tt>;</PRE></DIV><P CLASS=para>To import subroutines defined in another package, say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use <tt CLASS=replaceable><i>PACKAGE</i></tt> qw(<tt CLASS=replaceable><i>NAME1 NAME2 NAME3</i></tt>...);</PRE></DIV><P CLASS=para>To call subroutines directly:<P CLASS=para><DIV CLASS=programlisting><P><PRE><tt CLASS=replaceable><i>NAME</i></tt>(<tt CLASS=replaceable><i>LIST</i></tt>);            # &amp; is optional with parentheses.<tt CLASS=replaceable><i>NAME</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>;             # Parens optional if predeclared/imported.&amp;<tt CLASS=replaceable><i>NAME;</i></tt>                 # Passes current @_ to subroutine.</PRE></DIV><P CLASS=para>To call subroutines indirectly (by name or by reference):<P CLASS=para><DIV CLASS=programlisting><P><PRE>&amp;$subref(<tt CLASS=replaceable><i>LIST</i></tt>);        # &amp; is not optional on indirect call.&amp;$subref;              # Passes current @_ to subroutine.</PRE></DIV><P CLASS=para>The Perl model for passing data into and out of a subroutine is simple:all function parameters are passed as one single, flat list of scalars,and all return values are likewise returned to the caller as one single, flatlist of scalars.  As with any <tt CLASS=replaceable><i>LIST</i></tt>, any arrays or hashes passed in theselists will interpolate their values into the flattened list, losingtheir identities--but there are several ways to get around this, and theautomatic list interpolation is frequently quite useful.  Both parameterlists and return lists may contain as many or as few scalar elements asyou'd like (though you may put constraints on the parameter list usingprototypes).  Indeed, Perl is designed around this notion of <I CLASS=emphasis>variadic</I>functions (those taking any number of arguments), unlike C, where they're sort of grudgingly kludged in so thatyou can call <I CLASS=emphasis>printf</I> (3).<P CLASS=para>Now, if you're going to design a language around the notion of passingvarying numbers of arbitrary arguments, you'd better make it easy toprocess those arbitrary lists of arguments.  In the interests of dealingwith the function parameters as a list, any arguments passed to aPerl routine come in as the array <tt CLASS=literal>@_</tt>.  If you call a function withtwo arguments, those would be stored in <tt CLASS=literal>$_[0]</tt> and <tt CLASS=literal>$_[1]</tt>.Since <tt CLASS=literal>@_</tt> is an array, you can use any array operations you likeon the parameter list.  (This is an area where Perl is <I CLASS=emphasis>more</I>orthogonal than the typical computer language.)  The array <tt CLASS=literal>@_</tt> is alocal array, but its values are implicit references to the actual scalarparameters.  Thus you can modify the actual parameters if you modify thecorresponding element of <tt CLASS=literal>@_</tt>.  (This is rarely done, however,since it's so easy to return interesting values in Perl.)<P CLASS=para>The return value of the subroutine (or of any other block, for thatmatter) is the value of the last expression evaluated.  Or you may usean explicit <B>return</B> statement to specify the return value and exit thesubroutine from any point in the subroutine.  Either way, as thesubroutine is called in a scalar or list context, so also is the finalexpression of the routine evaluated in the same scalar or list context.<P CLASS=para>Perl does not have named formal parameters, but in practice all you do isassign the contents of <tt CLASS=literal>@_</tt> to a <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> list, which serves nicely fora list of formal parameters.  But you don't have to, which is the wholepoint of the <tt CLASS=literal>@_</tt> array.  <P CLASS=para>For example, to calculate a maximum, thefollowing routine just iterates over <tt CLASS=literal>@_</tt> directly:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub max {    my $max = shift(@_);    foreach $foo (@_) {        $max = $foo if $max &lt; $foo;    }    return $max;}$bestday = max($mon,$tue,$wed,$thu,$fri);</PRE></DIV><P CLASS=para>Here's a routine that ignores its parameters entirely, since it wants tokeep a global lookahead variable:<P CLASS=para><DIV CLASS=programlisting><P><PRE># Get a line, combining continuation lines that start with whitespacesub get_line {    my $thisline = $LOOKAHEAD;    LINE: while ($LOOKAHEAD = &lt;STDIN&gt;) {        if ($LOOKAHEAD =~ /^[ \t]/) {            $thisline .= $LOOKAHEAD;        }        else {            last LINE;        }    }    $thisline;}$LOOKAHEAD = &lt;STDIN&gt;;       # get first linewhile ($_ = get_line()) {    ...}</PRE></DIV><P CLASS=para>Use list assignment to a private list to name your formal arguments:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub maybeset {    my($key, $value) = @_;    $Foo{$key} = $value unless $Foo{$key};}</PRE></DIV><P CLASS=para>This also has the effect of turning call-by-reference into call-by-value(to borrow some fancy terms from computer science), since the assignment copiesthe values.<P CLASS=para>Here's an example of <I CLASS=emphasis>not</I> naming your formal arguments, so that youcan modify your actual arguments:<P CLASS=para><DIV CLASS=programlisting><P><PRE>upcase_in($v1, $v2);  # this changes $v1 and $v2sub upcase_in {    for (@_) { tr/a-z/A-Z/ } }</PRE></DIV><P CLASS=para>You aren't allowed to modify constants in this way, of course.  If anargument were actually a literal and you tried to change it, you'd take anexception (presumably fatal, possibly career-threatening).   Forexample, this won't work:<P CLASS=para><DIV CLASS=programlisting><P><PRE>upcase_in("frederick");</PRE></DIV><P CLASS=para>It would be much safer if the <tt CLASS=literal>upcase_in( )</tt> function were written toreturn a copy of its parameters instead of changing them in place:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($v3, $v4) = upcase($v1, $v2);sub upcase {    my @parms = @_;    for (@parms) { tr/a-z/A-Z/ }     # wantarray checks whether we were called in list context    return wantarray ? @parms : $parms[0];}</PRE></DIV><P CLASS=para>Notice how this (unprototyped) function doesn't care whether it was passedreal scalars or arrays.  Perl will see everything as one big, long, flat<tt CLASS=literal>@_</tt> parameter list.  This is one of the ways where Perl's simpleargument-passing style shines.  The <tt CLASS=literal>upcase</tt> function will workperfectly well without changing the <tt CLASS=literal>upcase</tt> definition even if we feedit things like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@newlist   = upcase(@list1, @list2);@newlist   = upcase( split /:/, $var );</PRE></DIV><P CLASS=para>Do not, however, be tempted to do this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>(@a, @b)   = upcase(@list1, @list2);   # WRONG</PRE></DIV><P CLASS=para>Why not? Because, like the flat incoming parameter list, the return list is alsoflat.  So all you have managed to do here is store everything in<tt CLASS=literal>@a</tt> and make <tt CLASS=literal>@b</tt> an empty list.See the later section on "Passing References" for alternatives.<P CLASS=para>The official name of a subroutine includes the <tt CLASS=literal>&amp;</tt> prefix.  Asubroutine may be called using the prefix, but the <tt CLASS=literal>&amp;</tt> is usuallyoptional, and so are the parentheses if the subroutine has been predeclared.(Note, however, that the <tt CLASS=literal>&amp;</tt> is not optional when you'rejust naming the subroutine, such as when it's used as an argument to<A HREF="ch03_02.htm#PERL2-CMD-DEFINED">defined</A> or <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A>, or when you want to generate a referenceto a named subroutine by saying <tt CLASS=literal>$subref = \&amp;name</tt>.  Nor is the<tt CLASS=literal>&amp;</tt> optional when you want to do an indirect subroutine call witha subroutine name or reference using the <tt CLASS=literal>&amp;$subref()</tt> or<tt CLASS=literal>&amp;{$subref}()</tt> constructs.  See <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A> for more on that.)<P CLASS=para>Subroutines may be called recursively.  If a subroutine is called usingthe <tt CLASS=literal>&amp;</tt> form, the argument list is optional, and if omitted, no <tt CLASS=literal>@_</tt>array is set up for the subroutine: the <tt CLASS=literal>@_</tt> array of the callingroutine at the time of the call is visible to called subroutine instead.This is an efficiency mechanism that new users may wish to avoid.<P CLASS=para><DIV CLASS=programlisting><P><PRE>&amp;foo(1,2,3);    # pass three argumentsfoo(1,2,3);     # the samefoo();          # pass a null list&amp;foo();         # the same&amp;foo;           # foo() gets current args, like foo(@_) !!foo;            # like foo() if sub foo pre-declared, else bareword "foo"</PRE></DIV><P CLASS=para>Not only does the <tt CLASS=literal>&amp;</tt> form make the argument list optional, but it alsodisables any prototype checking on the arguments you do provide.  Thisis partly for historical reasons, and partly for having a convenient wayto cheat if you know what you're doing.  See the section on"Prototypes" later in this chapter.<P CLASS=para>Any variables you use in the function that aren't declared private areglobal variables.  For more on creating private variables,see <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-7.1">Passing Symbol Table Entries (Typeglobs)</A></h3><P CLASS=para>Note that the mechanism described in this section was originally the onlyway to simulate pass-by-reference in older versions of Perl.  While itstill works fine in modern versions, the new reference mechanism isgenerally easier to work with.  See below.<P CLASS=para>Sometimes you don't want to pass the value of an array to a subroutinebut rather the name of it, so that the subroutine can modify the globalcopy of it rather than working with a local copy.  In Perl you canrefer to all objects of a particular name by prefixing the namewith a star: <tt CLASS=literal>*foo</tt>.  This is often known as a <I CLASS=emphasis>typeglob</I>, since thestar on the front can be thought of as a wildcard match for all thefunny prefix characters on variables and subroutines and such.<P CLASS=para>When evaluated, a typeglob produces a scalar value that represents allthe objects of that name, including any scalar, array, or hash variable,and also any filehandle, format, or subroutine.  When assigned to, a typeglobsets up its own name to be an alias for whatever typeglob value wasassigned to it.  For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub doubleary {    local(*someary) = @_;    foreach $elem (@someary) {        $elem *= 2;    }}doubleary(*foo);doubleary(*bar);</PRE></DIV><P CLASS=para>Note that scalars are already passed by reference, so you can modifyscalar arguments without using this mechanism by referring explicitlyto <tt CLASS=literal>$_[0]</tt>, and so on.  You can modify all the elements of an array by passingall the elements as scalars, but you have to use the <tt CLASS=literal>*</tt> mechanism (orthe equivalent reference mechanism described below)to <B>push</B>, <B>pop</B>, or change the size ofan array.  It will certainly be faster to pass the typeglob (or reference)than to push a bunch of scalars onto the argument stack only to popthem all back off again.<P CLASS=para>Even if you don't want to modify an array, this mechanism is useful forpassing multiple arrays in a single <tt CLASS=replaceable><i>LIST</i></tt>, since normally the<tt CLASS=replaceable><i>LIST</i></tt>mechanism will flatten all the list values so that you can't extract outthe individual arrays.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-7.2">Passing References</A></h3><P CLASS=para><A NAME="CH02.PASS1"></A><A NAME="CH02.PASS2"></A>If you want to pass more than one array or hash into or out of a functionand have them maintain their integrity, then you'regoing to want to use an explicit pass-by-reference.  Before you do that,you need to understand references as detailed in <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>.  Thissection may not make much sense to you otherwise.  But hey, you canalways look at the pictures.<P CLASS=para>Here are a few simple examples.  First, let's pass in severalarrays to a function and have it <B>pop</B> each of them, returning a newlist of all their former last elements:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@tailings = popmany ( \@a, \@b, \@c, \@d );sub popmany {    my $aref;    my @retlist = ();    foreach $aref ( @_ ) {        push @retlist, pop @$aref;    }     return @retlist;}</PRE></DIV><P CLASS=para>Here's how you might write a function that returns a list of keys occurring in all the hashes passed to it:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@common = inter( \%foo, \%bar, \%joe ); sub inter {    my ($k, $href, %seen); # locals    foreach $href (@_) {        while ( ($k) = each %$href ) {            $seen{$k}++;        }     }     return grep { $seen{$_} == @_ } keys %seen;}</PRE></DIV><P CLASS=para>So far, we're just using the normal list return mechanism.What happens if you want to pass or return a hash?  Well, if you're only using one of them, or you don't mind them concatenating, then the normal calling convention is OK, althougha little expensive.<P CLASS=para>Where people get into trouble is here:<P CLASS=para><DIV CLASS=programlisting><P><PRE>(@a, @b) = func(@c, @d);</PRE></DIV><P CLASS=para>or here:<P CLASS=para><DIV CLASS=programlisting><P><PRE>(%a, %b) = func(%c, %d);</PRE></DIV><P CLASS=para>That syntax simply won't work.  It just sets <tt CLASS=literal>@a</tt> or <tt CLASS=literal>%a</tt> and clears<tt CLASS=literal>@b</tt> or <tt CLASS=literal>%b</tt>.  Plus the function doesn't get twoseparate arrays or hashes as arguments: it gets one long list in <tt CLASS=literal>@_</tt>,as always.<P CLASS=para>If you can arrange for the function to receive references as its parameters andreturn them as its return results, it's cleaner code, although not so nice tolook at.  Here's a function that takes two array references as arguments,returning the two array references ordered according to how many elements theyhave in them:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($aref, $bref) = func(\@c, \@d);print "@$aref has more than @$bref\n";sub func {    my ($cref, $dref) = @_;    if (@$cref &gt; @$dref) {        return ($cref, $dref);    } else {        return ($dref, $cref);    } }</PRE></DIV><P CLASS=para>It turns out that you can actually mix the typeglob approach with thereference approach, like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>(*a, *b) = func(\@c, \@d);print "@a has more than @b\n";sub func {    local (*c, *d) = @_;    if (@c &gt; @d) {        return (\@c, \@d);    } else {        return (\@d, \@c);    } }</PRE></DIV><P CLASS=para>Here we're using the typeglobs to do symbol table aliasing.  It's a tadsubtle, though, and also won't work if you're using <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> variables,since only globals (well, and <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A>s) are in the symbol table. When you assign a reference to a typeglob like that, only the one elementfrom the typeglob (in this case, the array element) is aliased, instead ofall the similarly named elements, since the reference knows what it'sreferring to.<P CLASS=para>If you're passing around filehandles, you can usually just use the baretypeglob, like <tt CLASS=literal>*STDOUT</tt>, but references to typeglobs work even betterbecause they still behave properly under <tt CLASS=literal>use strict 'refs'</tt>.  Forexample:<P CLASS=para><DIV CLASS=programlisting><P><PRE>splutter(\*STDOUT);sub splutter {    my $fh = shift;    print $fh "her um well a hmmm\n";}$rec = get_rec(\*STDIN);sub get_rec {    my $fh = shift;    return scalar &lt;$fh&gt;;}</PRE></DIV><P CLASS=para>If you're planning on generating new filehandles, see the <B>open</B> entry in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A> for an example using the FileHandlemodule.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-7.3">Prototypes</A></h3><P CLASS=para><A NAME="CH02.PROTO"></A>As of the 5.003 release of Perl, you can declare your subroutines totake arguments just like many of the built-ins, that is, with certainconstraints on the number and types of arguments.  For instance,if you declare:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub mypush (\@@)</PRE></DIV><P CLASS=para>then <tt CLASS=literal>mypush</tt> takes arguments exactly like <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A> does.  Thedeclaration of the function to be called must be visible at compile time.The prototype only affects the interpretation of new-style calls to thefunction, where new-style is defined as "not using the <tt CLASS=literal>&amp;</tt>character".In other words, if you call it like a built-in function, then it behaveslike a built-in function.  If you call it like an old-fashioned subroutine,then it behaves like an old-fashioned subroutine.  It naturally falls outfrom this rule that prototypes have no influence on subroutine referenceslike <tt CLASS=literal>\&amp;foo</tt> or on indirect subroutine calls like <tt CLASS=literal>&amp;{$subref}</tt>.<P CLASS=para>Method calls are not influenced by prototypes either. This is because thefunction to be called is indeterminate at compile-time, depending asit does on inheritance, which is dynamically determined in Perl.<P CLASS=para>Since the intent is primarily to let you define subroutines that worklike built-in commands, here are the prototypes for some other functionsthat parse almost exactly like the corresponding built-ins.  (Note thatthe "<tt CLASS=literal>my</tt>" on the front of each is just part of the name we picked, andhas nothing to do with Perl <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> operator.  You can name your prototypedfunctions anything you like--we just picked our names to parallel thebuilt-in functions.)<DIV CLASS=informaltable><P><A NAME="PERL2-CH-2-TAB-16"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Declared as</TH><TH ALIGN="left">Called as</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub mylink ($$)</tt></TD><TD ALIGN="left"><tt CLASS=literal>mylink $old, $new</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub myvec ($$$)</tt></TD><TD ALIGN="left"><tt CLASS=literal>myvec $var, $offset, 1</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub myindex ($$;$)</tt></TD><TD ALIGN="left"><tt CLASS=literal>myindex &amp;getstring, `substr`</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub mysyswrite ($$$;$)</tt></TD><TD ALIGN="left"><tt CLASS=literal>mysyswrite $buf, 0, length($buf) - $off, $off</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub myreverse (@)</tt></TD><TD ALIGN="left"><tt CLASS=literal>myreverse $a,$b,$c</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub myjoin ($@)</tt></TD><TD ALIGN="left"><tt CLASS=literal>myjoin `:`,$a,$b,$c</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub mypop (\@)</tt></TD><TD ALIGN="left"><tt CLASS=literal>mypop @array</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub mysplice (\@$$@)</tt></TD><TD ALIGN="left"><tt CLASS=literal>mysplice @array,@array,0,@pushme</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub mykeys (\%)</tt></TD><TD ALIGN="left"><tt CLASS=literal>mykeys %{$hashref}</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub myopen (*;$)</tt></TD><TD ALIGN="left"><tt CLASS=literal>myopen HANDLE, $name</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub mypipe (**)</tt></TD><TD ALIGN="left"><tt CLASS=literal>mypipe READHANDLE, WRITEHANDLE</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub mygrep (&amp;@)</tt></TD><TD ALIGN="left"><tt CLASS=literal>mygrep { /foo/ } $a,$b,$c</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub myrand ($)</tt></TD><TD ALIGN="left"><tt CLASS=literal>myrand 42</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>sub mytime ()</tt></TD><TD ALIGN="left"><tt CLASS=literal>mytime</tt></TD></TR></TABLE><P></DIV><P CLASS=para>Any backslashed prototype character (shown between parentheses in theleft column above) represents an actual argument (exemplified in theright column) that absolutely must start with that character.  Just asthe first argument to <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> must startwith <tt CLASS=literal>%</tt>, so too must the first argument to<tt CLASS=literal>mykeys</tt>.<P CLASS=para>Unbackslashed prototype characters have special meanings.  Anyunbackslashed @ or % eats all the rest of the actual arguments, andforces list context.  (It's equivalent to <tt CLASS=replaceable><i>LIST</i></tt> ina syntax diagram.) An argument represented by $ forces scalar contexton it.  An &amp; requires an anonymous subroutine (which, if passed asthe first argument, does not require the "<tt CLASS=literal>sub</tt>" keyword or a subsequentcomma).  And a <tt CLASS=literal>*</tt> does whatever it has to do to turn the argument intoa reference to a symbol table entry.  It's typically used forfilehandles.<P CLASS=para>A semicolon separates mandatory arguments from optional arguments.(It would be redundant before <tt CLASS=literal>@</tt> or <tt CLASS=literal>%</tt>, since lists can be null.)<P CLASS=para>Note how the last three examples above are treated specially by theparser.  <tt CLASS=literal>mygrep</tt> is parsed as a true list operator,<tt CLASS=literal>myrand</tt> is parsed as a true unary operator withunary precedence the same as <A HREF="ch03_02.htm#PERL2-CMD-RAND">rand</A>, and<tt CLASS=literal>mytime</tt> is truly argumentless, just like <A HREF="ch03_02.htm#PERL2-CMD-TIME">time</A>.  <P CLASS=para>That is, if you say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>mytime +2;</PRE></DIV><P CLASS=para>you'll get <tt CLASS=literal>mytime() + 2</tt>, not<tt CLASS=literal>mytime(2)</tt>, which is how it would be parsed withoutthe prototype, or with a unary prototype.<P CLASS=para>The interesting thing about <tt CLASS=literal>&amp;</tt> is that you can generate newsyntax with it:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub try (&amp;$) {    my($try,$catch) = @_;    eval { &amp;$try };    if ($@) {        local $_ = $@;        &amp;$catch;    }}sub catch (&amp;) { shift }try {    die "phooey";} catch {    /phooey/ and print "unphooey\n";};</PRE></DIV><P CLASS=para>This prints "<tt CLASS=literal>unphooey</tt>".  What happens is that <tt CLASS=literal>try</tt> is called with twoarguments, the anonymous function <tt CLASS=literal>{die `phooey`;}</tt> and the return valueof the <tt CLASS=literal>catch</tt> function, which in this case is nothing but its ownargument, the entire block of yet another anonymous function.  Within<tt CLASS=literal>try</tt>, the first function argument is called while protected within an<A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> block to trap anything that blows up.  If something does blow up, thesecond function is called with a local version of the global <tt CLASS=literal>$_</tt> variableset to the raised exception.[47]If this all sounds like pure gobbledygook, you'll have to read about<A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> and <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>, and then gocheck out anonymous functions in <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>.<blockquote class=footnote><P CLASS=para>[47] Yes, there are still unresolved issues having to do with the visibility of<tt CLASS=literal>@_</tt>.  We're ignoring that question for the moment.  (But note that if wemake <tt CLASS=literal>@_</tt> lexically scoped someday, those anonymous subroutines can act likeclosures. (Gee, is this sounding a little Lispish?  (Nevermind.)))</blockquote><P CLASS=para>And here's a reimplementation of the <A HREF="ch03_02.htm#PERL2-CMD-GREP">grep</A> operator (the built-in one ismore efficient, of course):<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub mygrep (&amp;@) {    my $coderef = shift;    my @result;    foreach $_ (@_) {        push(@result, $_) if &amp;$coderef;    }    @result;}</PRE></DIV><P CLASS=para>Some folks would prefer to see full alphanumeric prototypes.Alphanumerics have been intentionally left out of prototypes for theexpress purpose of someday adding named, formal parameters.(Maybe.)  The current mechanism's main goal is to let module writersprovide better diagnostics for module users.  Larry feels that the notationis quite understandable to Perl programmers, and that it will not intrudegreatly upon the meat of the module, nor make it harder to read.  Theline noise is visually encapsulated into a small pill that's easy toswallow.<P CLASS=para>One note of caution.  It's probably best to put prototypes on new functions,not retrofit prototypes onto older ones.  That's because you must beespecially careful about silently imposing a different context.  Suppose,for example, you decide that a function should take just one parameter,like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub func ($) {    my $n = shift;    print "you gave me $n\n";}</PRE></DIV><P CLASS=para>and someone has been calling it with an array or expressionreturning a single-element list:<P CLASS=para><DIV CLASS=programlisting><P><PRE>func(@foo);func( split /:/ );</PRE></DIV><P CLASS=para>Then you've just supplied an implicit <A HREF="ch03_02.htm#PERL2-CMD-SCALAR">scalar</A> in front of theirargument, which can be more than a bit surprising.  The old <tt CLASS=literal>@foo</tt>that used to hold one thing doesn't get passed in.  Instead, 1 (thenumber of elements in <tt CLASS=literal>@foo</tt>) is now passed to <tt CLASS=literal>func</tt>.And the <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> gets called in a scalar context andstarts scribbling on your <B>@_</B> parameter list.<P CLASS=para>But if you're careful, you can do a lot of neat things with prototypes.This is all very powerful, of course, and should only be used in moderationto make the world a better place.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_06.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch02_08.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Statements and Declarations</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Formats</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>