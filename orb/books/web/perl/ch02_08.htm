<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 2] 2.8 Formats</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:03:42 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_07.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 2</b></td><td width=172 align=right valign=top><A HREF="ch02_09.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-8">2.8 Formats</A></h2><P CLASS=para><A NAME="CH02.FORMAT"></A>Perl has a mechanism to help you generate simple, formatted reportsand charts.  It can keep track of things like how many lines on apage, what page you're on, when to print page headers, and so on.Keywords are borrowed from FORTRAN: <A HREF="ch03_02.htm#PERL2-CMD-FORMAT">format</A> to declare and <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> to execute; see the relevant entries in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.  Fortunately, the layout is much more legible,more like the <tt CLASS=literal>PRINT USING</tt> statement of BASIC.Think of it as a poor man's <I CLASS=emphasis>nroff</I> (1).  (If youknow <I CLASS=emphasis>nroff</I>, that may not sound like arecommendation.)<P CLASS=para>Formats, like packages and subroutines, are declared rather thanexecuted, so they may occur at any point in your program.  (Usuallyit's best to keep them all together.) They have their own namespaceapart from all the other types in Perl.  This means that if you have afunction named "<tt CLASS=literal>Foo</tt>", it is not the same thing as a format named"<tt CLASS=literal>Foo</tt>".  However, the default name for the format associated with agiven filehandle is the same as the name of the filehandle.  Thus, thedefault format for <tt CLASS=literal>STDOUT</tt> is named"<tt CLASS=literal>STDOUT</tt>", and the default format for filehandle<tt CLASS=literal>TEMP</tt> is named "<tt CLASS=literal>TEMP</tt>".  They justlook the same.  They really aren't.<P CLASS=para>Output record formats are declared as follows:<P CLASS=para><DIV CLASS=programlisting><P><PRE>format <tt CLASS=replaceable><i>NAME</i></tt> =<tt CLASS=replaceable><i>FORMLIST</i></tt>.</PRE></DIV><P CLASS=para>If <tt CLASS=replaceable><i>NAME</i></tt> is omitted, format <tt CLASS=literal>STDOUT</tt> is defined.<tt CLASS=replaceable><i>FORMLIST</i></tt> consists of asequence of lines, each of which may be of one of three types:<P><UL CLASS=itemizedlist><li CLASS=listitem>A comment, indicated by putting a <tt CLASS=literal>#</tt> in the first column.<P><li CLASS=listitem>A "picture" line giving the format for one output line.<P><li CLASS=listitem>An argument line supplying values to plug into the previous picture line.<P></UL><P CLASS=para>Picture lines are printed exactly as they look, except for certain fieldsthat substitute values into the line.[48]Each substitution field in a picture line startswith either <tt CLASS=literal>@</tt> (at) or <tt CLASS=literal>^</tt> (caret).  These lines do not undergo any kindof variable interpolation.  The <tt CLASS=literal>@</tt> field (not to be confused with the arraymarker <tt CLASS=literal>@</tt>) is the normal kind of field; the other kind,the ^ field, is used to do rudimentary multiline text-block filling.  The length of the fieldis indicated by padding out the field with multiple <tt CLASS=literal>&lt;</tt>, <tt CLASS=literal>&gt;</tt>, or <tt CLASS=literal>|</tt>characters to specify, respectively, left justification, rightjustification, or centering.  If the variable would exceed the widthspecified, it is truncated.<blockquote class=footnote><P CLASS=para>[48] Even those fields maintain theintegrity of the columns you put them in, however.  There is nothingin a picture line that can cause fields to grow or shrink or shift backand forth.  The columns you see are sacred in a WYSIWYG sense.</blockquote><P CLASS=para>As an alternate form of right justification, you may also use <tt CLASS=literal>#</tt> characters(after an initial <tt CLASS=literal>@</tt> or <tt CLASS=literal>^</tt>, andwith an optional ".") to specify a numeric field.  This wayyou can line up the decimal points.  If any value supplied for thesefields contains a newline, only the text up to the newline is printed.Finally, the special field <tt CLASS=literal>@*</tt> can be used for printing multi-line,non-truncated values; it should generally appear on a picture line by itself.<P CLASS=para>The values are specified on the following line in the same order asthe picture fields.  The expressions providing the values should beseparated by commas.  The expressions are all evaluated in a list contextbefore the line is processed, so a single list expression could producemultiple list elements.  The expressions may be spread out to more thanone line if enclosed in braces.  If so, the opening brace must be the firsttoken on the first line.<P CLASS=para>Picture fields that begin with <tt CLASS=literal>^</tt> rather than<tt CLASS=literal>@</tt> are treated specially.  With a <tt CLASS=literal>#</tt> field, the fieldis blanked out if the value is undefined.  For other field types, thecaret enables a kind of fill mode.  Instead of an arbitraryexpression, the value supplied must be a scalar variable name thatcontains a text string.  Perl puts as much text as it can into thefield, and then chops off the front of the string so that the nexttime the variable is referenced, more of the text can be printed.(Yes, this means that the variable itself is altered during executionof the <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> call, and is notpreserved. Use a scratch variable if you want to preserve the original value.)  Normally you would use a sequence of fields in a verticalstack to print out a block of text.  You might wish to end the finalfield with the text "<tt CLASS=literal>...</tt>", which will appear in the output if the textwas too long to appear in its entirety.  You can change whichcharacters are legal to "break" on (or after) by changing the variable <B>$:</B> (that's<tt CLASS=literal>$FORMAT_LINE_BREAK_CHARACTERS</tt> if you're using theEnglish module) to a list of the desired characters.<P CLASS=para>Using ^ fields can produce variable-length records.  If the text tobe formatted is short, just repeat the format line with the ^ fieldin it a few times.  If you just do this for short data you'd endup getting a few blank lines.  To suppress lines that would end up blank,put a <tt CLASS=literal>~</tt> (tilde) character anywhere in the line.  (The tilde itself will betranslated to a space upon output.)  If you put a second tilde contiguousto the first, the line will be repeated until all the text in the fieldson that line have been printed.  (This works because the ^ fields chewup the strings they print.  But if you use a field of the <tt CLASS=literal>@</tt> varietyin conjunction with two tildes, the expression you supply had betternot give the same value every time forever!  Use a <A HREF="ch03_02.htm#PERL2-CMD-SHIFT">shift</A>, or someother operator with a side effect that exhausts the set of values.)<P CLASS=para>Top-of-form processing is by default handled by a format with the samename as the current filehandle with "<tt CLASS=literal>_TOP</tt>"concatenated to it.  It's triggered at the top of each page.  See<A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.<P CLASS=para>Examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE># a report on the /etc/passwd fileformat STDOUT_TOP =                    Passwd FileName                Login    Office   Uid   Gid Home------------------------------------------------------------------.format STDOUT =@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||||| @&lt;&lt;&lt;&lt;&lt;&lt;@&gt;&gt;&gt;&gt; @&gt;&gt;&gt;&gt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;$name,              $login,  $office,$uid,$gid, $home.# a report from a bug report formformat STDOUT_TOP =                         Bug Reports@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;     @|||         @&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;$system,                      $%,         $date------------------------------------------------------------------.format STDOUT =Subject: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;         $subjectIndex: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;       $index,                       $descriptionPriority: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Date: @&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;          $priority,        $date,   $descriptionFrom: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;      $from,                         $descriptionAssigned to: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;             $programmer,            $description~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                                     $description~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                                     $description~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                                     $description~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                                     $description~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;...                                     $description.</PRE></DIV><P CLASS=para>It is possible to intermix <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>s with<A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A>s on the same output channel, butyou'll have to handle the <B>$-</B> specialvariable (<tt CLASS=literal>$FORMAT_LINES_LEFT</tt> if you're using theEnglish module) yourself.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-8.1">Format Variables</A></h3><P CLASS=para><A NAME="CH02.VARI"></A>The current format name is stored in the variable <B>$~</B> (<tt CLASS=literal>$FORMAT_NAME</tt>), and thecurrent top-of-form format name is in <B>$^</B> (<tt CLASS=literal>$FORMAT_TOP_NAME</tt>).  Thecurrent output page number is stored in <B>$%</B> (<tt CLASS=literal>$FORMAT_PAGE_NUMBER</tt>), andthe number of lines on the page is in <B>$=</B> (<tt CLASS=literal>$FORMAT_LINES_PER_PAGE</tt>).Whether to autoflush output on this handle is stored in <B>$|</B> (<tt CLASS=literal>$OUTPUT_AUTOFLUSH</tt>).  Thestring to be output before each top of page (except the first) isstored in <B>$^L</B>(<tt CLASS=literal>$FORMAT_FORMFEED</tt>).  These variables are set on aper-filehandle basis, so you'll need to <B>select</B> the filehandle associated with a format inorder to affect its format variables.<P CLASS=para><DIV CLASS=programlisting><P><PRE>select((select(OUTF),         $~ = "My_Other_Format",        $^ = "My_Top_Format"       )[0]);</PRE></DIV><P CLASS=para>Pretty ugly, eh?  It's a common idiom though, so don't be too surprisedwhen you see it.  You can at least use a temporary variable to holdthe previous filehandle (this is a much better approach in general,because not only does legibility improve, but you now have an intermediarystatement in the code to stop on when you're single-stepping the debugger):<P CLASS=para><DIV CLASS=programlisting><P><PRE>$ofh = select(OUTF);$~ = "My_Other_Format";$^ = "My_Top_Format";select($ofh);</PRE></DIV><P CLASS=para>If you use the English module, you can even read the variable names:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use English;$ofh = select(OUTF);$FORMAT_NAME     = "My_Other_Format";$FORMAT_TOP_NAME = "My_Top_Format";select($ofh);</PRE></DIV><P CLASS=para>But you still have those funny calls to <B>select</B>.  So just use theFileHandle module.  Now you can access these special variables usinglowercase method names instead:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use FileHandle;OUTF-&gt;format_name("My_Other_Format");OUTF-&gt;format_top_name("My_Top_Format");</PRE></DIV><P CLASS=para>Much better!<P CLASS=para>Since the values line following your picture line may contain arbitraryexpressions (for <tt CLASS=literal>@</tt> fields, not <tt CLASS=literal>^</tt> fields), you can farm out moresophisticated processing to other functions, like <A HREF="ch03_02.htm#PERL2-CMD-SPRINTF">sprintf</A> or one ofyour own.  For example, to insert commas into a number:<P CLASS=para><DIV CLASS=programlisting><P><PRE>format Ident =     @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;    commify($n).</PRE></DIV><P CLASS=para>To get a real <tt CLASS=literal>@</tt>, <tt CLASS=literal>~</tt>, or <tt CLASS=literal>^</tt> into the field, do this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>format Ident = I have an @ here.         "@".</PRE></DIV><P CLASS=para>To center a whole line of text, do something like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>format Ident = @||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||                          "Some text line".</PRE></DIV><P CLASS=para>The <tt CLASS=literal>&gt;</tt> field-length indicator ensures that the text will beright-justified within the field, but the field as a whole occursexactly where you show it occurring.There is no built-in way to say "float this field to the right-hand sideof the page, however wide it is."  You have to specify where it goesrelative to the left margin.The truly desperate can generate their own format on the fly, basedon the current number of columns, and then <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> it:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$format  = "format STDOUT = \n"         . '^' . '&lt;' x $cols . "\n"         . '$entry' . "\n"         . "\t^" . "&lt;" x ($cols-8) . "~~\n"         . '$entry' . "\n"         . ".\n";print $format if $Debugging;eval $format; die $@ if $@;</PRE></DIV><P CLASS=para>The most important line there is probably the <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>.What the <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> would print out looks something like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>format STDOUT = ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;$entry    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;~~$entry.</PRE></DIV><P CLASS=para>Here's a little program that's somewhat like <I CLASS=emphasis>fmt</I> (1):<P CLASS=para><DIV CLASS=programlisting><P><PRE>format = ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~~$_.$/ = "";while (&lt;&gt;) {    s/\s*\n\s*/ /g;    write;}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-8.2">Footers</A></h3><P CLASS=para>While <tt CLASS=literal>$FORMAT_TOP_NAME</tt> contains the name of the current header format,there is no corresponding mechanism to automatically do the same thingfor a footer.  Not knowing how big a format is going to be until youevaluate it is one of the major problems.  It's on the TODO list.<P CLASS=para>Here's one strategy:  If you have a fixed-size footer, you can get footersby checking <tt CLASS=literal>$FORMAT_LINES_LEFT</tt> before each <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> and then <B>print</B>the footer yourself if necessary.<P CLASS=para>Here's another strategy; open a pipe to yourself, using <tt CLASS=literal>open(MESELF,`|-`)</tt>  (see the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> entry in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>) andalways <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> to <tt CLASS=literal>MESELF</tt> instead of <tt CLASS=literal>STDOUT.</tt>  Have yourchild process postprocess its <tt CLASS=literal>STDIN</tt> to rearrange headers andfooters however you like.  Not very convenient, but doable.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-8.3">Accessing Formatting Internals</A></h3><P CLASS=para>For low-level access to the formatting mechanism, you may use<A HREF="ch03_02.htm#PERL2-CMD-FORMLINE">formline</A> and access <B>$^A</B> (the <tt CLASS=literal>$ACCUMULATOR</tt> variable)directly.  (Formats essentially compile into a sequence of calls to<A HREF="ch03_02.htm#PERL2-CMD-FORMLINE">formline</A>.) For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$str = formline &lt;&lt;'END', 1,2,3;@&lt;&lt;&lt;  @|||  @&gt;&gt;&gt;ENDprint "Wow, I just stored `$^A' in the accumulator!\n";</PRE></DIV><P CLASS=para>Or to make an <tt CLASS=literal>swrite( )</tt> subroutine which is to <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> as<A HREF="ch03_02.htm#PERL2-CMD-SPRINTF">sprintf</A> is to <A HREF="ch03_02.htm#PERL2-CMD-PRINTF">printf</A>, do this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use Carp;sub swrite {    croak "usage: swrite PICTURE ARGS" unless @_;    my $format = shift;    $^A = "";    formline($format,@_);    return $^A;} $string = swrite(&lt;&lt;'END', 1, 2, 3);Check me out@&lt;&lt;&lt;  @|||  @&gt;&gt;&gt;ENDprint $string;</PRE></DIV><P CLASS=para>Lexical variables (declared with <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>) are not visible within aformat unless the format is declared within the scope of the lexicalvariable.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_07.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch02_09.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Subroutines</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Special Variables</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>