<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 2] 2.9 Special Variables</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:03:52 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_08.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 2</b></td><td width=172 align=right valign=top><A HREF="ch03_01.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-9">2.9 Special Variables</A></h2><P CLASS=para><A NAME="CH02.SPECIAL1"></A><A NAME="CH02.SPECIAL2"></A>The following names have special meaning to Perl.  Most of thepunctuational names have reasonable mnemonics, or analogs in one ofthe shells.  Nevertheless, if you wish to use the long variable names,just say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use English;</PRE></DIV><P CLASS=para>at the top of your program.  This will alias all the short names to the long names in the current package.  Some of them even have medium names,generally borrowed from <I CLASS=emphasis>awk</I> (1).<P CLASS=para>A few of these variables are considered read-only.  This means that ifyou try to assign to this variable, either directly, or indirectly througha reference, you'll raise a run-time exception.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-9.1">Regular Expression Special Variables</A></h3><P CLASS=para>There are several variables that are associated with regular expressionsand pattern matching.  Except for <B>$*</B> they are always local to thecurrent block, so you never need to mention them in a <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A>.  (And<B>$*</B> is deprecated, so you never need to mention it at all.)<P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>$</tt><tt CLASS=replaceable><i>digit</i></tt><DD><P CLASS=para>Contains the text matched by the corresponding set of parentheses inthe last pattern matched, not counting patterns matched in nestedblocks that have been exited already.  (Mnemonic: like <tt CLASS=literal>\</tt><tt CLASS=replaceable><i>digit</i></tt>.)These variables are all read-only.<p><DT CLASS=varlistentry><tt CLASS=literal>$&amp;</tt> <tt CLASS=literal>$MATCH</tt><DD><P CLASS=para>The string matched by the last successful pattern match, not counting anymatches hidden within a block or <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> enclosed by thecurrent block.  (Mnemonic: like <tt CLASS=literal>&amp;</tt> in some editors.)  Thisvariable is read-only. <p><DT CLASS=varlistentry><tt CLASS=literal>$`</tt> <tt CLASS=literal>$PREMATCH</tt><DD><P CLASS=para>The string preceding whatever was matched by the last successful patternmatch not counting any matches hidden within a block or <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>enclosed by the current block.  (Mnemonic: <tt CLASS=literal>`</tt> often precedes aquoted string.)  This variable is read-only. <p><DT CLASS=varlistentry><tt CLASS=literal>$'</tt> <tt CLASS=literal>$POSTMATCH</tt><DD><P CLASS=para>The string following whatever was matched by the last successful patternmatch not counting any matches hidden within a block or <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>enclosed by the current block.(Mnemonic: <tt CLASS=literal>'</tt> often follows a quotedstring.)  Example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$_ = 'abcdefghi';/def/;print "$`:$&amp;:$'\n";         # prints abc:def:ghi</PRE></DIV><P CLASS=para>This variable is read-only.<DT CLASS=varlistentry><tt CLASS=literal>$+</tt> <tt CLASS=literal>$LAST_PAREN_MATCH</tt><DD><P CLASS=para>The last bracket matched by the last search pattern.  This is useful if youdon't know which of a set of alternative patterns matched.  For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>/Version: (.*)|Revision: (.*)/ &amp;&amp; ($rev = $+);</PRE></DIV><P CLASS=para>(Mnemonic: be positive and forward looking.)  This variable is read-only.<p><DT CLASS=varlistentry><tt CLASS=literal>$*</tt> <tt CLASS=literal>$MULTILINE_MATCHING</tt><DD><P CLASS=para>Use of <B>$*</B> is now deprecated, and is allowed only for maintaining backwardscompatibility with older versions of Perl.  Use <B>/m</B> (and maybe <B>/s</B>)in the regular expression match instead.<P CLASS=para>Set to 1 to do multi-line matching within a string, 0 to tell Perl that itcan assume that strings contain a single line for the purpose ofoptimizing pattern matches.  Pattern matches on strings containing multiplenewlines can produce confusing results when <B>$*</B> is 0.  Default is 0.(Mnemonic: <tt CLASS=literal>*</tt> matches multiple things.) Note that this variable onlyinfluences the interpretation of <tt CLASS=literal>^</tt> and <tt CLASS=literal>$</tt>.  A literalnewline can be searched for even when <tt CLASS=literal>$* == 0</tt>.</DL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-9.2">Per-Filehandle Special Variables</A></h3><P CLASS=para>These variables never need to be mentioned in a <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> because they always refer to some valuepertaining to the currently selected output filehandle--eachfilehandle keeps its own set of values.  When you <B>select</B> another filehandle, the old filehandlekeeps whatever values it had in effect, and the variables now reflectthe values of the new filehandle.<P CLASS=para>To go a step further and avoid <B>select</B>entirely, these variables that depend on the currently selectedfilehandle may instead be set by calling an object method on theFileHandle object.  (Summary lines below for this contain the word<tt CLASS=replaceable><i>HANDLE</i></tt>.)  First you must say:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use FileHandle;</PRE></DIV><P CLASS=para>after which you may use either:<P CLASS=para><DIV CLASS=programlisting><P><PRE><tt CLASS=replaceable><i>method</i></tt> <tt CLASS=replaceable><i>HANDLE</i></tt> <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>or:<P CLASS=para><DIV CLASS=programlisting><P><PRE><tt CLASS=replaceable><i>HANDLE</i></tt>-&gt;<tt CLASS=replaceable><i>method</i></tt>(<tt CLASS=replaceable><i>EXPR</i></tt>)</PRE></DIV><P CLASS=para>Each of the methods returns the old value of the FileHandle attribute.The methods each take an optional <tt CLASS=replaceable><i>EXPR</i></tt>, which if supplied specifies thenew value for the FileHandle attribute in question.  If not supplied,most of the methods do nothing to the current value, except for<tt CLASS=literal>autoflush</tt>, which will assume a <tt CLASS=literal>1</tt> for you, just to be different.<P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>$|</tt> <tt CLASS=literal>$OUTPUT_AUTOFLUSH</tt> <tt CLASS=literal>autoflush</tt> <tt CLASS=replaceable><i>HANDLE EXPR</i></tt><DD><P CLASS=para>If set to nonzero, forces an <I CLASS=emphasis>fflush</I> (3) after every <B>write</B> or<B>print</B> on the currently selected output channel.  (This is called"command buffering".  Contrary to popular belief, setting this variabledoes not turn off buffering.)  Default is 0, which on many systemsmeans that <tt CLASS=literal>STDOUT</tt> will default to being line buffered if output is tothe terminal, and block buffered otherwise.  Setting this variable isuseful primarily when you are outputting to a pipe, such as when you arerunning a Perl script under <I CLASS=emphasis>rsh</I> and want to see the output as it'shappening.  This has no effect on input buffering.  If you have a need toflush a buffer immediately after setting <B>$|</B>,you may simply <tt CLASS=literal>print "";</tt> rather than waiting for thenext <B>print</B> to flush it.  (Mnemonic: when youwant your pipes to be piping hot.)<p><DT CLASS=varlistentry><tt CLASS=literal>$%</tt> <tt CLASS=literal>$FORMAT_PAGE_NUMBER</tt> <tt CLASS=literal>format_page_number</tt> <tt CLASS=replaceable><i>HANDLE EXPR</i></tt><DD><P CLASS=para>The current page number of the currently selected output channel.(Mnemonic: <tt CLASS=literal>%</tt> is page number in <I CLASS=emphasis>nroff</I>.) <p><DT CLASS=varlistentry><tt CLASS=literal>$=</tt> <tt CLASS=literal>$FORMAT_LINES_PER_PAGE</tt> <tt CLASS=literal>format_lines_per_page</tt> <tt CLASS=replaceable><i>HANDLE EXPR</i></tt><DD><P CLASS=para>The current page length (printable lines) of the currently selected outputchannel.  Default is 60.  (Mnemonic: <tt CLASS=literal>=</tt> has horizontal lines.) <p><DT CLASS=varlistentry><tt CLASS=literal>$-</tt> <tt CLASS=literal>$FORMAT_LINES_LEFT</tt> <tt CLASS=literal>format_lines_left</tt> <tt CLASS=replaceable><i>HANDLE EXPR</i></tt><DD><P CLASS=para>The number of lines left on the page of the currently selected outputchannel.  (Mnemonic: <tt CLASS=literal>lines_on_page - lines_printed</tt>.) <p><DT CLASS=varlistentry><tt CLASS=literal>$~</tt> <tt CLASS=literal>$FORMAT_NAME</tt> <tt CLASS=literal>format_name</tt> <tt CLASS=replaceable><i>HANDLE EXPR</i></tt><DD><P CLASS=para>The name of the current report format for the currently selected outputchannel.  Default is name of the filehandle.  (Mnemonic: takes a turn after<B>$^</B>.) <p><DT CLASS=varlistentry><tt CLASS=literal>$^</tt> <tt CLASS=literal>$FORMAT_TOP_NAME</tt> <tt CLASS=literal>format_top_name</tt> <tt CLASS=replaceable><i>HANDLE EXPR</i></tt><DD><P CLASS=para>The name of the current top-of-page format for the currently selectedoutput channel.  Default is name of the filehandle with <tt CLASS=literal>_TOP</tt> appended.(Mnemonic: points to top of page.)</DL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-9.3">Global Special Variables</A></h3><P CLASS=para><A NAME="CH02.GLOBAL1"></A><A NAME="CH02.GLOBAL2"></A>There are quite a few variables that are global in the fullestsense--they mean the same thing in every package.  If you want aprivate copy of one of these, you must localize it in the currentblock.<P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>$_</tt> <tt CLASS=literal>$ARG</tt><DD><P CLASS=para>The default input and pattern-searching space. These pairs areequivalent:<P CLASS=para><DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {...}    # only equivalent in while!while (defined($_ = &lt;&gt;)) {...}/^Subject:/$_ =~ /^Subject:/tr/a-z/A-Z/$_ =~ tr/a-z/A-Z/chopchop($_)</PRE></DIV><P CLASS=para>Here are the places where Perl will assume <B>$_</B> even if you don't useit: <P><UL CLASS=itemizedlist><li CLASS=listitem>Various unary functions, including functions like <A HREF="ch03_02.htm#PERL2-CMD-ORD">ord</A> and<A HREF="ch03_02.htm#PERL2-CMD-INT">int</A>, as well as the all file tests (<tt CLASS=literal>-f</tt>, <tt CLASS=literal>-d</tt>) except for<tt CLASS=literal>-t</tt>, which defaults to <tt CLASS=literal>STDIN</tt>.<P><li CLASS=listitem>Various list functions like <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> and <A HREF="ch03_02.htm#PERL2-CMD-UNLINK">unlink</A>.<P><li CLASS=listitem>The pattern-matching operations <tt CLASS=literal>m//</tt>, <tt CLASS=literal>s///</tt>, and <tt CLASS=literal>tr///</tt>when used without an <tt CLASS=literal>=~</tt> operator.<P><li CLASS=listitem>The default iterator variable in a <B>foreach</B> loop if no othervariable is supplied. <P><li CLASS=listitem>The implicit iterator variable in the <A HREF="ch03_02.htm#PERL2-CMD-GREP">grep</A> and <A HREF="ch03_02.htm#PERL2-CMD-MAP">map</A>functions.<P><li CLASS=listitem>The default place to put an input record when a <tt CLASS=literal>&lt;FH&gt;</tt> operation'sresult is tested by itself as the sole criterion of a <B>while</B> test.Note that outside of a <B>while</B> test, thiswill not happen. <P></UL><P CLASS=para>Mnemonic: underline is the underlying operand in certain operations.<p><DT CLASS=varlistentry><tt CLASS=literal>$.</tt> <tt CLASS=literal>$INPUT_LINE_NUMBER</tt> <tt CLASS=literal>$NR</tt><DD><P CLASS=para>The current input line number of the last filehandle that was read.  Anexplicit close on the filehandle resets the line number.  Since <tt CLASS=literal>&lt;&gt;</tt>never does an explicit close, line numbers increase across<B>ARGV</B> files (but see examples under <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A> in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>).  Localizing<B>$.</B> has the effect of also localizing Perl's notion of the last readfilehandle.  (Mnemonic: many programs use "." to mean the current linenumber.)<p><DT CLASS=varlistentry><tt CLASS=literal>$/</tt> <tt CLASS=literal>$INPUT_RECORD_SEPARATOR</tt> <tt CLASS=literal>$RS</tt><DD><P CLASS=para>The input record separator, newline by default.  It works like <I CLASS=emphasis>awk</I>&nbsp;'s<tt CLASS=literal>RS</tt> variable, and, if set to the null string, treats blank lines asdelimiters.  You may set it to a multi-character string to match amulti-character delimiter.  Note that setting it to <tt CLASS=literal>"\n\n"</tt> meanssomething slightly different than setting it to <tt CLASS=literal>""</tt>, if the filecontains consecutive blank lines.  Setting it to <tt CLASS=literal>""</tt> will treat two ormore consecutive blank lines as a single blank line.  Setting it to<tt CLASS=literal>"\n\n"</tt> means Perl will blindly assume that the next input character belongs tothe next paragraph, even if it's a third newline.  (Mnemonic: <tt CLASS=literal>/</tt> is used todelimit line boundaries when quoting poetry.)<P CLASS=para><DIV CLASS=programlisting><P><PRE>undef $/;$_ = &lt;FH&gt;;          # whole file now heres/\n[ \t]+/ /g;</PRE></DIV><p><DT CLASS=varlistentry><tt CLASS=literal>$,</tt> <tt CLASS=literal>$OUTPUT_FIELD_SEPARATOR</tt> <tt CLASS=literal>$OFS</tt><DD><P CLASS=para>The output field separator for the <B>print</B> operator.  Ordinarily the <B>print</B>operator simply prints out the comma separated fields you specify.  Inorder to get behavior more like <I CLASS=emphasis>awk</I>, set this variable as you wouldset <I CLASS=emphasis>awk</I>&nbsp;'s <tt CLASS=literal>OFS</tt> variable to specify what is printed betweenfields.  (Mnemonic: what is printed when there is a "<tt CLASS=literal>,</tt>" in your <B>print</B>statement.)<p><DT CLASS=varlistentry><tt CLASS=literal>$\</tt> <tt CLASS=literal>$OUTPUT_RECORD_SEPARATOR</tt> <tt CLASS=literal>$ORS</tt><DD><P CLASS=para>The output record separator for the <B>print</B> operator.  Ordinarily the<B>print</B> operator simply prints out the comma-separated fields youspecify, with no trailing newline or record separator assumed.  Inorder to get behavior more like <I CLASS=emphasis>awk</I>, set this variable as you wouldset <I CLASS=emphasis>awk</I>&nbsp;'s <tt CLASS=literal>ORS</tt> variable to specify what is printed at the endof the <B>print</B>.  (Mnemonic: you set <B>$\</B> instead of adding <tt CLASS=literal>"\n"</tt> at theend of the print.  Also, it's just like <tt CLASS=literal>/</tt>, but it's what you get "back"from Perl.)<p><DT CLASS=varlistentry><tt CLASS=literal>$`</tt> <tt CLASS=literal>$LIST_SEPARATOR</tt><DD><P CLASS=para>This is like <tt CLASS=literal>$,</tt> above except that it applies to list values interpolatedinto a double-quoted string (or similar interpreted string).  Defaultis a space.  (Mnemonic: obvious, I think.)<p><DT CLASS=varlistentry><tt CLASS=literal>$;</tt> <tt CLASS=literal>$SUBSCRIPT_SEPARATOR</tt> <tt CLASS=literal>$SUBSEP</tt><DD><P CLASS=para>The subscript separator for multi-dimensional array emulation.  If yourefer to a hash element as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$foo{$a,$b,$c}</PRE></DIV><P CLASS=para>it really means:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$foo{join($;, $a, $b, $c)}</PRE></DIV><P CLASS=para>But don't put:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@foo{$a,$b,$c}      # a slice--note the @</PRE></DIV><P CLASS=para>which means:<P CLASS=para><DIV CLASS=programlisting><P><PRE>($foo{$a},$foo{$b},$foo{$c})</PRE></DIV><P CLASS=para>Default is <tt CLASS=literal>"\034"</tt>, the same as SUBSEP in <I CLASS=emphasis>awk</I>.  Note that if yourkeys contain binary data there might not be any safe value for <tt CLASS=literal>$;</tt>.(Mnemonic: comma--the syntactic subscript separator--is asemi-semicolon.  Yeah, I know, it's pretty lame, but <tt CLASS=literal>$,</tt> is alreadytaken for something more important.)<P CLASS=para>This variable is for maintaining backward compatibility, so consider using"real" multi-dimensional arrays now.<p><DT CLASS=varlistentry><tt CLASS=literal>$^L</tt> <tt CLASS=literal>$FORMAT_FORMFEED</tt> <tt CLASS=literal>format_formfeed</tt> <tt CLASS=replaceable><i>HANDLE EXPR</i></tt><DD><P CLASS=para>What a format outputs to perform a formfeed.  Default is <tt CLASS=literal>`\f`</tt>.<p><DT CLASS=varlistentry><tt CLASS=literal>$:</tt> <tt CLASS=literal>$FORMAT_LINE_BREAK_CHARACTERS</tt> <tt CLASS=literal>format_line_break_characters HANDLE EXPR</tt><DD><P CLASS=para>The current set of characters after which a string may be broken to fillcontinuation fields (starting with <tt CLASS=literal>^</tt>) in a format.  Default is <tt CLASS=literal>` \n-`</tt>, to break on whitespace or hyphens.  (Mnemonic:a colon in poetry is a part of a line.)<p><DT CLASS=varlistentry><tt CLASS=literal>$^A</tt> <tt CLASS=literal>$ACCUMULATOR</tt><DD><P CLASS=para>The current value of the <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A>accumulator for <A HREF="ch03_02.htm#PERL2-CMD-FORMAT">format</A> lines.  A formatcontains <A HREF="ch03_02.htm#PERL2-CMD-FORMLINE">formline</A> commands that puttheir result into <B>$^A</B>.  After callingits format, <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> prints out thecontents of <B>$^A</B> and empties.  So younever actually see the contents of <B>$^A</B>unless you call <A HREF="ch03_02.htm#PERL2-CMD-FORMLINE">formline</A> yourself andthen look at it.  <p><DT CLASS=varlistentry><tt CLASS=literal>$#</tt> <tt CLASS=literal>$OFMT</tt><DD><P CLASS=para>Use of <B>$#</B> is now deprecated and is allowed only for maintaining backwardscompatibility with older versions of Perl.  You should use <A HREF="ch03_02.htm#PERL2-CMD-PRINTF">printf</A> instead. <B>$#</B> contains the output format for printed numbers.  This variable is a half-heartedattempt to emulate <I CLASS=emphasis>awk</I>&nbsp;'s <tt CLASS=literal>OFMT</tt> variable.  There are times, however,when <I CLASS=emphasis>awk</I> and Perl have differing notions of what is in fact numeric.Also, the initial value is approximately <tt CLASS=literal>%.14g</tt> rather than <tt CLASS=literal>%.6g</tt>, so youneed to set <B>$#</B> explicitly to get <I CLASS=emphasis>awk</I>&nbsp;'s value.  (Mnemonic: <tt CLASS=literal>#</tt> is thenumber sign.  Better yet, just forget it.)<p><DT CLASS=varlistentry><tt CLASS=literal>$?</tt> <tt CLASS=literal>$CHILD_ERROR</tt><DD><P CLASS=para>The status returned by the last pipe close, backtick (<tt CLASS=literal>``</tt>) command,or <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A> operator.  Note that this is the status word returned bythe <I CLASS=emphasis>wait</I>&nbsp;(2) system call, so the exit value of the subprocess is actually<tt CLASS=literal>($? &gt;&gt; 8)</tt>.  Thus on many systems, <tt CLASS=literal>($? &amp; 255)</tt> gives which signal,if any, the process died from, and whether there was a core dump.(Mnemonic: similar to <I CLASS=emphasis>sh</I> and <I CLASS=emphasis>ksh</I>.)<p><DT CLASS=varlistentry><tt CLASS=literal>$!</tt> <tt CLASS=literal>$OS_ERROR</tt> <tt CLASS=literal>$ERRNO</tt><DD><P CLASS=para>If used in a numeric context, yields the current value of the<tt CLASS=literal>errno</tt> variable (identifying the last system call error) in thecurrently executing <I CLASS=emphasis>perl</I>, withall the usual caveats.  (This means that you shouldn't depend on the valueof <B>$!</B> to be anything in particular unless you've gotten a specificerror return indicating a system error.)  If used in a string context,yields the corresponding system error string.  You can assign to <B>$!</B>in order to set <tt CLASS=literal>errno</tt>, if, for instance, you want <B>$!</B> to returnthe string for error <I CLASS=emphasis>n</I>, or you want to set the exit value for the<A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> operator.  (Mnemonic: What just went bang?)<p><DT CLASS=varlistentry><tt CLASS=literal>$@</tt> <tt CLASS=literal>$EVAL_ERROR</tt><DD><P CLASS=para>The Perl syntax error message from the last <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> command.  If null,the last <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> was parsed and executed correctly (although the operationsyou invoked may have failed in the normal fashion).  (Mnemonic: Where wasthe syntax error "at"?)<P CLASS=para>Note that warning messages are not collected in this variable.  You can, however, set up a routine to process warnings by setting<tt CLASS=literal>$SIG{_ _WARN_ _}</tt> below. <p><DT CLASS=varlistentry><tt CLASS=literal>$$</tt> <tt CLASS=literal>$PROCESS_ID</tt> <tt CLASS=literal>$PID</tt><DD><P CLASS=para>The process number of the Perl running this script.  (Mnemonic: sameas shells.)<p><DT CLASS=varlistentry><tt CLASS=literal>$&lt;</tt> <tt CLASS=literal>$REAL_USER_ID</tt> <tt CLASS=literal>$UID</tt><DD><P CLASS=para>The real user ID (uid) of this process.  (Mnemonic: it's the uid you came<I CLASS=emphasis>from</I>, if you're running setuid.)<p><DT CLASS=varlistentry><tt CLASS=literal>$&gt;</tt> <tt CLASS=literal>$EFFECTIVE_USER_ID</tt> <tt CLASS=literal>$EUID</tt><DD><P CLASS=para>The effective uid of this process.  Example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$&lt; = $&gt;;            # set real to effective uid($&lt;,$&gt;) = ($&gt;,$&lt;);  # swap real and effective uid</PRE></DIV><P CLASS=para>(Mnemonic: it's the uid you went <I CLASS=emphasis>to</I>, if you're runningsetuid.)  Note: <B>$&lt;</B> and <B>$&gt;</B> can only be swapped on machinessupporting <I CLASS=emphasis>setreuid</I>&nbsp;(2).  And sometimes not even then.<p><DT CLASS=varlistentry><tt CLASS=literal>$(</tt> <tt CLASS=literal>$REAL_GROUP_ID</tt> <tt CLASS=literal>$GID</tt><DD><P CLASS=para>The real group ID (gid) of this process.  If you are on a machine that supportsmembership in multiple groups simultaneously, gives a space-separatedlist of groups you are in.  The first number is the one returned by<I CLASS=emphasis>getgid</I> (1), and the subsequent ones by <I CLASS=emphasis>getgroups</I>(2), one of whichmay be the same as the first number.  (Mnemonic: parentheses are used to<I CLASS=emphasis>group</I> things.  The real gid is the group you<I CLASS=emphasis>left</I>, if you're running setgid.) <p><DT CLASS=varlistentry><tt CLASS=literal>$)</tt> <tt CLASS=literal>$EFFECTIVE_GROUP_ID</tt> <tt CLASS=literal>$EGID</tt><DD><P CLASS=para>The effective gid of this process.  If you are on a machine thatsupports membership in multiple groups simultaneously, <B>$)</B> gives aspace-separated list of groups you are in.  The first number is theone returned by <I CLASS=emphasis>getegid</I>&nbsp;(2), and the subsequentones by <I CLASS=emphasis>getgroups</I>&nbsp;(2), one of which may be thesame as the first number.  (Mnemonic: parentheses are used to<I CLASS=emphasis>group</I> things.  The effective gid is the groupthat's <I CLASS=emphasis>right</I> for you, if you're running setgid.)<P CLASS=para>Note: <B>$&lt;</B>, <B>$&gt;</B>, <B>$(</B>, and<B>$)</B> can only be set on machines thatsupport the corresponding system set-id routine.  <B>$(</B> and <B>$)</B> can onlybe swapped on machines supporting <I CLASS=emphasis>setregid</I>(2).Because Perl doesn't currently use <I CLASS=emphasis>initgroups</I>(2),you can't set your group vector to multiple groups.<p><DT CLASS=varlistentry><tt CLASS=literal>$0</tt> <tt CLASS=literal>$PROGRAM_NAME</tt><DD><P CLASS=para>Contains the name of the file containing the Perl script being executed.Assigning to <B>$0</B> attempts to modify the argument area that the<I CLASS=emphasis>ps</I> (1) program sees.  This is more useful as a way of indicating thecurrent program state than it is for hiding the program you're running.But it doesn't work on all systems.  (Mnemonic: same as <I CLASS=emphasis>sh</I> and<I CLASS=emphasis>ksh</I>.)<p><DT CLASS=varlistentry><tt CLASS=literal>$[</tt><DD><P CLASS=para>The index of the first element in an array, and of the first character ina substring.  Default is 0, but you could set it to 1 to make Perlbehave more like <I CLASS=emphasis>awk</I> (or FORTRAN) whensubscripting and when evaluating the <A HREF="ch03_02.htm#PERL2-CMD-INDEX">index</A> and <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A>functions.  (Mnemonic: [ begins subscripts.)<P CLASS=para>Assignment to <B>$[</B> is now treated as a compiler directive, and cannotinfluence the behavior of any other file.  Its use is discouraged.<p><DT CLASS=varlistentry><tt CLASS=literal>$]</tt> <tt CLASS=literal>$PERL_VERSION</tt><DD><P CLASS=para>Returns the version + patchlevel / 1000.  It can be used to determine atthe beginning of a script whether the Perl interpreter executing the scriptis in the right range of versions.  Example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>warn "No checksumming!\n" if $] &lt; 3.019;die "Must have prototyping available\n" if $] &lt; 5.003;</PRE></DIV><P CLASS=para>(Mnemonic: Is this version of Perl in the right bracket?)<p><DT CLASS=varlistentry><tt CLASS=literal>$^D</tt> <tt CLASS=literal>$DEBUGGING</tt><DD><P CLASS=para>The current value of the debugging flags.  (Mnemonic: value of <B>-D</B>switch.)<p><DT CLASS=varlistentry><tt CLASS=literal>$^F</tt> <tt CLASS=literal>$SYSTEM_FD_MAX</tt><DD><P CLASS=para>The maximum system file descriptor, ordinarily 2.  System filedescriptors are passed to <I CLASS=emphasis>exec</I> edprocesses, while higher file descriptors are not.  Also, during an<A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A>, system file descriptors arepreserved even if the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> fails.(Ordinary file descriptors are closed before the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> is attempted, and stay closed if the<A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> fails.)  Note that theclose-on-exec status of a file descriptor will be decided according tothe value of <B>$^F</B> at the time of the<B>open</B>, not the time of the <I CLASS=emphasis>exec</I>.  <p><DT CLASS=varlistentry><tt CLASS=literal>$^H</tt><DD><P CLASS=para>This variable contains internal compiler hints enabled by certain pragmatic modules.  Hint: ignore this and use the pragmata.<p><DT CLASS=varlistentry><tt CLASS=literal>$^I</tt> <tt CLASS=literal>$INPLACE_EDIT</tt><DD><P CLASS=para>The current value of the inplace-edit extension.  Use <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> to disableinplace editing.  (Mnemonic: value of <B>-i</B> switch.)<p><DT CLASS=varlistentry><tt CLASS=literal>$^O</tt> <tt CLASS=literal>$OSNAME</tt><DD><P CLASS=para>This variable contains the name of the operating system the currentPerl binary was compiled for.  It's intended as a cheap alternativeto pulling it out of the Config module.<p><DT CLASS=varlistentry><tt CLASS=literal>$^P</tt> <tt CLASS=literal>$PERLDB</tt><DD><P CLASS=para>The internal flag that the debugger clears so that it doesn't debugitself.  You could conceivably disable debugging yourself by clearingit.<p><DT CLASS=varlistentry><tt CLASS=literal>$^T</tt> <tt CLASS=literal>$BASETIME</tt><DD><P CLASS=para>The time at which the script began running, in seconds since the epoch(the beginning of 1970, for UNIX systems).  The values returned by the<tt CLASS=literal>-M</tt>, <tt CLASS=literal>-A</tt>, and <tt CLASS=literal>-C</tt> filetests are based on this value.<p><DT CLASS=varlistentry><tt CLASS=literal>$^W</tt> <tt CLASS=literal>$WARNING</tt><DD><P CLASS=para>The current value of the warning switch, either true orfalse.  (Mnemonic: the value is related to the <B>-w</B> switch.)<p><DT CLASS=varlistentry><tt CLASS=literal>$^X</tt> <tt CLASS=literal>$EXECUTABLE_NAME</tt><DD><P CLASS=para>The name that the Perl binary itself was executed as, from C's <tt CLASS=literal>argv[0]</tt>.<p><DT CLASS=varlistentry><tt CLASS=literal>$ARGV</tt><DD><P CLASS=para>Contains the name of the current file when reading from <tt CLASS=literal>&lt;ARGV&gt;</tt>.</DL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-9.4">Global Special Arrays</A></h3><P CLASS=para><A NAME="CH02.GAH1"></A><A NAME="CH02.GAH2"></A><A NAME="CH02.GAH3"></A>The following arrays and hashes are global.  Just like the special globalscalar variables, they refer to package main no matter when they arereferenced.  The following two statements are exactly the same:<P CLASS=para><DIV CLASS=programlisting><P><PRE>print "@INC\n";print "@main::INC\n";</PRE></DIV><P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>@ARGV</tt><DD><P CLASS=para>The array containing the command-line arguments intended for thescript.  Note that <tt CLASS=literal>$#ARGV</tt> is generally the number of arguments minusone, since <tt CLASS=literal>$ARGV[0]</tt> is the first argument, not thecommand name.  See <B>$0</B> for the command name.<p><DT CLASS=varlistentry><tt CLASS=literal>@INC</tt><DD><P CLASS=para>The array containing the list of places to look for Perl scriptsto be evaluated by the <tt CLASS=literal>do EXPR</tt>, <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>, or <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A>constructs.  It initially consists of the arguments to any <B>-I</B>command-line switches, followed by the default Perl libraries, such as:<P CLASS=para><DIV CLASS=programlisting><P><PRE>/usr/local/lib/perl5/$ARCH/$VERSION/usr/local/lib/perl5/usr/local/lib/perl5/site_perl/usr/local/lib/perl5/site_perl/$ARCH</PRE></DIV><P CLASS=para>followed by ".", to represent thecurrent directory.  If you need to modify this list at run-time, you should usethe lib module in order to also get the machine-dependent libraryproperly loaded:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use lib '/mypath/libdir/';use SomeMod;</PRE></DIV><p><DT CLASS=varlistentry><tt CLASS=literal>@F</tt><DD><P CLASS=para>The array into which the input lines are split when the <B>-a</B>command-line switch is given.  If the <B>-a</B> option is not used, thisarray has no special meaning.  (This array is actually only <tt CLASS=literal>@main::F</tt>, and notin all packages at once.)<p><DT CLASS=varlistentry><tt CLASS=literal>%INC</tt><DD><P CLASS=para>The hash containing entries for the filename of each file that has beenincluded via <A HREF="ch03_02.htm#PERL2-CMD-DO">do</A> or <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>.  The key is the filename youspecified, and the value is the location of the file actually found.  The<A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> command uses this array to determine whether a given file hasalready been included.<p><DT CLASS=varlistentry><tt CLASS=literal>%ENV</tt><DD><P CLASS=para>The hash containing your current environment.  Setting a value in <B>%ENV</B>changes the environment for child processes:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$ENV{PATH} = "/bin:/usr/bin";</PRE></DIV><P CLASS=para>To remove something from your environment, make sureto use <A HREF="ch03_02.htm#PERL2-CMD-DELETE">delete</A> instead of <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A>.<P CLASS=para>Note that processes running as a <I CLASS=emphasis>crontab</I> entryinherit a particularly impoverished set of environment variables.Also note that you should set <tt CLASS=literal>$ENV{PATH}</tt>,<tt CLASS=literal>$ENV{SHELL}</tt>, and <tt CLASS=literal>$ENV{IFS}</tt> ifyou are running as a setuid script.  See <A HREF="ch08_01.htm">Chapter 8, <i>Other Oddments</i></A>,for more on security and setuid issues.<p><DT CLASS=varlistentry><tt CLASS=literal>%SIG</tt><DD><P CLASS=para>The hash used to set signal handlers for various signals.  Example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub handler {       # 1st argument is signal name    local($sig) = @_;    print "Caught a SIG$sig--shutting down\n";    close(LOG);    exit(0);}$SIG{INT} = 'handler';$SIG{QUIT} = 'handler';...$SIG{INT} = 'DEFAULT';    # restore default action$SIG{QUIT} = 'IGNORE';    # ignore SIGQUIT</PRE></DIV><P CLASS=para>The <B>%SIG</B> array only contains values for the signals actually setwithin the Perl script.  Here are some other examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$SIG{PIPE} = Plumber;     # SCARY!!$SIG{PIPE} = "Plumber";   # just fine, assumes main::Plumber$SIG{PIPE} = \&amp;Plumber;   # just fine; assume current Plumber$SIG{PIPE} = Plumber();   # oops, what did Plumber() return??</PRE></DIV><P CLASS=para>The example marked <tt CLASS=literal>SCARY!!</tt> is problematic because it's a bareword, which meanssometimes it's a string representing the function, and sometimes it's going to call the subroutine right then and there!  Best to be sureand quote it or take a reference to it.Certain internal hooks can also be set using the <B>%SIG</B> hash.  Theroutine indicated by <tt CLASS=literal>$SIG{_ _WARN_ _}</tt> is called when a warning messageis about to be printed.  The warning message is passed as the firstargument.  The presence of a <tt CLASS=literal>_ _WARN_ _</tt> hook causes the ordinaryprinting of warnings to <tt CLASS=literal>STDERR</tt> to be suppressed.  You can use thisto save warnings in a variable, or turn warnings into fatal errors, likethis:<P CLASS=para><DIV CLASS=programlisting><P><PRE>local $SIG{_ _WARN_ _} = sub { die $_[0] };eval $proggie;</PRE></DIV><P CLASS=para>The routine indicated by <tt CLASS=literal>$SIG{_ _DIE_ _}</tt> is calledwhen a fatal exception is about to be thrown.  The error message ispassed as the first argument.  When a <tt CLASS=literal>_ _DIE_ _</tt> hookroutine returns, the exception processing continues as it would havein the absence of the hook, unless the hook routine itself exits via a<A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A>, a loop exit, or a <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A>.  The <tt CLASS=literal>_ _DIE_ _</tt> handler isexplicitly disabled during the call, so that you yourself can thencall the real <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> from a<tt CLASS=literal>_ _DIE_ _</tt> handler.  (If it weren't disabled, thehandler would call itself recursively forever.)  The case is similar for<tt CLASS=literal>_ _WARN_ _</tt>.</DL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-2-SECT-9.5">Global Special Filehandles</A></h3><P CLASS=para>The following filehandles (except for <tt CLASS=literal>DATA</tt>) always refer to<tt CLASS=literal>main::FILEHANDLE</tt>.<P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>ARGV</tt><DD><P CLASS=para>The special filehandle that iterates over command line filenames in<B>@ARGV</B>.  Usually written as the null filehandle in <tt CLASS=literal>&lt;&gt;</tt>.<p><DT CLASS=varlistentry><tt CLASS=literal>STDERR</tt><DD><P CLASS=para>The special filehandle for standard error in any package. <p><DT CLASS=varlistentry><tt CLASS=literal>STDIN</tt><DD><P CLASS=para>The special filehandle for standard input in any package.<p><DT CLASS=varlistentry><tt CLASS=literal>STDOUT</tt><DD><P CLASS=para>The special filehandle for standard output in any package.<p><DT CLASS=varlistentry><tt CLASS=literal>DATA</tt><DD><P CLASS=para>The special filehandle that refers to anything following the<tt CLASS=literal>_ _END_ _</tt> token in the filecontaining the script.  Or, the special filehandle for anythingfollowing the <tt CLASS=literal>_ _DATA_ _</tt> token in a required file, as long asyou're reading data in the same package that the <tt CLASS=literal>_ _DATA_ _</tt> wasfound in.<p><DT CLASS=varlistentry><tt CLASS=literal>_</tt> (underline)<DD><P CLASS=para>The special filehandle used to cache the information from the last <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A>,<A HREF="ch03_02.htm#PERL2-CMD-LSTAT">lstat</A>, or <B>file</B> test operator.</DL></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch02_08.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch03_01.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Formats</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Functions</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>