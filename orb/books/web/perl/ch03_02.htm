<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 3] 3.2 Perl Functions in Alphabetical Order</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:06:49 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch03_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 3</b></td><td width=172 align=right valign=top><A HREF="ch04_01.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CMD-ALPH">3.2 Perl Functions in Alphabetical Order</A></h2><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SPATTERNS">/PATTERN/</A></h3><DIV CLASS=programlisting><P><PRE>/<tt CLASS=replaceable><i>PATTERN</i></tt>/m/<tt CLASS=replaceable><i>PATTERN</i></tt>/</PRE></DIV><P CLASS=para>The match operator.  See "Regular Expressions" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-QPATTERNQ">?PATTERN?</A></h3><DIV CLASS=programlisting><P><PRE>?<tt CLASS=replaceable><i>PATTERN</i></tt>?</PRE></DIV><P CLASS=para>This is just like the<tt CLASS=literal>/</tt><tt CLASS=replaceable><i>PATTERN</i></tt><tt CLASS=literal>/</tt>search, except that it matches only once betweencalls to <A HREF="ch03_02.htm#PERL2-CMD-RESET">reset</A>, soit finds only the first occurrence of something rather than all occurrences.(In other words, the operator works repeatedly until it actually matchessomething, then it turns itself off until you explicitly turn it backon with <A HREF="ch03_02.htm#PERL2-CMD-RESET">reset</A>.)This may be useful (and efficient) if you want to see only the firstoccurrence of the pattern in each file of a set of files. Note that <tt CLASS=literal>m??</tt> is equivalent to <tt CLASS=literal>??</tt>.<P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-RESET">reset</A> operator will only resetinstances of <tt CLASS=literal>??</tt> that were compiled inthe same package that it was.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-ABS">abs</A></h3><DIV CLASS=programlisting><P><PRE>abs <tt CLASS=replaceable><i>VALUE</i></tt></PRE></DIV><P CLASS=para>This function returns the absolute value of its argument (or<B>$_</B> if omitted).</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-ACCEPT">accept</A></h3><DIV CLASS=programlisting><P><PRE>accept <tt CLASS=replaceable><i>NEWSOCKET</i></tt>, <tt CLASS=replaceable><i>GENERICSOCKET</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as the<A HREF="ch03_02.htm#PERL2-CMD-ACCEPT">accept</A>system call--see<I CLASS=emphasis>accept</I> (2).It is used by server processes that wish to accept socket connectionsfrom clients.Execution is suspended until a connection is made, at which timethe <tt CLASS=replaceable><i>NEWSOCKET</i></tt>filehandle is opened and attached to the newly made connection.The function returns the connected address if the callsucceeded, false otherwise(and puts the error code into<B>$!</B>).<tt CLASS=replaceable><i>GENERICSOCKET</i></tt>must be a filehandle already opened via the<A HREF="ch03_02.htm#PERL2-CMD-SOCKET">socket</A>operator and bound to one of the server's network addresses.For example:<DIV CLASS=programlisting><P><PRE>unless ($peer = accept NS, S) {    die "Can't accept a connection: $!\n";}</PRE></DIV><P CLASS=para>See also the example in the section "Sockets" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-ALARM">alarm</A></h3><DIV CLASS=programlisting><P><PRE>alarm <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function sends a <tt CLASS=literal>SIGALRM</tt> signal to the executing Perl program after<tt CLASS=replaceable><i>EXPR</i></tt>seconds.On some older systems, alarms go off at the "top of the second,"so, for instance, an<tt CLASS=literal>alarm 1</tt>may go off anywhere between 0 to 1 second from now,depending on when in the current second it is.  An<tt CLASS=literal>alarm 2</tt>may go off anywhere from 1 to 2 seconds from now.  And so on.For better resolution, you may be able to use<A HREF="ch03_02.htm#PERL2-CMD-SYSCALL">syscall</A>to call the <I CLASS=emphasis>itimer</I>routines that some UNIX systems support.Or you can use the timeout feature of the <B>select</B> function.<P CLASS=para>Each call disables the previous timer, and an argument of 0 may besupplied to cancel the previous timer without starting a new one.  Thereturn value is the number of seconds remaining on the previous timer.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-ATAN2">atan2</A></h3><DIV CLASS=programlisting><P><PRE>atan2 <tt CLASS=replaceable><i>Y</i></tt>, <tt CLASS=replaceable><i>X</i></tt></PRE></DIV><P CLASS=para>This function returns the arctangent of<tt CLASS=replaceable><i>Y</i></tt><tt CLASS=literal>/</tt><tt CLASS=replaceable><i>X</i></tt> inthe range -pi to pi.A quick way to get an approximate value of pi is to say:<DIV CLASS=programlisting><P><PRE>$pi = atan2(1,1) * 4;</PRE></DIV><P CLASS=para>For the tangent operation, you may use the <tt CLASS=literal>POSIX::tan()</tt>function, or use the familiar relation:<DIV CLASS=programlisting><P><PRE>sub tan { sin($_[0]) / cos($_[0]) }</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-BIND">bind</A></h3><DIV CLASS=programlisting><P><PRE>bind <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>NAME</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as the <A HREF="ch03_02.htm#PERL2-CMD-BIND">bind</A> system call--see<I CLASS=emphasis>bind</I> (2).  It attaches an address (a name) to analready opened socket specified by the <tt CLASS=replaceable><i>SOCKET</i></tt> filehandle.The function returns true if it succeeded, false otherwise (and putsthe error code into <B>$!</B>).<tt CLASS=replaceable><i>NAME</i></tt> should be a packed address of the proper type for the socket.<DIV CLASS=programlisting><P><PRE>bind S, $sockaddr or die "Can't bind address: $!\n";</PRE></DIV><P CLASS=para>See also the example in the section "Sockets" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-BINMODE">binmode</A></h3><DIV CLASS=programlisting><P><PRE>binmode <tt CLASS=replaceable><i>FILEHANDLE</i></tt></PRE></DIV><P CLASS=para>This function arranges for the file to be treated in binary mode onoperating systems that distinguish between binary and text files.It should be called after the <B>open</B> but before anyI/O is done on the filehandle.The only way to reset binary mode on a filehandle is to reopen the file.<P CLASS=para>On systems that distinguish binary mode from text mode,files that are read in text mode have<tt CLASS=literal>\r\n</tt> sequences translated to <tt CLASS=literal>\n</tt>on input and <tt CLASS=literal>\n</tt> translated to <tt CLASS=literal>\r\n</tt>on output.  <A HREF="ch03_02.htm#PERL2-CMD-BINMODE">binmode</A>has no effect under UNIX or Plan9.  If<tt CLASS=replaceable><i>FILEHANDLE</i></tt>is an expression, the value is taken as the name ofthe filehandle.The following example shows how a Perl script might prepare toread a word processor file with embedded control codes:<DIV CLASS=programlisting><P><PRE>open WP, "$file.wp" or die "Can't open $file.wp: $!\n";binmode WP;while (read WP, $buf, 1024) {...}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-BLESS">bless</A></h3><DIV CLASS=programlisting><P><PRE>bless <tt CLASS=replaceable><i>REF</i></tt>, <tt CLASS=replaceable><i>CLASSNAME</i></tt>bless <tt CLASS=replaceable><i>REF</i></tt></PRE></DIV><P CLASS=para>This function looks up the item pointed to by reference <tt CLASS=replaceable><i>REF</i></tt> and tellsthe item that it is nowan object in the <tt CLASS=replaceable><i>CLASSNAME</i></tt> package--or the current package if no<tt CLASS=replaceable><i>CLASSNAME</i></tt>is specified, which is often the case.  It returns the reference forconvenience, since a <A HREF="ch03_02.htm#PERL2-CMD-BLESS">bless</A> is often the last thing in a constructorfunction.  (Always use the two-argument version if the constructor doingthe blessing might be inherited by a derived class.  In such cases,the class you want to bless your object into will normally be found as thefirst argument to the constructor in question.)See "Objects" in <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A> for more about theblessing (and blessings) of objects.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CALLER">caller</A></h3><DIV CLASS=programlisting><P><PRE>caller <tt CLASS=replaceable><i>EXPR</i></tt>caller</PRE></DIV><P CLASS=para>This function returns information about the stack of current subroutine calls.Without an argumentit returns the package name, filename, and line number that the currentlyexecuting subroutine was called from:<DIV CLASS=programlisting><P><PRE>($package, $filename, $line) = caller;</PRE></DIV><P CLASS=para>With an argument it evaluates<tt CLASS=replaceable><i>EXPR</i></tt>as the number of stack frames to go backbefore the current one.It also reports some additional information.<DIV CLASS=programlisting><P><PRE>$i = 0;while (($pack, $file, $line, $subname, $hasargs, $wantarray) = caller($i++)) {    ...}</PRE></DIV><P CLASS=para>Furthermore, when called from within the DB package,<A HREF="ch03_02.htm#PERL2-CMD-CALLER">caller</A> returns more detailed information: it sets the listvariable <tt CLASS=literal>@DB::args</tt> to be the arguments passed in the given stack frame.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CHDIR">chdir</A></h3><DIV CLASS=programlisting><P><PRE>chdir <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function changes the working directory to<tt CLASS=replaceable><i>EXPR</i></tt>,if possible.If<tt CLASS=replaceable><i>EXPR</i></tt>is omitted, it changes to the home directory.The function returns 1 upon success, 0 otherwise (and puts the errorcode into <B>$!</B>).<DIV CLASS=programlisting><P><PRE>chdir "$prefix/lib" or die "Can't cd to $prefix/lib: $!\n";</PRE></DIV><P CLASS=para>The following code can be used to move to the user's home directory,one way or another:<DIV CLASS=programlisting><P><PRE>$ok = chdir($ENV{"HOME"} || $ENV{"LOGDIR"} || (getpwuid($&lt;))[7]);</PRE></DIV><P CLASS=para>Alternately, taking advantage of the default, you could say this:<DIV CLASS=programlisting><P><PRE>$ok = chdir() || chdir((getpwuid($&lt;))[7]);</PRE></DIV><P CLASS=para>See also the Cwd module, described in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>, which lets youkeep track of your current directory.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CHMOD">chmod</A></h3><DIV CLASS=programlisting><P><PRE>chmod <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function changes the permissions of a list of files.The first element of the list must be the numerical mode, as in<I CLASS=emphasis>chmod</I> (2).(When using nonliteral mode data, you may need to convert an octal stringto a decimal number using the <A HREF="ch03_02.htm#PERL2-CMD-OCT">oct</A> function.)The function returns the number of files successfully changed.For example:<DIV CLASS=programlisting><P><PRE>$cnt = chmod 0755, 'file1', 'file2';</PRE></DIV><P CLASS=para>will set <tt CLASS=literal>$cnt</tt> to <tt CLASS=literal>0</tt>, <tt CLASS=literal>1</tt>, or <tt CLASS=literal>2</tt>, depending on howmany files got changed (in the sense that the operation succeeded, notin the sense that the bits were different afterward).  Here's a moretypical usage:<DIV CLASS=programlisting><P><PRE>chmod 0755, @executables;</PRE></DIV><P CLASS=para>If you need to know which files didn't allow the change, use something like this:<DIV CLASS=programlisting><P><PRE>@cannot = grep {not chmod 0755, $_} 'file1', 'file2', 'file3';die "$0: could not chmod @cannot\n" if @cannot;</PRE></DIV><P CLASS=para>This idiom makes use of the <A HREF="ch03_02.htm#PERL2-CMD-GREP">grep</A> function to select only thoseelements of the list for which the <A HREF="ch03_02.htm#PERL2-CMD-CHMOD">chmod</A> function failed.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CHOMP">chomp</A></h3><DIV CLASS=programlisting><P><PRE>chomp <tt CLASS=replaceable><i>VARIABLE</i></tt>chomp <tt CLASS=replaceable><i>LIST</i></tt>chomp</PRE></DIV><P CLASS=para>This is a slightly safer version of <A HREF="ch03_02.htm#PERL2-CMD-CHOP">chop</A> (see below) in that itremoves only any line ending corresponding to the current value of<B>$/</B>, and not just any last character.  Unlike <A HREF="ch03_02.htm#PERL2-CMD-CHOP">chop</A>,<A HREF="ch03_02.htm#PERL2-CMD-CHOMP">chomp</A> returns the number of characters deleted. If <B>$/</B> isempty (in paragraph mode), <A HREF="ch03_02.htm#PERL2-CMD-CHOMP">chomp</A> removes all trailing newlinesfrom the selected string (or strings, if chomping a <tt CLASS=replaceable><i>LIST</i></tt>).</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CHOP">chop</A></h3><DIV CLASS=programlisting><P><PRE>chop <tt CLASS=replaceable><i>VARIABLE</i></tt>chop <tt CLASS=replaceable><i>LIST</i></tt>chop</PRE></DIV><P CLASS=para>This function chops off the last character of a string and returns thecharacter chopped.  The <A HREF="ch03_02.htm#PERL2-CMD-CHOP">chop</A> operator is used primarily toremove the newline from the end of an input record, but is moreefficient than <tt CLASS=literal>s/\n$//</tt>.If <tt CLASS=replaceable><i>VARIABLE</i></tt> is omitted, the function chops the <B>$_</B> variable.  Forexample:<DIV CLASS=programlisting><P><PRE>while (&lt;PASSWD&gt;) {    chop;   # avoid \n on last field    @array = split /:/;    ...}</PRE></DIV><P CLASS=para>If you chop a <tt CLASS=replaceable><i>LIST</i></tt>, each string in the list is chopped:<DIV CLASS=programlisting><P><PRE>@lines = `cat myfile`;chop @lines;</PRE></DIV><P CLASS=para>You can actually chop anything that is an lvalue, including anassignment:<DIV CLASS=programlisting><P><PRE>chop($cwd = `pwd`);chop($answer = &lt;STDIN&gt;);</PRE></DIV><P CLASS=para>Note that this is different from:<DIV CLASS=programlisting><P><PRE>$answer = chop($tmp = &lt;STDIN&gt;);  # WRONG</PRE></DIV><P CLASS=para>which puts a newline into <tt CLASS=literal>$answer</tt>, because <A HREF="ch03_02.htm#PERL2-CMD-CHOP">chop</A> returns thecharacter chopped, not the remaining string (which is in <tt CLASS=literal>$tmp</tt>).  One wayto get the result intended here is with <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A>:<DIV CLASS=programlisting><P><PRE>$answer = substr &lt;STDIN&gt;, 0, -1;</PRE></DIV><P CLASS=para>But this is more commonly written as:<DIV CLASS=programlisting><P><PRE>chop($answer = &lt;STDIN&gt;);</PRE></DIV><P CLASS=para>To chop more than one character, use<A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A>as an lvalue, assigning a null string.The following removes the lastfive characters of<tt CLASS=literal>$caravan</tt>:<DIV CLASS=programlisting><P><PRE>substr($caravan, -5) = "`;</PRE></DIV><P CLASS=para>The negative subscript causes<A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A>to count from the end of the string instead of the beginning.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CHOWN">chown</A></h3><DIV CLASS=programlisting><P><PRE>chown <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function changes the owner (and group) of a list of files.The first two elements of the list must be the<I CLASS=emphasis>numerical</I>uid and gid, in that order.The function returns the number of files successfully changed.For example:<DIV CLASS=programlisting><P><PRE>$cnt = chown $uid, $gid, 'file1', 'file2';</PRE></DIV><P CLASS=para>will set <tt CLASS=literal>$cnt</tt> to <tt CLASS=literal>0</tt>, <tt CLASS=literal>1</tt>, or <tt CLASS=literal>2</tt>, depending on howmany files got changed (in the sense that the operation succeeded, notin the sense that the owner was different afterward).  Here's a moretypical usage:<DIV CLASS=programlisting><P><PRE>chown $uid, $gid, @filenames;</PRE></DIV><P CLASS=para>Here's a subroutine that looks everything up for you, and then does the <B>chown</B>:<DIV CLASS=programlisting><P><PRE>sub chown_by_name {    local($user, $pattern) = @_;    chown((getpwnam($user))[2,3], glob($pattern));}&amp;chown_by_name("fred", "*.c");</PRE></DIV><P CLASS=para>Notice that this forces the group of each file to be the gid fetched from the<I CLASS=emphasis>passwd</I>file.  An alternative is to pass a -1 for the gid, whichleaves the group of the file unchanged.<P CLASS=para>On most systems, you are not allowed to change the ownership of the file unless you're the superuser, although you should be able to changethe group to any of your secondary groups.  On insecure systems, theserestrictions may be relaxed, but this is not a portable assumption.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CHR">chr</A></h3><DIV CLASS=programlisting><P><PRE>chr <tt CLASS=replaceable><i>NUMBER</i></tt></PRE></DIV><P CLASS=para>This function returns the character represented by that<tt CLASS=replaceable><i>NUMBER</i></tt> in the character set.For example, <tt CLASS=literal>chr(65)</tt> is "A" in ASCII.To convert multiple characters, use <tt CLASS=literal>pack(`C*`,</tt><tt CLASS=replaceable><i>LIST</i></tt><tt CLASS=literal>)</tt> instead.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CHROOT">chroot</A></h3><DIV CLASS=programlisting><P><PRE>chroot <tt CLASS=replaceable><i>FILENAME</i></tt></PRE></DIV><P CLASS=para>This function does the same operation as the <A HREF="ch03_02.htm#PERL2-CMD-CHROOT">chroot</A> systemcall--see <I CLASS=emphasis>chroot</I> (2).  If successful, <tt CLASS=replaceable><i>FILENAME</i></tt> becomes the newroot directory for the current process--the starting point forpathnames beginning with "<tt CLASS=literal>/</tt>".  This directory is inheritedacross <I CLASS=emphasis>exec</I> calls and by all subprocesses.  There is no way toundo a <A HREF="ch03_02.htm#PERL2-CMD-CHROOT">chroot</A>.  Only the superuser can use this function.Here's some code that approximates what many FTP servers do:<DIV CLASS=programlisting><P><PRE>chroot +(getpwnam('ftp'))[7]    or die "Can't do anonymous ftp: $!\n";</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CLOSE">close</A></h3><DIV CLASS=programlisting><P><PRE>close <tt CLASS=replaceable><i>FILEHANDLE</i></tt></PRE></DIV><P CLASS=para>This function closes the file, socket, or pipe associated with the filehandle.You don't have to close <tt CLASS=replaceable><i>FILEHANDLE</i></tt> if you are immediately going to doanother <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> on it, since the next <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> will close it foryou.  (See <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A>.)  However, an explicit <B>close</B> on an input fileresets the line counter (<B>$.</B>), while the implicit close done by<A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> does not.Also, closing a pipe will wait for the process executing on the pipeto complete (in case you want to look at the output of the pipeafterward), and it prevents the script from exiting before the pipeline isfinished.[1]Closing a pipe explicitly also puts the status value of the commandexecuting on the pipe into<B>$?</B>.For example:<blockquote class=footnote><P CLASS=para>[1] Note, however, that a<I CLASS=emphasis>dup</I>'edpipe is treated as an ordinary filehandle,and <B>close</B> will not wait for the child on that filehandle.You have to wait for the child by closing the filehandle on whichit was originally opened.</blockquote><DIV CLASS=programlisting><P><PRE>open OUTPUT, '|sort &gt;foo';     # pipe to sort...                            # print stuff to outputclose OUTPUT;                  # wait for sort to finishdie "sort failed" if $?;       # check for sordid sortopen INPUT, 'foo';             # get sort's results</PRE></DIV><P CLASS=para><tt CLASS=replaceable><i>FILEHANDLE</i></tt>may be an expression whose value gives the real filehandle name.It may also be a reference to a filehandle object returned by some ofthe newer object-oriented I/O packages.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CLOSEDIR">closedir</A></h3><DIV CLASS=programlisting><P><PRE>closedir <tt CLASS=replaceable><i>DIRHANDLE</i></tt></PRE></DIV><P CLASS=para>This function closes a directory opened by<A HREF="ch03_02.htm#PERL2-CMD-OPENDIR">opendir</A>.See the examples under<A HREF="ch03_02.htm#PERL2-CMD-OPENDIR">opendir</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CONNECT">connect</A></h3><DIV CLASS=programlisting><P><PRE>connect <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>NAME</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as the<A HREF="ch03_02.htm#PERL2-CMD-CONNECT">connect</A>system call--see<I CLASS=emphasis>connect</I> (2).The function initiates a connection with another processthat is waiting at an<I CLASS=emphasis>accept</I> (2).The function returns true if it succeeded, false otherwise (and putsthe error code into<B>$!</B>).<tt CLASS=replaceable><i>NAME</i></tt>should be a packed network address of the proper type for the socket.For example:<DIV CLASS=programlisting><P><PRE>connect S, $destadd    or die "Can't connect to $hostname: $!\n";</PRE></DIV><P CLASS=para>To disconnect a socket, either <B>close</B> or<B>shutdown</B>.See also the example in the section "Sockets" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-COS">cos</A></h3><DIV CLASS=programlisting><P><PRE>cos <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns the cosine of <tt CLASS=replaceable><i>EXPR</i></tt> (expressed in radians).  Forexample, the following script will print a cosine table of anglesmeasured in degrees:<DIV CLASS=programlisting><P><PRE># Here's the lazy way of getting degrees-to-radians.$pi = atan2(1,1) * 4;$piover180 = $pi/180;# Print table.for ($_ = 0; $_ &lt;= 90; $_++) {    printf "%3d %7.5f\n", $_, cos($_ * $piover180);}</PRE></DIV><P CLASS=para>For the inverse cosine operation, you may use the <tt CLASS=literal>POSIX::acos()</tt>function, or use this relation:<DIV CLASS=programlisting><P><PRE>sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-CRYPT">crypt</A></h3><DIV CLASS=programlisting><P><PRE>crypt <tt CLASS=replaceable><i>PLAINTEXT</i></tt>, <tt CLASS=replaceable><i>SALT</i></tt></PRE></DIV><P CLASS=para>This function encrypts a string exactly in the manner of <I CLASS=emphasis>crypt</I> (3).This is useful for checking the password file for lousy passwords.[2]Only the guys wearing white hats are allowed to do this.<blockquote class=footnote><P CLASS=para>[2] What you really want to do is prevent people from addingthe bad passwords in the first place.</blockquote><P CLASS=para>To see whether a typed-in password<tt CLASS=literal>$guess</tt>matches the password<tt CLASS=literal>$pass</tt>obtained from a file(such as<I CLASS=emphasis>/etc/passwd</I>),try something like the following:<DIV CLASS=programlisting><P><PRE>if (crypt($guess, $pass) eq $pass) {    # guess is correct}</PRE></DIV><P CLASS=para>Note that there is no easy way to decrypt an encrypted password apartfrom guessing.Also, truncating the salt to two characters is a waste of CPU time,although the manpage for<I CLASS=emphasis>crypt</I> (3)would have you believe otherwise.<P CLASS=para>Here's an example that makes sure that whoever runs this program knowstheir own password:<DIV CLASS=programlisting><P><PRE>$pwd = (getpwuid $&lt;)[1];$salt = substr $pwd, 0, 2;system "stty -echo";print "Password: ";chop($word = &lt;STDIN&gt;);print "\n";system "stty echo";if (crypt($word, $salt) ne $pwd) {    die "Sorry...\n";} else {    print "ok\n";}</PRE></DIV><P CLASS=para>Of course, typing in your own password to whoever asks for it is unwise.<P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-CRYPT">crypt</A> function is unsuitable forencrypting large quantities of data.  Find a library module for PGP (orsomething like that) for something like that.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-DBMCLOSE">dbmclose</A></h3><DIV CLASS=programlisting><P><PRE>dbmclose <tt CLASS=replaceable><i>HASH</i></tt></PRE></DIV><P CLASS=para>This function breaks the binding between a DBM file and a hash.<P CLASS=para>This function is actually just a call to <A HREF="ch03_02.htm#PERL2-CMD-UNTIE">untie</A> with the properarguments, but is provided for backward compatibility with olderversions of Perl.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-DBMOPEN">dbmopen</A></h3><DIV CLASS=programlisting><P><PRE>dbmopen <tt CLASS=replaceable><i>HASH</i></tt>, <tt CLASS=replaceable><i>DBNAME</i></tt>, <tt CLASS=replaceable><i>MODE</i></tt></PRE></DIV><P CLASS=para>This binds a DBM file to a hash (that is, an associative array).(DBM stands for Data Base Management, and consists of a set of C libraryroutines that allow random access to records via a hashing algorithm.)<tt CLASS=replaceable><i>HASH</i></tt> is the name of the hash (with a <tt CLASS=literal>%</tt>).  <tt CLASS=replaceable><i>DBNAME</i></tt>is the name of the database (without the <tt CLASS=literal>.dir</tt> or <tt CLASS=literal>.pag</tt>extension).  If the database does not exist, and a valid <tt CLASS=replaceable><i>MODE</i></tt> isspecified, the database is created with the protection specified by<tt CLASS=replaceable><i>MODE</i></tt> (as modified by the umask).  To prevent creation of the databaseif it doesn't exist, you may specify a <tt CLASS=replaceable><i>MODE</i></tt> of <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A>, and thefunction will return a false value if it can't find an existingdatabase.  If your system supports only the older DBM functions, youmay have only one <A HREF="ch03_02.htm#PERL2-CMD-DBMOPEN">dbmopen</A> in your program.<P CLASS=para>Values assigned to the hash prior to the<A HREF="ch03_02.htm#PERL2-CMD-DBMOPEN">dbmopen</A>are not accessible.<P CLASS=para>If you don't have write access to the DBM file, you can only read thehash variables, not set them.If you want to test whether you can write, either use file tests ortry setting a dummy array entry inside an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, which will trapthe error.<P CLASS=para>Note that functions such as <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> and <A HREF="ch03_02.htm#PERL2-CMD-VALUES">values</A> mayreturn huge list values when used on large DBM files.You may prefer to use the <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> function to iterate overlarge DBM files.This example prints out the mail aliases on a system using <I CLASS=emphasis>sendmail</I>:<DIV CLASS=programlisting><P><PRE>dbmopen %ALIASES, "/etc/aliases", 0666    or die "Can't open aliases: $!\n";while (($key,$val) = each %ALIASES) {    print $key, ' = ', $val, "\n";}dbmclose %ALIASES;</PRE></DIV><P CLASS=para>Hashes bound to DBM files have the same limitations as DBMfiles, in particular the restrictions on how much you can put into abucket.  If you stick to short keys and values, it's rarely a problem.Another thing you should bear in mind is that many existing DBMdatabases contain null-terminated keys and values because they wereset up with C programs in mind.  The B News history fileand the old <I CLASS=emphasis>sendmail</I> aliases file are examples.  Just use<tt CLASS=literal>"$key\0"</tt> instead of <tt CLASS=literal>$key</tt>.<P CLASS=para>There is currently no built-in way to lock generic DBM files.  Some wouldconsider this a bug.  The DB_File module does provide locking at thegranularity of the entire file, however.  See the documentation on thatmodule in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> for details.<P CLASS=para>This function is actually just a call to <A HREF="ch03_02.htm#PERL2-CMD-TIE">tie</A> with the properarguments, but is provided for backward compatibility with olderversions of Perl.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-DEFINED">defined</A></h3><DIV CLASS=programlisting><P><PRE>defined <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns a Boolean value saying whether <tt CLASS=replaceable><i>EXPR</i></tt> has a realvalue or not.  A scalar that contains no valid string, numeric, or referencevalue is known as the undefined value, or<A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> for short.Many operations return the undefined value under exceptionalconditions, such as end of file, uninitialized variable, system error,and such.  This function allows you to distinguish between anundefined null string and a defined null string when you're using operatorsthat might return a real null string.<P CLASS=para>You may also check to see whether arrays, hashes, or subroutines have beenallocated any memory yet.  Arrays and hashes are allocated when you firstput something into them, whereas subroutines are allocated when adefinition has been successfully parsed.Using <A HREF="ch03_02.htm#PERL2-CMD-DEFINED">defined</A> on the predefined special variables is notguaranteed to produce intuitive results.<P CLASS=para>Here is a fragment that tests a scalar value from a hash:<DIV CLASS=programlisting><P><PRE>print if defined $switch{'D'};</PRE></DIV><P CLASS=para>When used on a hash element like this, <A HREF="ch03_02.htm#PERL2-CMD-DEFINED">defined</A> onlytells you whether the value is defined, not whether the key hasan entry in the hash table.  It's possible to have an undefined scalar valuefor an existing hash key.  Use <A HREF="ch03_02.htm#PERL2-CMD-EXISTS">exists</A> to determinewhether the hash key exists.<P CLASS=para>In the next example we use the fact that some operations returnthe undefined value when you run out of data:<DIV CLASS=programlisting><P><PRE>print "$val\n" while defined($val = pop(@ary));</PRE></DIV><P CLASS=para>The same thing goes for error returns from system calls:<DIV CLASS=programlisting><P><PRE>die "Can't readlink $sym: $!"    unless defined($value = readlink $sym);</PRE></DIV><P CLASS=para>Since symbol tables for packages are stored as hashes (associative arrays),it's possible to check for the existence of a package like this:<DIV CLASS=programlisting><P><PRE>die "No XYZ package defined" unless defined %XYZ::;</PRE></DIV><P CLASS=para>Finally, it's possible to avoid blowing up on nonexistent subroutines:<DIV CLASS=programlisting><P><PRE>sub saymaybe {   if (defined &amp;say) {       say(@_);   }   else {       warn "Can't say";   }}</PRE></DIV><P CLASS=para>See also <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-DELETE">delete</A></h3><DIV CLASS=programlisting><P><PRE>delete <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function deletes the specified key and associated value from the specified hash.(It doesn't delete a file.  See <A HREF="ch03_02.htm#PERL2-CMD-UNLINK">unlink</A> for that.)Deleting from<tt CLASS=literal>$ENV{}</tt>modifies the environment.Deleting from a hash that is bound to a (writable) DBM file deletes the entryfrom the DBM file.<P CLASS=para>The following na&iuml;veexample inefficiently deletes all the values of a hash:<DIV CLASS=programlisting><P><PRE>foreach $key (keys %HASH) {    delete $HASH{$key};}</PRE></DIV><P CLASS=para>(It would be faster to use the <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> command.)<tt CLASS=replaceable><i>EXPR</i></tt> can be arbitrarily complicated as long as the finaloperation is a hash key lookup:<DIV CLASS=programlisting><P><PRE>delete $ref-&gt;[$x][$y]{$key};</PRE></DIV><P CLASS=para>For normal hashes, the <B>delete</B> function happensto return the value (not the key) that was deleted, but this behavior isnot guaranteed for tied hashes, such as those bound to DBM files.<P CLASS=para>To test whether a hash element has been deleted, use <A HREF="ch03_02.htm#PERL2-CMD-EXISTS">exists</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-DIE">die</A></h3><DIV CLASS=programlisting><P><PRE>die <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>Outside of an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, this function prints the concatenated valueof <tt CLASS=replaceable><i>LIST</i></tt> to <tt CLASS=literal>STDERR</tt> and exits with the current value of <B>$!</B>(<tt CLASS=literal>errno</tt>).If <B>$!</B> is 0, it exits with the value of <tt CLASS=literal>($? &gt;&gt; 8)</tt>(which is the status of the last reaped child from a <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A>, <A HREF="ch03_02.htm#PERL2-CMD-WAIT">wait</A>, <A HREF="ch03_02.htm#PERL2-CMD-CLOSE">close</A> on a pipe, or `command`).If <tt CLASS=literal>($? &gt;&gt; 8)</tt> is 0, it exits with 255.  If <tt CLASS=replaceable><i>LIST</i></tt> is unspecified,the current value of the <tt CLASS=literal>$@</tt> variable is propagated, if any.Otherwise the string <tt CLASS=literal>"Died"</tt> is used as the default.<P CLASS=para>Equivalent examples:<DIV CLASS=programlisting><P><PRE>die "Can't cd to spool: $!\n" unless chdir '/usr/spool/news';chdir '/usr/spool/news' or die "Can't cd to spool: $!\n"</PRE></DIV><P CLASS=para>(The second form is generally preferred, since the important part isthe <A HREF="ch03_02.htm#PERL2-CMD-CHDIR">chdir</A>.)<P CLASS=para>Within an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, the function sets the<B>$@</B> variable equal to the error message that wouldhave been produced otherwise, and aborts the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, which then returns the undefined value.  The <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> function can thus be used to raise namedexceptions that can be caught at a higher level in the program.  See the sectionon the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> function later in this chapter.<P CLASS=para>If the final value of <tt CLASS=replaceable><i>LIST</i></tt> does not end in a newline, the currentscript filename, line number, and input line number (if any) areappended to the message, as well as a newline.  Hint: sometimesappending <tt CLASS=literal>`, stopped"</tt> to your message will cause it tomake better sense when the string <tt CLASS=literal>"at scriptname line 123"</tt> isappended.  Suppose you are running script <I CLASS=emphasis>canasta</I>:<DIV CLASS=programlisting><P><PRE>die "/etc/games is no good";die "/etc/games is no good, stopped";</PRE></DIV><P CLASS=para>which produces, respectively:<DIV CLASS=programlisting><P><PRE>/etc/games is no good at canasta line 123./etc/games is no good, stopped at canasta line 123.</PRE></DIV><P CLASS=para>If you want your own error messages reporting the filename and linenumber, usethe <tt CLASS=literal>_  _FILE_  _</tt> and<tt CLASS=literal>_  _LINE_  _</tt> special tokens:<DIV CLASS=programlisting><P><PRE>die '"', _  _FILE_  _, '", line ', _  _LINE_  _, ", phooey on you!\n";</PRE></DIV><P CLASS=para>This produces output like:<DIV CLASS=programlisting><P><PRE>"canasta", line 38, phooey on you!</PRE></DIV><P CLASS=para>See also <A HREF="ch03_02.htm#PERL2-CMD-EXIT">exit</A> and <A HREF="ch03_02.htm#PERL2-CMD-WARN">warn</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-DO">do</A></h3><DIV CLASS=programlisting><P><PRE>do <tt CLASS=replaceable><i>BLOCK</i></tt>do <tt CLASS=replaceable><i>SUBROUTINE</i></tt>(<tt CLASS=replaceable><i>LIST</i></tt>)do <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>The <tt CLASS=literal>do</tt> <tt CLASS=replaceable><i>BLOCK</i></tt> form executes thesequence of commands in the <tt CLASS=replaceable><i>BLOCK</i></tt>, and returns the value of the lastexpression evaluated in the block.  When modified by a loop modifier, Perlexecutes the <tt CLASS=replaceable><i>BLOCK</i></tt> once before testing the loopcondition.  (On other statements the loop modifiers test theconditional first.)  <P CLASS=para>The <tt CLASS=literal>do</tt><tt CLASS=replaceable><i>SUBROUTINE</i></tt><tt CLASS=literal>(</tt><tt CLASS=replaceable><i>LIST</i></tt><tt CLASS=literal>)</tt>is a deprecated form of a subroutinecall.  See "Subroutines" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.<P CLASS=para>The<tt CLASS=literal>do</tt> <tt CLASS=replaceable><i>EXPR</i></tt>,form uses the value of<tt CLASS=replaceable><i>EXPR</i></tt>as a filename and executes the contents of the fileas a Perl script.Its primary use is (or rather was) to include subroutines from aPerl subroutine library, so that:<DIV CLASS=programlisting><P><PRE>do 'stat.pl';</PRE></DIV><P CLASS=para>is rather like:<DIV CLASS=programlisting><P><PRE>eval `cat stat.pl`;</PRE></DIV><P CLASS=para>except that it's more efficient, more concise, keeps track of the currentfilename for error messages, and searches all the directories listedin the <B>@INC</B> array.(See the section on "Special Variables" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.)It's the same, however, in that it does reparse the file every timeyou call it, so you probably don't want to do this inside a loop.<P CLASS=para>Note that inclusion of library modules is better done with the<A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> and <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> operators, which also do error checkingand raise an exception if there's a problem.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-DUMP">dump</A></h3><DIV CLASS=programlisting><P><PRE>dump <tt CLASS=replaceable><i>LABEL</i></tt>dump</PRE></DIV><P CLASS=para>This function causes an immediate core dump.Primarily this is so that you can use <I CLASS=emphasis>undump</I> (1) to turnyour core dump into an executable binary after having initialized allyour variables at the beginning of the program.(The <I CLASS=emphasis>undump</I> program is not supplied with the Perl distribution,and is not even possible on some architectures.  There are hooks inthe code for using the GNU <tt CLASS=literal>unexec()</tt> routine as an alternative.Other methods may be supported in the future.)  When the new binary isexecuted it will begin by executing a <tt CLASS=literal>goto LABEL</tt> (with all therestrictions that <A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A> suffers).  Think of the operation as a<A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A>with an intervening core dump and reincarnation.If <tt CLASS=replaceable><i>LABEL</i></tt> is omitted, the function arranges for the program to restartfrom the top.  Please note that any files opened at the time of thedump will not be open any more when the program is reincarnated,with possible confusion resulting on the part of Perl.  See also the<B>-u</B> command-line switch.For example:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perluse Getopt::Std;use MyHorridModule;%days = (    Sun =&gt; 1,    Mon =&gt; 2,    Tue =&gt; 3,    Wed =&gt; 4,    Thu =&gt; 5,    Fri =&gt; 6,    Sat =&gt; 7,);dump QUICKSTART if $ARGV[0] eq '-d';QUICKSTART:Getopts('f:');...</PRE></DIV><P CLASS=para>This startup code does some slow initialization code, and then callsthe <A HREF="ch03_02.htm#PERL2-CMD-DUMP">dump</A> function to take a snapshot of the program's state.When the dumped version of the program is run, it bypasses all thestartup code and goes directly to the <tt CLASS=literal>QUICKSTART</tt> label.  If theoriginal script is invoked without the <B>-d</B> switch, it just fallsthrough and runs normally.<P CLASS=para>If you're looking to use <A HREF="ch03_02.htm#PERL2-CMD-DUMP">dump</A> tospeed up your program, check out the discussion of efficiency matters in<A HREF="ch08_01.htm">Chapter 8, <i>Other Oddments</i></A>, as well thePerl native-code compiler in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.  You might also consider autoloading, which at least makes it <I CLASS=emphasis>appear</I> to run faster.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-EACH">each</A></h3><DIV CLASS=programlisting><P><PRE>each <tt CLASS=replaceable><i>HASH</i></tt></PRE></DIV><P CLASS=para>This function returns a two-element list consisting of the key andvalue for the next value of a hash.  With successivecalls to <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> you can iterate over the entire hash.Entries are returned in an apparently random order.  When the hash isentirely read, a null list is returned (which, when used in a list assignment,produces a false value).  The next call to <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> after thatwill start a new iteration.  The iterator can be reset either by readingall the elements from the hash, or by calling the <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> function inscalar context.  You must not add elements to thehash while iterating over it, although you are permitted to use<A HREF="ch03_02.htm#PERL2-CMD-DELETE">delete</A>.  In a scalar context, <B>each</B> returns just the key, but watch out forfalse keys.<P CLASS=para>There is a single iterator for each hash, shared by all<A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A>, <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A>, and <A HREF="ch03_02.htm#PERL2-CMD-VALUES">values</A> function calls inthe program.  This means that after a <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> or <A HREF="ch03_02.htm#PERL2-CMD-VALUES">values</A> call, thenext <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> call will start again from the beginning.The following example prints out your environment likethe <I CLASS=emphasis>printenv</I> (1) program, only in a different order:<DIV CLASS=programlisting><P><PRE>while (($key,$value) = each %ENV) {    print "$key=$value\n";}</PRE></DIV><P CLASS=para>See also <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> and <A HREF="ch03_02.htm#PERL2-CMD-VALUES">values</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-EOF">eof</A></h3><DIV CLASS=programlisting><P><PRE>eof <tt CLASS=replaceable><i>FILEHANDLE</i></tt>eof()eof</PRE></DIV><P CLASS=para>This function returns true if the next read on <tt CLASS=replaceable><i>FILEHANDLE</i></tt> will returnend of file, or if <tt CLASS=replaceable><i>FILEHANDLE</i></tt> is not open.<tt CLASS=replaceable><i>FILEHANDLE</i></tt> may be an expression whose value gives the real filehandlename.An <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A> without an argument returns the end-of-filestatus for the last file read.Empty parentheses <tt CLASS=literal>()</tt> may be used in connection with thecombined files listed on the command line.  That is, inside a<tt CLASS=literal>while (&lt;&gt;)</tt> loop <tt CLASS=literal>eof()</tt> will detect theend of only the last of a group of files.Use <tt CLASS=literal>eof(ARGV)</tt> or <tt CLASS=literal>eof</tt> (without the parentheses) to test<I CLASS=emphasis>each</I> file in a <tt CLASS=literal>while (&lt;&gt;)</tt> loop.  For example, thefollowing code inserts dashes just before the last line ofthe <I CLASS=emphasis>last</I>file:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    if (eof()) {        print "-" x 30, "\n";    }    print;}</PRE></DIV><P CLASS=para>On the other hand, this script resets line numbering on <I CLASS=emphasis>each</I>input file:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    print "$.\t$_";    if (eof) {       # Not eof().        close ARGV;  # reset $.    }}</PRE></DIV><P CLASS=para>Like "<tt CLASS=literal>$</tt>" in a <I CLASS=emphasis>sed</I> program, <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A> tends to show up inline number ranges.  Here's a script that prints lines from<tt CLASS=literal>/pattern/</tt> to end of each input file:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    print if /pattern/ .. eof;}</PRE></DIV><P CLASS=para>Here, the flip-flop operator (<tt CLASS=literal>..</tt>) evaluates the regular expressionmatch for each line.  Until the pattern matches, the operator returnsfalse.  When it finally matches, the operator starts returning true,causing the lines to be printed.  When the <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A> operator finallyreturns true (at the end of the file being examined), the flip-flopoperator resets, and starts returning false again.<P CLASS=para>Note that the <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A> function actually reads a byte and thenpushes it back on the input stream with<I CLASS=emphasis>ungetc</I> (3), so it is not very useful in an interactive context.In fact, experienced Perl programmers rarely use <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A>, since the variousinput operators already behave quite nicely in <B>while</B>-loop conditionals.See the example in the description of <B>foreach</B> in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-EVAL">eval</A></h3><DIV CLASS=programlisting><P><PRE>eval <tt CLASS=replaceable><i>EXPR</i></tt>eval <tt CLASS=replaceable><i>BLOCK</i></tt></PRE></DIV><P CLASS=para><A NAME="CH03.EVAL"></A>The value expressed by <tt CLASS=replaceable><i>EXPR</i></tt> is parsed and executed as though it were alittle Perl program.  It is executed in the context of the currentPerl program, so that any variable settings remain afterward, as doany subroutine or format definitions.  The code of the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> is treated as ablock, so any locally scoped variables declared within the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> lastonly until the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> is done.(See <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> and <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>.)As with any code in a block, a final semicolon is not required.If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, the operator evaluates <B>$_</B>.<P CLASS=para>The value returned from an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> is the value of the last expression evaluated, justas with subroutines.  Similarly, you may use the <A HREF="ch03_02.htm#PERL2-CMD-RETURN">return</A> operator toreturn a value from the middle of the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>.If there is a syntax error or run-time error(including any produced by the <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> operator), <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> returnsthe undefined value and puts the error message in <B>$@</B>.If there is no error, <B>$@</B> is guaranteed to be set to the nullstring, so you can test it reliably afterward for errors.<P CLASS=para>Here's a statement thatassigns an element to a hash chosen at run-time:<DIV CLASS=programlisting><P><PRE>eval "\$$arrayname{\$key} = 1";</PRE></DIV><P CLASS=para>(You can accomplish that more simply with soft references--see"Symbolic References" in <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>.)And here is a simple Perl shell:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) { eval; print $@; }</PRE></DIV><P CLASS=para>Since <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> traps otherwise-fatal errors, it is usefulfor determining whether a particular feature (such as <A HREF="ch03_02.htm#PERL2-CMD-SOCKET">socket</A> or<A HREF="ch03_02.htm#PERL2-CMD-SYMLINK">symlink</A>) is implemented.In fact, <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> is the way to do allexception handling in Perl. If the code to be executed doesn't vary,you should use the<tt CLASS=literal>eval</tt> <tt CLASS=replaceable><i>BLOCK</i></tt> form to traprun-time errors; the code in the block iscompiled only once rather than on each execution, yielding greaterefficiency.  The error, if any, is stillreturned in <B>$@</B>.  Examples:<DIV CLASS=programlisting><P><PRE># make divide-by-zero non-fataleval { $answer = $a / $b; }; warn $@ if $@;# same thing, but less efficienteval '$answer = $a / $b'; warn $@ if $@;# a compile-time error (not trapped)eval { $answer = };# a run-time erroreval '$answer =';  # sets $@</PRE></DIV><P CLASS=para>Here, the code in the <tt CLASS=replaceable><i>BLOCK</i></tt> has to be valid Perl codeto make it past the compilation phase.  The code in the string doesn't getexamined until run-time, and so doesn't cause an error until run-time.<P CLASS=para>With an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> you should be carefulto remember what's being looked at when:<DIV CLASS=programlisting><P><PRE>eval $x;          # CASE 1eval "$x";        # CASE 2eval '$x';        # CASE 3eval { $x };      # CASE 4eval "\$$x++";    # CASE 5$$x++;            # CASE 6</PRE></DIV><P CLASS=para>Cases 1 and 2 above behave identically: they run the code contained inthe variable <tt CLASS=literal>$x</tt>.  (Case 2 has misleading double quotes,making the reader wonder what else might be happening, when nothing is.The contents of <tt CLASS=literal>$x</tt> would in any event have to be converted toa string for parsing.)Cases 3 and 4 likewise behave in the same way: they run the code<tt CLASS=literal>$x</tt>, which does nothing at all except return the value of <tt CLASS=literal>$x</tt>.(Case 4 is preferred since the expression doesn't need to recompiled each time.)Case 5 is a place where normally you <I CLASS=emphasis>would</I> like to use double quotesto let you interpolate the variable name, except that in this particularsituation you can just use symbolic references instead, as in case 6.<P CLASS=para>A frequently asked question is how to set up an exit routine.One common way is to use an <tt CLASS=literal>END</tt> block.But you can also do it with an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, like this:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perleval &lt;&lt;'EndOfEval';  $start = __LINE__;   .   .           # your ad here   .EndOfEval# Cleanupunlink "/tmp/myfile$$";$@ &amp;&amp; ($@ =~ s/\(eval \d+\) at line (\d+)/$0 .    " line " . ($1+$start)/e, die $@);exit 0;</PRE></DIV><P CLASS=para>Note that the code supplied for an <B>eval</B> might notbe recompiled if the text hasn't changed.  On the rare occasions when you wantto force a recompilation (because you want to reset a <tt CLASS=literal>..</tt> operator, for instance), you could say something likethis:<DIV CLASS=programlisting><P><PRE>eval $prog . '#' . ++$seq;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-EXEC">exec</A></h3><DIV CLASS=programlisting><P><PRE>exec <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function terminates the currently running Perl script byexecuting another program in place of itself.  If there is more thanone argument in <tt CLASS=replaceable><i>LIST</i></tt> (or if <tt CLASS=replaceable><i>LIST</i></tt>is an array with more than one value)the function calls C's <I CLASS=emphasis>execvp</I> (3) routine with the arguments in<tt CLASS=replaceable><i>LIST</i></tt>.  This bypasses any shell processing of the command.If there is only one scalar argument, the argument is checkedfor shell metacharacters.  If metacharacters are found, the entire argument ispassed to "<tt CLASS=literal>/bin/sh -c</tt>" for parsing.[3]If there are no metacharacters, the argument is split into words and passeddirectly to <I CLASS=emphasis>execvp</I> (3) in the interests of efficiency, sincethis bypasses all the overhead of shell processing.Ordinarily <A HREF="ch03_02.htm#PERL2-CMD-EXEC">exec</A> never returns--if it does return, it alwaysreturns false, and you should check <B>$!</B> to find out what wentwrong.Note that <A HREF="ch03_02.htm#PERL2-CMD-EXEC">exec</A> (and <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A>) do not flush your outputbuffer, so you may need to enable command buffering by setting<B>$|</B> on one or more filehandles to avoid lost output.This statement runs the <I CLASS=emphasis>echo</I> program to print the current argument list:<blockquote class=footnote><P CLASS=para>[3] Under UNIX, that is.  Other operating systems may use other command interpreters.</blockquote><DIV CLASS=programlisting><P><PRE>exec 'echo', 'Your arguments are: ', @ARGV;</PRE></DIV><P CLASS=para>This example shows that you can <A HREF="ch03_02.htm#PERL2-CMD-EXEC">exec</A> a pipeline:<DIV CLASS=programlisting><P><PRE>exec "sort $outfile | uniq"  or die "Can't do sort/uniq: $!\n";</PRE></DIV><P CLASS=para>The UNIX <I CLASS=emphasis>execv</I> (3) call provides the ability to tell aprogram the name it was invoked as.  This name might have nothing todo with the name of the program you actually gave the operating systemto run.  By default, Perl simply replicates the first element of <tt CLASS=replaceable><i>LIST</i></tt>and uses it for both purposes.  If, however, you don't really want toexecute the first argument of <tt CLASS=replaceable><i>LIST</i></tt>, but you want to lie to the programyou are executing about its own name, you can do so.Put the real name of the programyou want to run into a variable andthen put that variable out in front of the <tt CLASS=replaceable><i>LIST</i></tt> <I CLASS=emphasis>without</I> a comma,kind of like a filehandle for a <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> statement.  (This alwaysforces interpretation of the <tt CLASS=replaceable><i>LIST</i></tt> as a multi-valued list, even ifthere is only a single scalar in the list.)  Then the first element of<tt CLASS=replaceable><i>LIST</i></tt> will be used only to mislead the executing program as to itsname.  For example:<DIV CLASS=programlisting><P><PRE>$shell = '/bin/csh';exec $shell '-sh', @args;      # pretend it's a login shelldie "Couldn't execute csh: $!\n";</PRE></DIV><P CLASS=para>You can also replace the simple scalar holding the program name with ablock containing arbitrary code, which simplifies the above exampleto:<DIV CLASS=programlisting><P><PRE>exec {'/bin/csh'} '-sh', @args; # pretend it's a login shell</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-EXISTS">exists</A></h3><DIV CLASS=programlisting><P><PRE>exists <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns true if the specified hash key exists in its hash, evenif the corresponding value is undefined.<DIV CLASS=programlisting><P><PRE>print "Exists\n" if exists $hash{$key};print "Defined\n" if defined $hash{$key};print "True\n" if $hash{$key};</PRE></DIV><P CLASS=para>A hash element can only be true if it's defined, and can only be defined ifit exists, but the reverse doesn't necessarily hold true in either case.<P CLASS=para><tt CLASS=replaceable><i>EXPR</i></tt> can be arbitrarily complicated as long as the finaloperation is a hash key lookup:<DIV CLASS=programlisting><P><PRE>if (exists $ref-&gt;[$x][$y]{$key}) { ... }</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-EXIT">exit</A></h3><DIV CLASS=programlisting><P><PRE>exit <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function evaluates <tt CLASS=replaceable><i>EXPR</i></tt> and exits immediately with that value.Here's a fragment that lets a user exit the program by typing <tt CLASS=literal>x</tt>or <tt CLASS=literal>X</tt>:<DIV CLASS=programlisting><P><PRE>$ans = &lt;STDIN&gt;;exit 0 if $ans =~ /^[Xx]/;</PRE></DIV><P CLASS=para>If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, the function exits with 0 status.  You shouldn'tuse <A HREF="ch03_02.htm#PERL2-CMD-EXIT">exit</A> to abort a subroutine if there's any chance thatsomeone might want to trap whatever error happened.  Use <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A>instead, which can be trapped by an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-EXP">exp</A></h3><DIV CLASS=programlisting><P><PRE>exp <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns <I CLASS=emphasis>e</I> to the power of<tt CLASS=replaceable><i>EXPR</i></tt>.  If <tt CLASS=replaceable><i>EXPR</i></tt> isomitted, it gives <tt CLASS=literal>exp($_)</tt>.To do general exponentiation, use the <tt CLASS=literal>**</tt> operator.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-FCNTL">fcntl</A></h3><DIV CLASS=programlisting><P><PRE>fcntl <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>FUNCTION</i></tt>, <tt CLASS=replaceable><i>SCALAR</i></tt></PRE></DIV><P CLASS=para>This function calls UNIX's <I CLASS=emphasis>fcntl</I> (2) function.(<I CLASS=emphasis>fcntl</I> stands for "file control".)You'll probably have to say:<DIV CLASS=programlisting><P><PRE>use Fcntl;</PRE></DIV><P CLASS=para>first to get the correct function definitions.<tt CLASS=replaceable><i>SCALAR</i></tt> will be read and/or written depending on the<tt CLASS=replaceable><i>FUNCTION</i></tt>--a pointer to the string value of<tt CLASS=replaceable><i>SCALAR</i></tt> will be passed as the third argument of theactual <I CLASS=emphasis>fcntl</I> call.  (If <tt CLASS=replaceable><i>SCALAR</i></tt>has no string value but does have a numeric value, that value will be passeddirectly rather than a pointer to the string value.)<P CLASS=para>The return value of <A HREF="ch03_02.htm#PERL2-CMD-FCNTL">fcntl</A> (and <A HREF="ch03_02.htm#PERL2-CMD-IOCTL">ioctl</A>) is as follows:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-3-TAB-1"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">System call returns</TH><TH ALIGN="left">Perl returns</TH></TR><TR CLASS=row><TD ALIGN="left">-1</TD><TD ALIGN="left">undefined value</TD></TR><TR CLASS=row><TD ALIGN="left">0</TD><TD ALIGN="left">string "<tt CLASS=literal>0 but true</tt>"</TD></TR><TR CLASS=row><TD ALIGN="left">anything else</TD><TD ALIGN="left">that number</TD></TR></TABLE><P></DIV><P CLASS=para>Thus Perl returns true on success and false on failure, yet you can stilleasily determine the actual value returned by the operating system:<DIV CLASS=programlisting><P><PRE>$retval = fcntl(...) or $retval = -1;printf "System returned %d\n", $retval;</PRE></DIV><P CLASS=para>Here, even the string "<tt CLASS=literal>0 but true</tt>" prints as 0, thanks to the<tt CLASS=literal>%d</tt> format.<P CLASS=para>For example, since Perl always sets the close-on-exec flag for filedescriptors above 2, if you wanted to pass file descriptor 3 to asubprocess, you might want to clear the flag like this:<DIV CLASS=programlisting><P><PRE>use Fcntl;open TTY,"+&gt;/dev/tty" or die "Can't open /dev/tty: $!\n";fileno TTY == 3 or die "Internal error: fd mixup";fcntl TTY, &amp;F_SETFL, 0    or die "Can't clear the close-on-exec flag: $!\n";</PRE></DIV><P CLASS=para><A HREF="ch03_02.htm#PERL2-CMD-FCNTL">fcntl</A> will produce a fatal error if used on a machinethat doesn't implement <I CLASS=emphasis>fcntl</I> (2).  On machines that do implementit, you can do such things as modify the close-on-exec flags, modifythe non-blocking I/O flags, emulate the <I CLASS=emphasis>lockf</I> (3) function, andarrange to receive the <tt CLASS=literal>SIGIO</tt> signal when I/O is pending.  Youmight even have record-locking facilities.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-FILENO">fileno</A></h3><DIV CLASS=programlisting><P><PRE>fileno <tt CLASS=replaceable><i>FILEHANDLE</i></tt></PRE></DIV><P CLASS=para>This function returns the file descriptor for a filehandle.(A <I CLASS=emphasis>file descriptor</I> is a small integer, unlike the filehandle, whichis a symbol.)  It returns <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> if the handle is not open.It's useful for constructing bitmaps for <B>select</B>, and forpassing to certain obscure system calls if <I CLASS=emphasis>syscall</I> (2) isimplemented.It's also useful for double-checking that the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> functiongave you the file descriptor you wanted--see the example under<A HREF="ch03_02.htm#PERL2-CMD-FCNTL">fcntl</A>.<P CLASS=para>If <tt CLASS=replaceable><i>FILEHANDLE</i></tt> is an expression, its value is takento represent a filehandle, either indirectly by name, or directlyas a reference to a filehandle object.<P CLASS=para>A caution: don't count on the association of a Perl filehandle and anumeric file descriptor throughout the life of the program.  If a filehas been closed and reopened, the file descriptor may change.Filehandles <tt CLASS=literal>STDIN</tt>, <tt CLASS=literal>STDOUT</tt>, and <tt CLASS=literal>STDERR</tt> start withfile descriptors of 0, 1, and 2 (the UNIX standard convention),but even they can change if you start closing and opening them withwild abandon.But you can't get into trouble with 0, 1, and 2 as long as you alwaysreopen immediately after closing, since the basic rule on UNIXsystems is to pick the lowest available descriptor, and that'll be theone you just closed.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-FLOCK">flock</A></h3><DIV CLASS=programlisting><P><PRE>flock <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>OPERATION</i></tt></PRE></DIV><P CLASS=para>This function calls <I CLASS=emphasis>flock</I> (2) on <tt CLASS=replaceable><i>FILEHANDLE</i></tt>.See the manual page for <I CLASS=emphasis>flock</I> (2) for the definition of <tt CLASS=replaceable><i>OPERATION</i></tt>.Invoking <A HREF="ch03_02.htm#PERL2-CMD-FLOCK">flock</A> will produce a fatal error if used on a machinethat doesn't implement <I CLASS=emphasis>flock</I> (2) or emulate it through some otherlocking mechanism.  Here's a mailbox appender for some BSD-based systems:<DIV CLASS=programlisting><P><PRE>$LOCK_SH = 1;$LOCK_EX = 2;$LOCK_NB = 4;$LOCK_UN = 8;sub lock {    flock MBOX, $LOCK_EX;    # and, in case someone appended    # while we were waiting...    seek MBOX, 0, 2;}sub unlock {    flock MBOX, $LOCK_UN;}open MBOX, "&gt;&gt;/usr/spool/mail/$ENV{'USER'}"    or die "Can't open mailbox: $!";lock();print MBOX $msg, "\n\n";unlock();</PRE></DIV><P CLASS=para>Note that <A HREF="ch03_02.htm#PERL2-CMD-FLOCK">flock</A> is unlikely to work on a file being accessedthrough a network file system.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-FORK">fork</A></h3><DIV CLASS=programlisting><P><PRE>fork</PRE></DIV><P CLASS=para>This function does a <I CLASS=emphasis>fork</I> (2) call.  If it succeeds, thefunction returns the child pid to the parent process and 0 to thechild process.  (If it fails, it returns the undefined value to theparent process. There is no child process.)Note that unflushed buffers remain unflushed in bothprocesses, which means you may need to set <B>$|</B> on one or morefilehandles earlier in the program to avoid duplicate output.<P CLASS=para>A nearly bulletproof way to launch a child process while checking for"cannot fork" errors would be:<DIV CLASS=programlisting><P><PRE>FORK: {    if ($pid = fork) {        # parent here        # child process pid is available in $pid    } elsif (defined $pid) { # $pid is zero here if defined        # child here        # parent process pid is available with getppid    } elsif ($! =~ /No more process/) {             # EAGAIN, supposedly recoverable fork error        sleep 5;        redo FORK;    } else {        # weird fork error        die "Can't fork: $!\n";    }}</PRE></DIV><P CLASS=para>These precautions are not necessary on operations which do an implicit<I CLASS=emphasis>fork</I> (2), such as <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A>, backquotes, or opening a processas a filehandle, because Perl automatically retries a fork on a temporaryfailure in these cases.Be very careful to end the child code with an<A HREF="ch03_02.htm#PERL2-CMD-EXIT">exit</A>, or your child may inadvertently leave the conditional andstart executing code intended only for the parent process.<P CLASS=para>If you <A HREF="ch03_02.htm#PERL2-CMD-FORK">fork</A> your child processes, you'll have to <A HREF="ch03_02.htm#PERL2-CMD-WAIT">wait</A> on theirzombies when they die.  See the <A HREF="ch03_02.htm#PERL2-CMD-WAIT">wait</A> function for examples ofdoing this.<P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-FORK">fork</A> function is unlikely to be implemented on any operating systemnot resembling UNIX, unless it purports POSIX compliance.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-FORMAT">format</A></h3><DIV CLASS=programlisting><P><PRE>format <tt CLASS=replaceable><i>NAME</i></tt> =    <tt CLASS=replaceable><i>picture line</i></tt>    <tt CLASS=replaceable><i>value list</i></tt>    ....</PRE></DIV><P CLASS=para>Declares a named sequence of picture lines (with associated values) foruse by the <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> function.  If <tt CLASS=replaceable><i>NAME</i></tt> is omitted, the namedefaults to <tt CLASS=literal>STDOUT,</tt> which happens to be the default format name for the<tt CLASS=literal>STDOUT</tt> filehandle.  Since, like a <A HREF="ch03_02.htm#PERL2-CMD-SUB">sub</A> declaration, this is aglobal declaration that happens at compile time, any variables usedin the value list need to be visible at the point of the format'sdeclaration.  That is, lexically scoped variables must be declaredearlier in the file, while dynamically scoped variables merely need tobe set in the routine that calls <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A>.  Here's an example (whichassumes we've already calculated <tt CLASS=literal>$cost</tt> and <tt CLASS=literal>$quantity</tt>:<DIV CLASS=programlisting><P><PRE>my $str = "widget";               # A lexically scoped variable.format Nice_Output =Test: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;      $str,     $%,    '$' . int($num).$~ = "Nice_Output";               # Select our format.local $num = $cost * $quantity;   # Dynamically scoped variable.write;</PRE></DIV><P CLASS=para>Like filehandles, format names are identifiers that exist in a symbol table(package) and may be fully qualified by package name.  Within the typeglobs of asymbol table's entries, formats reside in their own namespace, which is distinctfrom filehandles, directory handles, scalars, arrays, hashes, or subroutines.Like those other six types, however, a format named <tt CLASS=literal>Whatever</tt>would also be affected by a <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> on the<tt CLASS=literal>*Whatever</tt> typeglob.  In other words, a format is just anothergadget contained in a typeglob, independent of the other gadgets.<P CLASS=para>The "Formats" section in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A> contains numerous detailsand examples of their use.  The "Per Filehandle Special Variables" and "GlobalSpecial Variables" sections in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A> describe the internalformat-specific variables, and the English and FileHandle modules in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> provide easier access to them.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-FORMLINE">formline</A></h3><DIV CLASS=programlisting><P><PRE>formline <tt CLASS=replaceable><i>PICTURE</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This is an internal function used by formats, although you mayalso call it.  It formats alist of values according to the contents of <tt CLASS=replaceable><i>PICTURE</i></tt>, placing theoutput into the format output accumulator, <B>$^A</B>.  Eventually,when a <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> is done, the contents of <B>$^A</B> are written tosome filehandle, but you could also read <B>$^A</B> yourself and thenset <B>$^A</B> back to <tt CLASS=literal>""</tt>.  Note that a format typically doesone <A HREF="ch03_02.htm#PERL2-CMD-FORMLINE">formline</A> per line of form, but the <A HREF="ch03_02.htm#PERL2-CMD-FORMLINE">formline</A> functionitself doesn't care how many newlines are embedded in the <tt CLASS=replaceable><i>PICTURE</i></tt>.This means that the <tt CLASS=literal>~</tt> and <tt CLASS=literal>~~</tt> tokens will treat theentire <tt CLASS=replaceable><i>PICTURE</i></tt> as a single line.  You may therefore need to usemultiple formlines to implement a single record-format, just like theformat compiler.<P CLASS=para>Be careful if you put double quotes around the picture, since an <tt CLASS=literal>@</tt>character may be taken to mean the beginning of an array name.<A HREF="ch03_02.htm#PERL2-CMD-FORMLINE">formline</A> always returns true.See "Formats" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A> for other examples.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETC">getc</A></h3><DIV CLASS=programlisting><P><PRE>getc <tt CLASS=replaceable><i>FILEHANDLE</i></tt>getc</PRE></DIV><P CLASS=para>This function returns the next byte from the input file attachedto <tt CLASS=replaceable><i>FILEHANDLE</i></tt>.  At end-of-file, it returns a null string.  If<tt CLASS=replaceable><i>FILEHANDLE</i></tt> isomitted, the function reads from <tt CLASS=literal>STDIN</tt>.  This operator isvery slow, but is occasionally useful for single-character,buffered input from the keyboard.  This does <I CLASS=emphasis>not</I> enable single-characterinput.  For unbuffered input, you haveto be slightly more clever, in an operating-system-dependent fashion.Under UNIX you might say this:<DIV CLASS=programlisting><P><PRE>if ($BSD_STYLE) {  system "stty cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1";} else {  system "stty", "-icanon", "eol", "\001";}$key = getc;if ($BSD_STYLE) {  system "stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1";} else {  system "stty", "icanon", "eol", "^@"; # ASCII NUL}print "\n";</PRE></DIV><P CLASS=para>This code puts the next character typed on the terminal in the string<tt CLASS=literal>$key</tt>.  If your <I CLASS=emphasis>stty</I> program has options like <tt CLASS=literal>cbreak</tt>,you'll need to use the code where <tt CLASS=literal>$BSD_STYLE</tt> is true,otherwise, you'll need to use the code where it is false.  Determiningthe options for <I CLASS=emphasis>stty</I> is left as an exercise to the reader.<P CLASS=para>The POSIX module in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> provides a more portable version ofthis using the <tt CLASS=literal>POSIX::getattr()</tt> function.See also the TERM::ReadKey module from your nearest CPAN site.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETGRENT">getgrent</A></h3><DIV CLASS=programlisting><P><PRE>getgrentsetgrentendgrent</PRE></DIV><P CLASS=para>These functions do the same thing as their like-named system libraryroutines--see <I CLASS=emphasis>getgrent</I> (3).  These routines iterate through your<I CLASS=emphasis>/etc/group</I> file (or its moral equivalent coming from some serversomewhere).  The return value from <A HREF="ch03_02.htm#PERL2-CMD-GETGRENT">getgrent</A>in list context is:<DIV CLASS=programlisting><P><PRE>($name, $passwd, $gid, $members)</PRE></DIV><P CLASS=para>where<tt CLASS=literal>$members</tt>contains a space-separated list of the login names of the members of the group.To set up a hash for translating group names to gids,say this:<DIV CLASS=programlisting><P><PRE>while (($name, $passwd, $gid) = getgrent) {    $gid{$name} = $gid;}</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETGRENT">getgrent</A> returns only the group name.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETGRGID">getgrgid</A></h3><DIV CLASS=programlisting><P><PRE>getgrgid <tt CLASS=replaceable><i>GID</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as<I CLASS=emphasis>getgrgid</I> (3):  it looksup a group file entry by group number.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $passwd, $gid, $members)</PRE></DIV><P CLASS=para>where<tt CLASS=literal>$members</tt>contains a space-separated list of the login names of the members of the group.If you want to do this repeatedly, consider caching the data in a hash(associative array) using<A HREF="ch03_02.htm#PERL2-CMD-GETGRENT">getgrent</A>.<P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETGRGID">getgrgid</A> returns only the group name.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETGRNAM">getgrnam</A></h3><DIV CLASS=programlisting><P><PRE>getgrnam <tt CLASS=replaceable><i>NAME</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as<I CLASS=emphasis>getgrnam</I> (3):  it looksup a group file entry by group name.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $passwd, $gid, $members)</PRE></DIV><P CLASS=para>where<tt CLASS=literal>$members</tt>contains a space-separated list of the login names of the members of the group.If you want to do this repeatedly, consider slurping the data into a hash(associative array) using<A HREF="ch03_02.htm#PERL2-CMD-GETGRENT">getgrent</A>.<P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETGRNAM">getgrnam</A> returns only the numeric group ID.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETHOSTBYADDR">gethostbyaddr</A></h3><DIV CLASS=programlisting><P><PRE>gethostbyaddr <tt CLASS=replaceable><i>ADDR</i></tt>, <tt CLASS=replaceable><i>ADDRTYPE</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as<I CLASS=emphasis>gethostbyaddr</I> (3):  it translatesa packed binary network address to its correspondingnames (and alternate addresses).The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $addrtype, $length, @addrs)</PRE></DIV><P CLASS=para>where<tt CLASS=literal>@addrs</tt>is a list of packed binary addresses.  In the Internet domain, each address isfour bytes long, and can be unpacked by saying something like:<DIV CLASS=programlisting><P><PRE>($a, $b, $c, $d) = unpack('C4', $addrs[0]);</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETHOSTBYADDR">gethostbyaddr</A> returns only the host name.See the section on "Sockets" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A> for another approach.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETHOSTBYNAME">gethostbyname</A></h3><DIV CLASS=programlisting><P><PRE>gethostbyname <tt CLASS=replaceable><i>NAME</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as<I CLASS=emphasis>gethostbyname</I> (3):  it translatesa network hostname to its correspondingaddresses (and other names).The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $addrtype, $length, @addrs)</PRE></DIV><P CLASS=para>where<tt CLASS=literal>@addrs</tt>is a list of raw addresses.  In the Internet domain, each address isfour bytes long, and can be unpacked by saying something like:<DIV CLASS=programlisting><P><PRE>($a, $b, $c, $d) = unpack('C4', $addrs[0]);</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETHOSTBYNAME">gethostbyname</A> returns only the host address.See the section on "Sockets" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A> for another approach.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETHOSTENT">gethostent</A></h3><DIV CLASS=programlisting><P><PRE>gethostentsethostent <tt CLASS=replaceable><i>STAYOPEN</i></tt>endhostent</PRE></DIV><P CLASS=para>These functions do the same thing as their like-named system libraryroutines--see <I CLASS=emphasis>gethostent</I> (3).<P CLASS=para>They iterate through your <I CLASS=emphasis>/etc/hosts</I>file and return each entry one at a time.The return value from <A HREF="ch03_02.htm#PERL2-CMD-GETHOSTENT">gethostent</A> is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $addrtype, $length, @addrs)</PRE></DIV><P CLASS=para>where<tt CLASS=literal>@addrs</tt>is a list of raw addresses.  In the Internet domain, each address isfour bytes long, and can be unpacked by saying something like:<DIV CLASS=programlisting><P><PRE>($a, $b, $c, $d) = unpack('C4', $addrs[0]);</PRE></DIV><P CLASS=para>Scripts that use these routines should not be considered portable.If a machine usesa nameserver, it would interrogate most of the Internet to tryto satisfy a request for all the addresses of every machine on theplanet.  So these routines are unimplemented on such machines.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETLOGIN">getlogin</A></h3><DIV CLASS=programlisting><P><PRE>getlogin</PRE></DIV><P CLASS=para>This function returns the current login from <I CLASS=emphasis>/etc/utmp</I>, if any.If null, use <A HREF="ch03_02.htm#PERL2-CMD-GETPWUID">getpwuid</A>.  For example:<DIV CLASS=programlisting><P><PRE>$login = getlogin || (getpwuid($&lt;))[0] || "Intruder!!";</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETNETBYADDR">getnetbyaddr</A></h3><DIV CLASS=programlisting><P><PRE>getnetbyaddr <tt CLASS=replaceable><i>ADDR</i></tt>, <tt CLASS=replaceable><i>ADDRTYPE</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as <I CLASS=emphasis>getnetbyaddr</I> (3):  it translatesa network address to the corresponding network name or names.  Thereturn value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $addrtype, $net)</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETNETBYADDR">getnetbyaddr</A> returns only the network name.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETNETBYNAME">getnetbyname</A></h3><DIV CLASS=programlisting><P><PRE>getnetbyname <tt CLASS=replaceable><i>NAME</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as<I CLASS=emphasis>getnetbyname</I> (3):  it translatesa network name to its correspondingnetwork address.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $addrtype, $net)</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETNETBYNAME">getnetbyname</A> returns only the network address.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETNETENT">getnetent</A></h3><DIV CLASS=programlisting><P><PRE>getnetentsetnetent <tt CLASS=replaceable><i>STAYOPEN</i></tt>endnetent</PRE></DIV><P CLASS=para>These functions do the same thing as their like-named system libraryroutines--see<I CLASS=emphasis>getnetent</I> (3). They iterate through your<I CLASS=emphasis>/etc/networks</I> file, or moral equivalent.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $addrtype, $net)</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETNETENT">getnetent</A> returns only the network name.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPEERNAME">getpeername</A></h3><DIV CLASS=programlisting><P><PRE>getpeername <tt CLASS=replaceable><i>SOCKET</i></tt></PRE></DIV><P CLASS=para>This function returns the packed socket address of other end of the<tt CLASS=replaceable><i>SOCKET</i></tt> connection.For example:<DIV CLASS=programlisting><P><PRE>use Socket;$hersockaddr = getpeername SOCK;($port, $heraddr) = unpack_sockaddr_in($hersockaddr);$herhostname = gethostbyaddr($heraddr, AF_INET);$herstraddr = inet_ntoa($heraddr);</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPGRP">getpgrp</A></h3><DIV CLASS=programlisting><P><PRE>getpgrp <tt CLASS=replaceable><i>PID</i></tt></PRE></DIV><P CLASS=para>This function returns the current process group for the specified <tt CLASS=replaceable><i>PID</i></tt>(use a <tt CLASS=replaceable><i>PID</i></tt> of 0 for the current process).Invoking <A HREF="ch03_02.htm#PERL2-CMD-GETPGRP">getpgrp</A> will produce a fatal error if used on a machinethat doesn't implement <I CLASS=emphasis>getpgrp</I> (2).  If <tt CLASS=replaceable><i>PID</i></tt> is omitted, thefunction returns the process group of the current process (the same asusing a <tt CLASS=replaceable><i>PID</i></tt> of 0).  On systems implementing this operator with thePOSIX <I CLASS=emphasis>getpgrp</I> (2) system call, <tt CLASS=replaceable><i>PID</i></tt> must be omitted or, ifsupplied, must be 0.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPPID">getppid</A></h3><DIV CLASS=programlisting><P><PRE>getppid</PRE></DIV><P CLASS=para>This function returns the process ID of the parent process.On the typical UNIX system, if your parent process ID changesto 1, your parent process has died and you've been adopted by the<I CLASS=emphasis>init</I> program.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPRIORITY">getpriority</A></h3><DIV CLASS=programlisting><P><PRE>getpriority <tt CLASS=replaceable><i>WHICH</i></tt>, <tt CLASS=replaceable><i>WHO</i></tt></PRE></DIV><P CLASS=para>This function returns the current priority for a process, a processgroup, or a user.  See <I CLASS=emphasis>getpriority</I> (2).  Invoking<A HREF="ch03_02.htm#PERL2-CMD-GETPRIORITY">getpriority</A> will produce a fatal error if used on a machine thatdoesn't implement <I CLASS=emphasis>getpriority</I> (2).  For example, to get thepriority of the current process, use:<DIV CLASS=programlisting><P><PRE>$curprio = getpriority(0, 0);</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPROTOBYNAME">getprotobyname</A></h3><DIV CLASS=programlisting><P><PRE>getprotobyname <tt CLASS=replaceable><i>NAME</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as<I CLASS=emphasis>getprotobyname</I> (3):  it translatesa protocol name to its corresponding number.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $protocol_number)</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETPROTOBYNAME">getprotobyname</A> returns only the protocol number.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPROTOBYNUMBER">getprotobynumber</A></h3><DIV CLASS=programlisting><P><PRE>getprotobynumber <tt CLASS=replaceable><i>NUMBER</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as<I CLASS=emphasis>getprotobynumber</I> (3):  it translatesa protocol number to its corresponding name.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $protocol_number)</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETPROTOBYNUMBER">getprotobynumber</A> returns only the protocol name.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPROTOENT">getprotoent</A></h3><DIV CLASS=programlisting><P><PRE>getprotoentsetprotoent <tt CLASS=replaceable><i>STAYOPEN</i></tt>endprotoent</PRE></DIV><P CLASS=para>These functions do the same thing as their like-named system libraryroutines--see<I CLASS=emphasis>getprotent</I> (3).The return value from<A HREF="ch03_02.htm#PERL2-CMD-GETPROTOENT">getprotoent</A>is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $protocol_number)</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETPROTOENT">getprotoent</A> returns only the protocol name.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPWENT">getpwent</A></h3><DIV CLASS=programlisting><P><PRE>getpwentsetpwentendpwent</PRE></DIV><P CLASS=para>These functions do the same thing as their like-named system libraryroutines--see<I CLASS=emphasis>getpwent</I> (3).They iterate through your<I CLASS=emphasis>/etc/passwd</I>file (or its moral equivalent coming from some server somewhere).The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name,$passwd,$uid,$gid,$quota,$comment,$gcos,$dir,$shell)</PRE></DIV><P CLASS=para>Some machines may use the quota and comment fields for other purposes,but the remaining fields will always be the same.To set up a hash for translating login names to uids,say this:<DIV CLASS=programlisting><P><PRE>while (($name, $passwd, $uid) = getpwent) {    $uid{$name} = $uid;}</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETPWENT">getpwent</A> returns only the username.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPWNAM">getpwnam</A></h3><DIV CLASS=programlisting><P><PRE>getpwnam <tt CLASS=replaceable><i>NAME</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as <I CLASS=emphasis>getpwnam</I> (3):  it translates ausername to the corresponding <I CLASS=emphasis>passwd</I> file entry.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name,$passwd,$uid,$gid,$quota,$comment,$gcos,$dir,$shell)</PRE></DIV><P CLASS=para>If you want to do this repeatedly, consider caching the data in a hash(associative array) using <A HREF="ch03_02.htm#PERL2-CMD-GETPWENT">getpwent</A>.<P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETPWNAM">getpwnam</A> returns only the numeric user ID.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETPWUID">getpwuid</A></h3><DIV CLASS=programlisting><P><PRE>getpwuid <tt CLASS=replaceable><i>UID</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as <I CLASS=emphasis>getpwuid</I> (3):  it translates anumeric user id to the corresponding <I CLASS=emphasis>passwd</I> file entry.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name,$passwd,$uid,$gid,$quota,$comment,$gcos,$dir,$shell)</PRE></DIV><P CLASS=para>If you want to do this repeatedly, consider slurping the data into ahash using <A HREF="ch03_02.htm#PERL2-CMD-GETPWENT">getpwent</A>.<P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETPWUID">getpwuid</A> returns the username.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETSERVBYNAME">getservbyname</A></h3><DIV CLASS=programlisting><P><PRE>getservbyname <tt CLASS=replaceable><i>NAME</i></tt>, <tt CLASS=replaceable><i>PROTO</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as<I CLASS=emphasis>getservbyname</I> (3):  it translatesa service (port) name to its corresponding port number.<tt CLASS=replaceable><i>PROTO</i></tt>is a protocol name such as<tt CLASS=literal>"tcp"</tt>.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $port_number, $protocol_name)</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETSERVBYNAME">getservbyname</A> returns only the service port number.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETSERVBYPORT">getservbyport</A></h3><DIV CLASS=programlisting><P><PRE>getservbyport <tt CLASS=replaceable><i>PORT</i></tt>, <tt CLASS=replaceable><i>PROTO</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as<I CLASS=emphasis>getservbyport</I> (3):  it translatesa service (port) number to its corresponding names.<tt CLASS=replaceable><i>PROTO</i></tt>is a protocol name such as<tt CLASS=literal>"tcp"</tt>.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $port_number, $protocol_name)</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETSERVBYPORT">getservbyport</A> returns only the service port name.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETSERVENT">getservent</A></h3><DIV CLASS=programlisting><P><PRE>getserventsetservent <tt CLASS=replaceable><i>STAYOPEN</i></tt>endservent</PRE></DIV><P CLASS=para>These functions do the same thing as their like-named system libraryroutines--see<I CLASS=emphasis>getservent</I> (3).They iterate through the<I CLASS=emphasis>/etc/services</I>file or its equivalent.The return value in list context is:<DIV CLASS=programlisting><P><PRE>($name, $aliases, $port_number, $protocol_name)</PRE></DIV><P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GETSERVENT">getservent</A> returns only the service port name.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETSOCKNAME">getsockname</A></h3><DIV CLASS=programlisting><P><PRE>getsockname <tt CLASS=replaceable><i>SOCKET</i></tt></PRE></DIV><P CLASS=para>This function returns the packed sockaddr address of this end of the<tt CLASS=replaceable><i>SOCKET</i></tt> connection.(And why wouldn't you know your own address already?  Because you mighthave bound an address containing wildcards to the generic socketbefore doing an <A HREF="ch03_02.htm#PERL2-CMD-ACCEPT">accept</A>.  Or because youmight have been passed asocket by your parent process--for example, <I CLASS=emphasis>inetd</I>.)<DIV CLASS=programlisting><P><PRE>use Socket;$mysockaddr = getsockname(SOCK);($port, $myaddr) = unpack_sockaddr_in($mysockaddr);</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GETSOCKOPT">getsockopt</A></h3><DIV CLASS=programlisting><P><PRE>getsockopt <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>LEVEL</i></tt>, <tt CLASS=replaceable><i>OPTNAME</i></tt></PRE></DIV><P CLASS=para>This function returns the socket option requested, or the undefined value ifthere is an error.  See <A HREF="ch03_02.htm#PERL2-CMD-SETSOCKOPT">setsockopt</A> for more.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GLOB">glob</A></h3><DIV CLASS=programlisting><P><PRE>glob <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns the value of <tt CLASS=replaceable><i>EXPR</i></tt> with filename expansions such as a shellwould do.  (If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, <B>$_</B> is globbed instead.)  This isthe internal function implementing the <tt CLASS=literal>&lt;*&gt;</tt> operator, exceptthat it may be easier to type this way.  For example, compare thesetwo:<DIV CLASS=programlisting><P><PRE>@result = map { glob($_) } "*.c", "*.c,v";@result = map &lt;${_}&gt;, "*.c", "*.c,v";</PRE></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-GLOB">glob</A> function is not related to the Perl notion of typeglobs,other than that they both use a <tt CLASS=literal>*</tt> to represent multiple items.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GMTIME">gmtime</A></h3><DIV CLASS=programlisting><P><PRE>gmtime <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function converts a time as returned by the <B>time</B> function to a9-element list withthe time correct for the Greenwich time zone (aka GMT, or UTC, or evenZulu in certain cultures, not including the Zulu culture, oddly enough).Typically used as follows:<DIV CLASS=programlisting><P><PRE>($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =        gmtime(time);</PRE></DIV><P CLASS=para>All list elements are numeric, and come straight out of a<tt CLASS=literal>struct tm</tt> (that's a C programming structure--don't sweat it).  Inparticular this means that <tt CLASS=literal>$mon</tt> has the range <tt CLASS=literal>0..11</tt>,<tt CLASS=literal>$wday</tt> has the range <tt CLASS=literal>0..6</tt>,and the year has had 1,900 subtracted fromit.  (You can remember which ones are0-based because those are the ones you're always using as subscriptsinto 0-based arrays containing month and day names.)  If <tt CLASS=replaceable><i>EXPR</i></tt> isomitted, it does <tt CLASS=literal>gmtime(time)</tt>.  For example, to print thecurrent month in London:<DIV CLASS=programlisting><P><PRE>$london_month = (qw(Jan Feb Mar Apr May Jun        Jul Aug Sep Oct Nov Dec))[(gmtime)[4]];</PRE></DIV><P CLASS=para>The Perl library module Time::Local contains a subroutine, <tt CLASS=literal>timegm( )</tt>,that can convert in the opposite direction.<P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GMTIME">gmtime</A> returns a <I CLASS=emphasis>ctime</I> (3)-like stringbased on theGMT time value.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GOTO">goto</A></h3><DIV CLASS=programlisting><P><PRE>goto <tt CLASS=replaceable><i>LABEL</i></tt>goto <tt CLASS=replaceable><i>EXPR</i></tt>goto <I CLASS=emphasis>&amp;NAME</I></PRE></DIV><P CLASS=para><tt CLASS=literal>goto</tt> <tt CLASS=replaceable><i>LABEL</i></tt> finds the statement labeled with<tt CLASS=replaceable><i>LABEL</i></tt> and resumes execution there.  It may not be used to go into anyconstruct that requires initialization, such as a subroutine or a<B>foreach</B> loop.  It also can't be used to go into a construct that isoptimized away.  It can be used to go almost anywhere else within thedynamic scope,[4]including out of subroutines, but for that purpose it'susually better to use some other construct such as <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A> or <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A>.The author of Perlhas never felt the need to use this form of <B>goto</B> (in Perl, that is--Cis another matter).<blockquote class=footnote><P CLASS=para>[4] This means that if it doesn't find the label in the current routine,it looks back through the routines that called the current routinefor the label, thus making it nearly impossible to maintain your program.</blockquote><P CLASS=para>Going to even greater heights of orthogonality (and depths of idiocy),Perl allows <tt CLASS=literal>goto</tt> <tt CLASS=replaceable><i>EXPR</i></tt>, which expects <tt CLASS=replaceable><i>EXPR</i></tt>to evaluate to a label name, whose scope is <I CLASS=emphasis>guaranteed</I> to be unresolvableuntil run-time since the label is unknown when the statement is compiled.This allows for computed gotos per FORTRAN, but isn't necessarilyrecommended[5]if you're optimizing for maintainability:<blockquote class=footnote><P CLASS=para>[5] Understatement is reputed to be funny, so we thought we'd try one here.</blockquote><DIV CLASS=programlisting><P><PRE>goto +("FOO", "BAR", "GLARCH")[$i];</PRE></DIV><P CLASS=para><tt CLASS=literal>goto</tt> <tt CLASS=literal>&amp;</tt><tt CLASS=replaceable><i>NAME</i></tt> is highly magical, substituting acall to the named subroutine for the currently running subroutine.This is used by <tt CLASS=literal>AUTOLOAD</tt> subroutines that wish to load anothersubroutine and then pretend that this subroutine--and not the originalone--had been calledin the first place (except that any modifications to <tt CLASS=literal>@_</tt> in theoriginal subroutine are propagated to the replacement subroutine).  After the<A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A>, not even <A HREF="ch03_02.htm#PERL2-CMD-CALLER">caller</A> will be able to tell that the originalroutine was called first.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-GREP">grep</A></h3><DIV CLASS=programlisting><P><PRE>grep <tt CLASS=replaceable><i>EXPR</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt>grep <tt CLASS=replaceable><i>BLOCK</i></tt> <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function evaluates <tt CLASS=replaceable><i>EXPR</i></tt> or <tt CLASS=replaceable><i>BLOCK</i></tt> in a Boolean contextfor each element of <tt CLASS=replaceable><i>LIST</i></tt>,temporarily setting <B>$_</B> to each element in turn.In list context, it returns a list of those elementsfor which the expression is true.(The operator is named after a beloved UNIX program thatextracts lines out of a file that match a particular pattern.In Perl the expression is often a pattern, but doesn't have to be.)In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-GREP">grep</A> returns the number of times theexpression was true.<P CLASS=para>Presuming <tt CLASS=literal>@all_lines</tt> contains lines of code, this example weeds outcomment lines:<DIV CLASS=programlisting><P><PRE>@code_lines = grep !/^#/, @all_lines;</PRE></DIV><P CLASS=para>Since <B>$_</B> is a reference into the list value, altering<B>$_</B> will modify the elements of the original list.While this is useful and supported, it can occasionally cause bizarreresults if you aren't expecting it.  For example:<DIV CLASS=programlisting><P><PRE>@list = qw(barney fred dino wilma);@greplist = grep { s/^[bfd]// } @list;</PRE></DIV><P CLASS=para><tt CLASS=literal>@greplist</tt> is now "<tt CLASS=literal>arney</tt>","<tt CLASS=literal>red</tt>", "<tt CLASS=literal>ino</tt>", but<tt CLASS=literal>@list</tt> is now "<tt CLASS=literal>arney</tt>","<tt CLASS=literal>red</tt>", "<tt CLASS=literal>ino</tt>","<tt CLASS=literal>wilma</tt>"!  Caveat Programmor.<P CLASS=para>See also <A HREF="ch03_02.htm#PERL2-CMD-MAP">map</A>.  The following two statementsare functionally equivalent:<DIV CLASS=programlisting><P><PRE>@out = grep { <tt CLASS=replaceable><i>EXPR</i></tt> } @in;@out = map { <tt CLASS=replaceable><i>EXPR</i></tt> ? $_ : () } @in</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-HEX">hex</A></h3><DIV CLASS=programlisting><P><PRE>hex <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function interprets <tt CLASS=replaceable><i>EXPR</i></tt> as a hexadecimal string and returns theequivalent decimal value.(To interpret strings that might start with <tt CLASS=literal>0</tt> or <tt CLASS=literal>0x</tt> see<A HREF="ch03_02.htm#PERL2-CMD-OCT">oct</A>.)  If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, it interprets <B>$_</B>.  Thefollowing code sets <tt CLASS=literal>$number</tt> to 4,294,906,560:<DIV CLASS=programlisting><P><PRE>$number = hex("ffff12c0");</PRE></DIV><P CLASS=para>To do the inverse function, use:<DIV CLASS=programlisting><P><PRE>sprintf "%lx", $number;         # (That's an ell, not a one.)</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-IMPORT">import</A></h3><DIV CLASS=programlisting><P><PRE>import <tt CLASS=replaceable><i>CLASSNAME</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>import <tt CLASS=replaceable><i>CLASSNAME</i></tt></PRE></DIV><P CLASS=para>There is no built-in <A HREF="ch03_02.htm#PERL2-CMD-IMPORT">import</A> function.  It is merely an ordinaryclass method defined (or inherited) by modules that wish to export namesto another module through the <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> operator.  See <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> fordetails.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-INDEX">index</A></h3><DIV CLASS=programlisting><P><PRE>index <tt CLASS=replaceable><i>STR</i></tt>, <tt CLASS=replaceable><i>SUBSTR</i></tt>, <tt CLASS=replaceable><i>POSITION</i></tt>index <tt CLASS=replaceable><i>STR</i></tt>, <tt CLASS=replaceable><i>SUBSTR</i></tt></PRE></DIV><P CLASS=para>This function returns the position of the first occurrence of <tt CLASS=replaceable><i>SUBSTR</i></tt>in <tt CLASS=replaceable><i>STR</i></tt>.  The <tt CLASS=replaceable><i>POSITION</i></tt>, if specified, says where to startlooking.Positions are based at 0 (or whatever you've set the <B>$[</B> variableto--but don't do that).If the substring is not found, the function returns one less than the base, ordinarily -1.  To work your way through a string, you mightsay:<DIV CLASS=programlisting><P><PRE>$pos = -1;while (($pos = index($string, $lookfor, $pos)) &gt; -1) {    print "Found at $pos\n";    $pos++;}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-INT">int</A></h3><DIV CLASS=programlisting><P><PRE>int <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns the integer portion of <tt CLASS=replaceable><i>EXPR</i></tt>.  If <tt CLASS=replaceable><i>EXPR</i></tt> isomitted, it uses <B>$_</B>.  If you're a C programmer, you'll oftenforget to use <A HREF="ch03_02.htm#PERL2-CMD-INT">int</A> in conjunction with division, which is afloating-point operation in Perl:<DIV CLASS=programlisting><P><PRE>$average_age = 939/16;      # yields 58.6875 (58 in C)$average_age = int 939/16;  # yields 58</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-IOCTL">ioctl</A></h3><DIV CLASS=programlisting><P><PRE>ioctl <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>FUNCTION</i></tt>, <tt CLASS=replaceable><i>SCALAR</i></tt></PRE></DIV><P CLASS=para>This function implements the <I CLASS=emphasis>ioctl</I> (2) system call.You'll probably have to say:<DIV CLASS=programlisting><P><PRE>require "ioctl.ph";    # probably /usr/local/lib/perl/ioctl.ph</PRE></DIV><P CLASS=para>first to get the correct function definitions.  If <I CLASS=emphasis>ioctl.ph</I>doesn't exist or doesn't have the correct definitions you'll have toroll your own, based on your C header files such as<I CLASS=emphasis>&lt;sys/ioctl.h&gt;</I>.  (The Perl distribution includes a script called<I CLASS=emphasis>h2ph</I> to help you do this, but it's non-trivial.)<tt CLASS=replaceable><i>SCALAR</i></tt> will be read and/or written depending on the <tt CLASS=replaceable><i>FUNCTION</i></tt>--apointer to the string value of <tt CLASS=replaceable><i>SCALAR</i></tt> will be passed as the thirdargument of the actual <I CLASS=emphasis>ioctl</I> (2) call. (If <tt CLASS=replaceable><i>SCALAR</i></tt> has no string value butdoes have a numeric value, that value will be passed directly ratherthan a pointer to the string value.)  The <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A> and<A HREF="ch03_02.htm#PERL2-CMD-UNPACK">unpack</A> functions are useful for manipulating the values ofstructures used by <A HREF="ch03_02.htm#PERL2-CMD-IOCTL">ioctl</A>.The following example sets the erase character to DEL on many UNIX systems(see the POSIX module in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> for a slightly more portable interface):<DIV CLASS=programlisting><P><PRE>require 'ioctl.ph';$getp = &amp;TIOCGETP or die "NO TIOCGETP";$sgttyb_t = "ccccs";            # 4 chars and a shortif (ioctl STDIN, $getp, $sgttyb) {    @ary = unpack $sgttyb_t, $sgttyb;    $ary[2] = 127;    $sgttyb = pack $sgttyb_t, @ary;    ioctl STDIN, &amp;TIOCSETP, $sgttyb        or die "Can't ioctl TIOCSETP: $!";}</PRE></DIV><P CLASS=para>The return value of <A HREF="ch03_02.htm#PERL2-CMD-IOCTL">ioctl</A> (and <A HREF="ch03_02.htm#PERL2-CMD-FCNTL">fcntl</A>) is as follows:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-3-TAB-2"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">System call returns</TH><TH ALIGN="left">Perl returns</TH></TR><TR CLASS=row><TD ALIGN="left">-1</TD><TD ALIGN="left">undefined value</TD></TR><TR CLASS=row><TD ALIGN="left">0</TD><TD ALIGN="left">string "<tt CLASS=literal>0 but true</tt>"</TD></TR><TR CLASS=row><TD ALIGN="left">anything else</TD><TD ALIGN="left">that number</TD></TR></TABLE><P></DIV><P CLASS=para>Thus Perl returns true on success and false on failure, yet you can stilleasily determine the actual value returned by the operating system:<DIV CLASS=programlisting><P><PRE>$retval = ioctl(...) or $retval = -1;printf "System returned %d\n", $retval;</PRE></DIV><P CLASS=para>Calls to <B>ioctl</B> should not be considered portable.  If, say, you'remerely turning off echo once for the whole script, it's much moreportable (and not much slower) to say:<DIV CLASS=programlisting><P><PRE>system "stty -echo";   # Works on most UNIX boxen.</PRE></DIV><P CLASS=para>Just because you <I CLASS=emphasis>can</I> do something in Perl doesn't mean you<I CLASS=emphasis>ought</I> to.  To quote the Apostle Paul, "Everything ispermissible--but not everything is beneficial."</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-JOIN">join</A></h3><DIV CLASS=programlisting><P><PRE>join <tt CLASS=replaceable><i>EXPR</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function joins the separate strings of <tt CLASS=replaceable><i>LIST</i></tt>into a single string with fields separated by thevalue of <tt CLASS=replaceable><i>EXPR</i></tt>, and returns the string.  For example:<DIV CLASS=programlisting><P><PRE>$_ = join ':', $login,$passwd,$uid,$gid,$gcos,$home,$shell;</PRE></DIV><P CLASS=para>To do the opposite, see <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A>.  To join things together intofixed-position fields, see <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A>.<P CLASS=para>The most efficient way to concatenate many strings together is to <B>join</B> them with a null string.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-KEYS">keys</A></h3><DIV CLASS=programlisting><P><PRE>keys <tt CLASS=replaceable><i>HASH</i></tt></PRE></DIV><P CLASS=para>This function returns a list consisting of all the keys of thenamed hash.The keys are returned in an apparently random order, but it is thesame order as either the <A HREF="ch03_02.htm#PERL2-CMD-VALUES">values</A> or <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> functionproduces (assuming that the hash has not been modified between calls).Here is yet another way to print your environment:<DIV CLASS=programlisting><P><PRE>@keys = keys %ENV;@values = values %ENV;while (@keys) {    print pop(@keys), '=', pop(@values), "\n";}</PRE></DIV><P CLASS=para>or how about sorted by key:<DIV CLASS=programlisting><P><PRE>foreach $key (sort keys %ENV) {    print $key, '=', $ENV{$key}, "\n";}</PRE></DIV><P CLASS=para>To sort an array by value, you'll need to provide a comparisonfunction.  Here's a descending numeric sort of a hash by its values:<DIV CLASS=programlisting><P><PRE>foreach $key (sort { $hash{$b} &lt;=&gt; $hash{$a} } keys %hash)) {    printf "%4d %s\n", $hash{$key}, $key;}</PRE></DIV><P CLASS=para>Note that using <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> on a hash bound to alargish DBM file will produce a largish list, causing you to have alargish process.  You might prefer to use the <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> function inthis case, which will iterate over the hash entries one-by-onewithout slurping them all into a single gargantuan list.<P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> returns the number of elements of thehash (and resets the <B>each</B> iterator). However, to get this information for tied hashes, including DBM files,Perl must still walk the entire hash, so it's not very efficient in thatcase.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-KILL">kill</A></h3><DIV CLASS=programlisting><P><PRE>kill <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function sends a signal to a list of processes.The first element of the list must be the signal to send.You may use a signal name in quotes (without a <tt CLASS=literal>SIG</tt> on the front).The function returns the number of processes successfully signaled.If the signal is negative, the function kills process groups insteadof processes.(On System V, a negative processnumber will also kill process groups,but that's not portable.)Examples:<DIV CLASS=programlisting><P><PRE>$cnt = kill 1, $child1, $child2;kill 9, @goners;kill 'STOP', getppid;  # Can *so* suspend my login shell...</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LAST">last</A></h3><DIV CLASS=programlisting><P><PRE>last <tt CLASS=replaceable><i>LABEL</i></tt>last</PRE></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A> command is like the <tt CLASS=literal>break</tt> statement in C (as usedin loops); it immediately exits the loop in question.If the <tt CLASS=replaceable><i>LABEL</i></tt>is omitted, the command refers to the innermost enclosing loop.The <B>continue</B> block, if any, is not executed.<DIV CLASS=programlisting><P><PRE>LINE: while (&lt;STDIN&gt;) {    last LINE if /^$/; # exit when done with header    # rest of loop here}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LC">lc</A></h3><DIV CLASS=programlisting><P><PRE>lc <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns a lowercased version of <tt CLASS=replaceable><i>EXPR</i></tt> (or <B>$_</B> if omitted).This is the internal function implementing the <tt CLASS=literal>\L</tt> escape in double-quotedstrings.POSIX <I CLASS=emphasis>setlocale</I> (3) settings are respected.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LCFIRST">lcfirst</A></h3><DIV CLASS=programlisting><P><PRE>lcfirst <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns a version of <tt CLASS=replaceable><i>EXPR</i></tt>(or <B>$_</B> if omitted) with the first characterlowercased.This is the internal function implementing the <tt CLASS=literal>\l</tt> escape in double-quotedstrings.POSIX <I CLASS=emphasis>setlocale</I> (3) settings are respected.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LENGTH">length</A></h3><DIV CLASS=programlisting><P><PRE>length <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns the length in bytes of the scalar value<tt CLASS=replaceable><i>EXPR</i></tt>.If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, the function returns the length of <B>$_</B>, but becareful that the next thing doesn't look like the start of an <tt CLASS=replaceable><i>EXPR</i></tt>, orthe tokener will get confused.  When in doubt, always put inparentheses.<P CLASS=para>Do not try to use <A HREF="ch03_02.htm#PERL2-CMD-LENGTH">length</A> to find the size of an array or hash.  Use<tt CLASS=literal>scalar @array</tt> for the size of an array, and <tt CLASS=literal>scalar keys %hash</tt>for the size of a hash.  (The <tt CLASS=literal>scalar</tt> is typicallydropped when redundant, which is typical.)</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LINK">link</A></h3><DIV CLASS=programlisting><P><PRE>link <tt CLASS=replaceable><i>OLDFILE</i></tt>, <tt CLASS=replaceable><i>NEWFILE</i></tt></PRE></DIV><P CLASS=para>This function creates a new filename linked to the old filename.  The functionreturns 1 for success, 0 otherwise (and puts the error code into <B>$!</B>).  See also <A HREF="ch03_02.htm#PERL2-CMD-SYMLINK">symlink</A>later in this chapter.  This function is unlikely to be implemented on non-UNIXsystems.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LISTEN">listen</A></h3><DIV CLASS=programlisting><P><PRE>listen <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>QUEUESIZE</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as the<I CLASS=emphasis>listen</I> (2) system call.  It tells the system thatyou're going to be accepting connections on this socket and that the system canqueue the number of waiting connections specified by<tt CLASS=replaceable><i>QUEUESIZE</i></tt>.  Imagine having call-waiting on yourphone, with up to five callers queued.  (Gives me the willies!)  The functionreturns true if it succeeded, false otherwise (and puts the error code into<B>$!</B>).  See the section "Sockets" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LOCAL">local</A></h3><DIV CLASS=programlisting><P><PRE>local <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This operator declares one or more global variables to have locally scopedvalues within the innermost enclosing block, subroutine, <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, or file.If more than one variable is listed, the list must be placed in parentheses,because the operator binds more tightly than comma.All the listed variables must be legal lvalues, that is, somethingyou could assign to.  This operator works bysaving the current values of those variables on a hidden stackand restoring them upon exiting the block, subroutine, or <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>,or file.After the <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> is executed, but before the scope is exited, anycalled subroutines will see the local, inner value, not the previous, outervalue, because the variable is still a global variable, despitehaving a localized value.  The technical term for this is "dynamic scoping".<P CLASS=para>The <tt CLASS=replaceable><i>EXPR</i></tt> may be assigned to if desired, which allows you to initializeyour local variables.  (If no initializer is given, all scalars areinitialized to the undefined value and all arrays and hashesto empty.)  Commonly, this is used to name theformal arguments to a subroutine.  As with ordinary assignment, if youuse parentheses around the variables on the left (or if the variable isan array or hash), the expression onthe right is evaluated in list context.  Otherwise the expressionon the right is evaluated in scalar context.<P CLASS=para>Here is a routine that executes some random piece of code that dependson <tt CLASS=literal>$i</tt> running through a range of numbers.  Note that the scopeof <tt CLASS=literal>$i</tt> propagates into the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> code.<DIV CLASS=programlisting><P><PRE>&amp;RANGEVAL(20, 30, '$foo[$i] = $i');sub RANGEVAL {    local($min, $max, $thunk) = @_;    local $result = "";    local $i;    # Presumably $thunk makes reference to $i    for ($i = $min; $i &lt; $max; $i++) {        $result .= eval $thunk;    }    $result;}</PRE></DIV><P CLASS=para>This code demonstrates how to make a temporary modification toa global array:<DIV CLASS=programlisting><P><PRE>if ($sw eq '-v') {    # init local array with global array    local @ARGV = @ARGV;    unshift @ARGV, 'echo';    system @ARGV;}# @ARGV restored</PRE></DIV><P CLASS=para>You can also temporarily modify hashes:<DIV CLASS=programlisting><P><PRE># temporarily add a couple of entries to the %digits hashif ($base12) {    # (NOTE: not claiming this is efficient!)    local(%digits) = (%digits, T =&gt; 10, E =&gt; 11);    parse_num();}</PRE></DIV><P CLASS=para>But you probably want to be using <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> instead, because<A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> isn't really what most people think of as local.See the section on <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> later.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LOCALTIME">localtime</A></h3><DIV CLASS=programlisting><P><PRE>localtime <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function converts the value returned by <A HREF="ch03_02.htm#PERL2-CMD-TIME">time</A> to anine-element list with the time corrected for the local time zone.It's typically used as follows:<DIV CLASS=programlisting><P><PRE>($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =        localtime(time);</PRE></DIV><P CLASS=para>All list elements are numeric, and come straight out of a<tt CLASS=literal>struct tm</tt>.(That's a bit of C programming lingo--don't worry about it.)In particular this means that<tt CLASS=literal>$mon</tt>has the range <tt CLASS=literal>0..11</tt>,<tt CLASS=literal>$wday</tt>has therange <tt CLASS=literal>0..6</tt>, and the year has had 1,900 subtracted from it.(You can remember which ones are 0-based because those are the onesyou're always using as subscripts into 0-based arrays containingmonth and day names.)If<tt CLASS=replaceable><i>EXPR</i></tt>is omitted, it does<tt CLASS=literal>localtime(time)</tt>.For example, to get the name of the current day of the week:<DIV CLASS=programlisting><P><PRE>$thisday = (Sun,Mon,Tue,Wed,Thu,Fri,Sat)[(localtime)[6]];</PRE></DIV><P CLASS=para>The Perl library module Time::Local contains a subroutine, <tt CLASS=literal>timelocal()</tt>,that can convert in the opposite direction.<P CLASS=para>In scalar context, <A HREF="ch03_02.htm#PERL2-CMD-LOCALTIME">localtime</A> returns a <I CLASS=emphasis>ctime</I> (3)-like stringbased on the localtime value.  For example, the <I CLASS=emphasis>date</I> command canbe emulated with:<DIV CLASS=programlisting><P><PRE>perl -e 'print scalar localtime'</PRE></DIV><P CLASS=para>See also <tt CLASS=literal>POSIX::strftime()</tt> in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> fora more fine-grained approach to formatting times.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LOG">log</A></h3><DIV CLASS=programlisting><P><PRE>log <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns logarithm (base <I CLASS=emphasis>e</I>) of<tt CLASS=replaceable><i>EXPR</i></tt>.  If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted,the function returns the logarithm of <B>$_</B>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-LSTAT">lstat</A></h3><DIV CLASS=programlisting><P><PRE>lstat <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function does the same thing as the <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A> function, but if thelast component of the filename is a symbolic link, stats a symbolic linkinstead of the file the symbolic link points to.  (If symbolic links areunimplemented on your system, a normal <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A> is done instead.)</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-MAP">map</A></h3><DIV CLASS=programlisting><P><PRE>map <tt CLASS=replaceable><i>BLOCK</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>map <tt CLASS=replaceable><i>EXPR</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function evaluates the <tt CLASS=replaceable><i>BLOCK</i></tt> or <tt CLASS=replaceable><i>EXPR</i></tt> for eachelement of <tt CLASS=replaceable><i>LIST</i></tt> (locally setting <B>$_</B> to each element) andreturns the list value composed of the results of each such evaluation.It evaluates <tt CLASS=replaceable><i>BLOCK</i></tt> or <tt CLASS=replaceable><i>EXPR</i></tt> in a list context, so eachelement of <tt CLASS=replaceable><i>LIST</i></tt> may produce zero, one, or more elements in thereturned value.  These are all flattened into one list.  For instance:<DIV CLASS=programlisting><P><PRE>@words = map { split ' ' } @lines;</PRE></DIV><P CLASS=para>splits a list of lines into a list of words.  Often, though, there is aone-to-one mapping between input values and output values:<DIV CLASS=programlisting><P><PRE>@chars = map chr, @nums;</PRE></DIV><P CLASS=para>translates a list of numbers to the corresponding characters.  Andhere's an example of a one-to-two mapping:<DIV CLASS=programlisting><P><PRE>%hash = map { genkey($_), $_ } @array;</PRE></DIV><P CLASS=para>which is just a funny functional way to write this:<DIV CLASS=programlisting><P><PRE>%hash = ();foreach $_ (@array) {    $hash{genkey($_)} = $_;}</PRE></DIV><P CLASS=para>See also <A HREF="ch03_02.htm#PERL2-CMD-GREP">grep</A>.  <A HREF="ch03_02.htm#PERL2-CMD-MAP">map</A> differs from <A HREF="ch03_02.htm#PERL2-CMD-GREP">grep</A>in that <A HREF="ch03_02.htm#PERL2-CMD-MAP">map</A> returns a list consisting of theresults of each successive evaluation of <tt CLASS=replaceable><i>EXPR</i></tt>,whereas <A HREF="ch03_02.htm#PERL2-CMD-GREP">grep</A> returns a list consisting ofeach value of <tt CLASS=replaceable><i>LIST</i></tt> for which<tt CLASS=replaceable><i>EXPR</i></tt> evaluates to true.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-MKDIR">mkdir</A></h3><DIV CLASS=programlisting><P><PRE>mkdir <tt CLASS=replaceable><i>FILENAME</i></tt>, <tt CLASS=replaceable><i>MODE</i></tt></PRE></DIV><P CLASS=para>This function creates the directory specified by <tt CLASS=replaceable><i>FILENAME</i></tt>, withpermissions specified by the numeric <tt CLASS=replaceable><i>MODE</i></tt> (as modified by thecurrent umask).If it succeeds it returns 1, otherwise it returns 0 and sets <B>$!</B>(from the value of <tt CLASS=literal>errno</tt>).<P CLASS=para>If <I CLASS=emphasis>mkdir</I> (2) is not built in to your C library, Perl emulates it bycalling the <I CLASS=emphasis>mkdir</I> (1) program.  If you are creating a long list ofdirectories on such a system it will be more efficient to call the<I CLASS=emphasis>mkdir</I> program yourself with the list of directories to avoidstarting zillions of subprocesses.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-MSGCTL">msgctl</A></h3><DIV CLASS=programlisting><P><PRE>msgctl <tt CLASS=replaceable><i>ID</i></tt>, <tt CLASS=replaceable><i>CMD</i></tt>, <tt CLASS=replaceable><i>ARG</i></tt></PRE></DIV><P CLASS=para>This function calls the <I CLASS=emphasis>msgctl</I> (2) system call.See <I CLASS=emphasis>msgctl</I> (2) for details.If <tt CLASS=replaceable><i>CMD</i></tt> is <tt CLASS=literal>&amp;IPC_STAT</tt>, then <tt CLASS=replaceable><i>ARG</i></tt> must be avariable that will hold the returned <tt CLASS=literal>msqid_ds</tt> structure.  Thereturn value works like <A HREF="ch03_02.htm#PERL2-CMD-IOCTL">ioctl</A>'s: the undefined value for error,"<tt CLASS=literal>0 but true</tt>" for zero, or the actual return value otherwise.On error, it puts the error code into <B>$!</B>.  Before calling, youshould say:<DIV CLASS=programlisting><P><PRE>require "ipc.ph";require "msg.ph";</PRE></DIV><P CLASS=para>This function is available only on machines supporting System V IPC, which turns out to be far fewer than those supporting sockets.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-MSGGET">msgget</A></h3><DIV CLASS=programlisting><P><PRE>msgget <tt CLASS=replaceable><i>KEY</i></tt>, <tt CLASS=replaceable><i>FLAGS</i></tt></PRE></DIV><P CLASS=para>This function calls the System V IPC <I CLASS=emphasis>msgget</I> (2) system call.See <I CLASS=emphasis>msgget</I> (2) for details.The function returns the message queue ID, or theundefined value if there is an error.  On error, it puts the errorcode into <B>$!</B>.  Before calling, you should say:<DIV CLASS=programlisting><P><PRE>require "ipc.ph";require "msg.ph";</PRE></DIV><P CLASS=para>This function is available only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-MSGRCV">msgrcv</A></h3><DIV CLASS=programlisting><P><PRE>msgrcv <tt CLASS=replaceable><i>ID</i></tt>, <tt CLASS=replaceable><i>VAR</i></tt>, <tt CLASS=replaceable><i>SIZE</i></tt>, <tt CLASS=replaceable><i>TYPE</i></tt>, <tt CLASS=replaceable><i>FLAGS</i></tt></PRE></DIV><P CLASS=para>This function callsthe <I CLASS=emphasis>msgrcv</I> (2) system call to receive a message frommessage queue ID into variable <tt CLASS=replaceable><i>VAR</i></tt> with a maximummessage size of <tt CLASS=replaceable><i>SIZE</i></tt>.  See<I CLASS=emphasis>msgrcv</I> (2) for details.  When a message is received,the message type will be the first thing in <tt CLASS=replaceable><i>VAR</i></tt>, andthe maximum length of <tt CLASS=replaceable><i>VAR</i></tt> is<tt CLASS=replaceable><i>SIZE</i></tt> plus the size of the message type.  The functionreturns true if successful, or false if there is an error.  On error, it putsthe error code into <B>$!</B>.  Before calling, youshould say:<DIV CLASS=programlisting><P><PRE>require "ipc.ph";require "msg.ph";</PRE></DIV><P CLASS=para>This function is available only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-MSGSND">msgsnd</A></h3><DIV CLASS=programlisting><P><PRE>msgsnd <tt CLASS=replaceable><i>ID</i></tt>, <tt CLASS=replaceable><i>MSG</i></tt>, <tt CLASS=replaceable><i>FLAGS</i></tt></PRE></DIV><P CLASS=para>This function calls the <I CLASS=emphasis>msgsnd</I> (2) system call to send themessage <tt CLASS=replaceable><i>MSG</i></tt> to the message queue <tt CLASS=replaceable><i>ID</i></tt>.See <I CLASS=emphasis>msgsnd</I> (2) for details.  <tt CLASS=replaceable><i>MSG</i></tt> mustbegin with the long integer message type.  You can create a messagelike this:<DIV CLASS=programlisting><P><PRE>$msg = pack "L a*", $type, $text_of_message;</PRE></DIV><P CLASS=para>The function returns true if successful, or false if there is anerror.  On error, it puts the error code into <B>$!</B>.  Beforecalling, you should say:<DIV CLASS=programlisting><P><PRE>require "ipc.ph";require "msg.ph";</PRE></DIV><P CLASS=para>This function is available only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-MY">my</A></h3><DIV CLASS=programlisting><P><PRE>my <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This operator declaresone or more private variables to exist only within the innermost enclosingblock, subroutine, <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, or file.  If morethan one variable is listed, the list must be placed in parentheses, because theoperator binds more tightly than comma.  Only simple scalars or complete arraysand hashes may be declared this way.  The variable name may not be packagequalified, because package variables are all global, and private variables arenot related to any package.  Unlike <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A>,this operator has nothing to do with global variables, other than hiding anyother variable of the same name from view within its scope.  (A global variablecan always be accessed through its package-qualified form, however.)  A privatevariable is not visible until the statement <I CLASS=emphasis>after</I> itsdeclaration.  Subroutines called from within the scope of such a private variable cannot see the privatevariable unless the subroutine is also textually declared within the scope ofthe variable.  The technical term for this is "lexical scoping", so we oftencall these "lexical variables".  In C culture they're called "auto" variables,since they're automatically allocated and deallocated at scope entry and exit.<P CLASS=para>The <tt CLASS=replaceable><i>EXPR</i></tt> may be assigned to if desired, which allows you to initializeyour lexical variables.  (If no initializer is given, all scalars areinitialized to the undefined value and all arrays and hashesto empty arrays.)  As with ordinary assignment, if youuse parentheses around the variables on the left (or if the variable isan array or hash), the expression onthe right is evaluated in list context.  Otherwise the expressionon the right is evaluated in scalar context.  You can name your formalsubroutine parameters with a list assignment, like this:<DIV CLASS=programlisting><P><PRE>my ($friends, $romans, $countrymen) = @_;</PRE></DIV><P CLASS=para>Be careful not to omit the parentheses indicating list assignment, like this:<DIV CLASS=programlisting><P><PRE>my $country = @_;  # right or wrong?</PRE></DIV><P CLASS=para>This assigns the length of the array (that is, the number of thesubroutine's arguments)to the variable, since the array is being evaluated in scalar context.You can profitably use scalar assignment for a formal parameter though,as long as you use the <A HREF="ch03_02.htm#PERL2-CMD-SHIFT">shift</A> operator.  In fact, since object methodsare passed the object as the first argument, many such method subroutinesstart off like this:<DIV CLASS=programlisting><P><PRE>sub simple_as {    my $self = shift;   # scalar assignment    my ($a,$b,$c) = @_; # list assignment    ...}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-NEW">new</A></h3><DIV CLASS=programlisting><P><PRE>new <tt CLASS=replaceable><i>CLASSNAME</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>new <tt CLASS=replaceable><i>CLASSNAME</i></tt></PRE></DIV><P CLASS=para>There is no built-in <A HREF="ch03_02.htm#PERL2-CMD-NEW">new</A> function.  It is merely an ordinaryconstructor method (subroutine) defined (or inherited) by the<tt CLASS=replaceable><i>CLASSNAME</i></tt> module to let you construct objects of type<tt CLASS=replaceable><i>CLASSNAME</i></tt>.  Most constructors are named "new", butonly by convention, just to delude C++ programmers into thinking theyknow what's going on.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-NEXT">next</A></h3><DIV CLASS=programlisting><P><PRE>next <tt CLASS=replaceable><i>LABEL</i></tt>next</PRE></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A> command is like the <B>continue</B> statement in C: it startsthe next iteration of the loop designated by <tt CLASS=replaceable><i>LABEL</i></tt>:<DIV CLASS=programlisting><P><PRE>LINE: while (&lt;STDIN&gt;) {    next LINE if /^#/;     # discard comments    ...}</PRE></DIV><P CLASS=para>Note that if there were a <B>continue</B> block in this example, it wouldexecute immediately following the invocation of <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A>.When <tt CLASS=replaceable><i>LABEL</i></tt> is omitted, the commandrefers to the innermost enclosing loop.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-NO">no</A></h3><DIV CLASS=programlisting><P><PRE>no <tt CLASS=replaceable><i>Module</i></tt> <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>See the <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> operator, which <A HREF="ch03_02.htm#PERL2-CMD-NO">no</A> is the opposite of, kind of.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-OCT">oct</A></h3><DIV CLASS=programlisting><P><PRE>oct <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function interprets <tt CLASS=replaceable><i>EXPR</i></tt> as an octal string and returns theequivalent decimal value.(If <tt CLASS=replaceable><i>EXPR</i></tt> happens to start off with <tt CLASS=literal>0x</tt>,it is interpreted as a hexstring instead.)  The following will handle decimal, octal, and hex inthe standard notation:<DIV CLASS=programlisting><P><PRE>$val = oct $val if $val =~ /^0/;</PRE></DIV><P CLASS=para>If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, the function interprets <B>$_</B>.To perform the inverse function on octal numbers,use:<DIV CLASS=programlisting><P><PRE>$oct_string = sprintf "%lo", $number;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-OPEN">open</A></h3><DIV CLASS=programlisting><P><PRE>open <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>EXPR</i></tt>open <tt CLASS=replaceable><i>FILEHANDLE</i></tt></PRE></DIV><P CLASS=para><A NAME="CH03.OPEN1"></A><A NAME="CH03.OPEN2"></A><A NAME="CH03.OPEN3"></A>This function opens the file whose filename is given by <tt CLASS=replaceable><i>EXPR</i></tt>, andassociates it with <tt CLASS=replaceable><i>FILEHANDLE</i></tt>.  If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, thescalar variable of the same name as the <tt CLASS=replaceable><i>FILEHANDLE</i></tt> must contain thefilename.  (And you must also be careful to use "<tt CLASS=literal>or die</tt>" after thestatement rather than "<tt CLASS=literal>|| die</tt>", because the precedence of <tt CLASS=literal>||</tt>is higher than list operators like <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A>.)<tt CLASS=replaceable><i>FILEHANDLE</i></tt> may be a directly specified filehandle name, or anexpression whose value will be used for the filehandle.  The latter iscalled an indirect filehandle.  If you supply an undefined variable for the indirectfilehandle, Perl will not automatically fill it in for you--youhave to make sure the expression returns something unique, eithera string specifying the actual filehandle name, or a filehandleobject from one of the object-oriented I/O packages.  (A filehandleobject is unique because you call a constructor to generate the object.See the example later in this section.)<P CLASS=para>After the filehandle is determined, the filename string is processed.  First,any leading and trailing whitespace is removed from the string.Then the string is examined on both ends for characters specifying howthe file is to be opened.  (By an amazing coincidence, these characterslook just like the characters you'd use to indicate I/O redirection to theBourne shell.)  If the filename begins with <tt CLASS=literal>&lt;</tt> or nothing, the fileis opened for input.  If the filename begins with <tt CLASS=literal>&gt;</tt>, the fileis truncated and opened for output.  If the filename begins with <tt CLASS=literal>&gt;&gt;</tt>, thefile is opened for appending.(You can also put a <tt CLASS=literal>+</tt> in front of the <tt CLASS=literal>&gt;</tt> or <tt CLASS=literal>&lt;</tt> toindicate that you want both read and write access to the file.)If the filename begins with <tt CLASS=literal>|</tt>, the filename is interpreted asa command to which output is to be piped, and if the filename endswith a <tt CLASS=literal>|</tt>, the filename is interpreted as command which pipesinput to us.You may not have an <B>open</B> command that pipes bothin and out, although the IPC::Open2 and IPC::Open3 library routines give you a closeequivalent.  See the section "Bidirectional Communication" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.<P CLASS=para>Any pipe command containing shell metacharacters is passed to<I CLASS=emphasis>/bin/sh</I> for execution; otherwise it is executed directly byPerl.  The filename "<tt CLASS=literal>-</tt>" refers to<tt CLASS=literal>STDIN</tt>, and "<tt CLASS=literal>&gt;-</tt>" refers to<tt CLASS=literal>STDOUT</tt>.  <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> returnsnon-zero upon success, the undefined value otherwise.  If the <B>open</B> involved a pipe, the return value happens to be theprocess ID of the subprocess.<P CLASS=para>If you're unfortunate enough to be running Perl on a system thatdistinguishes between text files and binary files (modern operatingsystems don't care), then you should check out <A HREF="ch03_02.htm#PERL2-CMD-BINMODE">binmode</A> for tipsfor dealing with this.  The key distinction between systems that need<A HREF="ch03_02.htm#PERL2-CMD-BINMODE">binmode</A> and those that don't is their text file formats.Systems like UNIX and Plan9 that delimit lines with a singlecharacter, and that encode that character in C as <tt CLASS=literal>'\n'</tt>, donot need <A HREF="ch03_02.htm#PERL2-CMD-BINMODE">binmode</A>.  The rest need it.<P CLASS=para>Here is some code that shows the relatedness of a filehandle and avariable of the same name:<DIV CLASS=programlisting><P><PRE>$ARTICLE = "/usr/spool/news/comp/lang/perl/misc/38245";open ARTICLE or die "Can't find article $ARTICLE: $!\n";while (&lt;ARTICLE&gt;) {...</PRE></DIV><P CLASS=para>Append to a file like this:<DIV CLASS=programlisting><P><PRE>open LOG, '&gt;&gt;/usr/spool/news/twitlog'; # (`log' is reserved)</PRE></DIV><P CLASS=para>Pipe your data from a process:<DIV CLASS=programlisting><P><PRE>open ARTICLE, "caesar &lt;$article |";   # decrypt article with rot13</PRE></DIV><P CLASS=para>Here <tt CLASS=literal>&lt;</tt> does not indicate that Perl should open the file for input,because <tt CLASS=literal>&lt;</tt>is not the first character of <tt CLASS=replaceable><i>EXPR</i></tt>.  Rather, the concluding<tt CLASS=literal>|</tt> indicates that input is to be piped from <tt CLASS=literal>caesar &lt;$article</tt> (fromthe program <I CLASS=emphasis>caesar</I>, which takes <I CLASS=emphasis>$article</I> as its standardinput).The <tt CLASS=literal>&lt;</tt> is interpreted by the subshell that Perl uses to startthe pipe, because <tt CLASS=literal>&lt;</tt> is a shell metacharacter.<P CLASS=para>Or pipe your data to a process:<DIV CLASS=programlisting><P><PRE>open EXTRACT, "|sort &gt;/tmp/Tmp$$";    # $$ is our process number</PRE></DIV><P CLASS=para>In this next example we show one way to do recursive opens, viaindirect filehandles.  The files will be opened on filehandles<tt CLASS=literal>fh01</tt>, <tt CLASS=literal>fh02</tt>, <tt CLASS=literal>fh03</tt>, and so on.  Because <tt CLASS=literal>$input</tt> isa local variable, it is preserved through recursion, allowing us toclose the correct file before we return.<DIV CLASS=programlisting><P><PRE># Process argument list of files along with any includes.foreach $file (@ARGV) {    process($file, 'fh00');}sub process {    local($filename, $input) = @_;    $input++;               # this is a string increment    unless (open $input, $filename) {        print STDERR "Can't open $filename: $!\n";        return;    }    while (&lt;$input&gt;) {      # note the use of indirection        if (/^#include "(.*)"/) {            process($1, $input);            next;        }        ...               # whatever    }    close $input;}</PRE></DIV><P CLASS=para>You may also, in the Bourne shell tradition, specify an <tt CLASS=replaceable><i>EXPR</i></tt> beginningwith <tt CLASS=literal>&gt;&amp;</tt>, in which case the rest of the string is interpretedas the name of a filehandle (or file descriptor, if numeric) which isto be duped and opened.[6]You may use <tt CLASS=literal>&amp;</tt> after <tt CLASS=literal>&gt;</tt>, <tt CLASS=literal>&gt;&gt;</tt>, <tt CLASS=literal>&lt;</tt>, <tt CLASS=literal>+&gt;</tt>,<tt CLASS=literal>+&gt;&gt;</tt>, and <tt CLASS=literal>+&lt;</tt>.  The mode you specify should match the modeof the original filehandle.  Here is a script that saves, redirects,and restores <tt CLASS=literal>STDOUT</tt> and <tt CLASS=literal>STDERR</tt>:<blockquote class=footnote><P CLASS=para>[6] The word "dup" is UNIX-speak for "duplicate".  We're not really tryingto dupe you.  Trust us.</blockquote><DIV CLASS=programlisting><P><PRE>#!/usr/bin/perlopen SAVEOUT, "&gt;&amp;STDOUT";open SAVEERR, "&gt;&amp;STDERR";open STDOUT, "&gt;foo.out" or die "Can't redirect stdout";open STDERR, "&gt;&amp;STDOUT" or die "Can't dup stdout";select STDERR; $| = 1;         # make unbufferedselect STDOUT; $| = 1;         # make unbufferedprint STDOUT "stdout 1\n";     # this propagates toprint STDERR "stderr 1\n";     # subprocesses tooclose STDOUT;close STDERR;open STDOUT, "&gt;&amp;SAVEOUT";open STDERR, "&gt;&amp;SAVEERR";print STDOUT "stdout 2\n";print STDERR "stderr 2\n";</PRE></DIV><P CLASS=para>If you specify <tt CLASS=literal>&lt;&amp;=</tt><tt CLASS=replaceable><i>N</i></tt>, where<tt CLASS=replaceable><i>N</i></tt> is a number, then Perl will do an equivalent of C's<I CLASS=emphasis>fdopen</I> (3) of that file descriptor; this is moreparsimonious with file descriptors than the dup form described earlier.  (On theother hand, it's more dangerous, since two filehandles may now be sharing thesame file descriptor, and a close on one filehandle may prematurely close theother.)  For example:<DIV CLASS=programlisting><P><PRE>open <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, "&lt;&amp;=$fd";</PRE></DIV><P CLASS=para>If you open apipe to or from the command "<tt CLASS=literal>-</tt>" (that is, either<tt CLASS=literal>|-</tt> or <tt CLASS=literal>-|</tt>), then an implicit fork is done,and the return value of <B>open</B> is the pid of thechild within the parent process, and <tt CLASS=literal>0</tt> within the childprocess.  (Use <tt CLASS=literal>defined($pid)</tt> in either the parent or child todetermine whether the <B>open</B> was successful.)  Thefilehandle behaves normally for the parent, but input and output to thatfilehandle is piped from or to the <tt CLASS=literal>STDOUT</tt> or<tt CLASS=literal>STDIN</tt> of the child process.  In the child process thefilehandle isn't opened--I/O happens from or to the new<tt CLASS=literal>STDIN</tt> or <tt CLASS=literal>STDOUT</tt>.  Typically this is usedlike the normal piped <B>open</B> when you want toexercise more control over just how the pipe command gets executed, such as whenyou are running setuid, and don't want to have to scan shell commands formetacharacters.  The following pairs are equivalent:<DIV CLASS=programlisting><P><PRE>open FOO, "|tr '[a-z]' '[A-Z]'";open FOO, "|-" or exec 'tr', '[a-z]', '[A-Z]';open FOO, "cat -n file|";open FOO, "-|" or exec 'cat', '-n', 'file';</PRE></DIV><P CLASS=para>Explicitly closing any piped filehandle causes the parent process towait for the child to finish, and returns the status value in<B>$?</B>.  On any operation which may do a fork, unflushedbuffers remain unflushed in both processes, which means you may needto set <B>$|</B> on one or more filehandles to avoid duplicate output(and then do output to flush them).<P CLASS=para>Filehandles <tt CLASS=literal>STDIN</tt>, <tt CLASS=literal>STDOUT</tt>, and <tt CLASS=literal>STDERR</tt> remain openfollowing an exec.  Other filehandles do not.  (However, on systemssupporting the <A HREF="ch03_02.htm#PERL2-CMD-FCNTL">fcntl</A> function, you may modify theclose-on-exec flag for a filehandle. See <A HREF="ch03_02.htm#PERL2-CMD-FCNTL">fcntl</A> earlier inthis chapter.  See also the special <B>$^F</B> variable.)<P CLASS=para>Using the constructor from theFileHandle module, described in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>,you can generate anonymous filehandles which have the scope of whatevervariables hold references to them, and automatically close wheneverand however you leave that scope:<DIV CLASS=programlisting><P><PRE>use FileHandle;...sub read_myfile_munged {    my $ALL = shift;    my $handle = new FileHandle;    open $handle, "myfile" or die "myfile: $!";    $first = &lt;$handle&gt; or return ();      # Automatically closed here.    mung $first or die "mung failed";     # Or here.    return $first, &lt;$handle&gt; if $ALL;     # Or here.    $first;                               # Or here.}</PRE></DIV><P CLASS=para>In order to open a file with arbitrary weird characters in it, it's necessaryto protect any leading and trailing whitespace, like this:<DIV CLASS=programlisting><P><PRE>$file =~ s#^\s#./$&amp;#;open FOO, "&lt; $file\0";</PRE></DIV><P CLASS=para>But we've never actually seen anyone use that in a script . . .<P CLASS=para>If you want a real C <I CLASS=emphasis>open</I> (2), thenyou should use the <A HREF="ch03_02.htm#PERL2-CMD-SYSOPEN">sysopen</A> function.  This is another way toprotect your filenames from interpretation.  For example:<DIV CLASS=programlisting><P><PRE>use FileHandle;sysopen HANDLE, $path, O_RDWR|O_CREAT|O_EXCL, 0700    or die "sysopen $path: $!";HANDLE-&gt;autoflush(1);HANDLE-&gt;print("stuff $$\n");seek HANDLE, 0, 0;print "File contains: ", &lt;HANDLE&gt;;</PRE></DIV><P CLASS=para>See <A HREF="ch03_02.htm#PERL2-CMD-SEEK">seek</A> for some details about mixing reading and writing.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-OPENDIR">opendir</A></h3><DIV CLASS=programlisting><P><PRE>opendir <tt CLASS=replaceable><i>DIRHANDLE</i></tt>, <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function opens a directory named <tt CLASS=replaceable><i>EXPR</i></tt> for processing by<A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A>,<A HREF="ch03_02.htm#PERL2-CMD-TELLDIR">telldir</A>,<A HREF="ch03_02.htm#PERL2-CMD-SEEKDIR">seekdir</A>,<A HREF="ch03_02.htm#PERL2-CMD-REWINDDIR">rewinddir</A>, and<A HREF="ch03_02.htm#PERL2-CMD-CLOSEDIR">closedir</A>.  The function returnstrue if successful.  Directory handles have their own namespace separate fromfilehandles.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-ORD">ord</A></h3><DIV CLASS=programlisting><P><PRE>ord <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns the numeric ASCII value of the first characterof <tt CLASS=replaceable><i>EXPR</i></tt>.If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, it uses <B>$_</B>.  The return value is alwaysunsigned.If you want a signed value, use <tt CLASS=literal>unpack('c',</tt> <tt CLASS=replaceable><i>EXPR</i></tt><tt CLASS=literal>)</tt>.If you want all the characters of the string converted to a list of numbers, use<tt CLASS=literal>unpack('C*',</tt> <tt CLASS=replaceable><i>EXPR</i></tt><tt CLASS=literal>)</tt> instead.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-PACK">pack</A></h3><DIV CLASS=programlisting><P><PRE>pack <tt CLASS=replaceable><i>TEMPLATE</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para><A NAME="CH03.PACK1"></A><A NAME="CH03.PACK2"></A>This function takes a list of values and packs it into abinary structure, returning the string containing the structure.The <tt CLASS=replaceable><i>TEMPLATE</i></tt> is a sequence of characters that give the order and typeof values, as follows:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-3-TAB-3"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="CENTER">Character</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>a</tt></TD><TD ALIGN="left">An ASCII string, will be null padded</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>A</tt></TD><TD ALIGN="left">An ASCII string, will be space padded</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>b</tt></TD><TD ALIGN="left">A bit string, low-to-high order (like <B>vec</B>( ))</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>B</tt></TD><TD ALIGN="left">A bit string, high-to-low order</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>c</tt></TD><TD ALIGN="left">A signed char value</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>C</tt></TD><TD ALIGN="left">An unsigned char value</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>d</tt></TD><TD ALIGN="left">A double-precision float in the native format</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>f</tt></TD><TD ALIGN="left">A single-precision float in the native format</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>h</tt></TD><TD ALIGN="left">A hexadecimal string, low nybble first</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>H</tt></TD><TD ALIGN="left">A hexadecimal string, high nybble first</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>i</tt></TD><TD ALIGN="left">A signed integer value</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>I</tt></TD><TD ALIGN="left">An unsigned integer value</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>l</tt></TD><TD ALIGN="left">A signed long value</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>L</tt></TD><TD ALIGN="left">An unsigned long value      <I CLASS=emphasis>(continued)</I></TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>n</tt></TD><TD ALIGN="left">A short in "network" (big-endian) order</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>N</tt></TD><TD ALIGN="left">A long in "network" (big-endian) order</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>p</tt></TD><TD ALIGN="left">A pointer to a string</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>P</tt></TD><TD ALIGN="left">A pointer to a structure (fixed-length string)</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>s</tt></TD><TD ALIGN="left">A signed short value</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>S</tt></TD><TD ALIGN="left">An unsigned short value</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>v</tt></TD><TD ALIGN="left">A short in "VAX" (little-endian) order</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>V</tt></TD><TD ALIGN="left">A long in "VAX" (little-endian) order</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>u</tt></TD><TD ALIGN="left">A uuencoded string</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>x</tt></TD><TD ALIGN="left">A null byte</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>X</tt></TD><TD ALIGN="left">Back up a byte</TD></TR><TR CLASS=row><TD ALIGN="CENTER"><tt CLASS=literal>@</tt></TD><TD ALIGN="left">Null-fill to absolute position</TD></TR></TABLE><P></DIV><P CLASS=para>Each character may optionally be followed by a number which gives a repeatcount.  Together the character and the repeat count make a field specifier.Field specifiers may be separated by whitespace, which will be ignored.  Withall types except <tt CLASS=literal>"a"</tt> and <tt CLASS=literal>"A"</tt>, the <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A> function will gobble up that many values fromthe <tt CLASS=replaceable><i>LIST</i></tt>.  Saying <tt CLASS=literal>"*"</tt> for therepeat count means to use however many items are left.  The<tt CLASS=literal>"a"</tt> and <tt CLASS=literal>"A"</tt> types gobble just one value,but pack it as a string of length <I CLASS=emphasis>count</I>, padding with nullsor spaces as necessary.  (When unpacking, <tt CLASS=literal>"A"</tt> strips trailingspaces and nulls, but <tt CLASS=literal>"a"</tt> does not.)  Real numbers (floatsand doubles) are in the native machine format only; due to the multiplicity offloating formats around, and the lack of a standard network representation, nofacility for interchange has been made.  This means that packed floating-pointdata written on one machine may not be readable on another--even if bothuse IEEE floating-point arithmetic (as the endian-ness of the memoryrepresentation is not part of the IEEE spec).  Also, Perl uses doublesinternally for all numeric calculation, and converting from double to float todouble will lose precision; that is, <tt CLASS=literal>unpack(`f`,pack(`f`,$num))</tt> will not in general equal <tt CLASS=literal>$num</tt>.<P CLASS=para>This first pair of examples packs numeric values into bytes:<DIV CLASS=programlisting><P><PRE>$out = pack "cccc", 65, 66, 67, 68;      # $out eq "ABCD"$out = pack "c4", 65, 66, 67, 68;        # same thing</PRE></DIV><P CLASS=para>This does a similar thing, with a couple of nulls thrown in:<DIV CLASS=programlisting><P><PRE>$out = pack "ccxxcc", 65, 66, 67, 68;    # $out eq "AB\0\0CD"</PRE></DIV><P CLASS=para>Packing your shorts doesn't imply that you're portable:<DIV CLASS=programlisting><P><PRE>$out = pack "s2", 1, 2;    # "\1\0\2\0" on little-endian                           # "\0\1\0\2" on big-endian</PRE></DIV><P CLASS=para>On binary and hex packs, the count refers to the number of bits or nybbles,not the number of bytes produced:<DIV CLASS=programlisting><P><PRE>$out = pack "B32", "01010000011001010111001001101100";$out = pack "H8", "5065726c";    # both produce "Perl"</PRE></DIV><P CLASS=para>The length on an <tt CLASS=literal>"a"</tt> field applies only to one string:<DIV CLASS=programlisting><P><PRE>$out = pack "a4", "abcd", "x", "y", "z";      # "abcd"</PRE></DIV><P CLASS=para>To get around that limitation, use multiple specifiers:<DIV CLASS=programlisting><P><PRE>$out = pack "aaaa",  "abcd", "x", "y", "z";   # "axyz"$out = pack "a" x 4, "abcd", "x", "y", "z";   # "axyz"</PRE></DIV><P CLASS=para>The <tt CLASS=literal>"a"</tt> format does null filling:<DIV CLASS=programlisting><P><PRE>$out = pack "a14", "abcdefg";   # "abcdefg\0\0\0\0\0\0\0"</PRE></DIV><P CLASS=para>This template packs a C <tt CLASS=literal>struct tm</tt> record (at least on somesystems):<DIV CLASS=programlisting><P><PRE>$out = pack "i9pl", gmtime, $tz, $toff;</PRE></DIV><P CLASS=para>The same template may generally also be used in the <A HREF="ch03_02.htm#PERL2-CMD-UNPACK">unpack</A> function.  If you want to join variable lengthfields with a delimiter, use the <A HREF="ch03_02.htm#PERL2-CMD-JOIN">join</A>function.<P CLASS=para>Note that, although all of our examples use literal strings as templates,there is no reason you couldn't pull in your templates from a disk file.You could, in fact, build an entire relational database system around thisfunction.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-PACKAGE">package</A></h3><DIV CLASS=programlisting><P><PRE>package <tt CLASS=replaceable><i>NAMESPACE</i></tt></PRE></DIV><P CLASS=para>This is not really a function, but a declaration that says that the rest of theinnermost enclosing block, subroutine, <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>or file belongs to the indicated namespace.  (The scope of a <A HREF="ch03_02.htm#PERL2-CMD-PACKAGE">package</A> declaration is thus the same as the scope of a<A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> or <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> declaration.)  All subsequent references to unqualifiedglobal identifiers will be resolved by looking them up in the declared package'ssymbol table.  A <A HREF="ch03_02.htm#PERL2-CMD-PACKAGE">package</A> declaration affectsonly global variables--including those you've used <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> on--but not lexical variables created with <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>.<P CLASS=para>Typically you would put a <B>package</B> declaration as the first thing in a file thatis to be included by the <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> or <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> operator, but you can put one anywhere that astatement would be legal.  When defining a class or a module file, it iscustomary to name the package the same name as the file, to avoid confusion.(It's also customary to name such packages beginning with a capital letter,because lowercase modules are by convention interpreted as pragmas.)<P CLASS=para>You can switch into a given package in more than one place; it merely influenceswhich symbol table is used by the compiler for the rest of that block.  (If itsees another <B>package</B> declaration at the samelevel, the new one overrides the previous one.)  Your main program is assumed tostart with a <tt CLASS=literal>package main</tt> declaration.<P CLASS=para>You can refer to variables and filehandles in other packages by qualifying theidentifier with the package name and a double colon:<tt CLASS=literal>$Package::Variable</tt>.  If the package name is null, the mainpackage as assumed.  That is, <tt CLASS=literal>$::sail</tt> is equivalent to<tt CLASS=literal>$main::sail</tt>.<P CLASS=para>The symbol table for a package is stored in a hash with a name ending in adouble colon.  The main package's symbol table is named<tt CLASS=literal>%main::</tt> for example.  So the package symbol<tt CLASS=literal>*main::sail</tt> can also be accessed as<tt CLASS=literal>$main::{"sail"}</tt>.<P CLASS=para>See "Packages" in <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>, for more information aboutpackages, modules, and classes.  See <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> in<A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>, for other scoping issues.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-PIPE">pipe</A></h3><DIV CLASS=programlisting><P><PRE>pipe <tt CLASS=replaceable><i>READHANDLE</i></tt>, <tt CLASS=replaceable><i>WRITEHANDLE</i></tt></PRE></DIV><P CLASS=para>Like the correspondingsystem call, this function opens a pair of connected pipes--see<I CLASS=emphasis>pipe</I> (2).  This call is almost always used rightbefore a <A HREF="ch03_02.htm#PERL2-CMD-FORK">fork</A>, after which the pipe's readershould close <tt CLASS=replaceable><i>WRITEHANDLE</i></tt>, and the writer close<tt CLASS=replaceable><i>READHANDLE</i></tt>.  (Otherwise the pipe won't indicate EOFto the reader when the writer closes it.)  Note that if you set up a loop ofpiped processes, deadlock can occur unless you are very careful.  In addition,note that Perl's pipes use standard I/O buffering, so you may need to set<B>$|</B> on your <tt CLASS=replaceable><i>WRITEHANDLE</i></tt>to flush after each output command, depending on the application--see <B>select</B> (<I CLASS=emphasis>output filehandle</I>).<P CLASS=para>See also the section on "Pipes" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-POP">pop</A></h3><DIV CLASS=programlisting><P><PRE>pop <tt CLASS=replaceable><i>ARRAY</i></tt>pop</PRE></DIV><P CLASS=para>This function treats an array like a stack--it popsand returns the last value of the array, shortening the array by 1.If<tt CLASS=replaceable><i>ARRAY</i></tt> is omitted, the function pops <B>@ARGV</B> (in the main program),or <B>@_</B> (in subroutines).It has the same effect as:<DIV CLASS=programlisting><P><PRE>$tmp = $ARRAY[$#ARRAY--];</PRE></DIV><P CLASS=para>or:<DIV CLASS=programlisting><P><PRE>$tmp = splice @ARRAY, -1;</PRE></DIV><P CLASS=para>If there are no elements in the array, <A HREF="ch03_02.htm#PERL2-CMD-POP">pop</A>returns the undefined value.  See also <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A>and <A HREF="ch03_02.htm#PERL2-CMD-SHIFT">shift</A>.  If you want to pop more than oneelement, use <A HREF="ch03_02.htm#PERL2-CMD-SPLICE">splice</A>.<P CLASS=para>Note that <A HREF="ch03_02.htm#PERL2-CMD-POP">pop</A> requires its first argument tobe an array, not a list.  If you just want the last element of a list, use this:<DIV CLASS=programlisting><P><PRE>(something_returning_a_list)[-1]</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-POS">pos</A></h3><DIV CLASS=programlisting><P><PRE>pos <tt CLASS=replaceable><i>SCALAR</i></tt></PRE></DIV><P CLASS=para>Returns the location in <tt CLASS=replaceable><i>SCALAR</i></tt> where the last <tt CLASS=literal>m//g</tt> searchover <tt CLASS=replaceable><i>SCALAR</i></tt> left off.  It returns the offset ofthe character <I CLASS=emphasis>after</I> the last one matched.  (That is, it's equivalent to<tt CLASS=literal>length($`) + length($&amp;)</tt>.)  This is the offset where the next<tt CLASS=literal>m//g</tt> search on that string will start.  Remember thatthe offset of the beginning of the string is <tt CLASS=literal>0</tt>.  For example:<DIV CLASS=programlisting><P><PRE>$grafitto = "fee fie foe foo";while ($grafitto =~ m/e/g) {    print pos $grafitto, "\n";}</PRE></DIV><P CLASS=para>prints <tt CLASS=literal>2</tt>, <tt CLASS=literal>3</tt>, <tt CLASS=literal>7</tt>, and<tt CLASS=literal>11</tt>, the offsets of each of the characters following an "e".The <A HREF="ch03_02.htm#PERL2-CMD-POS">pos</A> function may be assigned a value totell the next <tt CLASS=literal>m//g</tt> where to start:<DIV CLASS=programlisting><P><PRE>$grafitto = "fee fie foe foo";pos $grafitto = 4;  # Skip the fee, start at fiewhile ($grafitto =~ m/e/g) {        print pos $grafitto, "\n";}</PRE></DIV><P CLASS=para>This prints only <tt CLASS=literal>7</tt> and <tt CLASS=literal>11</tt>.  (Thankheaven.)  The regular expression assertion, <tt CLASS=literal>\G</tt>, matches onlyat the location currently specified by <A HREF="ch03_02.htm#PERL2-CMD-POS">pos</A>for the string being searched.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-PRINT">print</A></h3><DIV CLASS=programlisting><P><PRE>print <tt CLASS=replaceable><i>FILEHANDLE</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>print <tt CLASS=replaceable><i>LIST</i></tt>print</PRE></DIV><P CLASS=para>This function prints a string or a comma-separated list of strings.The function returns 1 if successful, 0 otherwise.  <tt CLASS=replaceable><i>FILEHANDLE</i></tt> may bea scalar variable name (unsubscripted), in which case the variablecontains either the name of the actual filehandle or a reference toa filehandle object from one of the object-oriented filehandle packages.<tt CLASS=replaceable><i>FILEHANDLE</i></tt> may also be a block that returns either kind of value:<DIV CLASS=programlisting><P><PRE>print { $OK ? "STDOUT" : "STDERR" } "stuff\n";print { $iohandle[$i] } "stuff\n";</PRE></DIV><P CLASS=para>Note that if <tt CLASS=replaceable><i>FILEHANDLE</i></tt> is a variable and the nexttoken is a term, it may be misinterpreted as an operator unless youinterpose a <B>+</B> or put parentheses around the arguments.For example:<DIV CLASS=programlisting><P><PRE>print $a - 2;   # prints $a - 2 to default filehandle (usually STDOUT)print $a (- 2); # prints -2 to filehandle specified in $aprint $a -2;    # ditto (weird parsing rules :-)</PRE></DIV><P CLASS=para>If <tt CLASS=replaceable><i>FILEHANDLE</i></tt> is omitted, the function prints to the currentlyselected output filehandle, initially <tt CLASS=literal>STDOUT</tt>.To set the default output filehandle to something other than<tt CLASS=literal>STDOUT</tt> use the <tt CLASS=literal>select</tt>(<tt CLASS=replaceable><i>FILEHANDLE</i></tt>) operation.[7]If <tt CLASS=replaceable><i>LIST</i></tt> is also omitted, prints <B>$_</B>.  Note that, because<A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> takes a <tt CLASS=replaceable><i>LIST</i></tt>, anything in the <tt CLASS=replaceable><i>LIST</i></tt>is evaluated inlist context, and any subroutine that you call will likely have one or moreof its own internal expressions evaluated in list context.Thus, when you say:<blockquote class=footnote><P CLASS=para>[7] Thus, <tt CLASS=literal>STDOUT</tt> isn't really the default filehandle for<A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>.  It's merely the default default filehandle.</blockquote><DIV CLASS=programlisting><P><PRE>print OUT &lt;STDIN&gt;;</PRE></DIV><P CLASS=para>it is not going to print out the next line from standard input, but all the restof the lines from standard input up to end-of-file, since that's what<tt CLASS=literal>&lt;STDIN&gt;</tt> returns in list context.  Also, remembering theif-it-looks-like-a-function-it-is-a-function rule, be careful not to follow the<A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> keyword with a left parenthesis unlessyou want the corresponding right parenthesis to terminate the arguments to the<A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>--interpose a <B>+</B> or put parens around all the arguments:<DIV CLASS=programlisting><P><PRE>print (1+2)*3, "\n";            # WRONGprint +(1+2)*3, "\n";           # okprint ((1+2)*3, "\n");          # ok</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-PRINTF">printf</A></h3><DIV CLASS=programlisting><P><PRE>printf <tt CLASS=replaceable><i>FILEHANDLE</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>printf <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function prints aformatted string to <tt CLASS=replaceable><i>FILEHANDLE</i></tt> or, if omitted, thecurrently selected output filehandle, initially <tt CLASS=literal>STDOUT</tt>.  Thisis similar to the C library's <I CLASS=emphasis>printf</I> (3) and<I CLASS=emphasis>fprintf</I> (3) function, except that the<tt CLASS=literal>*</tt> field width specifier is not supported.  The function isexactly equivalent to:<DIV CLASS=programlisting><P><PRE>print <tt CLASS=replaceable><i>FILEHANDLE</i></tt> sprintf <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>See <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> and <A HREF="ch03_02.htm#PERL2-CMD-SPRINTF">sprintf</A>.  The description of <A HREF="ch03_02.htm#PERL2-CMD-SPRINTF">sprintf</A> includes the list of acceptable specifications forthe format string.<P CLASS=para>Don't fall into the trap of using a <A HREF="ch03_02.htm#PERL2-CMD-PRINTF">printf</A>when a simple <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> would do.  The <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> is more efficient, and less error prone.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-PUSH">push</A></h3><DIV CLASS=programlisting><P><PRE>push <tt CLASS=replaceable><i>ARRAY</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function treats<tt CLASS=replaceable><i>ARRAY</i></tt> as a stack, and pushes the values of<tt CLASS=replaceable><i>LIST</i></tt> onto the end of<tt CLASS=replaceable><i>ARRAY</i></tt>.  The length of<tt CLASS=replaceable><i>ARRAY</i></tt> increases by the length of<tt CLASS=replaceable><i>LIST</i></tt>.  The function returns this new length.  The<A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A> function has the same effect as:<DIV CLASS=programlisting><P><PRE>foreach $value (<tt CLASS=replaceable><i>LIST</i></tt>) {    $ARRAY[++$#ARRAY] = $value;}</PRE></DIV><P CLASS=para>or:<DIV CLASS=programlisting><P><PRE>splice @ARRAY, @ARRAY, 0, <tt CLASS=replaceable><i>LIST</i></tt>;</PRE></DIV><P CLASS=para>but is more efficient (for both you and your computer).  You can use <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A> in combination with <A HREF="ch03_02.htm#PERL2-CMD-SHIFT">shift</A> to make a fairly time-efficient shift register orqueue:<DIV CLASS=programlisting><P><PRE>for (;;) {    push @ARRAY, shift @ARRAY;    ...}</PRE></DIV><P CLASS=para>See also <A HREF="ch03_02.htm#PERL2-CMD-POP">pop</A> and <A HREF="ch03_02.htm#PERL2-CMD-UNSHIFT">unshift</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-QSSTRINGS">q/STRING/</A></h3><DIV CLASS=programlisting><P><PRE>q/<tt CLASS=replaceable><i>STRING</i></tt>/qq/<tt CLASS=replaceable><i>STRING</i></tt>/qx/<tt CLASS=replaceable><i>STRING</i></tt>/qw/<tt CLASS=replaceable><i>STRING</i></tt>/</PRE></DIV><P CLASS=para>Generalized quotes.  See <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-QUOTEMETA">quotemeta</A></h3><DIV CLASS=programlisting><P><PRE>quotemeta <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns the value of <tt CLASS=replaceable><i>EXPR</i></tt> (or <B>$_</B> if notspecified) with all non-alphanumeric characters backslashed.This is the internal function implementing the <tt CLASS=literal>\Q</tt> escapein interpolative contexts (including double-quoted strings, backticks, and patterns).</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-RAND">rand</A></h3><DIV CLASS=programlisting><P><PRE>rand <tt CLASS=replaceable><i>EXPR</i></tt>rand</PRE></DIV><P CLASS=para>This function returns a random fractional number between 0 and thevalue of <tt CLASS=replaceable><i>EXPR</i></tt>.  (<tt CLASS=replaceable><i>EXPR</i></tt> should be positive.)If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, the function returns a value between 0 and 1(including 0, but excluding 1).  Seealso <A HREF="ch03_02.htm#PERL2-CMD-SRAND">srand</A>.<P CLASS=para>To get an integral value, combine this with <A HREF="ch03_02.htm#PERL2-CMD-INT">int</A>, as in:<DIV CLASS=programlisting><P><PRE>$roll = int(rand 6) + 1;       # $roll is now an integer between 1 and 6</PRE></DIV><P CLASS=para></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-READ">read</A></h3><DIV CLASS=programlisting><P><PRE>read <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>SCALAR</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt>read <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>SCALAR</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt></PRE></DIV><P CLASS=para>This function attempts to read <tt CLASS=replaceable><i>LENGTH</i></tt> bytes of data into variable<tt CLASS=replaceable><i>SCALAR</i></tt> from the specified <tt CLASS=replaceable><i>FILEHANDLE</i></tt>.The function returns the numberof bytes actually read, 0 at end-of-file.  It returns the undefinedvalue on error.  <tt CLASS=replaceable><i>SCALAR</i></tt> will be grown or shrunk to the length actuallyread.  The <tt CLASS=replaceable><i>OFFSET</i></tt>, if specified, says where in the variable to startputting bytes, so that you can do a read into the middle of a string.<P CLASS=para>To copy data from filehandle <tt CLASS=literal>FROM</tt> into filehandle <tt CLASS=literal>TO</tt>, you couldsay:<DIV CLASS=programlisting><P><PRE>while (read FROM, $buf, 16384) {    print TO $buf;}</PRE></DIV><P CLASS=para>Note that the opposite of <A HREF="ch03_02.htm#PERL2-CMD-READ">read</A> is simply a<A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>, which already knows the length of thestring you want to write, and can write a string of any length.<P CLASS=para>Perl's <A HREF="ch03_02.htm#PERL2-CMD-READ">read</A> function is actually implementedin terms of standard I/O's <I CLASS=emphasis>fread</I> (3) function, sothe actual <I CLASS=emphasis>read</I> (2) system call may read more than<tt CLASS=replaceable><i>LENGTH</i></tt> bytes to fill the input buffer, and<I CLASS=emphasis>fread</I> (3) may do more than one system<I CLASS=emphasis>read</I> (2) in order to fill the buffer.  To gaingreater control, specify the real system call using <A HREF="ch03_02.htm#PERL2-CMD-SYSREAD">sysread</A>.  Calls to <A HREF="ch03_02.htm#PERL2-CMD-READ">read</A>and <A HREF="ch03_02.htm#PERL2-CMD-SYSREAD">sysread</A> should not be intermixed unlessyou are into heavy wizardry (or pain).</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-READDIR">readdir</A></h3><DIV CLASS=programlisting><P><PRE>readdir <tt CLASS=replaceable><i>DIRHANDLE</i></tt></PRE></DIV><P CLASS=para>This function reads directory entries from a directory handle openedby <A HREF="ch03_02.htm#PERL2-CMD-OPENDIR">opendir</A>.In scalar context, this function returns the next directory entry, if any,otherwise an undefined value.In list context, it returns all the rest of the entries in thedirectory, which will of course be a null list if there are none.For example:<DIV CLASS=programlisting><P><PRE>opendir THISDIR, "." or die "serious dainbramage: $!";@allfiles = readdir THISDIR;closedir THISDIR;print "@allfiles\n";</PRE></DIV><P CLASS=para>prints all the files in the current directory on one line.  If you want to avoidthe "<tt CLASS=literal>.</tt>" and "<tt CLASS=literal>..</tt>"entries, use this instead:<DIV CLASS=programlisting><P><PRE>@allfiles = grep !/^\.\.?$/, readdir THISDIR;</PRE></DIV><P CLASS=para>And to avoid all <tt CLASS=literal>.*</tt> files (like the <I CLASS=emphasis>ls</I> program):<DIV CLASS=programlisting><P><PRE>@allfiles = grep !/^\./, readdir THISDIR;</PRE></DIV><P CLASS=para>To get just text files, say this:<DIV CLASS=programlisting><P><PRE>@textfiles = grep -T, readdir THISDIR;</PRE></DIV><P CLASS=para>But watch out on that last one, because the result of <A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A>needs to have the directory part glued back on if it's not the currentdirectory--like this:<DIV CLASS=programlisting><P><PRE>opendir THATDIR, $thatdir;@text_of_thatdir = grep -T, map "$thatdir/$_", readdir THATDIR;closedir THATDIR;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-READLINK">readlink</A></h3><DIV CLASS=programlisting><P><PRE>readlink <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns the name of a file pointed to by a symbolic link.<tt CLASS=replaceable><i>EXPR</i></tt> should evaluate to a filename, the last component of whichis a symbolic link.If it is not a symbolic link, or if symbolic linksare not implemented, or if some system error occurs, the undefinedvalue is returned, and you should check the error code in <tt CLASS=literal>$!</tt>.If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, the function uses <B>$_</B>.<P CLASS=para>Be aware that the returned symlink may be relativeto the location you specified.  For instance, you may say:<DIV CLASS=programlisting><P><PRE>readlink "/usr/local/src/express/yourself.h"</PRE></DIV><P CLASS=para>and <A HREF="ch03_02.htm#PERL2-CMD-READLINK">readlink</A> might return:<DIV CLASS=programlisting><P><PRE>../express.1.23/includes/yourself.h</PRE></DIV><P CLASS=para>which is not directly usable as a filename unless your current directory happens tobe <tt CLASS=literal>/usr/local/src/express</tt>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-RECV">recv</A></h3><DIV CLASS=programlisting><P><PRE>recv <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>SCALAR</i></tt>, <tt CLASS=replaceable><i>LEN</i></tt>, <tt CLASS=replaceable><i>FLAGS</i></tt></PRE></DIV><P CLASS=para>This function receives a message on a socket.It attempts to receive <tt CLASS=replaceable><i>LENGTH</i></tt>bytes of data into variable <tt CLASS=replaceable><i>SCALAR</i></tt> fromthe specified <tt CLASS=replaceable><i>SOCKET</i></tt> filehandle.  The function returns the address ofthe sender, or the undefined value if there's an error.  <tt CLASS=replaceable><i>SCALAR</i></tt> willbe grown or shrunk to the length actually read.  The function takesthe same flags as <I CLASS=emphasis>recv</I> (2).  See the section "Sockets" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-REDO">redo</A></h3><DIV CLASS=programlisting><P><PRE>redo <tt CLASS=replaceable><i>LABEL</i></tt>redo</PRE></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-REDO">redo</A> command restarts a loop block without evaluating theconditional again.  The <B>continue</B> block, if any, is not executed.  Ifthe <tt CLASS=replaceable><i>LABEL</i></tt> is omitted, the command refers to the innermost enclosingloop.  This command is normally used by programs that wish to deceivethemselves about what was just input:<DIV CLASS=programlisting><P><PRE># A loop that joins lines continued with a backslash.LINE: while (&lt;STDIN&gt;) {    if (s/\\\n$// and $nextline = &lt;STDIN&gt;) {        $_ .= $nextline;        redo LINE;    }    print;  # or whatever...}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-REF">ref</A></h3><DIV CLASS=programlisting><P><PRE>ref <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-REF">ref</A> operator returns a true value if <tt CLASS=replaceable><i>EXPR</i></tt> is a reference,the null string otherwise.  The value returned depends on the type of thing thereference is a reference to.  Built-in types include:<DIV CLASS=programlisting><P><PRE>REFSCALARARRAYHASHCODEGLOB</PRE></DIV><P CLASS=para>If the referenced object has been blessed into a package, then that package nameis returned instead.  You can think of <A HREF="ch03_02.htm#PERL2-CMD-REF">ref</A>as a "typeof" operator.<DIV CLASS=programlisting><P><PRE>if (ref($r) eq "HASH") {    print "r is a reference to a hash.\n";} elsif (ref($r) eq "Hump") {    print "r is a reference to a Hump object.\n";} elsif (not ref $r) {    print "r is not a reference at all.\n";}</PRE></DIV><P CLASS=para>See <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A> for more details.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-RENAME">rename</A></h3><DIV CLASS=programlisting><P><PRE>rename <tt CLASS=replaceable><i>OLDNAME</i></tt>, <tt CLASS=replaceable><i>NEWNAME</i></tt></PRE></DIV><P CLASS=para>This function changes the name of a file.It returns 1 for success, 0 otherwise (and puts the error code into<B>$!</B>).  It will not work across filesystem boundaries.  If thereis already a file named <tt CLASS=replaceable><i>NEWNAME</i></tt>, it will be destroyed.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-REQUIRE">require</A></h3><DIV CLASS=programlisting><P><PRE>require <tt CLASS=replaceable><i>EXPR</i></tt>require</PRE></DIV><P CLASS=para>This function asserts a dependency of some kind on its argument.(If <tt CLASS=replaceable><i>EXPR</i></tt> is not supplied, <B>$_</B> is used as the argument.)<P CLASS=para>If the argument is a string, this function includes and executes the Perl codefound in the separate file whose name is given by the string.  This is similarto performing an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> on the contents of thefile, except that <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> checks to see thatthe library file has not been included already.  (It can thus be used to expressfile dependencies without worrying about duplicate compilation.)  The functionalso knows how to search the include path stored in the <B>@INC</B> array (see the section "Special Variables" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>).<P CLASS=para>This form of the <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> function behavesmuch like this subroutine:<DIV CLASS=programlisting><P><PRE>sub require {    my($filename) = @_;    return 1 if $INC{$filename};    my($realfilename, $result);    ITER: {        foreach $prefix (@INC) {            $realfilename = "$prefix/$filename";            if (-f $realfilename) {                $result = eval `cat $realfilename`;                last ITER;            }        }        die "Can't find $filename in \@INC";    }    die $@ if $@;    die "$filename did not return true value" unless $result;    $INC{$filename} = $realfilename;    return $result;}</PRE></DIV><P CLASS=para>Note that the file must return true as the last value to indicatesuccessful execution of any initialization code, so it's customary toend such a file with <tt CLASS=literal>1;</tt> unless you're sure it'll return trueotherwise.<P CLASS=para>This operator differs from the now somewhat obsolete <tt CLASS=literal>do</tt><tt CLASS=replaceable><i>EXPR</i></tt> operator in that the file will not be includedagain if it was included previously with either a <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> or <tt CLASS=literal>do</tt><tt CLASS=replaceable><i>EXPR</i></tt> command, and any difficulties will be detectedand reported as fatal errors (which may be trapped by use of <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>).  The <A HREF="ch03_02.htm#PERL2-CMD-DO">do</A> commanddoes know how to do the <B>@INC</B> path search,however.<P CLASS=para>If <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>'s argument is a number, theversion number of the currently executing Perl binary (as known by <B>$]</B>) is compared to <tt CLASS=replaceable><i>EXPR</i></tt>, and ifsmaller, execution is immediately aborted. Thus, a script that requires Perlversion 5.003 can have as its first line:<DIV CLASS=programlisting><P><PRE>require 5.003;</PRE></DIV><P CLASS=para>and earlier versions of Perl will abort.<P CLASS=para>If <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>'s argument is a package name (see<A HREF="ch03_02.htm#PERL2-CMD-PACKAGE">package</A>), <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> assumes an automatic <tt CLASS=literal>.pm</tt> suffix,making it easy to load standard modules.  This is like <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A>, except that it happens at run-time, not compile time,and the <A HREF="ch03_02.htm#PERL2-CMD-IMPORT">import</A> routine is not called.  Forexample, to pull in Socket.pm without introducing any symbols into the currentpackage, say this:<DIV CLASS=programlisting><P><PRE>require Socket; # instead of "use Socket;"</PRE></DIV><P CLASS=para>However, one can get the same effect with the following, which has theadvantage of giving a compile-time warning if Socket.pm can't be located:<DIV CLASS=programlisting><P><PRE>use Socket ();</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-RESET">reset</A></h3><DIV CLASS=programlisting><P><PRE>reset <tt CLASS=replaceable><i>EXPR</i></tt>reset</PRE></DIV><P CLASS=para>This function is generally used at the top of a loop or in a <B>continue</B> block at the end of a loop, to clear globalvariables or reset <tt CLASS=literal>??</tt> searches so that they work again.  Theexpression is interpreted as a list of single characters (hyphens are allowedfor ranges).  All scalar variables, arrays, and hashes beginning with one ofthose letters are reset to their pristine state.  If the expression is omitted,one-match searches(<tt CLASS=literal>?</tt><tt CLASS=replaceable><i>PATTERN</i></tt><tt CLASS=literal>?</tt>) arereset to match again.  The function resets variables or searches for the currentpackage only.  It always returns 1.<P CLASS=para>To reset all "<tt CLASS=literal>X</tt>" variables, say this:<DIV CLASS=programlisting><P><PRE>reset 'X';</PRE></DIV><P CLASS=para>To reset all lowercase variables, say this:<DIV CLASS=programlisting><P><PRE>reset 'a-z';</PRE></DIV><P CLASS=para>Lastly, to just reset <tt CLASS=literal>??</tt> searches, say:<DIV CLASS=programlisting><P><PRE>reset;</PRE></DIV><P CLASS=para>Note that resetting "<tt CLASS=literal>A-Z</tt>" is not recommended since you'llwipe out your <B>ARGV</B>, <B>INC</B>, <B>ENV</B>, and <B>SIG</B> arrays.<P CLASS=para>Lexical variables (created by <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>) are notaffected.  Use of <A HREF="ch03_02.htm#PERL2-CMD-RESET">reset</A> is vaguelydeprecated.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-RETURN">return</A></h3><DIV CLASS=programlisting><P><PRE>return <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns from a subroutine (or <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>) with the value specified.  (In the absence of anexplicit <B>return</B>, the value of the last expression evaluated is returned.)  Useof <B>return</B> outside of a subroutine or <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> is verboten, and results in a fatal error.Note also that an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> cannot do a <A HREF="ch03_02.htm#PERL2-CMD-RETURN">return</A> on behalf of the subroutine thatcalled the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>.<P CLASS=para>The supplied expression will be evaluated in the context of the subroutineinvocation.  That is, if the subroutine was called in a scalar context,<tt CLASS=replaceable><i>EXPR</i></tt> is also evaluated in scalar context.  If thesubroutine was invoked in a list context, then <tt CLASS=replaceable><i>EXPR</i></tt>is also evaluated in list context, and can return a list value.  A return withno argument returns the undefined value in scalar context, and a null list inlist context.  The context of the subroutine call can be determined from withinthe subroutine by using the (misnamed) <A HREF="ch03_02.htm#PERL2-CMD-WANTARRAY">wantarray</A> function.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-REVERSE">reverse</A></h3><DIV CLASS=programlisting><P><PRE>reverse <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>In list context, this function returns a list value consistingof the elements of <tt CLASS=replaceable><i>LIST</i></tt> in the opposite order.  This is fairlyefficient because it just swaps the pointers around.  The function canbe used to create descending sequences:<DIV CLASS=programlisting><P><PRE>for (reverse 1 .. 10) { ... }</PRE></DIV><P CLASS=para>Because of the way hashes flatten into lists when passed to (non-hash-aware)functions, <A HREF="ch03_02.htm#PERL2-CMD-REVERSE">reverse</A> can also be used toinvert a hash, presuming the values are unique:<DIV CLASS=programlisting><P><PRE>%barfoo = reverse %foobar;</PRE></DIV><P CLASS=para>In scalar context, the function concatenates all the elements of <tt CLASS=replaceable><i>LIST</i></tt>together and then returns the reverse of that, character by character.<P CLASS=para>A small hint: reversing a list sorted earlier by a user-defined function cansometimes be achieved more easily by simply sorting in the oppositedirection in the first place.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-REWINDDIR">rewinddir</A></h3><DIV CLASS=programlisting><P><PRE>rewinddir <tt CLASS=replaceable><i>DIRHANDLE</i></tt></PRE></DIV><P CLASS=para>This function sets the current position to the beginning of thedirectory for the <A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A> routine on<tt CLASS=replaceable><i>DIRHANDLE</i></tt>.  The function may not be available on all machines that support<A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-RINDEX">rindex</A></h3><DIV CLASS=programlisting><P><PRE>rindex <tt CLASS=replaceable><i>STR</i></tt>, <tt CLASS=replaceable><i>SUBSTR</i></tt>, <tt CLASS=replaceable><i>POSITION</i></tt>rindex <tt CLASS=replaceable><i>STR</i></tt>, <tt CLASS=replaceable><i>SUBSTR</i></tt></PRE></DIV><P CLASS=para>This function works just like <A HREF="ch03_02.htm#PERL2-CMD-INDEX">index</A> exceptthat it returns the position of the last occurrence of<tt CLASS=replaceable><i>SUBSTR</i></tt> in <tt CLASS=replaceable><i>STR</i></tt> (a reverse<A HREF="ch03_02.htm#PERL2-CMD-INDEX">index</A>).  The function returns<tt CLASS=literal>$[-1</tt> if not found.  Since <tt CLASS=literal>$[</tt> is almostalways <tt CLASS=literal>0</tt> nowadays, the function almost always returns -1.<tt CLASS=replaceable><i>POSITION</i></tt>, if specified, is the rightmost positionthat may be returned.  To work your way through a string backward, say:<DIV CLASS=programlisting><P><PRE>$pos = length $string;while (($pos = rindex $string, $lookfor, $pos) &gt;= 0) {    print "Found at $pos\n";    $pos--;}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-RMDIR">rmdir</A></h3><DIV CLASS=programlisting><P><PRE>rmdir <tt CLASS=replaceable><i>FILENAME</i></tt></PRE></DIV><P CLASS=para>This function deletes the directory specified by <tt CLASS=replaceable><i>FILENAME</i></tt> if it isempty.If it succeeds, it returns 1, otherwise it returns 0 and puts theerror code into <B>$!</B>.  If <tt CLASS=literal>FILENAME</tt> is omitted, the function uses<B>$_</B>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SSSS">s///</A></h3><DIV CLASS=programlisting><P><PRE>s///</PRE></DIV><P CLASS=para>The substitution operator.  See "Pattern Matching Operators" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SCALAR">scalar</A></h3><DIV CLASS=programlisting><P><PRE>scalar <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This pseudo-function may be used within a <tt CLASS=replaceable><i>LIST</i></tt> to force <tt CLASS=replaceable><i>EXPR</i></tt>to beevaluated in scalar context when evaluation in list contextwould produce a different result.<P CLASS=para>For example:<DIV CLASS=programlisting><P><PRE>local($nextvar) = scalar &lt;STDIN&gt;;</PRE></DIV><P CLASS=para>prevents <tt CLASS=literal>&lt;STDIN&gt;</tt> from reading all the lines fromstandard input before doing the assignment, since assignment to a <B>local</B> list provides a list context.  (Without the use of<A HREF="ch03_02.htm#PERL2-CMD-SCALAR">scalar</A> in this example, the first line from<tt CLASS=literal>&lt;STDIN&gt;</tt> would still be assigned to<tt CLASS=literal>$nextvar</tt>, but the subsequent lines would be read and thrownaway.  This is because the assignment is being made to a list--one thathappens to be able to receive only a single, scalar value.)<P CLASS=para>Of course, a simpler way with less typing would be to simply leave theparentheses off, thereby changing the list context to a scalar one:<DIV CLASS=programlisting><P><PRE>local $nextvar = &lt;STDIN&gt;;</PRE></DIV><P CLASS=para>Since a <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> function is a<tt CLASS=replaceable><i>LIST</i></tt> operator, you have to say:<DIV CLASS=programlisting><P><PRE>print "Length is ", scalar(@ARRAY), "\n";</PRE></DIV><P CLASS=para>if you want the length of <tt CLASS=literal>@ARRAY</tt> to be printed out.<P CLASS=para>One never needs to force evaluation in a list context, because any operationthat wants a list already provides a list context to its list arguments forfree.  So there's no <B>list</B> function correspondingto <A HREF="ch03_02.htm#PERL2-CMD-SCALAR">scalar</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SEEK">seek</A></h3><DIV CLASS=programlisting><P><PRE>seek <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt>, <tt CLASS=replaceable><i>WHENCE</i></tt></PRE></DIV><P CLASS=para>This function positions the file pointer for <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, justlike the <I CLASS=emphasis>fseek</I> (3) call of standard I/O.  The first position in afile is at offset 0, not offset 1, and offsets refer to byte positions,not line numbers.  (In general, since line lengths vary, it's notpossible to access a particular line number without examining the wholefile up to that line number, unless all your lines are known to be of aparticular length, or you've built an index that translates line numbersinto byte offsets.)  <tt CLASS=replaceable><i>FILEHANDLE</i></tt> may be an expressionwhose value gives the name of the filehandle or a reference to a filehandleobject.  The function returns 1 upon success, 0 otherwise.For handiness, the function can calculate offsets from various filepositions for you.  The value of <tt CLASS=replaceable><i>WHENCE</i></tt> specifies which fileposition your <tt CLASS=replaceable><i>OFFSET</i></tt> is relative to: <tt CLASS=literal>0</tt>, the beginning ofthe file; <tt CLASS=literal>1</tt>, the current position in the file; or <tt CLASS=literal>2</tt>, theend of the file.  <tt CLASS=replaceable><i>OFFSET</i></tt> may be negative for a <tt CLASS=replaceable><i>WHENCE</i></tt> of<tt CLASS=literal>1</tt> or <tt CLASS=literal>2</tt>.<P CLASS=para>One interesting use for this function is to allow you to followgrowing files, like this:<DIV CLASS=programlisting><P><PRE>for (;;) {    while (&lt;LOG&gt;) {        ...           # Process file.    }    sleep 15;    seek LOG,0,1;      # Reset end-of-file error.}</PRE></DIV><P CLASS=para>The final <A HREF="ch03_02.htm#PERL2-CMD-SEEK">seek</A> clears the end-of-file error without moving thepointer.If that doesn't work (depending on your C library's standard I/Oimplementation), thenyou may need something more like this:<DIV CLASS=programlisting><P><PRE>for (;;) {    for ($curpos = tell FILE; $_ = &lt;FILE&gt;; $curpos = tell FILE) {        # search for some stuff and put it into files    }    sleep $for_a_while;    seek FILE, $curpos, 0;}</PRE></DIV><P CLASS=para>Similar strategies could be used to remember the <A HREF="ch03_02.htm#PERL2-CMD-SEEK">seek</A> addresses of each line in an array.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SEEKDIR">seekdir</A></h3><DIV CLASS=programlisting><P><PRE>seekdir <tt CLASS=replaceable><i>DIRHANDLE</i></tt>, <tt CLASS=replaceable><i>POS</i></tt></PRE></DIV><P CLASS=para>This function sets the current position for the <A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A>routine on <tt CLASS=replaceable><i>DIRHANDLE</i></tt>.  <tt CLASS=replaceable><i>POS</i></tt>must be a value returned by <A HREF="ch03_02.htm#PERL2-CMD-TELLDIR">telldir</A>.  This function has the same caveats about possibledirectory compaction as the corresponding system library routine.  Thefunction may not be implemented everywhere that <A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A> is.It's certainly not implemented where <A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A> isn't.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SELECT-OUT">select (output filehandle)</A></h3><DIV CLASS=programlisting><P><PRE>select <tt CLASS=replaceable><i>FILEHANDLE</i></tt>select</PRE></DIV><P CLASS=para>For historical reasons, there are two <B>select</B>operators that are totally unrelated to each other.  See the next section forthe other one.  This <B>select</B> operator returnsthe currently selected output filehandle, and if<tt CLASS=replaceable><i>FILEHANDLE</i></tt> is supplied, sets the current defaultfilehandle for output.  This has two effects: first, a <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> or a <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>without a filehandle will default to this <tt CLASS=replaceable><i>FILEHANDLE</i></tt>.Second, special variables related to output will refer to this outputfilehandle.  For example, if you have to set the same top-of-form format formore than one output filehandle, you might do the following:<DIV CLASS=programlisting><P><PRE>select REPORT1;$^ = 'MyTop';select REPORT2;$^ = 'MyTop';</PRE></DIV><P CLASS=para>But note that this leaves <tt CLASS=literal>REPORT2</tt> as the currently selectedfilehandle.  This could be construed as antisocial, since it could really foulup some other routine's <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> or <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> statements.  Properly written libraryroutines leave the currently selected filehandle the same on exit as it was uponentry. To support this, <tt CLASS=replaceable><i>FILEHANDLE</i></tt> may be anexpression whose value gives the name of the actual filehandle.  Thus, you cansave and restore the currently selected filehandle:<DIV CLASS=programlisting><P><PRE>my $oldfh = select STDERR; $| = 1; select $oldfh;</PRE></DIV><P CLASS=para>or (being bizarre and obscure):<DIV CLASS=programlisting><P><PRE>select((select(STDERR), $| = 1)[0])</PRE></DIV><P CLASS=para>This example works by building a list consisting of the returned value from<tt CLASS=literal>select(STDERR)</tt> (which selects <tt CLASS=literal>STDERR</tt> as aside effect) and <tt CLASS=literal>$| = 1</tt> (which is always 1), but setsautoflushing on the now-selected <tt CLASS=literal>STDERR</tt> as a side effect.The first element of that list (the previously selected filehandle) is now usedas an argument to the outer <B>select</B>.Bizarre, right?  That's what you get for knowing just enough Lisp to bedangerous.<P CLASS=para>However, now that we've explained all that, we should point out that you rarelyneed to use this form of <B>select</B> nowadays,because most of the special variables you would want to set have object-orientedwrapper methods to do it for you.  So instead of setting <tt CLASS=literal>$|</tt>directly, you might say:<DIV CLASS=programlisting><P><PRE>use FileHandle;STDOUT-&gt;autoflush (1);</PRE></DIV><P CLASS=para>And the earlier format example might be coded as:<DIV CLASS=programlisting><P><PRE>use FileHandle;REPORT1-&gt;format_top_name("MyTop");REPORT2-&gt;format_top_name("MyTop");</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SELECT">select (ready file descriptors)</A></h3><DIV CLASS=programlisting><P><PRE>select <tt CLASS=replaceable><i>RBITS</i></tt>, <tt CLASS=replaceable><i>WBITS</i></tt>, <tt CLASS=replaceable><i>EBITS</i></tt>, <tt CLASS=replaceable><i>TIMEOUT</i></tt></PRE></DIV><P CLASS=para>The four-argument <B>select</B> operator is totally unrelated to thepreviously described operator.  This operator is for discovering which(if any) of your file descriptors are ready to do input or output, or toreport an exceptional condition.  (This helps you avoid having to dopolling.)  It calls the <I CLASS=emphasis>select</I> (2) system call with the bitmasksyou've specified, which you can construct using <A HREF="ch03_02.htm#PERL2-CMD-FILENO">fileno</A> and<A HREF="ch03_02.htm#PERL2-CMD-VEC">vec</A>, like this:<DIV CLASS=programlisting><P><PRE>$rin = $win = $ein = "";vec($rin, fileno(STDIN), 1) = 1;vec($win, fileno(STDOUT), 1) = 1;$ein = $rin | $win;</PRE></DIV><P CLASS=para>If you want to <B>select</B> on many filehandles youmight wish to write a subroutine:<DIV CLASS=programlisting><P><PRE>sub fhbits {    my @fhlist = @_;    my $bits;    for (@fhlist) {        vec($bits, fileno($_), 1) = 1;    }    return $bits;}$rin = fhbits(qw(STDIN TTY MYSOCK));</PRE></DIV><P CLASS=para>If you wish to use the same bitmasks repeatedly (and it's more efficientif you do), the usual idiom is:<DIV CLASS=programlisting><P><PRE>($nfound, $timeleft) =    select($rout=$rin, $wout=$win, $eout=$ein, $timeout);</PRE></DIV><P CLASS=para>Or to block until any file descriptor becomes ready:<DIV CLASS=programlisting><P><PRE>$nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);</PRE></DIV><P CLASS=para>The <tt CLASS=literal>$wout=$win</tt> trick works because the value of an assignment isits left side, so <tt CLASS=literal>$wout</tt> gets clobbered first by the assignment,and then by the <B>select</B>, while <tt CLASS=literal>$win</tt> remains unchanged.<P CLASS=para>Any of the bitmasks can also be <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A>.  Thetimeout, if specified, is in seconds, which may be fractional.  (A timeout of<tt CLASS=literal>0</tt> effects a poll.)  Not many implementations are capable ofreturning the <tt CLASS=literal>$timeleft</tt>.  If not, they always return<tt CLASS=literal>$timeleft</tt> equal to the supplied <tt CLASS=literal>$timeout</tt>.<P CLASS=para>One use for <B>select</B> is to sleep with a finerresolution than <A HREF="ch03_02.htm#PERL2-CMD-SLEEP">sleep</A> allows.  To do this,specify <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> for all the bitmasks. So, to sleep for (at least) 4.75 seconds, use:<DIV CLASS=programlisting><P><PRE>select undef, undef, undef, 4.75;</PRE></DIV><P CLASS=para>(On some non-UNIX systems this may not work, and you may need to fake upat least one bitmask for a valid descriptor that won't ever be ready.)<P CLASS=para>Mixing buffered I/O (like <A HREF="ch03_02.htm#PERL2-CMD-READ">read</A> or<tt CLASS=literal>&lt;HANDLE&gt;</tt>) with four-argument <B>select</B> is asking for trouble.  Use <A HREF="ch03_02.htm#PERL2-CMD-SYSREAD">sysread</A> instead.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SEMCTL">semctl</A></h3><DIV CLASS=programlisting><P><PRE>semctl <tt CLASS=replaceable><i>ID</i></tt>, <tt CLASS=replaceable><i>SEMNUM</i></tt>, <tt CLASS=replaceable><i>CMD</i></tt>, <tt CLASS=replaceable><i>ARG</i></tt></PRE></DIV><P CLASS=para>This function calls the System V IPC system call <I CLASS=emphasis>semctl</I> (2).  If<tt CLASS=replaceable><i>CMD</i></tt> is <tt CLASS=literal>&amp;IPC_STAT</tt> or <tt CLASS=literal>&amp;GETALL</tt>, then <tt CLASS=replaceable><i>ARG</i></tt> mustbe a variablewhich will hold the returned <tt CLASS=literal>semid_ds</tt> structure or semaphorevalue array.  The function returns like <A HREF="ch03_02.htm#PERL2-CMD-IOCTL">ioctl</A>: the undefinedvalue for error, "<tt CLASS=literal>0 but true</tt>" for zero, or the actual returnvalue otherwise.  On error, it puts the error code into <B>$!</B>.Before calling, you should say:<DIV CLASS=programlisting><P><PRE>require "ipc.ph";require "sem.ph";</PRE></DIV><P CLASS=para>This function is available only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SEMGET">semget</A></h3><DIV CLASS=programlisting><P><PRE>semget <tt CLASS=replaceable><i>KEY</i></tt>, <tt CLASS=replaceable><i>NSEMS</i></tt>, <tt CLASS=replaceable><i>SIZE</i></tt>, <tt CLASS=replaceable><i>FLAGS</i></tt></PRE></DIV><P CLASS=para>This function calls the System V IPC system call <I CLASS=emphasis>semget</I> (2).The function returns the semaphore ID, or theundefined value if there is an error.  On error, it puts the errorcode into <B>$!</B>.  Before calling, you should say:<DIV CLASS=programlisting><P><PRE>require "ipc.ph";require "sem.ph";</PRE></DIV><P CLASS=para>This function is available only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SEMOP">semop</A></h3><DIV CLASS=programlisting><P><PRE>semop <tt CLASS=replaceable><i>KEY</i></tt>, <tt CLASS=replaceable><i>OPSTRING</i></tt></PRE></DIV><P CLASS=para>This function calls the System V IPC system call <I CLASS=emphasis>semop</I> (2) to performsemaphore operations such as signaling and waiting.<tt CLASS=replaceable><i>OPSTRING</i></tt> must be a packed array of <tt CLASS=literal>semop</tt>structures.  You can make each <A HREF="ch03_02.htm#PERL2-CMD-SEMOP">semop</A> structure by saying<tt CLASS=literal>pack(`s*`, $semnum, $semop, $semflag)</tt>.  The number ofsemaphore operations is implied by the length of <tt CLASS=replaceable><i>OPSTRING</i></tt>.  Thefunction returns true if successful, or false if there is an error.On error, it puts the error code into <B>$!</B>.  Before calling, youshould say:<DIV CLASS=programlisting><P><PRE>require "ipc.ph";require "sem.ph";</PRE></DIV><P CLASS=para>The following code waits on semaphore <tt CLASS=literal>$semnum</tt> of semaphore id<tt CLASS=literal>$semid</tt>:<DIV CLASS=programlisting><P><PRE>$semop = pack "s*", $semnum, -1, 0;die "Semaphore trouble: $!\n" unless semop $semid, $semop;</PRE></DIV><P CLASS=para>To signal the semaphore, simply replace <tt CLASS=literal>-1</tt> with <tt CLASS=literal>1</tt>.<P CLASS=para>This function is available only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SEND">send</A></h3><DIV CLASS=programlisting><P><PRE>send <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>MSG</i></tt>, <tt CLASS=replaceable><i>FLAGS</i></tt>, <tt CLASS=replaceable><i>TO</i></tt>send <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>MSG</i></tt>, <tt CLASS=replaceable><i>FLAGS</i></tt></PRE></DIV><P CLASS=para>This function sends a message on a socket.It takes the same flags as the system call of the same name--see<I CLASS=emphasis>send</I> (2).  On unconnected sockets you must specify a destinationto send <tt CLASS=replaceable><i>TO</i></tt>, in which case <A HREF="ch03_02.htm#PERL2-CMD-SEND">send</A> works like<I CLASS=emphasis>sendto</I> (2).The function returns the number of bytes sent, orthe undefined value if there is an error.  On error, it puts the errorcode into <B>$!</B>.<P CLASS=para>(Some non-UNIX systems improperly treat sockets as different objects thanordinary file descriptors, with the result that you must always use <A HREF="ch03_02.htm#PERL2-CMD-SEND">send</A> and <A HREF="ch03_02.htm#PERL2-CMD-RECV">recv</A>on sockets rather than the handier standard I/O operators.)</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SETPGRP">setpgrp</A></h3><DIV CLASS=programlisting><P><PRE>setpgrp <tt CLASS=replaceable><i>PID</i></tt>, <tt CLASS=replaceable><i>PGRP</i></tt></PRE></DIV><P CLASS=para>This function sets the current process group (pgrp) for the specified<tt CLASS=replaceable><i>PID</i></tt> (use a <tt CLASS=replaceable><i>PID</i></tt> of 0 forthe current process).  Invoking <A HREF="ch03_02.htm#PERL2-CMD-SETPGRP">setpgrp</A> willproduce a fatal error if used on a machine that doesn't implement<I CLASS=emphasis>setpgrp</I> (2).  Beware: some systems will ignore thearguments you provide and always do <tt CLASS=literal>setpgrp(0, $$)</tt>.Fortunately, those are the arguments one usually provides.  (For betterportability (by some definition), use the <tt CLASS=literal>setpgid()</tt> function inthe POSIX module, or if you're really just trying to daemonize your script, considerthe <tt CLASS=literal>POSIX::setsid()</tt> function as well.)</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SETPRIORITY">setpriority</A></h3><DIV CLASS=programlisting><P><PRE>setpriority <tt CLASS=replaceable><i>WHICH</i></tt>, <tt CLASS=replaceable><i>WHO</i></tt>, <tt CLASS=replaceable><i>PRIORITY</i></tt></PRE></DIV><P CLASS=para>This function sets the current priority for a process, a processgroup, or a user.  See <I CLASS=emphasis>setpriority</I> (2).Invoking <A HREF="ch03_02.htm#PERL2-CMD-SETPRIORITY">setpriority</A> will produce a fatal error if used on amachine that doesn't implement <I CLASS=emphasis>setpriority</I> (2).  To "nice" yourprocess down by four units (the same as executing your program with<I CLASS=emphasis>nice</I> (1)), try:<DIV CLASS=programlisting><P><PRE>setpriority 0, 0, getpriority(0, 0) + 4;</PRE></DIV><P CLASS=para>The interpretation of a given priority may vary from one operating system tothe next.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SETSOCKOPT">setsockopt</A></h3><DIV CLASS=programlisting><P><PRE>setsockopt <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>LEVEL</i></tt>, <tt CLASS=replaceable><i>OPTNAME</i></tt>, <tt CLASS=replaceable><i>OPTVAL</i></tt></PRE></DIV><P CLASS=para>This function sets the socket option requested.The function returns undefined if there is an error.  <tt CLASS=replaceable><i>OPTVAL</i></tt> may bespecified as <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> if you don't want to pass an argument.A common option to set on a socket is <tt CLASS=literal>SO_REUSEADDR</tt>,to get around the problemof not being able to bind to a particular address while the previous TCPconnection on that port is still making up its mind to shut down.  Thatwould look like this:<DIV CLASS=programlisting><P><PRE>use Socket;...setsockopt(<tt CLASS=replaceable><i>MYSOCK</i></tt>, SOL_SOCKET, SO_REUSEADDR, 1)        or warn "Can't do setsockopt: $!\n";</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SHIFT">shift</A></h3><DIV CLASS=programlisting><P><PRE>shift <tt CLASS=replaceable><i>ARRAY</i></tt>shift</PRE></DIV><P CLASS=para>This function shifts the first value of the array off and returns it, shorteningthe array by 1 and moving everything down.  (Or up, or left, depending on howyou visualize the array list.)  If there are no elements in the array, thefunction returns the undefined value.  If <tt CLASS=replaceable><i>ARRAY</i></tt> isomitted, the function shifts <B>@ARGV</B> (in the mainprogram), or <B>@_</B> (in subroutines).  See also <A HREF="ch03_02.htm#PERL2-CMD-UNSHIFT">unshift</A>, <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A>,<A HREF="ch03_02.htm#PERL2-CMD-POP">pop</A>, and <A HREF="ch03_02.htm#PERL2-CMD-SPLICE">splice</A>.  The <A HREF="ch03_02.htm#PERL2-CMD-SHIFT">shift</A> and<A HREF="ch03_02.htm#PERL2-CMD-UNSHIFT">unshift</A> functions do the same thing to theleft end of an array that <A HREF="ch03_02.htm#PERL2-CMD-POP">pop</A> and <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A> do to the right end.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SHMCTL">shmctl</A></h3><DIV CLASS=programlisting><P><PRE>shmctl <tt CLASS=replaceable><i>ID</i></tt>, <tt CLASS=replaceable><i>CMD</i></tt>, <tt CLASS=replaceable><i>ARG</i></tt></PRE></DIV><P CLASS=para>This function calls the System V IPC system call,<I CLASS=emphasis>shmctl</I> (2).  If <tt CLASS=replaceable><i>CMD</i></tt> is <tt CLASS=literal>&amp;IPC_STAT</tt>, then <tt CLASS=replaceable><i>ARG</i></tt>must be avariable which will hold the returned <tt CLASS=literal>shmid_ds</tt> structure.  Thefunction returns like <A HREF="ch03_02.htm#PERL2-CMD-IOCTL">ioctl</A>: the undefined value for error,"<tt CLASS=literal>0 but true</tt>" for zero, or the actual return value otherwise.On error, it puts the error code into <B>$!</B>.  Before calling, youshould say:<DIV CLASS=programlisting><P><PRE>require "ipc.ph";require "shm.ph";</PRE></DIV><P CLASS=para>This function is available only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SHMGET">shmget</A></h3><DIV CLASS=programlisting><P><PRE>shmget <tt CLASS=replaceable><i>KEY</i></tt>, <tt CLASS=replaceable><i>SIZE</i></tt>, <tt CLASS=replaceable><i>FLAGS</i></tt></PRE></DIV><P CLASS=para>This function calls the System V IPC system call,<I CLASS=emphasis>shmget</I> (2).  The function returns the shared memory segment ID,or the undefined value if there is an error.  On error, it puts theerror code into <B>$!</B>.  Before calling, you should say:<DIV CLASS=programlisting><P><PRE>require "ipc.ph";require "shm.ph";</PRE></DIV><P CLASS=para>This function is available only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SHMREAD">shmread</A></h3><DIV CLASS=programlisting><P><PRE>shmread <tt CLASS=replaceable><i>ID</i></tt>, <tt CLASS=replaceable><i>VAR</i></tt>, <tt CLASS=replaceable><i>POS</i></tt>, <tt CLASS=replaceable><i>SIZE</i></tt></PRE></DIV><P CLASS=para>This function reads from the shared memory segment <tt CLASS=replaceable><i>ID</i></tt> starting atposition <tt CLASS=replaceable><i>POS</i></tt> for size <tt CLASS=replaceable><i>SIZE</i></tt> (by attaching to it, copying out, anddetaching from it).  <tt CLASS=replaceable><i>VAR</i></tt> must be a variable that will hold the dataread.  The function returns true if successful, or false if there isan error.  On error, it puts the error code into <B>$!</B>.  Thisfunction is available only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SHMWRITE">shmwrite</A></h3><DIV CLASS=programlisting><P><PRE>shmwrite <tt CLASS=replaceable><i>ID</i></tt>, <tt CLASS=replaceable><i>STRING</i></tt>, <tt CLASS=replaceable><i>POS</i></tt>, <tt CLASS=replaceable><i>SIZE</i></tt></PRE></DIV><P CLASS=para>This function writes to the shared memory segment ID starting atposition <tt CLASS=replaceable><i>POS</i></tt> for size <tt CLASS=replaceable><i>SIZE</i></tt> (by attaching to it, copying in, anddetaching from it).  If <tt CLASS=replaceable><i>STRING</i></tt> is too long, only <tt CLASS=replaceable><i>SIZE</i></tt>bytes are used;if <tt CLASS=replaceable><i>STRING</i></tt> is too short, nulls are written to fill out <tt CLASS=replaceable><i>SIZE</i></tt>bytes.  Thefunction returns true if successful, or false if there is an error.On error, it puts the error code into <B>$!</B>.  This function isavailable only on machines supporting System V IPC.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SHUTDOWN">shutdown</A></h3><DIV CLASS=programlisting><P><PRE>shutdown <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>HOW</i></tt></PRE></DIV><P CLASS=para>This function shuts down a socket connection in the manner indicated by<tt CLASS=replaceable><i>HOW</i></tt>.  If <tt CLASS=replaceable><i>HOW</i></tt> is 0, further receives are disallowed.  If<tt CLASS=replaceable><i>HOW</i></tt> is 1, further sends are disallowed.  If <tt CLASS=replaceable><i>HOW</i></tt> is 2,everything is disallowed.<P CLASS=para>(If you came here trying to figure out how to shut down your system, you'll haveto execute an external program to do that.  See <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A>.)</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SIN">sin</A></h3><DIV CLASS=programlisting><P><PRE>sin <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>Sorry, there's nothing wicked about this operator.  It merely returns the sineof <tt CLASS=replaceable><i>EXPR</i></tt> (expressed in radians).  If<tt CLASS=replaceable><i>EXPR</i></tt> is omitted, it returns sine of <B>$_</B>.<P CLASS=para>For the inverse sine operation, you may use the <tt CLASS=literal>POSIX::asin()</tt>function, or use this relation:<DIV CLASS=programlisting><P><PRE>sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SLEEP">sleep</A></h3><DIV CLASS=programlisting><P><PRE>sleep <tt CLASS=replaceable><i>EXPR</i></tt>sleep</PRE></DIV><P CLASS=para>This function causes the script to sleep for <tt CLASS=replaceable><i>EXPR</i></tt>seconds, or forever if no <tt CLASS=replaceable><i>EXPR</i></tt>.  It may beinterrupted by sending the process a <tt CLASS=literal>SIGALRM</tt>.  The functionreturns the number of seconds actually slept.  On some systems, the functionsleeps till the "top of the second," so, for instance, a <tt CLASS=literal>sleep1</tt> may sleep anywhere from 0 to 1 second, depending on when in thecurrent second you started sleeping.  A <tt CLASS=literal>sleep 2</tt> may sleepanywhere from 1 to 2 seconds.  And so on.  If available, the <B>select</B> (ready file descriptors) call can give you betterresolution.  You may also be able to use <A HREF="ch03_02.htm#PERL2-CMD-SYSCALL">syscall</A> to call the<I CLASS=emphasis>getitimer</I> (2) and<I CLASS=emphasis>setitimer</I> (2) routines that some UNIX systemssupport.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SOCKET">socket</A></h3><DIV CLASS=programlisting><P><PRE>socket <tt CLASS=replaceable><i>SOCKET</i></tt>, <tt CLASS=replaceable><i>DOMAIN</i></tt>, <tt CLASS=replaceable><i>TYPE</i></tt>, <tt CLASS=replaceable><i>PROTOCOL</i></tt></PRE></DIV><P CLASS=para>This function opens a socket of the specified kind and attaches it tofilehandle <tt CLASS=replaceable><i>SOCKET</i></tt>.  <tt CLASS=replaceable><i>DOMAIN</i></tt>, <tt CLASS=replaceable><i>TYPE</i></tt>, and<tt CLASS=replaceable><i>PROTOCOL</i></tt> are specified the sameas for <I CLASS=emphasis>socket</I> (2).  Before using this function, your program shouldcontain the line:<DIV CLASS=programlisting><P><PRE>use Socket;</PRE></DIV><P CLASS=para>This gives you the proper constants.  The function returns trueif successful.  See the examples in the section "Sockets" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SOCKETPAIR">socketpair</A></h3><DIV CLASS=programlisting><P><PRE>socketpair <tt CLASS=replaceable><i>SOCKET1</i></tt>, <tt CLASS=replaceable><i>SOCKET2</i></tt>, <tt CLASS=replaceable><i>DOMAIN</i></tt>, <tt CLASS=replaceable><i>TYPE</i></tt>, <tt CLASS=replaceable><i>PROTOCOL</i></tt></PRE></DIV><P CLASS=para>This function creates an unnamed pair of sockets in the specifieddomain, of the specified type.  <tt CLASS=replaceable><i>DOMAIN</i></tt>, <tt CLASS=replaceable><i>TYPE</i></tt>, and<tt CLASS=replaceable><i>PROTOCOL</i></tt> arespecified the same as for <I CLASS=emphasis>socketpair</I> (2).  If <I CLASS=emphasis>socketpair</I> (2)is unimplemented,invoking this function yields a fatal error.  The function returnstrue if successful.<P CLASS=para>This function is typically used just before a <B>fork</B>.  One of the resulting processes should close<tt CLASS=replaceable><i>SOCKET1</i></tt>, and the other should close<tt CLASS=replaceable><i>SOCKET2</i></tt>.  You can use these sockets bidirectionally,unlike the filehandles created by the <A HREF="ch03_02.htm#PERL2-CMD-PIPE">pipe</A>function.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SORT">sort</A></h3><DIV CLASS=programlisting><P><PRE>sort <tt CLASS=replaceable><i>SUBNAME</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>sort <tt CLASS=replaceable><i>BLOCK</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>sort <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function sorts the <tt CLASS=replaceable><i>LIST</i></tt> and returns the sortedlist value.  By default, it sorts in standard string comparison order (undefinedvalues sorting before defined null strings, which sort before everything else).<tt CLASS=replaceable><i>SUBNAME</i></tt>, if given, is the name of a subroutine thatreturns an integer less than, equal to, or greater than 0, depending on how theelements of the list are to be ordered.  (The handy <tt CLASS=literal>&lt;=&gt;</tt>and <tt CLASS=literal>cmp</tt> operators can be used to perform three-way numericand string comparisons.)  In the interests of efficiency, the normal callingcode for subroutines is bypassed, with the following effects: the subroutine maynot be a recursive subroutine, and the two elements to be compared are passedinto the subroutine not via <tt CLASS=literal>@_</tt> but as <B>$a</B> and <B>$b</B> (see the examplesbelow).  The variables <B>$a</B> and <B>$b</B> are passed by reference, so don't modify them in thesubroutine.  <tt CLASS=replaceable><i>SUBNAME</i></tt> may be a scalar variable name(unsubscripted), in which case the value provides the name of (or a referenceto) the actual subroutine to use.  In place of a<tt CLASS=replaceable><i>SUBNAME</i></tt>, you can provide a<tt CLASS=replaceable><i>BLOCK</i></tt> as an anonymous, in-line sort subroutine.<P CLASS=para>To do an ordinary numeric sort, say this:<DIV CLASS=programlisting><P><PRE>sub numerically { $a &lt;=&gt; $b; }@sortedbynumber = sort numerically 53,29,11,32,7;</PRE></DIV><P CLASS=para>To sort in descending order, simply reverse the <tt CLASS=literal>$a</tt>and <tt CLASS=literal>$b</tt>. To sort a list value by some associated value, use a hashlookup in the sort routine:<DIV CLASS=programlisting><P><PRE>sub byage {    $age{$a} &lt;=&gt; $age{$b};}@sortedclass = sort byage @class;</PRE></DIV><P CLASS=para>As an extension of that notion, you can cascade several differentcomparisons using the handy comparison operators, which work nicely forthis because when they return <tt CLASS=literal>0</tt> they fall through to the nextcase.  The routine below sorts to the front of the list those people who arefirst richer, then taller, then younger, then less alphabeticallychallenged.  We also put a final comparison between <tt CLASS=literal>$a</tt> and<tt CLASS=literal>$b</tt> to make sure the ordering is always well defined.<DIV CLASS=programlisting><P><PRE>sub prospects {    $money{$b} &lt;=&gt; $money{$a}       or    $height{$b} &lt;=&gt; $height{$a}       or    $age{$a} &lt;=&gt; $age{$b}       or    $lastname{$a} cmp $lastname{$b}       or    $a cmp $b;}@sortedclass = sort prospects @class;</PRE></DIV><P CLASS=para>To sort fields without regard to case, say:<DIV CLASS=programlisting><P><PRE>@sorted = sort { lc($a) cmp lc($b) } @unsorted;</PRE></DIV><P CLASS=para>And finally, note the equivalence of the two ways to sort inreverse:<DIV CLASS=programlisting><P><PRE>sub backwards { $b cmp $a; }@harry = qw(dog cat x Cain Abel);@george = qw(gone chased yz Punished Axed);print sort @harry;                   # prints AbelCaincatdogxprint sort backwards @harry;         # prints xdogcatCainAbelprint reverse sort @harry;           # prints xdogcatCainAbelprint sort @george, "to", @harry;    # Remember, it's one LIST.        # prints AbelAxedCainPunishedcatchaseddoggonetoxyz</PRE></DIV><P CLASS=para>Do not declare <B>$a</B> and <B>$b</B> as lexicalvariables (with <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>). They are packageglobals (though they're exempt from the usual restrictions on globals whenyou're using <tt CLASS=literal>use strict</tt>).  You do need to make sure your sortroutine is in the same package though, or qualify <tt CLASS=literal>$a</tt> and<tt CLASS=literal>$b</tt> with the package name of the caller.<P CLASS=para>One last caveat. Perl's <A HREF="ch03_02.htm#PERL2-CMD-SORT">sort</A> isimplemented in terms of C's <I CLASS=emphasis>qsort</I> (3) function.Some <I CLASS=emphasis>qsort</I> (3) versions will dump core if yoursort subroutine provides inconsistent ordering of values.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SPLICE">splice</A></h3><DIV CLASS=programlisting><P><PRE>splice <tt CLASS=replaceable><i>ARRAY</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt>splice <tt CLASS=replaceable><i>ARRAY</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt>splice <tt CLASS=replaceable><i>ARRAY</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt></PRE></DIV><P CLASS=para>This function removes the elements designated by <tt CLASS=replaceable><i>OFFSET</i></tt> and<tt CLASS=replaceable><i>LENGTH</i></tt>from an array, and replaces them with the elements of <tt CLASS=replaceable><i>LIST</i></tt>, if any.The function returns the elements removed from the array.  The arraygrows or shrinks as necessary.If <tt CLASS=replaceable><i>LENGTH</i></tt> is omitted, the function removes everything from<tt CLASS=replaceable><i>OFFSET</i></tt>onward.  The following equivalences hold (assuming <B>$[</B> is 0):<DIV CLASS=informaltable><P><A NAME="PERL2-CH-3-TAB-4"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Direct Method</TH><TH ALIGN="left">Splice Equivalent</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>push(@a, $x, $y)</tt></TD><TD ALIGN="left"><tt CLASS=literal>splice(@a, $#a+1, 0, $x, $y)</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>pop(@a)</tt></TD><TD ALIGN="left"><tt CLASS=literal>splice(@a, -1)</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>shift(@a)</tt></TD><TD ALIGN="left"><tt CLASS=literal>splice(@a, 0, 1)</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>unshift(@a, $x, $y)</tt></TD><TD ALIGN="left"><tt CLASS=literal>splice(@a, 0, 0, $x, $y)</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>$a[$x] = $y</tt></TD><TD ALIGN="left"><tt CLASS=literal>splice(@a, $x, 1, $y);</tt></TD></TR></TABLE><P></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-SPLICE">splice</A> function is also handy forcarving up the argument list passed to a subroutine.  For example, assuming listlengths are passed before lists:<DIV CLASS=programlisting><P><PRE>sub list_eq {       # compare two list values    my @a = splice(@_, 0, shift);    my @b = splice(@_, 0, shift);    return 0 unless @a == @b;       # same len?    while (@a) {        return 0 if pop(@a) ne pop(@b);    }    return 1;}if (list_eq($len, @foo[1..$len], scalar(@bar), @bar)) { ... }</PRE></DIV><P CLASS=para>It would probably be cleaner just to use references for this, however.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SPLIT">split</A></h3><DIV CLASS=programlisting><P><PRE>split /<tt CLASS=replaceable><i>PATTERN</i></tt>/, <tt CLASS=replaceable><i>EXPR</i></tt>, <tt CLASS=replaceable><i>LIMIT</i></tt>split /<tt CLASS=replaceable><i>PATTERN</i></tt>/, <tt CLASS=replaceable><i>EXPR</i></tt>split /<tt CLASS=replaceable><i>PATTERN</i></tt>/split</PRE></DIV><P CLASS=para><A NAME="CH03.SPLIT"></A><A NAME="CH03.STRSPL"></A><A NAME="CH03.PAT"></A>This function scans a string given by <tt CLASS=replaceable><i>EXPR</i></tt> for delimiters, andsplits the string into a list of substrings, returning the resultinglist value in list context, or the count of substrings in scalarcontext. The delimiters are determined by repeated pattern matching,using the regular expression given in <tt CLASS=replaceable><i>PATTERN</i></tt>, so the delimitersmay be of any size, and need not be the same string on every match.(The delimiters are not ordinarily returned, but see below.)  If the<tt CLASS=replaceable><i>PATTERN</i></tt> doesn't match at all, <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> returns the originalstring as a single substring.  If it matches once, you get twosubstrings, and so on.<P CLASS=para>If <tt CLASS=replaceable><i>LIMIT</i></tt> is specified and is not negative, the function splits into nomore than that many fields (though it may split into fewer if it runs out ofdelimiters).  If <tt CLASS=replaceable><i>LIMIT</i></tt> is negative, it istreated as if an arbitrarily large <tt CLASS=replaceable><i>LIMIT</i></tt> hasbeen specified.  If <tt CLASS=replaceable><i>LIMIT</i></tt> is omitted, trailing nullfields are stripped from the result (which potential users of <A HREF="ch03_02.htm#PERL2-CMD-POP">pop</A> would do well to remember).  If<tt CLASS=replaceable><i>EXPR</i></tt> is omitted, the function splits the <B>$_</B> string.  If <tt CLASS=replaceable><i>PATTERN</i></tt> is alsoomitted, the function splits on whitespace, <tt CLASS=literal>/\s+/</tt>, afterskipping any leading whitespace.<P CLASS=para>Strings of any length can be split:<DIV CLASS=programlisting><P><PRE>@chars = split //, $word;@fields = split /:/, $line;@words = split ' ', $paragraph;@lines = split /^/m, $buffer;</PRE></DIV><P CLASS=para>A pattern capable of matching either the null string or something longer thanthe null string (for instance, a pattern consisting ofany single character modified by a <tt CLASS=literal>*</tt> or <tt CLASS=literal>?</tt>) will split thevalue of <tt CLASS=replaceable><i>EXPR</i></tt>into separate characters wherever it is the null string thatproduces the match; non-null matches will skip over occurrences of thedelimiter in the usual fashion.  (In other words, a pattern won't matchin one spot more than once, even if it matched with a zero width.)For example:<DIV CLASS=programlisting><P><PRE>print join ':', split / */, 'hi there';</PRE></DIV><P CLASS=para>produces the output <tt CLASS=literal>"h:i:t:h:e:r:e"</tt>.The space disappears because it matched as part of the delimiter.As a trivial case, the nullpattern <B>//</B> simply splits into separatecharacters (and spaces do not disappear).<P CLASS=para>The <tt CLASS=replaceable><i>LIMIT</i></tt> parameter is used to split only part of a string:<DIV CLASS=programlisting><P><PRE>($login, $passwd, $remainder) = split /:/, $_, 3;</PRE></DIV><P CLASS=para>We encourage you to split to lists of names like this in order to make your codeself-documenting.  (For purposes of error checking, note that<tt CLASS=literal>$remainder</tt> would be undefined if there were fewer than threefields.)  When assigning to a list, if <tt CLASS=replaceable><i>LIMIT</i></tt> isomitted, Perl supplies a <tt CLASS=replaceable><i>LIMIT</i></tt> one larger than thenumber of variables in the list, to avoid unnecessary work.  For the splitabove, <tt CLASS=replaceable><i>LIMIT</i></tt> would have been 4 by default, and<tt CLASS=literal>$remainder</tt> would have received only the third field, not allthe rest of the fields.  In time-critical applications it behooves you not tosplit into more fields than you really need.<P CLASS=para>We said earlier that the delimiters are not returned, but ifthe <tt CLASS=replaceable><i>PATTERN</i></tt> contains parentheses, then the substring matchedby each pair of parentheses is included in the resulting list,interspersed with the fields that are ordinarily returned.Here's a simple case:<DIV CLASS=programlisting><P><PRE>split /([-,])/, "1-10,20";</PRE></DIV><P CLASS=para>produces the list value:<DIV CLASS=programlisting><P><PRE>(1, '-', 10, ',', 20)</PRE></DIV><P CLASS=para>With more parentheses, a field is returned for each pair, even if someof the pairs don't match, in which case undefined values are returnedin those positions.  So if you say:<DIV CLASS=programlisting><P><PRE>split /(-)|(,)/, "1-10,20";</PRE></DIV><P CLASS=para>you get the value:<DIV CLASS=programlisting><P><PRE>(1, '-', undef, 10, undef, ',', 20)</PRE></DIV><P CLASS=para>The <tt CLASS=literal>/</tt><tt CLASS=replaceable><i>PATTERN</i></tt><tt CLASS=literal>/</tt>argument may be replaced with an expression to specify patterns that vary atrun-time.  (To do run-time compilation only once, use<tt CLASS=literal>/$variable/o</tt>.)  As a special case, specifying a space<tt CLASS=literal>` `</tt> will split on whitespace just as <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> with no arguments does.  Thus, <tt CLASS=literal>split(``)</tt> can be used to emulate <I CLASS=emphasis>awk</I> 's defaultbehavior, whereas <tt CLASS=literal>split(/ /)</tt> will give you as many nullinitial fields as there are leading spaces.  (Other than this special case, ifyou supply a string instead of a regular expression, it'll be interpreted as aregular expression anyway.)<P CLASS=para>The following example splits an RFC-822 message header into a hashcontaining <tt CLASS=literal>$head{Date}</tt>, <tt CLASS=literal>$head{Subject}</tt>, and so on.  Ituses the trick of assigning a list of pairs to a hash, based on the factthat delimiters alternate with delimited fields.  It makes use ofparentheses to return part of each delimiter as part of the returnedlist value.  Since the <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> pattern is guaranteed to returnthings in pairs by virtue of containing one set of parentheses, the hashassignment is guaranteed to receive a list consisting of key/valuepairs, where each key is the name of a header field.  (Unfortunatelythis technique loses information for multiple lines with the same keyfield, such as Received-By lines.  Ah, well. . . .)<DIV CLASS=programlisting><P><PRE>$header =~ s/\n\s+/ /g;      # Merge continuation lines.%head = ('FRONTSTUFF', split /^([-\w]+):/m, $header);</PRE></DIV><P CLASS=para>The following example processes the entries in a UNIX<I CLASS=emphasis>passwd</I> file.  You could leave out the <A HREF="ch03_02.htm#PERL2-CMD-CHOP">chop</A>, in which case <tt CLASS=literal>$shell</tt> would have anewline on the end of it.<DIV CLASS=programlisting><P><PRE>open PASSWD, '/etc/passwd';while (&lt;PASSWD&gt;) {    chop;        # remove trailing newline    ($login, $passwd, $uid, $gid, $gcos, $home, $shell) =            split /:/;    ...}</PRE></DIV><P CLASS=para>The inverse of <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> is performed by <A HREF="ch03_02.htm#PERL2-CMD-JOIN">join</A> (except that <A HREF="ch03_02.htm#PERL2-CMD-JOIN">join</A> can only join with the same delimiter between allfields).  To break apart a string with fixed-position fields, use <A HREF="ch03_02.htm#PERL2-CMD-UNPACK">unpack</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SPRINTF">sprintf</A></h3><DIV CLASS=programlisting><P><PRE>sprintf <tt CLASS=replaceable><i>FORMAT</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function returns a string formatted by the usual <A HREF="ch03_02.htm#PERL2-CMD-PRINTF">printf</A>conventions.  The <tt CLASS=replaceable><i>FORMAT</i></tt> string contains text with embedded fieldspecifiers into which the elements of <tt CLASS=replaceable><i>LIST</i></tt> are substituted, one perfield.  Field specifiers are roughly of the form:<DIV CLASS=programlisting><P><PRE>%<tt CLASS=replaceable><i>m.nx</i></tt></PRE></DIV><P CLASS=para>where the <tt CLASS=replaceable><i>m</i></tt> and <tt CLASS=replaceable><i>n</i></tt> areoptional sizes whose interpretation depends on the type of field, and<tt CLASS=replaceable><i>x</i></tt> is one of:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-3-TAB-5"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Code</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>c</tt></TD><TD ALIGN="left">Character</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>d</tt></TD><TD ALIGN="left">Decimal integer</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>e</tt></TD><TD ALIGN="left">Exponential format floating-point number</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>f</tt></TD><TD ALIGN="left">Fixed point format floating-point number</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>g</tt></TD><TD ALIGN="left">Compact format floating-point number</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>ld</tt></TD><TD ALIGN="left">Long decimal integer</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>lo</tt></TD><TD ALIGN="left">Long octal integer</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>lu</tt></TD><TD ALIGN="left">Long unsigned decimal integer</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>lx</tt></TD><TD ALIGN="left">Long hexadecimal integer</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>o</tt></TD><TD ALIGN="left">Octal integer</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>s</tt></TD><TD ALIGN="left">String</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>u</tt></TD><TD ALIGN="left">Unsigned decimal integer</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>x</tt></TD><TD ALIGN="left">Hexadecimal integer</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>X</tt></TD><TD ALIGN="left">Hexadecimal integer with upper-case letters</TD></TR></TABLE><P></DIV><P CLASS=para>The various combinations are fully documented in the manpage for<I CLASS=emphasis>printf (3)</I>, but we'll mention that<tt CLASS=replaceable><i>m</i></tt> is typically the minimum length of the field(negative for left justified), and <tt CLASS=replaceable><i>n</i></tt> is precision forexponential formats and the maximum length for other formats.  Padding istypically done with spaces for strings and zeroes for numbers.  The<tt CLASS=literal>*</tt> character as a length specifier is not supported. But,you can easily get around this by including the length expression directly into<tt CLASS=replaceable><i>FORMAT</i></tt>, as in:<DIV CLASS=programlisting><P><PRE>$width = 20; $value = sin 1.0;foreach $precision (0..($width-2)) {    printf "%${width}.${precision}f\n", $value;}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SQRT">sqrt</A></h3><DIV CLASS=programlisting><P><PRE>sqrt <tt CLASS=replaceable><i>EXPR</i></tt>sqrt</PRE></DIV><P CLASS=para>This function returns the square root of <tt CLASS=replaceable><i>EXPR</i></tt>.  If <tt CLASS=replaceable><i>EXPR</i></tt>is omitted, itreturns the square root of <B>$_</B>.For other roots such as cube roots, you can use the <tt CLASS=literal>**</tt> operatorto raise something to a fractional power.[8]<blockquote class=footnote><P CLASS=para>[8] Don't try either of these approaches with negative numbers, as that poses a slightly more complex problem.</blockquote></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SRAND">srand</A></h3><DIV CLASS=programlisting><P><PRE>srand <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function sets the random number seed for the <A HREF="ch03_02.htm#PERL2-CMD-RAND">rand</A> operator.  If <tt CLASS=replaceable><i>EXPR</i></tt> isomitted, it does <tt CLASS=literal>srand(time)</tt>, which is pretty predictable, sodon't use it for security-type things, such as random password generation. Trysomething like this instead:[9]<blockquote class=footnote><P CLASS=para>[9]  Frequently called programs (likeCGI scripts) that simply use<DIV CLASS=programlisting><P><PRE>time ^ $$</PRE></DIV><P CLASS=para>for a seed can fall prey to the mathematical property that<DIV CLASS=programlisting><P><PRE>a^b == (a+1)^(b+1)</PRE></DIV><P CLASS=para>one-third of the time.  If you're particularly concerned with this, see the Math::TrulyRandommodule in CPAN.</blockquote><DIV CLASS=programlisting><P><PRE>srand( time() ^ ($$ + ($$ &lt;&lt; 15)) );</PRE></DIV><P CLASS=para>Of course, you'd need something much more random than that forserious cryptographic purposes, since it's easy to guess the current time.Checksumming the compressed output of one or more rapidly changing operatingsystem status programs is the usual method. For example:<DIV CLASS=programlisting><P><PRE>srand (time ^ $$ ^ unpack "%32L*", `ps axww | gzip`);</PRE></DIV><P CLASS=para>Do <I CLASS=emphasis>not</I> call <A HREF="ch03_02.htm#PERL2-CMD-SRAND">srand</A>multiple times in your program unless you know exactly what you're doing and whyyou're doing it.  The point of the function is to "seed" the <A HREF="ch03_02.htm#PERL2-CMD-RAND">rand</A> function so that <A HREF="ch03_02.htm#PERL2-CMD-RAND">rand</A> can produce a different sequence each time you runyour program.  Just do it once at the top of your program, or you won't getrandom numbers out of <A HREF="ch03_02.htm#PERL2-CMD-RAND">rand</A>!</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-STAT">stat</A></h3><DIV CLASS=programlisting><P><PRE>stat <tt CLASS=replaceable><i>FILEHANDLE</i></tt>stat <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns a 13-element list giving the statistics for afile, either the file opened via <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, or named by <tt CLASS=replaceable><i>EXPR</i></tt>.It's typically used as follows:<DIV CLASS=programlisting><P><PRE>($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,    $atime,$mtime,$ctime,$blksize,$blocks)            = stat $filename;</PRE></DIV><P CLASS=para>Not all fields are supported on all filesystem types.Here are the meanings of the fields:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-3-TAB-6"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Field</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>dev</tt></TD><TD ALIGN="left">Device number of filesystem </TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>ino</tt></TD><TD ALIGN="left">Inode number</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>mode</tt></TD><TD ALIGN="left">File mode  (type and permissions)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>nlink</tt></TD><TD ALIGN="left">Number of (hard) links to the file </TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>uid</tt></TD><TD ALIGN="left">Numeric user ID of file's owner </TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>gid</tt></TD><TD ALIGN="left">Numeric group ID of file's owner </TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>rdev</tt></TD><TD ALIGN="left">The device identifier (special files only)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>size</tt></TD><TD ALIGN="left">Total size of file, in bytes </TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>atime</tt></TD><TD ALIGN="left">Last access time since the epoch</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>mtime</tt></TD><TD ALIGN="left">Last modify time since the epoch</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>ctime</tt></TD><TD ALIGN="left">Inode change time (NOT creation time!) since the epoch</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>blksize</tt></TD><TD ALIGN="left">Preferred blocksize for file system I/O</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>blocks</tt></TD><TD ALIGN="left">Actual number of blocks allocated</TD></TR></TABLE><P></DIV><P CLASS=para><tt CLASS=literal>$dev</tt> and <tt CLASS=literal>$ino</tt>, taken together, uniquelyidentify a file.  The <tt CLASS=literal>$blksize</tt> and <tt CLASS=literal>$blocks</tt>are likely defined only on BSD-derived filesystems.  The<tt CLASS=literal>$blocks</tt> field (if defined) is reported in 512-byte blocks.Note that <tt CLASS=literal>$blocks*512</tt> can differ greatly from<tt CLASS=literal>$size</tt> for files containing unallocated blocks, or "holes",which aren't counted in <tt CLASS=literal>$blocks</tt>.<P CLASS=para>If <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A> is passed the special filehandleconsisting of an underline, no actual <I CLASS=emphasis>stat</I> (2) is done, but the current contents ofthe stat structure from the last <B>stat</B> or <B>stat</B>-based file test (the <tt CLASS=literal>-x</tt> operators) are returned.<P CLASS=para>The following example first stats <tt CLASS=literal>$file</tt> to see whether it isexecutable.  If it is, it then pulls the device number out of the existing statstructure and tests it to see whether it looks like a Network File System(NFS). Such filesystems tend to have negative device numbers.<DIV CLASS=programlisting><P><PRE>if (-x $file and ($d) = stat(_) and $d &lt; 0) {    print "$file is executable NFS file\n";}</PRE></DIV><P CLASS=para>Hint: if you need only the size of the file, check out the <tt CLASS=literal>-s</tt> file test operator, which returns the size inbytes directly.  There are also file tests that return the ages of files indays.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-STUDY">study</A></h3><DIV CLASS=programlisting><P><PRE>study <tt CLASS=replaceable><i>SCALAR</i></tt>study</PRE></DIV><P CLASS=para>This function takes extra time to study <tt CLASS=replaceable><i>SCALAR</i></tt>(<B>$_</B> ifunspecified) in anticipation of doing many pattern matches on thestring before it is next modified.  This may or may not save time,depending on the nature and number of patterns you are searching on,and on the distribution of character frequencies in the string to besearched--you probably want to compare run-times with and without it tosee which runs faster.  Those loops that scan for many short constantstrings (including the constant parts of more complex patterns) willbenefit most.  If all your pattern matches are constant strings,anchored at the front, <A HREF="ch03_02.htm#PERL2-CMD-STUDY">study</A> won't help at all, because noscanning is done.  You may have only one <A HREF="ch03_02.htm#PERL2-CMD-STUDY">study</A> active at a time--ifyou study a different scalar the first is "unstudied".<P CLASS=para>The way <A HREF="ch03_02.htm#PERL2-CMD-STUDY">study</A>works is this: a linked list of every character in the string to besearched is made, so we know, for example, where all the "<tt CLASS=literal>k</tt>"characters are.  From each search string, the rarest character isselected, based on some static frequency tables constructed from someC programs and English text.  Only those places that contain this rarest character are examined.<P CLASS=para>For example, here is a loop that inserts index-producing entriesbefore any line containing a certain pattern:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    study;    print ".IX foo\n" if /\bfoo\b/;    print ".IX bar\n" if /\bbar\b/;    print ".IX blurfl\n" if /\bblurfl\b/;    ...    print;}</PRE></DIV><P CLASS=para>In searching for <tt CLASS=literal>/\bfoo\b/</tt>, only those locations in <B>$_</B> that contain "<tt CLASS=literal>f</tt>" will be looked at,because "<tt CLASS=literal>f</tt>" is rarer than "<tt CLASS=literal>o</tt>".  Ingeneral, this is a big win except in pathological cases.  The only question iswhether it saves you more time than it took to build the linked list in thefirst place.<P CLASS=para>If you have to look for strings that you don't know until run-time, you canbuild an entire loop as a string and <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>that to avoid recompiling all your patterns all the time.  Together with setting<B>$/</B> to input entire files as one record, this canbe very fast, often faster than specialized programs like<I CLASS=emphasis>fgrep</I>.  The following scans a list of files(<tt CLASS=literal>@files</tt>) for a list of words (<tt CLASS=literal>@words</tt>), andprints out the names of those files that contain a match:<DIV CLASS=programlisting><P><PRE>$search = 'while (&lt;&gt;) { study;';foreach $word (@words) {    $search .= "++\$seen{\$ARGV} if /\\b$word\\b/;\n";}$search .= "}";@ARGV = @files;undef $/;               # slurp each entire fileeval $search;           # this screamsdie $@ if $@;           # in case eval failed$/ = "\n";              # put back to normal input delimforeach $file (sort keys(%seen)) {    print $file, "\n";}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SUB">sub</A></h3><DIV CLASS=programlisting><P><PRE>sub <tt CLASS=replaceable><i>NAME</i></tt> <tt CLASS=replaceable><i>BLOCK</i></tt>sub <tt CLASS=replaceable><i>NAME</i></tt>sub <tt CLASS=replaceable><i>BLOCK</i></tt>sub <tt CLASS=replaceable><i>NAME</i></tt> <tt CLASS=replaceable><i>PROTO</i></tt> <tt CLASS=replaceable><i>BLOCK</i></tt>sub <tt CLASS=replaceable><i>NAME</i></tt> <tt CLASS=replaceable><i>PROTO</i></tt>sub <tt CLASS=replaceable><i>PROTO</i></tt> <tt CLASS=replaceable><i>BLOCK</i></tt></PRE></DIV><P CLASS=para>The first two of these are not really operators, but rather theydeclare the existence of named subroutines, which is why thesyntax includes a <tt CLASS=replaceable><i>NAME</i></tt>, after all.  (As declarations, theyreturn no value.)  The first one additionally defines thesubroutine with a <tt CLASS=replaceable><i>BLOCK</i></tt>, which contains the code for thesubroutine.  The second one (the one without the <tt CLASS=replaceable><i>BLOCK</i></tt>) isjust a forward declaration, that is, a declaration that introduces thesubroutine name without defining it, with the expectation that the realdefinition will come later.  (This is useful because the parser treats aword specially if it knows it's a user-defined subroutine.  You can callsuch a subroutine as if it were a list operator, for instance.)<P CLASS=para>The third form really <I CLASS=emphasis>is</I> an operator, in that it can beused within expressions to generate an anonymous subroutine at run-time.  (Morespecifically, it returns a reference to an anonymous subroutine, since you can'ttalk about something anonymous without some kind of reference to it.)  If theanonymous subroutine refers to any lexical variables declared outside its<tt CLASS=replaceable><i>BLOCK</i></tt>, it functions as a<I CLASS=emphasis>closure</I>, which means that different calls to the same <A HREF="ch03_02.htm#PERL2-CMD-SUB">sub</A> operator will do the bookkeeping necessary tokeep the correct "version" of each such lexical variable in sight for the lifeof the closure, even if the original scope of the lexical variable has beendestroyed.<P CLASS=para>The final three forms are identical to the first three, except that theyalso supply a prototype that lets you specify how calls to yoursubroutine should be parsed and analyzed, so you can make yourroutines act more like some of Perl's built-in functions.  See"Subroutines" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A> and "Anonymous Subroutines" in <A HREF="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>for more details.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SUBSTR">substr</A></h3><DIV CLASS=programlisting><P><PRE>substr <tt CLASS=replaceable><i>EXPR</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt>substr <tt CLASS=replaceable><i>EXPR</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt></PRE></DIV><P CLASS=para>This function extracts a substring out of the string given by <tt CLASS=replaceable><i>EXPR</i></tt> andreturns it.  The substring is extracted starting at <tt CLASS=replaceable><i>OFFSET</i></tt> charactersfrom the front of the string.(Note: if you've messed with <tt CLASS=literal>$[</tt>, the beginning of the string isn't at 0,but since you haven't messed with it (have you?), it is.)If <tt CLASS=replaceable><i>OFFSET</i></tt> is negative, the substring starts that far from theend of the string instead.  If <tt CLASS=replaceable><i>LENGTH</i></tt> is omitted, everything tothe end of the string is returned.  If <tt CLASS=replaceable><i>LENGTH</i></tt> is negative, thelength is calculated to leave that many characters off the end of thestring.  Otherwise, <tt CLASS=replaceable><i>LENGTH</i></tt> indicates the length of the substringto extract, which is sort of what you'd expect.<P CLASS=para>You can use <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A> as an lvalue (somethingto assign to), in which case <tt CLASS=replaceable><i>EXPR</i></tt> must also be alegal lvalue.  If you assign something shorter than the length of yoursubstring, the string will shrink, and if you assign something longer than thelength, the string will grow to accommodate it.  To keep the string the samelength you may need to pad or chop your value using <A HREF="ch03_02.htm#PERL2-CMD-SPRINTF">sprintf</A> or the <B>x</B> operator.<P CLASS=para>To prepend the string <tt CLASS=literal>"Larry"</tt> to thecurrent value of <B>$_</B>, use:<DIV CLASS=programlisting><P><PRE>substr($_, 0, 0) = "Larry";</PRE></DIV><P CLASS=para>To instead replace the first character of <B>$_</B> with <tt CLASS=literal>"Moe"</tt>,use:<DIV CLASS=programlisting><P><PRE>substr($_, 0, 1) = "Moe";</PRE></DIV><P CLASS=para>and finally, to replace the last character of <B>$_</B> with<tt CLASS=literal>"Curly"</tt>, use:<DIV CLASS=programlisting><P><PRE>substr($_, -1, 1) = "Curly";</PRE></DIV><P CLASS=para>These last few examples presume you haven't messed with the value of <B>$[</B>.You haven't, have you?  Good.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SYMLINK">symlink</A></h3><DIV CLASS=programlisting><P><PRE>symlink <tt CLASS=replaceable><i>OLDFILE</i></tt>, <tt CLASS=replaceable><i>NEWFILE</i></tt></PRE></DIV><P CLASS=para>This function creates a new filename symbolically linked to the old filename.The function returns 1 for success, 0 otherwise.  On systems thatdon't support symbolic links, it produces a fatal error at run-time.To check for that, use <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> to trap the potential error:<DIV CLASS=programlisting><P><PRE>$can_symlink = (eval { symlink("", ""); }, $@ eq "");</PRE></DIV><P CLASS=para>Or use the Config module.  Be careful if you supply a relative symboliclink, since it'll be interpreted relative to the location of thesymbolic link itself, not your current working directory.<P CLASS=para>See also <A HREF="ch03_02.htm#PERL2-CMD-LINK">link</A> and <A HREF="ch03_02.htm#PERL2-CMD-READLINK">readlink</A> earlier in this chapter.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SYSCALL">syscall</A></h3><DIV CLASS=programlisting><P><PRE>syscall <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function calls the system call specified as the first element ofthe list, passing the remaining elements as arguments to the systemcall.  (Many of these are now more readily available through the POSIXmodule, and others.)  The function produces a fatal error if<I CLASS=emphasis>syscall</I> (2) is unimplemented.  The arguments are interpreted asfollows: if a given argument is numeric, the argument is passed as aC integer.  If not, a pointer to the string value ispassed.  You are responsible for making sure the string is long enoughto receive any result that might be written into it.  Otherwise you'relooking at a coredump.  If your integer arguments are not literals andhave never been interpreted in a numeric context, you may need to add 0to them to force them to look like numbers.  (See the followingexample.)<P CLASS=para>This example calls the <I CLASS=emphasis>setgroups</I> (2) system call to add to thegroup list of the current process.  (It will only work on machinesthat support multiple group membership.)<DIV CLASS=programlisting><P><PRE>require 'syscall.ph';syscall &amp;SYS_setgroups, @groups+0, pack("i*", @groups);</PRE></DIV><P CLASS=para>Note that you may have to run <I CLASS=emphasis>h2ph</I> as indicated in thePerl installation instructions for <I CLASS=emphasis>syscall.ph</I> to exist.Some systems may require a <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A> template of<tt CLASS=literal>"s*"</tt> instead.Best of all, the <A HREF="ch03_02.htm#PERL2-CMD-SYSCALL">syscall</A> function assumes the size equivalence of theC types <tt CLASS=literal>int</tt>, <tt CLASS=literal>long</tt>, and <tt CLASS=literal>char</tt>&nbsp;*.<P CLASS=para>Try not to think of <A HREF="ch03_02.htm#PERL2-CMD-SYSCALL">syscall</A> as the epitome of portability.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SYSOPEN">sysopen</A></h3><DIV CLASS=programlisting><P><PRE>sysopen <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>FILENAME</i></tt>, <tt CLASS=replaceable><i>MODE</i></tt>sysopen <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>FILENAME</i></tt>, <tt CLASS=replaceable><i>MODE</i></tt>, <tt CLASS=replaceable><i>PERMS</i></tt></PRE></DIV><P CLASS=para>This function opens the file whose filename is given by <tt CLASS=replaceable><i>FILENAME</i></tt>, andassociates itwith <tt CLASS=replaceable><i>FILEHANDLE</i></tt>.  If <tt CLASS=replaceable><i>FILEHANDLE</i></tt> is an expression,its value is used as the name of (or reference to) the filehandle.This function calls <I CLASS=emphasis>open</I> (2) with theparameters <tt CLASS=replaceable><i>FILENAME</i></tt>, <tt CLASS=replaceable><i>MODE</i></tt>, <tt CLASS=replaceable><i>PERMS</i></tt>.<P CLASS=para>The possible values and flag bits of the <tt CLASS=replaceable><i>MODE</i></tt> parameter aresystem-dependent; they are available via the Fcntl library module.However, for historical reasons, some values areuniversal: zero means read-only, one means write-only, and two meansread/write.<P CLASS=para>If the file named by <tt CLASS=replaceable><i>FILENAME</i></tt> does not exist and<B>sysopen</B> creates it (typically because<tt CLASS=replaceable><i>MODE</i></tt> includes the <tt CLASS=literal>O_CREAT</tt> flag),then the value of <tt CLASS=replaceable><i>PERMS</i></tt> specifies the permissions ofthe newly created file.  If <tt CLASS=replaceable><i>PERMS</i></tt> is omitted, thedefault value is <tt CLASS=literal>0666</tt>, which allows read and write for all.This default is reasonable: see <A HREF="ch03_02.htm#PERL2-CMD-UMASK">umask</A>.<P CLASS=para>The FileHandle module described in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> provides a moreobject-oriented approach to <A HREF="ch03_02.htm#PERL2-CMD-SYSOPEN">sysopen</A>.  Seealso <B>open</B> earlier in this chapter.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SYSREAD">sysread</A></h3><DIV CLASS=programlisting><P><PRE>sysread <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>SCALAR</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt>sysread <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>SCALAR</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt></PRE></DIV><P CLASS=para>This function attempts to read <tt CLASS=replaceable><i>LENGTH</i></tt> bytes of datainto variable <tt CLASS=replaceable><i>SCALAR</i></tt> from the specified<tt CLASS=replaceable><i>FILEHANDLE</i></tt> using<I CLASS=emphasis>read</I> (2).  The function returns the number of bytesactually read, or 0 at EOF.  It returns the undefined value on error.<tt CLASS=replaceable><i>SCALAR</i></tt> will be grown or shrunk to the length actuallyread.  The <tt CLASS=replaceable><i>OFFSET</i></tt>, if specified, says where in thestring to start putting the bytes, so that you can read into the middle of astring that's being used as a buffer.  For an example, see <A HREF="ch03_02.htm#PERL2-CMD-SYSWRITE">syswrite</A>.  You should be prepared to handle the problems(like interrupted system calls) that standard I/O normally handles for you.Also, do not mix calls to <A HREF="ch03_02.htm#PERL2-CMD-READ">read</A> and <A HREF="ch03_02.htm#PERL2-CMD-SYSREAD">sysread</A> on the same filehandle unless you are intoheavy wizardry (and/or pain).</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SYSTEM">system</A></h3><DIV CLASS=programlisting><P><PRE>system <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function executes any program on the system for you.  It does exactly thesame thing as <tt CLASS=literal>exec</tt> <tt CLASS=replaceable><i>LIST</i></tt> exceptthat it does a <A HREF="ch03_02.htm#PERL2-CMD-FORK">fork</A> first, and then, afterthe exec, it waits for the exec'd program to complete.  That is (in non-UNIXterms), it runs the program for you, and returns when it's done, unlike <A HREF="ch03_02.htm#PERL2-CMD-EXEC">exec</A>, which never returns (if it succeeds).  Notethat argument processing varies depending on the number of arguments, asdescribed for <A HREF="ch03_02.htm#PERL2-CMD-EXEC">exec</A>.  The return value is theexit status of the program as returned by the<I CLASS=emphasis>wait</I> (2) call.  To get the actual exit value, divideby 256.  (The lower 8 bits are set if the process died from a signal.)  See<A HREF="ch03_02.htm#PERL2-CMD-EXEC">exec</A>.<P CLASS=para>Because <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A> and backticks block<tt CLASS=literal>SIGINT</tt> and <tt CLASS=literal>SIGQUIT</tt>, killing the programthey're running with one of those signals doesn't actually interrupt yourprogram.<DIV CLASS=programlisting><P><PRE>@args = ("command", "arg1", "arg2");system(@args) == 0      or die "system @args failed: $?"</PRE></DIV><P CLASS=para>Here's a more elaborate example of analyzing the return value from <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A> on a UNIX system to check for allpossibilities, including for signals and coredumps.<DIV CLASS=programlisting><P><PRE>$rc = 0xffff &amp; system @args;printf "system(%s) returned %#04x: ", "@args", $rc;if ($rc == 0) {    print "ran with normal exit\n";} elsif ($rc == 0xff00) {    print "command failed: $!\n";} elsif ($rc &gt; 0x80) {    $rc &gt;&gt;= 8;    print "ran with non-zero exit status $rc\n";} else {    print "ran with ";    if ($rc &amp;   0x80) {        $rc &amp;= ~0x80;        print "coredump from ";    }     print "signal $rc\n"} $ok = ($rc != 0);</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-SYSWRITE">syswrite</A></h3><DIV CLASS=programlisting><P><PRE>syswrite <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>SCALAR</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt>syswrite <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>SCALAR</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt></PRE></DIV><P CLASS=para>This function attempts to write <tt CLASS=replaceable><i>LENGTH</i></tt> bytes of data fromvariable <tt CLASS=replaceable><i>SCALAR</i></tt> to the specified <tt CLASS=replaceable><i>FILEHANDLE</i></tt> using<I CLASS=emphasis>write</I> (2).  The function returns the number of bytes actuallywritten, or the undefined value on error.  You should be prepared tohandle the problems that standard I/O normally handles for you, such aspartial writes.  The <tt CLASS=replaceable><i>OFFSET</i></tt>, if specified, says where in thestring to start writing from, in case you're using the string as abuffer, for instance, or you need to recover from a partial write.  Tocopy data from filehandle <tt CLASS=literal>FROM</tt> into filehandle <tt CLASS=literal>TO</tt>, usesomething like:<DIV CLASS=programlisting><P><PRE>$blksize = (stat FROM)[11] || 16384;  # preferred block size?while ($len = sysread FROM, $buf, $blksize) {    if (!defined $len) {        next if $! =~ /^Interrupted/;        die "System read error: $!\n";    }    $offset = 0;    while ($len) {          # Handle partial writes.        $written = syswrite TO, $buf, $len, $offset;        die "System write error: $!\n"            unless defined $written;        $len -= $written;        $offset += $written;    };}</PRE></DIV><P CLASS=para>Do not mix calls to (<A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> or <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A>) and <A HREF="ch03_02.htm#PERL2-CMD-SYSWRITE">syswrite</A> onthe same filehandle unless you are into heavy wizardry.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-TELL">tell</A></h3><DIV CLASS=programlisting><P><PRE>tell <tt CLASS=replaceable><i>FILEHANDLE</i></tt>tell</PRE></DIV><P CLASS=para>This function returns the current file position (in bytes, 0-based) for<tt CLASS=replaceable><i>FILEHANDLE</i></tt>.This value is typically fed to the <A HREF="ch03_02.htm#PERL2-CMD-SEEK">seek</A> function at some future timeto get back to the current position.<tt CLASS=replaceable><i>FILEHANDLE</i></tt> may be an expression whose value gives the name of theactual filehandle, or a reference to a filehandle object.If <tt CLASS=replaceable><i>FILEHANDLE</i></tt> is omitted, the function returns theposition of the file last read.  File positions are only meaningful onregular files.  Devices, pipes, and sockets have no file position.<P CLASS=para>See <A HREF="ch03_02.htm#PERL2-CMD-SEEK">seek</A> for an example.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-TELLDIR">telldir</A></h3><DIV CLASS=programlisting><P><PRE>telldir <tt CLASS=replaceable><i>DIRHANDLE</i></tt></PRE></DIV><P CLASS=para>This function returns the current position of the <A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A> routines on <tt CLASS=replaceable><i>DIRHANDLE</i></tt>.This value may be given to <A HREF="ch03_02.htm#PERL2-CMD-SEEKDIR">seekdir</A> to accessa particular location in a directory.  The function has the same caveats aboutpossible directory compaction as the corresponding system library routine.  Thisfunction may not be implemented everywhere that <A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A> is.  Even if it is, no calculation may be done withthe return value.  It's just an opaque value, meaningful only to <A HREF="ch03_02.htm#PERL2-CMD-SEEKDIR">seekdir</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-TIE">tie</A></h3><DIV CLASS=programlisting><P><PRE>tie <tt CLASS=replaceable><i>VARIABLE</i></tt>, <tt CLASS=replaceable><i>CLASSNAME</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function binds a variable to a package class that will providethe implementation for the variable.  <tt CLASS=replaceable><i>VARIABLE</i></tt> is the name of thevariable to be tied.  <tt CLASS=replaceable><i>CLASSNAME</i></tt> is the name of a classimplementing objects of an appropriate type.  Any additional arguments arepassed to the "new" method of the class (meaning <tt CLASS=literal>TIESCALAR</tt>,<tt CLASS=literal>TIEARRAY</tt>, or <tt CLASS=literal>TIEHASH</tt>).  Typically these are arguments suchas might be passed to the <I CLASS=emphasis>dbm_open</I> (3) function of C, but this ispackage dependent.  The objectreturned by the "new" method is also returned by the <A HREF="ch03_02.htm#PERL2-CMD-TIE">tie</A>function, which can be useful if you want to access other methods in<tt CLASS=replaceable><i>CLASSNAME</i></tt>.  (The object can also be accessed through the <A HREF="ch03_02.htm#PERL2-CMD-TIED">tied</A>function.) So, a class for tying a hash to an ISAM implementationmight provide an extra method to traverse a set of keys sequentially(the "S" of ISAM), since your typical DBM implementation can't do that.<P CLASS=para>Note that functions such as <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> and <A HREF="ch03_02.htm#PERL2-CMD-VALUES">values</A> may return huge list values when used onlarge objects like DBM files.  You may prefer to use the <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> function to iterate over such.  For example:<DIV CLASS=programlisting><P><PRE>use NDBM_File;tie %ALIASES, "NDBM_File", "/etc/aliases", 1, 0    or die "Can't open aliases: $!\n";while (($key,$val) = each %ALIASES) {    print $key, ' = ', $val, "\n";}untie %ALIASES;</PRE></DIV><P CLASS=para>A class implementing a hash should provide the followingmethods:<DIV CLASS=programlisting><P><PRE>TIEHASH $class, <tt CLASS=replaceable><i>LIST</i></tt>DESTROY $selfFETCH $self, $keySTORE $self, $key, $valueDELETE $self, $keyEXISTS $self, $keyFIRSTKEY $selfNEXTKEY $self, $lastkey</PRE></DIV><P CLASS=para>A class implementing an ordinary array should provide the following methods:<DIV CLASS=programlisting><P><PRE>TIEARRAY $classname, <tt CLASS=replaceable><i>LIST</i></tt>DESTROY $selfFETCH $self, $subscriptSTORE $self, $subscript, $value</PRE></DIV><P CLASS=para>(As of this writing, other methods are still being designed.  Check theonline documentation for additions.)<P CLASS=para>A class implementing a scalar should provide the following methods:<DIV CLASS=programlisting><P><PRE>TIESCALAR $classname, <tt CLASS=replaceable><i>LIST</i></tt>DESTROY $selfFETCH $self, STORE $self, $value</PRE></DIV><P CLASS=para>See "Using Tied Variables" in <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A> for detailed discussion of all these methods.Unlike <A HREF="ch03_02.htm#PERL2-CMD-DBMOPEN">dbmopen</A>, the <A HREF="ch03_02.htm#PERL2-CMD-TIE">tie</A> function will not <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> or <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> a modulefor you--you need to do that explicitly yourself.  See the DB_File andConfig modules for interesting <A HREF="ch03_02.htm#PERL2-CMD-TIE">tie</A>implementations.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-TIED">tied</A></h3><DIV CLASS=programlisting><P><PRE>tied <tt CLASS=replaceable><i>VARIABLE</i></tt></PRE></DIV><P CLASS=para>This function returns a reference to the object underlying<tt CLASS=replaceable><i>VARIABLE</i></tt> (the same value that was originally returnedby the <A HREF="ch03_02.htm#PERL2-CMD-TIE">tie</A> call which bound the variable toa package.)  It returns the undefined value if<tt CLASS=replaceable><i>VARIABLE</i></tt> isn't tied to a package.  So, for example,you can use:<DIV CLASS=programlisting><P><PRE>ref tied %hash</PRE></DIV><P CLASS=para>to find out which package your hash is currently tied to.  (Presumingyou've forgotten.)</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-TIME">time</A></h3><DIV CLASS=programlisting><P><PRE>time</PRE></DIV><P CLASS=para>This function returns the number of non-leap seconds since January 1, 1970,UTC.[10] Thereturned value is suitable for feeding to <A HREF="ch03_02.htm#PERL2-CMD-GMTIME">gmtime</A> and <A HREF="ch03_02.htm#PERL2-CMD-LOCALTIME">localtime</A>,and for comparison with file modification and access times returned by <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A>, and for feeding to <A HREF="ch03_02.htm#PERL2-CMD-UTIME">utime</A>--see the examples under <A HREF="ch03_02.htm#PERL2-CMD-UTIME">utime</A>.<blockquote class=footnote><P CLASS=para>[10]  Also known as the "epoch", not to be confused with the"epic", which is about the making of UNIX.  (Other operating systems may have adifferent epoch, not to mention a different epic.)  </blockquote></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-TIMES">times</A></h3><DIV CLASS=programlisting><P><PRE>times</PRE></DIV><P CLASS=para>This function returns a four-element list giving the user and systemCPU times, in seconds (possibly fractional), for this process and thechildren of this process.<DIV CLASS=programlisting><P><PRE>($user, $system, $cuser, $csystem) = times;</PRE></DIV><P CLASS=para>For example, to time the execution speed of a section of Perl code:<DIV CLASS=programlisting><P><PRE>$start = (times)[0];...$end = (times)[0];printf "that took %.2f CPU seconds\n", $end - $start;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-TR">tr///</A></h3><DIV CLASS=programlisting><P><PRE>tr///y///</PRE></DIV><P CLASS=para>This is the translation operator, which is like the one in the UNIX<I CLASS=emphasis>sed</I> program, only better, in everybody's humble opinion.  See<A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-TRUNCATE">truncate</A></h3><DIV CLASS=programlisting><P><PRE>truncate <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt>truncate <tt CLASS=replaceable><i>EXPR</i></tt>, <tt CLASS=replaceable><i>LENGTH</i></tt></PRE></DIV><P CLASS=para>This function truncates the file opened on <tt CLASS=replaceable><i>FILEHANDLE</i></tt>, or named by<tt CLASS=replaceable><i>EXPR</i></tt>, to the specified length.  The function produces a fatal error if<I CLASS=emphasis>truncate</I> (2) or an equivalent isn't implemented on your system.  (Youcan always truncate a file by copying the front of it, if you have thedisk space.)</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-UC">uc</A></h3><DIV CLASS=programlisting><P><PRE>uc <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns an uppercased version of <tt CLASS=replaceable><i>EXPR</i></tt> (or <B>$_</B> if<tt CLASS=replaceable><i>EXPR</i></tt>is omitted).This is the internal function implementing the <tt CLASS=literal>\U</tt>escape in double-quotedstrings.POSIX <I CLASS=emphasis>setlocale</I> (3) settings are respected.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-UCFIRST">ucfirst</A></h3><DIV CLASS=programlisting><P><PRE>ucfirst <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function returns a version of <tt CLASS=replaceable><i>EXPR</i></tt> (or <B>$_</B> if <tt CLASS=replaceable><i>EXPR</i></tt>is omitted) with the firstcharacter uppercased, that is, capitalized.This is the internal function implementing the \u escape in double-quotedstrings.POSIX <I CLASS=emphasis>setlocale</I> (3) settings are respected.<P CLASS=para>To force initial caps, and everything else lowercase, use:<DIV CLASS=programlisting><P><PRE>ucfirst lc $word</PRE></DIV><P CLASS=para>which is equivalent to <tt CLASS=literal>"\u\L$word"</tt>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-UMASK">umask</A></h3><DIV CLASS=programlisting><P><PRE>umask <tt CLASS=replaceable><i>EXPR</i></tt>umask</PRE></DIV><P CLASS=para>This function sets the umask for the process and returns the old one.(The umask tells UNIX which permission bits to disallow whencreating a file.)  If <tt CLASS=replaceable><i>EXPR</i></tt> is omitted, the function merely returnsthe current umask.  For example, to ensure that the "other" bits areturned on, and the "user" bits are turned off, try something like:<DIV CLASS=programlisting><P><PRE>umask((umask() &amp; 077) | 7);</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-UNDEF">undef</A></h3><DIV CLASS=programlisting><P><PRE>undef <tt CLASS=replaceable><i>EXPR</i></tt>undef</PRE></DIV><P CLASS=para>This function undefines the value of <tt CLASS=replaceable><i>EXPR</i></tt>, which mustbe an lvalue.  Use only on a scalar value, an entire array or hash, or asubroutine name (using the <tt CLASS=literal>&amp;</tt> prefix).  Any storageassociated with the object will be recovered for reuse (though not returned tothe system, for most versions of UNIX).  The <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> function will probably not do what you expect on mostspecial variables.<P CLASS=para>The function always returns the undefined value.This is useful because you can omit the <tt CLASS=replaceable><i>EXPR</i></tt>, in which casenothing gets undefined, but you still get an undefined value that youcould, for instance, return from a subroutine to indicate an error.Here are some uses of <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> as a unary operator:<DIV CLASS=programlisting><P><PRE>undef $foo;undef $bar{'blurfl'};undef @ary;undef %assoc;undef &amp;mysub;</PRE></DIV><P CLASS=para>Without an argument, <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> is just used for its value:<DIV CLASS=programlisting><P><PRE>return (wantarray ? () : undef) if $they_blew_it;select(undef, undef, undef, $naptime);</PRE></DIV><P CLASS=para>You may use <B>undef</B> as a placeholder on theleft side of a list assignment, in which case the corresponding valuefrom the right side is simply discarded.  Apart from that, you may notuse <B>undef</B> as an lvalue.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-UNLINK">unlink</A></h3><DIV CLASS=programlisting><P><PRE>unlink <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function deletes a list of files.[11]If <tt CLASS=replaceable><i>LIST</i></tt> is omitted, it unlinks the file given in <B>$_</B>.The function returns the number of files successfully deleted.Some sample commands:<blockquote class=footnote><P CLASS=para>[11] Actually, under UNIX, it removes the directory entries thatrefer to the real files.  Since a file may be referenced (linked) frommore than one directory, the file isn't actually removed until thelast reference to it is removed.</blockquote><DIV CLASS=programlisting><P><PRE>$cnt = unlink 'a', 'b', 'c';unlink @goners;unlink &lt;*.bak&gt;;</PRE></DIV><P CLASS=para>Note that <A HREF="ch03_02.htm#PERL2-CMD-UNLINK">unlink</A> will not delete directoriesunless you are superuser and the <B>-U</B> flag issupplied to Perl.  Even if these conditions are met, be warned that unlinking adirectory can inflict Serious Damage on your filesystem.  Use <A HREF="ch03_02.htm#PERL2-CMD-RMDIR">rmdir</A> instead.<P CLASS=para>Here's a very simple <I CLASS=emphasis>rm</I> command with very simple error checking:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl@cannot = grep {not unlink} @ARGV;die "$0: could not unlink @cannot\n" if @cannot;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-UNPACK">unpack</A></h3><DIV CLASS=programlisting><P><PRE>unpack <tt CLASS=replaceable><i>TEMPLATE</i></tt>, <tt CLASS=replaceable><i>EXPR</i></tt></PRE></DIV><P CLASS=para>This function does the reverse of <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A>: ittakes a string (<tt CLASS=replaceable><i>EXPR</i></tt>) representing a data structureand expands it out into a list value, returning the list value.  (In a scalarcontext, it can be used to unpack a single value.)  The<tt CLASS=replaceable><i>TEMPLATE</i></tt> has much the same format as in the <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A> function--it specifies the order andtype of the values to be unpacked.  (See <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A> for a more detailed description of<tt CLASS=replaceable><i>TEMPLATE</i></tt>.)<P CLASS=para>Here's a subroutine that does (some of) <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A>, only slower:<DIV CLASS=programlisting><P><PRE>sub substr {    my($what, $where, $howmuch) = @_;    if ($where &lt; 0) {        $where = -$where;        return unpack "\@* X$where a$howmuch", $what;    }    else {        return unpack "x$where a$howmuch", $what;    }}</PRE></DIV><P CLASS=para>and then there's:<DIV CLASS=programlisting><P><PRE>sub signed_ord { unpack "c", shift }</PRE></DIV><P CLASS=para>Here's a complete<I CLASS=emphasis>uudecode</I>program:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl$_ = &lt;&gt; until ($mode,$file) = /^begin\s*(\d*)\s*(\S*)/;open(OUT,"&gt; $file") if $file ne "";while (&lt;&gt;) {    last if /^end/;    next if /[a-z]/;    next unless int((((ord() - 32) &amp; 077) + 2) / 3) ==                int(length() / 4);    print OUT unpack "u", $_;}chmod oct $mode, $file;</PRE></DIV><P CLASS=para>In addition, you may prefix a field with <tt CLASS=literal>%</tt><tt CLASS=replaceable><i>number</i></tt> toindicate that you want it to return a<tt CLASS=replaceable><i>number</i></tt>-bit checksum of the itemsinstead of the items themselves.Default is a 16-bit checksum.  For example, the following computes thesame number as the System V <I CLASS=emphasis>sum</I> program:<DIV CLASS=programlisting><P><PRE>undef $/;$checksum = unpack ("%32C*", &lt;&gt;) % 32767;</PRE></DIV><P CLASS=para>The following efficiently counts the number of set bits in a bit vector:<DIV CLASS=programlisting><P><PRE>$setbits = unpack "%32b*", $selectmask;</PRE></DIV><P CLASS=para>Here's a simple MIME decoder:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {  tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars  tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format  $len = pack("c", 32 + 0.75*length);   # compute length byte  print unpack("u", $len . $_);         # uudecode and print}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-UNSHIFT">unshift</A></h3><DIV CLASS=programlisting><P><PRE>unshift <tt CLASS=replaceable><i>ARRAY</i></tt>, <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function does the opposite of a <A HREF="ch03_02.htm#PERL2-CMD-SHIFT">shift</A>.(Or the opposite of a <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A>, depending on howyou look at it.)  It prepends <tt CLASS=replaceable><i>LIST</i></tt> to the front ofthe array, and returns the new number of elements in the array:<DIV CLASS=programlisting><P><PRE>unshift @ARGV, '-e', $cmd unless $ARGV[0] =~ /^-/;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-UNTIE">untie</A></h3><DIV CLASS=programlisting><P><PRE>untie <tt CLASS=replaceable><i>VARIABLE</i></tt></PRE></DIV><P CLASS=para>Breaks the binding between a variable and a package.  See <A HREF="ch03_02.htm#PERL2-CMD-TIE">tie</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-USE">use</A></h3><DIV CLASS=programlisting><P><PRE>use <tt CLASS=replaceable><i>Module</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>use <tt CLASS=replaceable><i>Module</i></tt></PRE></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> declaration imports some semantics intothe current packagefrom the named module, generally by aliasing certain subroutine orvariable names into your package.  It is exactly equivalent to the following:<DIV CLASS=programlisting><P><PRE>BEGIN { require <tt CLASS=replaceable><i>Module</i></tt>; import <tt CLASS=replaceable><i>Module</i></tt> <tt CLASS=replaceable><i>LIST</i></tt>; }</PRE></DIV><P CLASS=para>The <tt CLASS=literal>BEGIN</tt> forces the <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> and <A HREF="ch03_02.htm#PERL2-CMD-IMPORT">import</A> tohappen at compile time.  The <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> makessure the module is loaded into memory if it hasn't been yet.  The <A HREF="ch03_02.htm#PERL2-CMD-IMPORT">import</A> is not a built-in--it's just an ordinary staticmethod call into the package named by <tt CLASS=replaceable><i>Module</i></tt> to tellthe module to import the list of features back into the current package.  Themodule can implement its import method any way it likes, though most modulesjust choose to derive their import method via inheritance from the Exporterclass that is defined in the Exporter module.  See <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>for more information.<P CLASS=para>If you don't want your namespace altered, explicitly supply an empty list:<DIV CLASS=programlisting><P><PRE>use Module ();</PRE></DIV><P CLASS=para>That is exactly equivalent to the following:<DIV CLASS=programlisting><P><PRE>BEGIN { require Module; }</PRE></DIV><P CLASS=para>Because this is a wide-open interface, pragmas (compiler directives)are also implemented this way.  Currently implemented pragmas include:<DIV CLASS=programlisting><P><PRE>use integer;use diagnostics;use sigtrap qw(SEGV BUS);use strict  qw(subs vars refs);</PRE></DIV><P CLASS=para>These pseudomodules typically import semantics into the current block scope, unlikeordinary modules, which import symbols into the current package.  (Thelatter areeffective through the end of the file.)<P CLASS=para>There's a corresponding declaration, <B>no</B>,that "unimports" any meaningsoriginally imported by <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A>, but that have since become, er, unimportant:<DIV CLASS=programlisting><P><PRE>no integer;no strict 'refs';</PRE></DIV><P CLASS=para>See <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> for a list of standard modules and pragmas.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-UTIME">utime</A></h3><DIV CLASS=programlisting><P><PRE>utime <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function changes the access and modification times on each fileof a list of files.The first two elements of the list must be the <I CLASS=emphasis>numerical</I> accessand modification times, in that order. The function returns thenumber of files successfully changed. The inode change time ofeach file is set to the current time. Here's an example of a<I CLASS=emphasis>touch</I> command:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl$now = time;utime $now, $now, @ARGV;</PRE></DIV><P CLASS=para>and here's a more sophisticated<I CLASS=emphasis>touch</I>command with a bit of error checking:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl$now = time;@cannot = grep {not utime $now, $now, $_} @ARGV;die "$0: Could not touch @cannot.\n" if @cannot;</PRE></DIV><P CLASS=para>The standard <I CLASS=emphasis>touch</I> command will actually create missing files, somethinglike this:<DIV CLASS=programlisting><P><PRE>$now = time;foreach $file (@ARGV) {    utime $now, $now, $file        or open TMP, "&gt;&gt;$file"        or warn "Couldn't touch $file: $!\n";}</PRE></DIV><P CLASS=para>To read the times from existing files, use <A HREF="ch03_02.htm#PERL2-CMD-STAT">stat</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-VALUES">values</A></h3><DIV CLASS=programlisting><P><PRE>values <tt CLASS=replaceable><i>HASH</i></tt></PRE></DIV><P CLASS=para>This function returns a list consisting of all the values ofthe named hash.The values are returned in an apparently random order, but it is thesame order as either the <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> or <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> functionwould produce on the same hash.To sort the hash by its values, see the example under <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A>.Note that using <A HREF="ch03_02.htm#PERL2-CMD-VALUES">values</A> on a hash that isbound to a humongous DBM file is bound to produce a humongous list,causing you to have a humongous process, leaving you in a bind.You might prefer to use the <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> function,which will iterate over the hash entries one by one without slurpingthem all into a single gargantuan (that is, humongous) list.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-VEC">vec</A></h3><DIV CLASS=programlisting><P><PRE>vec <tt CLASS=replaceable><i>EXPR</i></tt>, <tt CLASS=replaceable><i>OFFSET</i></tt>, <tt CLASS=replaceable><i>BITS</i></tt></PRE></DIV><P CLASS=para>This function treats a string (the value of <tt CLASS=replaceable><i>EXPR</i></tt>) as a vector ofunsigned integers, and returns the value of the element specified by<tt CLASS=replaceable><i>OFFSET</i></tt> and <tt CLASS=replaceable><i>BITS</i></tt>.The function may also be assigned to, which causes the element to bemodified.The purpose of the function is to provide very compact storage of lists ofsmall integers.  The integers may be very small--vectors can holdnumbers that are as small as one bit, resulting in a bitstring.<P CLASS=para>The <tt CLASS=replaceable><i>OFFSET</i></tt> specifies how many elements to skip over to find the one youwant.  <tt CLASS=replaceable><i>BITS</i></tt> is the number of bits per element in the vector, so eachelement can contain an unsigned integer in the range<tt CLASS=literal>0..(2**</tt><tt CLASS=replaceable><i>BITS</i></tt>)<tt CLASS=literal>-1</tt>.<tt CLASS=replaceable><i>BITS</i></tt> must be one of <tt CLASS=literal>1</tt>, <tt CLASS=literal>2</tt>, <tt CLASS=literal>4</tt>, <tt CLASS=literal>8</tt>,<tt CLASS=literal>16</tt>, or<tt CLASS=literal>32</tt>.  As many elements as possible are packed into each byte, andthe ordering is such that <tt CLASS=literal>vec($vectorstring,0,1)</tt> is guaranteedto go into the lowest bit of the first byte of the string.  To findout the position of the byte in which an element is going to be put,you have to multiply the <tt CLASS=replaceable><i>OFFSET</i></tt> by the number of elements perbyte.  When <tt CLASS=replaceable><i>BITS</i></tt> is 1, there are eight elements per byte.  When<tt CLASS=replaceable><i>BITS</i></tt> is 2,there are four elements per byte.  When <tt CLASS=replaceable><i>BITS</i></tt>is 4, there are two elements (called nybbles)per byte.  And so on.<P CLASS=para>Regardless of whether your machine is big-endian or little-endian,<tt CLASS=literal>vec($foo, 0, 8)</tt> always refers to the first byte of string<tt CLASS=literal>$foo</tt>.  See <B>select</B> forexamples of bitmaps generated with <A HREF="ch03_02.htm#PERL2-CMD-VEC">vec</A>.<P CLASS=para>Vectors created with <A HREF="ch03_02.htm#PERL2-CMD-VEC">vec</A> can also bemanipulated with the logical operators <tt CLASS=literal>|</tt>,<tt CLASS=literal>&amp;</tt>, <tt CLASS=literal>^</tt>, and <tt CLASS=literal>~</tt>, whichwill assume a bit vector operation is desired when the operands are strings.<P CLASS=para>A bit vector (<tt CLASS=replaceable><i>BITS == 1</i></tt>) can be translated to or froma string of 1s and 0s by supplying a <tt CLASS=literal>b*</tt> template to <A HREF="ch03_02.htm#PERL2-CMD-UNPACK">unpack</A> or <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A>.  Similarly, a vector of nybbles (<tt CLASS=replaceable><i>BITS ==4</i></tt>) can be translated with an <tt CLASS=literal>h*</tt> template.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-WAIT">wait</A></h3><DIV CLASS=programlisting><P><PRE>wait</PRE></DIV><P CLASS=para>This function waits for a child process to terminate and returns thepid of the deceased process, or -1 if there are no child processes.The status is returned in <B>$?</B>.If you get zombie child processes, you should be calling this function,or <A HREF="ch03_02.htm#PERL2-CMD-WAITPID">waitpid</A>.  A common strategy to avoid such zombies is:<DIV CLASS=programlisting><P><PRE>$SIG{CHLD} = sub { wait };</PRE></DIV><P CLASS=para>If you expected a child and didn't find it, you probably had a call to <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A>, a close on a pipe, or backticks betweenthe <A HREF="ch03_02.htm#PERL2-CMD-FORK">fork</A> and the <A HREF="ch03_02.htm#PERL2-CMD-WAIT">wait</A>.  These constructs also do a<I CLASS=emphasis>wait</I> (2) and may have harvested your child process.Use <A HREF="ch03_02.htm#PERL2-CMD-WAITPID">waitpid</A> to avoid this problem.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-WAITPID">waitpid</A></h3><DIV CLASS=programlisting><P><PRE>waitpid <tt CLASS=replaceable><i>PID</i></tt>, <tt CLASS=replaceable><i>FLAGS</i></tt></PRE></DIV><P CLASS=para>This function waits for a particular child process to terminate andreturns the pid when the process is dead, or -1 if there are no childprocesses, or if the <tt CLASS=replaceable><i>FLAGS</i></tt> specify non-blocking and the process isn'tdead yet.  The status of the dead process is returned in <B>$?</B>.To get valid flag values say this:<DIV CLASS=programlisting><P><PRE>use POSIX "sys_wait_h";</PRE></DIV><P CLASS=para>On systems that implement neither the <I CLASS=emphasis>waitpid</I> (2) nor<I CLASS=emphasis>wait4</I> (2) system call, <tt CLASS=replaceable><i>FLAGS</i></tt> may be specified only as 0.  Inother words, you can wait for a specific <tt CLASS=replaceable><i>PID</i></tt>, but you can't do it innon-blocking mode.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-WANTARRAY">wantarray</A></h3><DIV CLASS=programlisting><P><PRE>wantarray</PRE></DIV><P CLASS=para>This function returns true if the context of the currently executing subroutineis looking for a list value.The function returns false if the context is looking for a scalar.Here's a typical usage, demonstrating an "unsuccessful" return:<DIV CLASS=programlisting><P><PRE>return wantarray ? () : undef;</PRE></DIV><P CLASS=para>See also <A HREF="ch03_02.htm#PERL2-CMD-CALLER">caller</A>.  This function shouldreally have been named "wantlist", but we named it back when list contexts werestill called array contexts.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-WARN">warn</A></h3><DIV CLASS=programlisting><P><PRE>warn <tt CLASS=replaceable><i>LIST</i></tt></PRE></DIV><P CLASS=para>This function produces a message on <tt CLASS=literal>STDERR</tt> just like <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A>, but doesn't try to exit or throw anexception.  For example:<DIV CLASS=programlisting><P><PRE>warn "Debug enabled" if $debug;</PRE></DIV><P CLASS=para>If the message supplied is null, the message "Something's wrong" is used.  Aswith <B>die</B>, a message not ending with a newlinewill have file and line number information automatically appended.The <A HREF="ch03_02.htm#PERL2-CMD-WARN">warn</A> operator is unrelated to the<B>-w</B> switch.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-WRITE">write</A></h3><DIV CLASS=programlisting><P><PRE>write <tt CLASS=replaceable><i>FILEHANDLE</i></tt>write</PRE></DIV><P CLASS=para>This function writes a formatted record (possibly multi-line) to thespecified filehandle, using the format associated with that filehandle--see thesection "Formats" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.  By default the format for a filehandle isthe one having the same name as the filehandle.  However, the format fora filehandle may be changed by saying:<DIV CLASS=programlisting><P><PRE>use FileHandle;HANDLE-&gt;format_name("NEWNAME");</PRE></DIV><P CLASS=para>Top-of-form processing is handled automatically: if there is insufficient roomon the current page for the formatted record, the page is advanced by writing aform feed, a special top-of-page format is used to format the new page header,and then the record is written.  The number of lines remaining on the currentpage is in variable <B>$-</B>, which can be set to 0 toforce a new page on the next <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A>.  (Youmay need to <B>select</B> the filehandle first.)By default the name of the top-of-page format is the name of the filehandle with"<tt CLASS=literal>_TOP</tt>" appended, but the format for a filehandlemay be changed by saying:<DIV CLASS=programlisting><P><PRE>use FileHandle;HANDLE-&gt;format_top_name("NEWNAME_TOP");</PRE></DIV><P CLASS=para>If <tt CLASS=replaceable><i>FILEHANDLE</i></tt> is unspecified, output goes to thecurrent default output filehandle, which starts out as <tt CLASS=literal>STDOUT</tt>but may be changed by the <B>select</B> operator.If the <tt CLASS=replaceable><i>FILEHANDLE</i></tt> is an expression, then theexpression is evaluated to determine the actual<tt CLASS=replaceable><i>FILEHANDLE</i></tt> at run-time.<P CLASS=para>Note that <A HREF="ch03_02.htm#PERL2-CMD-WRITE">write</A> is <I CLASS=emphasis>not</I>the opposite of <A HREF="ch03_02.htm#PERL2-CMD-READ">read</A>.  Use <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> for simple string output.  If you looked up thisentry because you wanted to bypass standard I/O, see <A HREF="ch03_02.htm#PERL2-CMD-SYSWRITE">syswrite</A>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CMD-YSSS">y///</A></h3><DIV CLASS=programlisting><P><PRE>y///</PRE></DIV><P CLASS=para>The translation operator, also known as <tt CLASS=literal>tr///</tt>.See <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch03_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch04_01.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Perl Functions by Category</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>References and Nested Data Structures</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>