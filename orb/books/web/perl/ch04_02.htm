<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 4] 4.2 Creating Hard References</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:08:57 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 4</b></td><td width=172 align=right valign=top><A HREF="ch04_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-2">4.2 Creating Hard References</A></h2><P CLASS=para><A NAME="CH04.HARD"></A>There are several ways to compose references, most of which we willdescribe before explaining how to use (dereference) the resultingreferences.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-2.1">The Backslash Operator</A></h3><P CLASS=para>You can create a reference to any named variable or subroutine by usingthe unary backslash operator.  (You may also use it on an anonymousscalar value.)  This works much like the <tt CLASS=literal>&amp;</tt> (address-of) operator in C.<P CLASS=para>Here are some examples:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$scalarref = \$foo;$constref  = \186_282.42;$arrayref  = \@ARGV;$hashref   = \%ENV;$coderef   = \&amp;handler;$globref   = \*STDOUT;</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-2.2">The Anonymous Array Composer</A></h3><P CLASS=para>You can create a reference to an anonymous array by using brackets:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$arrayref = [1, 2, ['a', 'b', 'c']];</PRE></DIV><P CLASS=para>Here we've composed a reference to an anonymous array of three elementswhose final element is a reference to another anonymous array of threeelements.<P CLASS=para>These square brackets work like this only where the Perl parser isexpecting a term in an expression, and should not be confused with thebrackets that are functioning as operators when used to subscript anarray (though there is an obvious mnemonic association with arrays).Square brackets inside a quoted string do not result in theinterpolation of a reference to an anonymous array.  Rather, suchbrackets become literal elements in the string.  (However, if you'reinterpolating something into the string, and the expression definingthe interpolation contains brackets, they have their normal meaningwithin the expression, since they are, after all, in an expression.)<P CLASS=para>Note that taking a reference to an enumerated list is not the sameas using brackets--instead it's treated as a shorthand for creatinga list of references:<P CLASS=para><DIV CLASS=programlisting><P><PRE>@list = (\$a, \$b, \$c);  @list = \($a, $b, $c);      # same thing!</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-2.3">The Anonymous Hash Composer</A></h3><P CLASS=para>You can create a reference to an anonymous hash by using braces:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$hashref = {    'Adam'  =&gt; 'Eve',    'Clyde' =&gt; 'Bonnie',};</PRE></DIV><P CLASS=para>The values above are literal strings; variables and expressions would workas well.  Also, for the values (but not the keys) of the hash, youcan freely mix anonymous hash and array composers to produce ascomplicated a structure as you want.<P CLASS=para>These braces work like this only where the Perl parser isexpecting a term in an expression, and should not be confused with thebraces that are functioning as operators when used to subscript ahash (though there is an obvious mnemonic association with hashes).Braces inside a quoted string do not result in theinterpolation of a reference to an anonymous hash.  Rather, suchbraces become literal elements in the string.  (However, the same caveatabout interpolating expressions applies to braces as it does to brackets.)<P CLASS=para>Since braces are also used for several other things including<tt CLASS=replaceable><i>BLOCK</i></tt>s, you may occasionally have to disambiguatebraces at the beginning of a statement by putting a+ or a <B>return</B> in front so thatPerl realizes the opening brace isn't starting a<tt CLASS=replaceable><i>BLOCK</i></tt>.  For example, if you wanted a function tomake a new hash and return a reference to it, you have these options:<P CLASS=para><DIV CLASS=programlisting><P><PRE>sub hashem {        { @_ } }   # silently WRONGsub hashem {       +{ @_ } }   # oksub hashem { return { @_ } }   # ok</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-2.4">The Anonymous Subroutine Composer</A></h3><P CLASS=para>You can create a reference to an anonymous subroutine byusing <A HREF="ch03_02.htm#PERL2-CMD-SUB">sub</A> without a subroutine name:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$coderef = sub { print "Boink!\n" };</PRE></DIV><P CLASS=para>Note the presence of the semicolon, which is required here toterminate the expression.  (It wouldn't be required after thedeclaration of a named subroutine.)  A nameless <tt CLASS=literal>sub{}</tt> is not so much a declaration as it is anoperator--like <tt CLASS=literal>do {}</tt> or<tt CLASS=literal>eval {}</tt>--except that the code inside isn'texecuted immediately.  Instead, it just generates a reference to thecode and returns that.  However, no matter how many times you executethe line shown above, <tt CLASS=literal>$coderef</tt> will still refer tothe same anonymous subroutine.[4]<blockquote class=footnote><P CLASS=para>[4] But see later about closures.  Even though there's only one anonymoussubroutine, there may be several copies of the lexical variables inuse by the subroutine, depending on when the subroutine reference wasgenerated.  </blockquote></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-2.5">Object Constructors</A></h3><P CLASS=para>Subroutines can also return references.  That may sound trite, butsometimes you are <I CLASS=emphasis>supposed</I> to use a subroutine to create areference rather than creating the reference yourself.  In particular,special subroutines called <I CLASS=emphasis>constructors</I> return references to objects.An object is simply a special kind of thingy that happens to know whichclass it's associated with.  Constructors know how to create thatassociation.  They do so by taking an ordinary thingy and turning itinto an object (which remains a thingy even while it's also being anobject).  The operator that a constructor uses to do this is called<A HREF="ch03_02.htm#PERL2-CMD-BLESS">bless</A>, so we can speak of an object as a blessed thingy.Constructors are customarily named <tt CLASS=literal>new()</tt>, but don't have to be.They're usually called in one of two ways:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$objref = new Doggie Tail =&gt; 'short', Ears =&gt; 'long';   # same as$objref = Doggie-&gt;new(Tail =&gt; 'short', Ears =&gt; 'long');</PRE></DIV><P CLASS=para>See <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>, for a discussion of Perl objects.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-2.6">Filehandle Referencers</A></h3><P CLASS=para>References to filehandles can be created by taking areference to a typeglob.  This is currently the best way to passnamed filehandles into or out of subroutines, or to store them in larger datastructures.<P CLASS=para><DIV CLASS=programlisting><P><PRE>splutter(\*STDOUT);sub splutter {    my $fh = shift;    print $fh "her um well a hmmm\n";}$rec = get_rec(\*STDIN);sub get_rec {    my $fh = shift;    return scalar &lt;$fh&gt;;}</PRE></DIV><P CLASS=para>However, if you don't need to refer to existing named filehandles, youshould consider using one of the newer, object-oriented library modulesthat provide filehandle objects via a constructor (see the previoussection).  In either case, you won't use filehandle names directly, butrather you'll use scalars (as above) to hold a reference tosomething that will (one way or another) be interpreted as afilehandle.  As we admitted earlier, there is some implicitdereferencing magic going on here.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-2.7">Implicit Creation of References</A></h3><P CLASS=para>A final method for creating references is not really a method at all.References of an appropriate type simply spring into existence if youdereference them in a context that assumes they exist.  This isextremely useful, and is also What You Expect.  This topic is covered in thenext section.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch04_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>What Is a Reference?</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Using Hard References</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>