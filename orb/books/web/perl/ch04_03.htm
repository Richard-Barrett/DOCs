<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 4] 4.3 Using Hard References</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:08:59 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_02.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 4</b></td><td width=172 align=right valign=top><A HREF="ch04_04.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-3">4.3 Using Hard References</A></h2><P CLASS=para>Just as there are numerous ways to create references, there are alsoseveral ways to use, or dereference, a reference.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-3.1">Using a Variable as a Variable Name</A></h3><P CLASS=para>Anywhere you might ordinarily put an alphanumeric identifier as part ofa variable or subroutine name, you can just replace the identifier witha simple scalar variable containing a reference of the correct type.For example:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$foo         = "two humps";$scalarref   = \$foo;$camel_model = $$scalarref;  # $camel_model is now "two humps"</PRE></DIV><P CLASS=para>Here are various dereferences:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$bar = $$scalarref;push(@$arrayref, $filename);$$arrayref[0] = "January";$$hashref{"KEY"} = "VALUE";&amp;$coderef(1,2,3);print $globref "output\n";</PRE></DIV><P CLASS=para>It's important to understand that we are specificallynot dereferencing <tt CLASS=literal>$arrayref[0]</tt>or <tt CLASS=literal>$hashref{"KEY"}</tt> there.  The dereferencing of thescalar variable happens before any array or hashlookups.  To dereference anything more complicated than a simplescalar variable, you must use one of the next two methods describedbelow.  However, "simple scalars" can include an identifier thatitself uses this first method recursively.  Therefore, the followingprints "howdy":<P CLASS=para><DIV CLASS=programlisting><P><PRE>$refrefref = \\\"howdy";print $$$$refrefref;</PRE></DIV><P CLASS=para>You can think of the dollar signs as executing right to left.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-3.2">Using a BLOCK as a Variable Name</A></h3><P CLASS=para>The second way is just like the first, except using a<tt CLASS=replaceable><i>BLOCK</i></tt> instead of a variable.  Anywhere you'd putan alphanumeric identifier as part of a variable or subroutine name,you can replace the identifier with a <tt CLASS=replaceable><i>BLOCK</i></tt>returning a reference of the correct type.  In other words, theprevious examples could also be handled like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$bar = ${$scalarref};push(@{$arrayref}, $filename);${$arrayref}[0] = "January";${$hashref}{"KEY"} = "VALUE";&amp;{$coderef}(1,2,3);</PRE></DIV><P CLASS=para>Admittedly, it's silly to use the braces in these simple cases, butthe <tt CLASS=replaceable><i>BLOCK</i></tt> can contain any arbitrary expression. In particular, it cancontain subscripted expressions. In the following example,<tt CLASS=literal>$dispatch{$index}</tt> is assumed to contain a reference to asubroutine. The example invokes the subroutine with three arguments.<DIV CLASS=programlisting><P><PRE>&amp;{ $dispatch{$index} }(1, 2, 3);</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-3.3">Using the Arrow Operator</A></h3><P CLASS=para>For references to arrays or hashes, a third method of dereferencingthe reference involves the use of the <tt CLASS=literal>-&gt;</tt> infixoperator.  This is a form of syntactic sugar that makes it easier toget at individual array or hash elements, especially when thereference expression is complicated.  Each of these trios isequivalent, corresponding to the three notations we've introduced.(We've inserted some spaces to line up equivalent elements.)<DIV CLASS=programlisting><P><PRE>$  $arrayref  [0] = "January";        #1${ $arrayref }[0] = "January";        #2   $arrayref-&gt;[0] = "January";        #3$  $hashref  {KEY} = "F#major";       #1${ $hashref }{KEY} = "F#major";       #2   $hashref-&gt;{KEY} = "F#major";       #3</PRE></DIV><P CLASS=para>You can see from this example that the first <tt CLASS=literal>$</tt> is missing from the thirdnotation.  It is, however, implied, and since it is implied, thenotation can only be used to reference scalar values, not slices.  Butjust as with the second notation, you can use any expression to the leftof the <tt CLASS=literal>-&gt;</tt>, including another dereference, because arrowoperators associate left to right:<DIV CLASS=programlisting><P><PRE>print $array[3]-&gt;{"English"}-&gt;[0];</PRE></DIV><P CLASS=para>Note that <tt CLASS=literal>$array[3]</tt> and <tt CLASS=literal>$array-&gt;[3]</tt> are not the same.The first is talking about the fourth element of <tt CLASS=literal>@array</tt>, while thesecond one is talking about the fourth element of the (possibly anonymous)array whose reference is contained in <tt CLASS=literal>$array</tt>.<P CLASS=para>Suppose now that <tt CLASS=literal>$array[3]</tt> is undefined.  The following statementis still legal:<DIV CLASS=programlisting><P><PRE>$array[3]-&gt;{"English"}-&gt;[0] = "January";</PRE></DIV><P CLASS=para>This is one of those cases mentioned earlier in which referencesspring into existence when used in an lvalue context.  Supposing<tt CLASS=literal>$array[3]</tt> to have been undefined, it'sautomatically defined with a hash reference so that we can look up<tt CLASS=literal>{"English"}</tt> in it.  Once that's done,<tt CLASS=literal>$array[3]-&gt;{"English"}</tt> will automatically getdefined with an array reference so that we can look up<tt CLASS=literal>[0]</tt> in it.  But this only happens when you'retrying to create an element.  Nothing would spring into existence ifyou were just trying to print out the value.  You'd just get theundefined value out of it.<P CLASS=para>One more shortcut here.  The arrow is optional between brace- orbracket-enclosed subscripts, so you can shrink the above code down to:<DIV CLASS=programlisting><P><PRE>$array[3]{"English"}[0] = "January";</PRE></DIV><P CLASS=para>Which, in the case of ordinary arrays, gives you multi-dimensional arraysjust like C's arrays:<DIV CLASS=programlisting><P><PRE>$answer[$x][$y][$z] += 42;</PRE></DIV><P CLASS=para>Well, okay, not <I CLASS=emphasis>entirely</I> like C's arrays.  For one thing, Cdoesn't know how to grow its arrays on demand, while Perl does.  Also, thereare similar constructs in the two languages that parse differently.In Perl, the following two statements do the same thing:<DIV CLASS=programlisting><P><PRE>$listref-&gt;[2][2] = "hello";    # pretty clear$$listref[2][2] = "hello";     # a bit confusing</PRE></DIV><P CLASS=para>This second of these statements may disconcert the C programmer, who isaccustomed to using <tt CLASS=literal>*a[i]</tt> to mean "what's pointed to by the<I CLASS=emphasis>i</I>  th element of <tt CLASS=literal>a</tt>".  But in Perl, the five prefixdereferencers (<tt CLASS=literal>$ @ * % &amp;</tt>) effectively bind more tightly than thesubscripting braces or brackets.[5]Therefore, it is <tt CLASS=literal>$$listref</tt> and not<tt CLASS=literal>$listref[$i]</tt> that is taken to be a reference to an array.If you want the C notion, you either have to write <tt CLASS=literal>${$listref[$i]}</tt> toforce the <tt CLASS=literal>$listref[$i]</tt> to get evaluated before the leading<tt CLASS=literal>$</tt> dereferencer, or you have to use the <tt CLASS=literal>-&gt;</tt> notation:<blockquote class=footnote><P CLASS=para>[5] But not because of operator precedence.  The funny characters in Perlare not operators in that sense.  The grammar simply prohibits anythingmore complicated than a simple variable or block from following theinitial funny character, for various funny reasons.</blockquote><DIV CLASS=programlisting><P><PRE>$listref[$i]-&gt;[$j] = "hello";</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-3.4">Using Object Methods</A></h3><P CLASS=para>If a reference happens to be a reference to an object (a blessed thingy,that is), then there are probably methods to access the innards of theobject, and you should probably stick to those methods unless you'rewriting the class package that defines the object's methods.  (Such apackage is allowed to treat the object as a mere thingy when it wantsto.)  In other words, be nice, and don't violate the object'sencapsulation without a very good reason.  Perl does not enforceencapsulation.  We are not totalitarians here.  We do expect some basiccivility, however.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-3.5">Other Tricks You Can Do with Hard References</A></h3><P CLASS=para>You can use the <A HREF="ch03_02.htm#PERL2-CMD-REF">ref</A> operator to determine what type of thingy areference is pointing to.  Think of <A HREF="ch03_02.htm#PERL2-CMD-REF">ref</A> as a "typeof" operatorthat returns true if its argument is a reference and falseotherwise.  The value returned depends on the type of thing referenced.Built-in types include:<DIV CLASS=programlisting><P><PRE>REFSCALARARRAYHASHCODEGLOB</PRE></DIV><P CLASS=para>If you simply use a hard reference in a string context, it'll be convertedto a string containing both the type and the address: <tt CLASS=literal>SCALAR(0x1fc0e)</tt>.(The reverse conversion cannot be done, since reference countinformation has been lost.)<P CLASS=para>You can use the <A HREF="ch03_02.htm#PERL2-CMD-BLESS">bless</A> operator toassociate a referenced thingy with a package functioning as an objectclass.  When you do this, <A HREF="ch03_02.htm#PERL2-CMD-REF">ref</A> willreturn that package name instead of the internal type.  An objectreference used in a string context returns a string with both theexternal and internal types, along with the address:<tt CLASS=literal>MyType=HASH(0x20d10)</tt>.  See <A HREF="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A> for more details about objects.<P CLASS=para>Since the dereference syntax always indicates the kind of referencedesired, a typeglob can be used the same way a reference can, despitethe fact that a typeglob contains multiple thingies of various types.So <tt CLASS=literal>${*foo}</tt> and <tt CLASS=literal>${\$foo}</tt> both refer to the same scalarvariable.  The latter is more efficient though.<P CLASS=para>Here's a trick for interpolating the value of a subroutine call into a string:<DIV CLASS=programlisting><P><PRE>print "My sub returned @{[ mysub(1,2,3) ]} that time.\n";</PRE></DIV><P CLASS=para>It works like this.  At compile time, when the <tt CLASS=literal>@{...}</tt> is seenwithin the double-quoted string, it's parsed as a block that will returna reference.  Within the block, there are square brackets that willcreate a reference to an anonymous array from whatever is in thebrackets.  So at run-time, <tt CLASS=literal>mysub(1,2,3)</tt> is called, and theresults are loaded into an anonymous array, a reference to which is thenreturned within the block.  That array reference is then immediatelydereferenced by the surrounding <tt CLASS=literal>@{...}</tt>, and the array value isinterpolated into the double-quoted string just as an ordinary arraywould be.  This chicanery is also useful for arbitrary expressions,such as:<DIV CLASS=programlisting><P><PRE>print "That yields @{[ $n + 5 ]} widgets\n";</PRE></DIV><P CLASS=para>Be careful though.  The inside of the square brackets is supplying alist context to its expression.  In this case it doesn't matter,although it's possible that the above call to <tt CLASS=literal>mysub()</tt> might care.When it does matter, a similar trick can be done with a scalarreference.  It just isn't quite as pretty:<DIV CLASS=programlisting><P><PRE>print "That yields ${ \($n + 5) } widgets.";</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-3.6">Closures</A></h3><P CLASS=para>Earlier we talked about creating anonymous subroutines with a nameless<tt CLASS=literal>sub {}</tt>.  Since anonymous subroutines have to begenerated someplace within your code (in order to generate thereference that you poke into some variable), such routines can bethought of as coming into existence at run-time.  (That is, they have atime of generation as well as a location of definition.)  Because ofthis fact, anonymous subroutines can act as <I CLASS=emphasis>closures</I>with respect to <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> variables--thatis, with respect to variables visible lexically within the currentscope.  Closure is a notion out of the Lisp world that says if youdefine an anonymous function in a particular lexical context at aparticular moment, it pretends to run in that context even when it'scalled outside of the context.  In other words, you are guaranteed toget the same copy of a lexical variable, eventhough many other instances of the same lexical variable may have beencreated before or since.  This gives you a way to pass arguments to asubroutine when you define it as well as when you call it.  It'suseful for setting up little bits of code to run later, such ascallbacks.<P CLASS=para>You can also think of closures as a way to write a subroutine template withoutusing <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>.  The lexical variables are like parameters to fill inthe template. <P CLASS=para>Here's a small example of how closures work:<DIV CLASS=programlisting><P><PRE>sub newprint {    my $x = shift;    return sub { my $y = shift; print "$x, $y!\n"; };}$h = newprint("Howdy");$g = newprint("Greetings");# Time passes...&amp;$h("world");&amp;$g("earthlings");</PRE></DIV><P CLASS=para>This prints:<DIV CLASS=programlisting><P><PRE>Howdy, world!Greetings, earthlings!</PRE></DIV><P CLASS=para>Note in particular how <tt CLASS=literal>$x</tt> continues to refer to the value passed into<tt CLASS=literal>newprint()</tt> despite the fact that the <tt CLASS=literal>my $x</tt> hasseemingly gone out ofscope by the time the anonymous subroutine runs.  That's what closuresare all about.<P CLASS=para>This method only applies to <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>variables. Global variables work as they always worked (since they're neithercreated nor destroyed the way lexical variables are). By and large,closures are not something you need to trouble yourself about.When you do need them, they just sorta do what you expect.[6]<blockquote class=footnote><P CLASS=para>[6] Always presuming you expect the right thing, of course.</blockquote><P CLASS=para>Perl doesn't provide member pointers like C++ does, but you can get asimilar effect using a closure.  Suppose you want a pointer to amethod for a particular object.  You can remember both the object andthe method as lexical variables bound to a closure:<DIV CLASS=programlisting><P><PRE>sub get_method_ref {    my ($self, $method) = @_;    return sub { return $self-&gt;$method(@_) };}$dog_wag = get_method_ref($dog, 'wag');&amp;$dog_wag("tail");  # Calls $dog-&gt;wag('tail').</PRE></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_02.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch04_04.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Creating Hard References</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Symbolic References</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>