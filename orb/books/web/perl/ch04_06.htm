<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 4] 4.6 A Brief Tutorial: Manipulating Lists of Lists</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:09:07 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_05.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 4</b></td><td width=172 align=right valign=top><A HREF="ch04_07.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-6">4.6 A Brief Tutorial: Manipulating Lists of Lists</A></h2><P CLASS=para><A NAME="CH04.TUT1"></A><A NAME="CH04.TUT2"></A><A NAME="CH04.TUT3"></A><A NAME="CH04.TUT4"></A><A NAME="CH04.TUT5"></A>There are many kinds of nested data structures.The simplest kind to build is a list of lists (also called an arrayof arrays, or a multi-dimensional array).  It's reasonably easy tounderstand, and almost everything that applies here will also be applicableto the fancier data structures.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-6.1">Composition and Access</A></h3><P CLASS=para>Here's how to put together a two-dimensional array value:<DIV CLASS=programlisting><P><PRE># assign to an array a list of list references@LoL = (        [ "fred", "barney" ],       [ "george", "jane", "elroy" ],       [ "homer", "marge", "bart" ],);print $LoL[2][2];   # prints "bart"</PRE></DIV><P CLASS=para>The overall list is enclosed by parentheses, not brackets.That's because you're assigning a list to an array.  If you didn't wantthe result to be a list, but rather a reference to an array, then youwould use brackets on the outside:<DIV CLASS=programlisting><P><PRE># assign to a scalar variable a reference to a list of list references$ref_to_LoL = [    [ "fred", "barney", "pebbles", "bambam", "dino", ],    [ "homer", "bart", "marge", "maggie", ],    [ "george", "jane", "elroy", "judy", ],];print $ref_to_LoL-&gt;[2][2];   # prints "elroy"</PRE></DIV><P CLASS=para><tt CLASS=literal>$ref_to_LoL</tt> is a reference to an array, whereas<tt CLASS=literal>@LoL</tt> is an array proper.  The parentheses(indicating a list) have changed to brackets (indicating the creationof a reference to an array).  Unlike C, Perl doesn't allow you tofreely interchange arrays with references to arrays.  This is afeature.<P CLASS=para>Remember that there is an implied <tt CLASS=literal>-&gt;</tt> between every pair ofadjacent braces or brackets.  Therefore these two lines:<DIV CLASS=programlisting><P><PRE>$LoL[2][2]$ref_to_LoL-&gt;[2][2]</PRE></DIV><P CLASS=para>are equivalent to these two lines:<DIV CLASS=programlisting><P><PRE>$LoL[2]-&gt;[2]$ref_to_LoL-&gt;[2]-&gt;[2]</PRE></DIV><P CLASS=para>There is, however, no implied<tt CLASS=literal>-&gt;</tt> before the first pair of brackets, which iswhy the dereference of <tt CLASS=literal>$ref_to_LoL</tt> requires the<tt CLASS=literal>-&gt;</tt>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-6.2">Growing Your Own</A></h3><P CLASS=para>Now those big list assignments are well and good for creating a fixeddata structure, but what if you want to calculate each element on thefly, or otherwise build the structure piecemeal?<P CLASS=para>First, let's look at reading a data structure in from a file.  We'llassume that there's a flat file in which each line is a row of thestructure, and each word an element.  Here's how to proceed:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    @tmp = split;    push @LoL, [ @tmp ];}</PRE></DIV><P CLASS=para>You can also load the array from a function:<DIV CLASS=programlisting><P><PRE>for $i ( 1 .. 10 ) {    @tmp = somefunc($i);    $LoL[$i] = [ @tmp ];}</PRE></DIV><P CLASS=para>Of course, you don't need to name the temporary array:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    push @LoL, [ split ];}</PRE></DIV><P CLASS=para>and:<DIV CLASS=programlisting><P><PRE>for $i ( 1 .. 10 ) {    $LoL[$i] = [ somefunc($i) ];}</PRE></DIV><P CLASS=para>You also don't have to use <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A>.  Youcould keep track of where you are in the array, and assign each lineof the file to the appropriate row of the array:<DIV CLASS=programlisting><P><PRE>my (@LoL, $i, $line);for $i ( 0 .. 10 ) { # just first 11 lines     $line = &lt;&gt;;    $LoL[$i] = [ split ' ', $line ];}</PRE></DIV><P CLASS=para>Simplifying, you can avoid the assignment of the line to amediating variable:<DIV CLASS=programlisting><P><PRE>my (@LoL, $i);for $i ( 0 .. 10 ) { # just first 11 lines    $LoL[$i] = [ split ' ', &lt;&gt; ];}</PRE></DIV><P CLASS=para>In general, you should be leery of using potential list functions like<tt CLASS=literal>&lt;&gt;</tt> in a scalar context without explicitly stating such.  The following example would be clearer to the casual reader:<DIV CLASS=programlisting><P><PRE>my (@LoL, $i);for $i ( 0 .. 10 ) { # just first 11 lines    $LoL[$i] = [ split ' ', scalar(&lt;&gt;) ];}</PRE></DIV><P CLASS=para>If you want a <tt CLASS=literal>$ref_to_LoL</tt> variable as a referenceto an array, do something like:<DIV CLASS=programlisting><P><PRE>my $ref_to_LoL;while (&lt;&gt;) {    push @$ref_to_LoL, [ split ];}</PRE></DIV><P CLASS=para>So much for adding new rows to the list of lists.  What about adding newcolumns? If you're just dealing with matrices, it's often easiest to usesimple assignment:<DIV CLASS=programlisting><P><PRE>for $x (1 .. 10) {    for $y (1 .. 10) {        $LoL[$x][$y] = func($x, $y);    }}for $x ( 3, 7, 9 ) {    $LoL[$x][20] += func2($x);}</PRE></DIV><P CLASS=para>It doesn't matter whether the subscripted elements of <tt CLASS=literal>@LoL</tt> are already there or not; Perl will gladly create them for you, settingintervening elements to the undefined value as need be. If you just want to append to a row, you haveto do something a bit funnier looking:<DIV CLASS=programlisting><P><PRE># add new columns to an existing rowpush @{ $LoL[0] }, "wilma", "betty";</PRE></DIV><P CLASS=para>Notice that this wouldn't work:<DIV CLASS=programlisting><P><PRE>push $LoL[0], "wilma", "betty";  # WRONG!</PRE></DIV><P CLASS=para>In fact, that wouldn't even compile, because the argument to <A HREF="ch03_02.htm#PERL2-CMD-PUSH">push</A> must be a real array, not just a referenceto an array.  Therefore, the first argument absolutely must beginwith an <tt CLASS=literal>@</tt> character.  What comes after the<tt CLASS=literal>@</tt> is somewhat negotiable.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-6.3">Access and Printing</A></h3><P CLASS=para>Now it's time to print your data structure.  If you only want one element, do this:<DIV CLASS=programlisting><P><PRE>print $LoL[0][0];</PRE></DIV><P CLASS=para>If you want to print the whole thing, though, you can't just say:<DIV CLASS=programlisting><P><PRE>print @LoL;         # WRONG</PRE></DIV><P CLASS=para>because you'll get references listed, and Perl will neverautomatically dereference thingies for you.  Instead, you have to rollyourself a loop or two.  The following code prints the wholestructure, using the shell-style <B>for</B>construct to loop through the outer set of subscripts:<DIV CLASS=programlisting><P><PRE>for $array_ref ( @LoL ) {    print "\t [ @$array_ref ],\n";}</PRE></DIV><P CLASS=para>Beware of the brackets.  In this and the following example, the(non-subscripting) brackets do not indicate the creation of areference.  The brackets occur inside a quoted string, not in a placewhere a term is expected, and therefore lose their special meaning.They are just part of the string that <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> outputs.<P CLASS=para>If you want to keep track of subscripts, you might do this:<DIV CLASS=programlisting><P><PRE>for $i ( 0 .. $#LoL ) {    print "\t element $i is [ @{$LoL[$i]} ],\n";}</PRE></DIV><P CLASS=para>or maybe even this (notice the inner loop):<DIV CLASS=programlisting><P><PRE>for $i ( 0 .. $#LoL ) {    for $j ( 0 .. $#{$LoL[$i]} ) {        print "element $i $j is $LoL[$i][$j]\n";    }}</PRE></DIV><P CLASS=para>As you can see, things are getting a bit complicated.  That's why sometimes it's easier to use a temporary variable on your way through:<DIV CLASS=programlisting><P><PRE>for $i ( 0 .. $#LoL ) {    $aref = $LoL[$i];    for $j ( 0 .. $#{$aref} ) {        print "element $i $j is $aref-&gt;[$j]\n";    }}</PRE></DIV><P CLASS=para>But that's still a bit ugly.  How about this:<DIV CLASS=programlisting><P><PRE>for $i ( 0 .. $#LoL ) {    $aref = $LoL[$i];    $n = @$aref - 1;    for $j ( 0 .. $n ) {        print "element $i $j is $aref-&gt;[$j]\n";    }}</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-6.4">Slices</A></h3><P CLASS=para>If you want to get at a slice (part of a row) in a multi-dimensionalarray, you're going to have to do some fancy subscripting.  That'sbecause, while we have a nice synonym for a single element via thepointer arrow, no such convenience exists for slices.However, you can always write a loop to do a slice operation.<P CLASS=para>Here's how to create a one-dimensional slice of one subarray of atwo-dimensional array, using a loop.  We'll assume a list-of-listsvariable (rather than a reference to a list of lists):<DIV CLASS=programlisting><P><PRE>@part = ();$x = 4;     for ($y = 7; $y &lt; 13; $y++) {    push @part, $LoL[$x][$y];}</PRE></DIV><P CLASS=para>That same loop could be replaced with a slice operation:<DIV CLASS=programlisting><P><PRE>@part = @{ $LoL[4] } [ 7..12 ];</PRE></DIV><P CLASS=para>If you want a <I CLASS=emphasis>two-dimensional slice</I>, say, with<tt CLASS=literal>$x</tt> running from <tt CLASS=literal>4..8</tt> and<tt CLASS=literal>$y</tt> from <tt CLASS=literal>7..12</tt>, here's one way todo it:<DIV CLASS=programlisting><P><PRE>@newLoL = ();for ($startx = $x = 4; $x &lt;= 8; $x++) {    for ($starty = $y = 7; $y &lt;= 12; $y++) {        $newLoL[$x - $startx][$y - $starty] = $LoL[$x][$y];    }}</PRE></DIV><P CLASS=para>In this example, the individual values within each subarray of<tt CLASS=literal>@newLoL</tt> are assigned one by one, taken from theappropriate locations in <tt CLASS=literal>@LoL</tt>.  An alternative isto create anonymous arrays, each consisting of a desired slice of asubarray of <tt CLASS=literal>@LoL</tt>, and then put references to theseanonymous arrays into <tt CLASS=literal>@newLoL</tt>.  So we are writingreferences into <tt CLASS=literal>@newLoL</tt> (subscripted once, so tospeak) instead of subarray values into a twice-subscripted<tt CLASS=literal>@newLol</tt>.  This method eliminates the innermost loop:<DIV CLASS=programlisting><P><PRE>for ($x = 4; $x &lt;= 8; $x++) {    push @newLoL, [ @{ $LoL[$x] } [ 7..12 ] ];}</PRE></DIV><P CLASS=para>Of course, if you do this very often, you should probably write asubroutine called something like <tt CLASS=literal>extract_rectangle()</tt>.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-4-SECT-6.5">Common Mistakes</A></h3><P CLASS=para><A NAME="CH04.TROUBLE"></A>As mentioned previously, every array or hash in Perl is implemented inone dimension.  "Multi-dimensional" arrays, too, are one-dimensional, butthe values in this one-dimensional array are references to other datastructures.  If you print these values out withoutdereferencing them, you will get the references rather than the datareferenced.  For example, these two lines:<DIV CLASS=programlisting><P><PRE>@LoL = ( [2, 3], [4, 5, 7], [0] );print "@LoL";</PRE></DIV><P CLASS=para>result in:<DIV CLASS=programlisting><P><PRE>ARRAY(0x83c38) ARRAY(0x8b194) ARRAY(0x8b1d0)</PRE></DIV><P CLASS=para>On the other hand, this line:<DIV CLASS=programlisting><P><PRE>print $LoL[1][2];</PRE></DIV><P CLASS=para>yields <tt CLASS=literal>7</tt> as output.<P CLASS=para>Perl dereferences your variables only when you employ one of thedereferencing mechanisms.  But remember that<tt CLASS=literal>$LoL[1][2]</tt> is just a convenient way to write<tt CLASS=literal>$LoL[1]-&gt;[2]</tt>, which in turn is a convenient way to write<tt CLASS=literal>${$LoL[1]}[2]</tt>.  Indeed, you could write all your dereferencingoperations with braces, but that would be uglier than ugly.Use the syntactic sugar Perl provides to sweeten your program.<P CLASS=para><tt CLASS=literal>@LoL</tt> was defined as an array whose values happened to bereferences.  Here's a similar-looking, but very different case:<DIV CLASS=programlisting><P><PRE>my $listref = [    [ "fred", "barney", "pebbles", "bambam", "dino", ],    [ "homer", "bart", "marge", "maggie", ],    [ "george", "jane", "elroy", "judy", ],];print $listref[2][2];   # WRONG!</PRE></DIV><P CLASS=para>Here, <tt CLASS=literal>$listref</tt> is not an array, but a scalarvariable <I CLASS=emphasis>referring</I> to an array--in thiscase, referring to an anonymous, multi-dimensional array, the onecreated by the outer brackets.  Therefore, to print<tt CLASS=literal>elroy</tt> in this example, we should have said:<DIV CLASS=programlisting><P><PRE>print $listref-&gt;[2][2];</PRE></DIV><P CLASS=para>By contrast, <tt CLASS=literal>$listref[2]</tt> in the erroneous <B>print</B>statement is the second element in a not-yet-declared array.  If youask to<DIV CLASS=programlisting><P><PRE>use strict 'vars'; # or just use strict</PRE></DIV><P CLASS=para>then the use of the undeclared array will be flagged as an error at compile time.<P CLASS=para>In constructing an array of arrays, remember to take a reference for thedaughter arrays.  Otherwise, you will just create an array containing theelement counts of the daughter arrays, like this:<DIV CLASS=programlisting><P><PRE>for $i (1..10) {    @list = somefunc($i);    $LoL[$i] = @list;       # WRONG!}</PRE></DIV><P CLASS=para>Here <tt CLASS=literal>@list</tt> is being accessed in a scalar context, and thereforeyields the a count of its elements, which is assigned to<tt CLASS=literal>$LoL[$i]</tt>.  The proper way to take the reference will be shownin a moment.<P CLASS=para>Another common error involves taking a reference to the same memory locationover and over again:<DIV CLASS=programlisting><P><PRE>for $i (1..10) {    @list = somefunc($i);    $LoL[$i] = \@list;      # WRONG!}</PRE></DIV><P CLASS=para>Every reference generated by the second line of the <B>for</B> loop isthe same, namely, a reference to the single array <tt CLASS=literal>@list</tt>.  Yes, thisarray is being given a different set of values on each pass through theloop, but when everything is said and done, <tt CLASS=literal>$LoL</tt> contains a set ofidentical references to the same array, which now holds the last set ofvalues that were assigned to it.<P CLASS=para>Here's a more successful approach:<DIV CLASS=programlisting><P><PRE>for $i (1..10) {    @list = somefunc($i);    $LoL[$i] = [ @list ];}</PRE></DIV><P CLASS=para>The brackets make a reference to a new array with a <I CLASS=emphasis>copy</I>of what's in <tt CLASS=literal>@list</tt> at the time of the assignment.<P CLASS=para>A similar result--though much more difficult to read--would be produced by:<DIV CLASS=programlisting><P><PRE>for $i (1..10) {    @list = somefunc($i);    @{$LoL[$i]} = @list;}</PRE></DIV><P CLASS=para>Since <tt CLASS=literal>$LoL[$i]</tt> needs to be a reference, the reference springsinto existence.  Then, the preceding <tt CLASS=literal>@</tt> dereferences this newreference, with the result that the values of <tt CLASS=literal>@list</tt> are assigned (in list context) to the array referenced by <tt CLASS=literal>$LoL[$i]</tt>.  Forclarity's sake, you might wish to avoid this construct.<P CLASS=para>But there <I CLASS=emphasis>is</I> a situation in which you might use it.Suppose <tt CLASS=literal>$LoL</tt> is already an array of references to arrays.That is, suppose you had made assignments like:<DIV CLASS=programlisting><P><PRE>$LoL[3] = \@original_list;</PRE></DIV><P CLASS=para>And now suppose that you want to change <tt CLASS=literal>@original_list</tt> (that is,you want to change the fourth row of <tt CLASS=literal>$LoL</tt>) so that itrefers to the elements of <tt CLASS=literal>@list</tt>.  This code will work:<DIV CLASS=programlisting><P><PRE>@{$LoL[3]} = @list;</PRE></DIV><P CLASS=para>In this case, the reference itself does not change, but the elements ofthe array being referred to do.  You need to be aware, however,that this approach overwrites the values of <tt CLASS=literal>@original_list</tt>.<P CLASS=para>Finally, the following dangerous-looking code actually works fine:<DIV CLASS=programlisting><P><PRE>for $i (1..10) {    my @list = somefunc($i);    $LoL[$i] = \@list;}</PRE></DIV><P CLASS=para>That's because the <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> variable iscreated afresh each time through the loop.  So even though it looks asthough you stored the same variable reference each time, you actually didnot.  This is a subtle distinction, but the technique can produce moreefficient code, at the risk of misleading less enlightened programmers.  It's more efficient because there's no copy in the final assignment.On the other hand, if you have to copy the values anyway (which thefirst assignment above is doing), then you might as well use the copyimplied by the brackets and avoid the temporary variable:<DIV CLASS=programlisting><P><PRE>for $i (1..10) {    $LoL[$i] = [ somefunc($i) ];}</PRE></DIV><P CLASS=para>In summary:<DIV CLASS=programlisting><P><PRE>$LoL[$i] = [ @list ];   # safest, sometimes fastest$LoL[$i] = \@list;      # fast but risky, depends on my-ness of list@{ $LoL[$i] } = @list;  # too tricky for most uses</PRE></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_05.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch04_07.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Braces, Brackets, and Quoting</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Data Structure Code Examples</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>