<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 5] Packages, Modules, and Object Classes</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:10:14 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_07.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 5</b></td><td width=172 align=right valign=top><A HREF="ch05_02.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><H1 CLASS=chapter><A CLASS="TITLE" NAME="PERL2-CH-5">Packages, Modules, and Object Classes</A></H1><DIV CLASS=htmltoc><p><b>Contents:</b><br>Packages<br><A HREF="ch05_02.htm">Modules</A><BR><A HREF="ch05_03.htm">Objects</A><BR><A HREF="ch05_04.htm">Using Tied Variables</A><BR><A HREF="ch05_05.htm">Some Hints About Object Design</A><BR></DIV><P CLASS=para>This chapter, more than any other in this book, is about Laziness,Impatience, and Hubris--because this chapter is about good softwaredesign.<P CLASS=para><A NAME="CH05.PACK"></A>We've all fallen into the trap of using cut-and-paste when we shouldhave chosen to define a higher-level abstraction, if only just a loop orsubroutine.[1]To be sure, some folks have gone to the opposite extreme of definingever-growing mounds of higher-level abstractions when they should haveused cut-and-paste.[2]Generally, though, most of us need to think about using more abstractionrather than less.<blockquote class=footnote><P CLASS=para>[1] This is a form of False Laziness.<P CLASS=para>[2] This is a form of False Hubris.</blockquote><P CLASS=para>(Caught somewhere in the middle are the people who have a balanced viewof how much abstraction is good, but who jump the gun on writing their ownabstractions when they should be reusing existing code.)[3]<blockquote class=footnote><P CLASS=para>[3] You guessed it, this is False Impatience.  But if you're determined toreinvent the wheel, at least try to invent a better one.</blockquote><P CLASS=para>Whenever you're tempted to do any of these things, you need to sit backand think about what will do the most good for you and your neighborover the long haul.  If you're going to pour your creative energies intoa lump of code, why not make the world a better place while you're atit?  (Even if you're only aiming for the program to <I CLASS=emphasis>succeed</I>, you needto make sure it fits its ecological niche.)<P CLASS=para>The first step toward ecologically sustainable programming is simply:don't litter in the park.  When you write a chunk of code, think aboutgiving the code its own namespace, so that your variables and functionsdon't clobber anyone else's, or vice versa.  A namespace is a bit likeyour home, where you're allowed to be as messy as you like, as longas you keep your external interface to other citizens moderately civil.In Perl, a namespace is called a <I CLASS=emphasis>package</I>.  Packages provide thefundamental building block upon which the higher-level concepts ofmodules and classes are constructed.<P CLASS=para>Like the notion of "home", the notion of "package" is a bit nebulous.Packages are independent of files.  You can have many packages in asingle file, or a single package that spans several files, just as yourhome could be one part of a larger building, if you live in an apartment, or could comprise severalbuildings, if your name happens to be Queen Elizabeth.  But the usualsize of a home is one building, and the usual size of a package is onefile.  Perl has some special help for people who want to put one packagein one file, as long as you're willing to name the file with the samename as the package and give your file an extension of "<I CLASS=emphasis>.pm</I>",which is short for "perl module". The <I CLASS=emphasis>module</I> is the unit ofreusability in Perl.  Indeed, the way you <I CLASS=emphasis>use</I> a module is with the<A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> command, which is a compiler directive that controls theimportation of functions and variables from a module.  Every example of<A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> you've seen until now has been an example of module reuse.<P CLASS=para>Object classes are another concept built on the package concept.The concept of classes therefore cuts across the concepts of files andmodules.  But the typical class is nevertheless implemented with amodule.  (If you're starting to get the feeling that much of Perl cultureis governed by mere convention, then you're starting to get the rightfeeling, civilly speaking.  The trend over the last 20 years or so hasbeen to design computer languages that enforce a state of paranoia.You're expected to program every module as if it were in a state ofsiege.  Certainly there are some feudal cultures where this isappropriate, but not all cultures are like this.  In Perl culture, bycontrast, you're expected to stay out of someone's home because youweren't invited in, not because there are bars[4]on the windows.)<blockquote class=footnote><P CLASS=para>[4] But Perl provides some bars if you want them, too.  See the Safe module in<A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>, for instance.</blockquote><P CLASS=para>Anyway, back to classes.  When you <B>use</B> a module that implements a class,you're benefiting from the direct reuse of the software that implementsthat module.  But with object classes you can get the additionalbenefits of <I CLASS=emphasis>indirect</I> software reuse when the class you're using turnsaround and reuses other classes that it gets some characteristicsfrom.  But this is not primarily a book about object-orientedmethodology, and we're not here to convert you into a ravingobject-oriented zealot, even if you want to be converted.  There arealready plenty of books out there for that.Perl's philosophy of object-oriented design fits right in with Perl'sphilosophy of everything else: use object-oriented design where it makessense, and avoid it where it doesn't.  Your call.<P CLASS=para>As we mentioned in the previous chapter, object-oriented programming inPerl is accomplished through use of references that happen to refer tothingies that know which class they're associated with.  In fact, nowthat you know about references, you know almost everything hard aboutobjects.  The rest of it just "lays under the fingers", as a violinistwould say.  You will need to practice a little, though.<P CLASS=para>In this chapter we will discuss creation and use of packages, modules,and classes.  Then we will review some of the essentials ofobject-oriented programming, explain how references become objects, andillustrate how these objects are manipulated as membersof one or more classes.  We'll also tell you how to <B>tie</B> ordinaryvariables into object classes to turn them into magical variables.<DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-5-SECT-1">5.1 Packages</A></h2><P CLASS=para>Perl provides a mechanism to protect different sections of code frominadvertently tampering with each other's variables.  In fact, apartfrom certain magical variables, there's really no such thing as a globalvariable in Perl.  Code is always compiled in the <I CLASS=emphasis>current package</I>.The initial current package is package main, but at any time you canswitch the current package to another one using the <A HREF="ch03_02.htm#PERL2-CMD-PACKAGE">package</A>declaration.  The current package determines which symbol table is usedfor name lookups (for names that aren't otherwise package-qualified).The notion of "current package" is both a compile-time and run-timeconcept.  Most name lookups happen at compile-time, but run-time lookupshappen when symbolic references are dereferenced, and also when new bitsof code are parsed under <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>.  In particular, <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> operationsknow which package they were invoked in, and propagate that packageinward as the current package of the evaluated code.  (You can alwaysswitch to a different package within the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> string, of course,since an <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> string counts as a block, as does a file loaded in with <B>do</B>,<B>require</B>, or <B>use</B>.)<P CLASS=para>The scope of a <A HREF="ch03_02.htm#PERL2-CMD-PACKAGE">package</A> declaration is from the declaration itselfthrough the end of the innermost enclosing block (or until another<A HREF="ch03_02.htm#PERL2-CMD-PACKAGE">package</A> declaration at the same level, which hides the earlier one).All subsequent identifiers (except those declared with <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>, or thosequalified with a different package name) will be placed in the symboltable belonging to the package.  Typically, you would put a <A HREF="ch03_02.htm#PERL2-CMD-PACKAGE">package</A>declaration as the first declaration in a file to be included by<A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> or <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A>.  But again, that's by convention.  You can put a<A HREF="ch03_02.htm#PERL2-CMD-PACKAGE">package</A> declaration anywhere you can put a statement.  You could evenput it at the end of a block, in which case it would have no effectwhatsoever.  You can switch into a package in more than one place; itmerely influences which symbol table is used by the compiler for therest of that block.  (This is how a given package can span more thanone file.)<P CLASS=para>You can refer to identifiers[5]in other packages by prefixing ("qualifying") the identifier with thepackage name and a double colon: <tt CLASS=literal>$Package::Variable</tt>.  If thepackage name is null, the main package is assumed.  That is,<tt CLASS=literal>$::sail</tt> is equivalent to <tt CLASS=literal>$main::sail</tt>.[6](The old package delimiter was a single quote, which produced things like<tt CLASS=literal>$main'sail</tt> and <tt CLASS=literal>$'sail</tt>.  But a double colon is now thepreferred delimiter, in part because it's more readable to humans, andin part because it's more readable to <I CLASS=emphasis>emacs</I> macros.  It also givesC++ programmers a warm feeling.)<blockquote class=footnote><P CLASS=para>[5] By identifiers, we mean the names used as symbol table keys to accessscalar variables, array variables, hash variables, functions, file ordirectory handles, and formats.  Syntactically speaking, labels are alsoidentifiers, but they aren't put into a particular symbol table; rather,they are attached directly to the statements in your program.  Labelsmay not be package qualified.<P CLASS=para>[6] To clear up another bit of potential confusion, in a variable name like<tt CLASS=literal>$main::sail</tt>, we use the term "identifier" to talk about <tt CLASS=literal>main</tt> and<tt CLASS=literal>sail</tt>, but not <tt CLASS=literal>main::sail</tt>.  We call that a variable name instead,because an identifier may not contain a colon.  The definition of anidentifier is lexical, in that an identifier is a token that matchesthe pattern <tt CLASS=literal>/^[A-Za-z_][A-Za-z_0-9]*$/</tt>.</blockquote><P CLASS=para>Packages may be nested inside other packages:<tt CLASS=literal>$OUTER::INNER::var</tt>.  This implies nothing about the order ofname lookups, however.  There are no fallback symbol tables.  Allundeclared symbols are either local to the current package, or must befully qualified from the outer package name down.  For instance, thereis nowhere within package <tt CLASS=literal>OUTER</tt> that <tt CLASS=literal>$INNER::var</tt> refersto <tt CLASS=literal>$OUTER::INNER::var</tt>.  It would treat package <tt CLASS=literal>INNER</tt> asa totally separate global package.  Similarly, every <B>package</B> declarationmust declare a complete package name.  No package name ever assumes anykind of implied "prefix", even if (seemingly) declared within the scopeof some other package declaration.<P CLASS=para>Only identifiers (names starting with letters or underscore) are storedin the current package's symbol table.  All other symbols are kept inpackage main, including all the magical punctuation-only variableslike <B>$!</B> and <B>$_</B>.  In addition, the identifiers <tt CLASS=literal>STDIN</tt>,<tt CLASS=literal>STDOUT</tt>, <tt CLASS=literal>STDERR</tt>, <tt CLASS=literal>ARGV</tt>, <tt CLASS=literal>ARGVOUT</tt>, <tt CLASS=literal>ENV</tt>,<tt CLASS=literal>INC</tt>, and <tt CLASS=literal>SIG</tt> are forced to be in package main even whenused for purposes other than their built-in ones.  Furthermore, if youhave a package called <tt CLASS=literal>m</tt>, <tt CLASS=literal>s</tt>, <tt CLASS=literal>y</tt>, or <tt CLASS=literal>tr</tt>,then you can't use the qualified form of an identifier as a filehandlebecause it will be interpreted instead as a pattern match, asubstitution, or a translation. Using uppercase package names avoidsthis problem.<P CLASS=para>Assignment of a string to <B>%SIG</B> assumes the signal handler specified isin the main package, if the name assigned is unqualified.  Qualifythe signal handler name if you want to have a signal handler in apackage, or don't use a string at all: assign a typeglob or a functionreference instead:<P CLASS=para><DIV CLASS=programlisting><P><PRE>$SIG{QUIT} = "quit_catcher";     # implies "main::quit_catcher"$SIG{QUIT} = *quit_catcher;      # forces current package's sub$SIG{QUIT} = \&amp;quit_catcher;     # forces current package's sub$SIG{QUIT} = sub { print "Caught SIGQUIT\n" };  # anonymous sub</PRE></DIV><P CLASS=para>See <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> and <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>, for other scopingissues.  See the "Signals" section in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>, for more on signal handlers.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-5-SECT-1.1">Symbol Tables</A></h3><P CLASS=para><A NAME="CH05.SYM1"></A><A NAME="CH05.SYM2"></A>The symbol table for a package happens to be stored in a hash whose nameis the same as the package name with two colons appended.  Themain symbol table's name is thus <tt CLASS=literal>%main::</tt>, or <tt CLASS=literal>%::</tt>for short, since package main is the default.  Likewise, the symbol tablefor the nestedpackage we mentioned earlier is named <tt CLASS=literal>%OUTER::INNER::</tt>.  As ithappens, the main symbol table contains all other top-level symboltables, including itself, so <tt CLASS=literal>%OUTER::INNER::</tt> is also<tt CLASS=literal>%main::OUTER::INNER::</tt>.<P CLASS=para>When we say that a symbol table "contains" another symbol table, we mean that it contains a reference to the other symbol table. Sincepackage main is a top-level package, it contains a reference to itself,with the result that <tt CLASS=literal>%main::</tt> is the same as<tt CLASS=literal>%main::main::</tt>, and <tt CLASS=literal>%main::main::main::</tt>, and so on, adinfinitum. It's important to check for this special case if you writecode to traverse all symbol tables.<P CLASS=para>The keys in a symbol table hash are the identifiers of the symbols inthe symbol table.  The values in a symbol table hash are thecorresponding typeglob values.  So when you use the <tt CLASS=literal>*name</tt> typeglobnotation, you're really just accessing a value in the hash that holdsthe current package's symbol table.  In fact, the following have thesame effect, although the first is potentially more efficient because it does thesymbol table lookup at compile time:<P CLASS=para><DIV CLASS=programlisting><P><PRE>local *somesym = *main::variable;local *somesym = $main::{"variable"};</PRE></DIV><P CLASS=para>Since a package is a hash, you can look up the keys of the package, andhence all the variables of the package.  Try this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>foreach $symname (sort keys %main::) {    local *sym = $main::{$symname};    print "\$$symname is defined\n" if defined $sym;    print "\@$symname is defined\n" if defined @sym;    print "\%$symname is defined\n" if defined %sym;}</PRE></DIV><P CLASS=para>Since all packages are accessible (directly or indirectly) throughpackage main, you can visit every package variable in the program,using code written in Perl.  The Perl debugger does precisely that whenyou ask it to dump all your variables.<P CLASS=para>Assignment to a typeglob performs an aliasing operation; that is,<P CLASS=para><DIV CLASS=programlisting><P><PRE>*dick = *richard;</PRE></DIV><P CLASS=para>causes everything accessible via the identifier <tt CLASS=literal>richard</tt> to also beaccessible via the symbol <tt CLASS=literal>dick</tt>.  If you only want to alias aparticular variable or subroutine, assign a reference instead:<P CLASS=para><DIV CLASS=programlisting><P><PRE>*dick = \$richard;</PRE></DIV><P CLASS=para>This makes <tt CLASS=literal>$richard</tt> and <tt CLASS=literal>$dick</tt> the same variable, but leaves<tt CLASS=literal>@richard</tt> and <tt CLASS=literal>@dick</tt> as separate arrays.  Tricky, eh?<P CLASS=para>This mechanism may be used to pass and return cheap referencesinto or from subroutines if you don't want to copy the whole thing:<P CLASS=para><DIV CLASS=programlisting><P><PRE>%some_hash = ();*some_hash = fn( \%another_hash );sub fn {    local *hashsym = shift;    # now use %hashsym normally, and you    # will affect the caller's %another_hash    my %nhash = (); # populate this hash at will    return \%nhash;}</PRE></DIV><P CLASS=para>On return, the reference will overwrite the hash slot in thesymbol table specified by the <tt CLASS=literal>*some_hash</tt> typeglob.  Thisis a somewhat sneaky way of passing around references cheaplywhen you don't want to have to remember to dereference variablesexplicitly. It only works on package variables though, which is whywe had to use <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> there instead of <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>.<P CLASS=para>Another use of symbol tables is for making "constant" scalars:<P CLASS=para><DIV CLASS=programlisting><P><PRE>*PI = \3.14159265358979;</PRE></DIV><P CLASS=para>Now you cannot alter <tt CLASS=literal>$PI</tt>, which is probably a good thing, all in all.<P CLASS=para>When you do that assignment, you're just replacing one reference withinthe typeglob.  If you think about it sideways, the typeglob itself canbe viewed as a kind of hash, with entries for the different variabletypes in it.  In this case, the keys are fixed, since a typeglob cancontain exactly one scalar, one array, one hash, and so on.  But you canpull out the individual references, like this:<P CLASS=para><DIV CLASS=programlisting><P><PRE>*pkg::sym{SCALAR}      # same as \$pkg::sym*pkg::sym{ARRAY}       # same as \@pkg::sym*pkg::sym{HASH}        # same as \%pkg::sym*pkg::sym{CODE}        # same as \&amp;pkg::sym*pkg::sym{GLOB}        # same as \*pkg::sym*pkg::sym{FILEHANDLE}  # internal filehandle, no direct equivalent*pkg::sym{NAME}        # "sym" (not a reference)*pkg::sym{PACKAGE}     # "pkg" (not a reference)</PRE></DIV><P CLASS=para>This is primarily used to get at the internal filehandle reference,since the other internal references are already accessible in otherways.  But we thought we'd generalize it because it looks kind ofpretty.  Sort of.  You probably don't need to remember all this unlessyou're planning to write a Perl debugger.  So let's get back to thetopic of writing good software.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-5-SECT-1.2">Package Constructors and Destructors: BEGIN and END</A></h3><P CLASS=para>Two special subroutine definitions that function as packageconstructors and destructors[7]are the <tt CLASS=literal>BEGIN</tt> and <tt CLASS=literal>END</tt> routines.  The <B>sub</B> is optionalfor these routines.<blockquote class=footnote><P CLASS=para>[7] Strictly speaking, these aren't constructors and destructors, butinitializers and finalizers.  And strictly speaking, packages aren'tobjects.  But strictly speaking, we don't speak strictly around heretoo often.</blockquote><P CLASS=para>A <tt CLASS=literal>BEGIN</tt> subroutine is executed as soon as possible, that is, themoment it is completely defined, even before the rest of the containingfile is parsed.  You may have multiple <tt CLASS=literal>BEGIN</tt> blocks within afile--they will execute in order of definition.  Because a <tt CLASS=literal>BEGIN</tt>block executes immediately, it can pull in definitions of subroutinesand such from other files in time to be visible during compilation of therest of the file.This is important because subroutine declarations change how the restof the file will be parsed.  At the very least, declaring a subroutineallows it to be used as a list operator, without parentheses.  And ifthe subroutine is declared with a prototype, then calls to thatsubroutine may be parsed like any of several built-in functions(depending on which prototype is used).<P CLASS=para>An <tt CLASS=literal>END</tt> subroutine, by contrast, is executed as <I CLASS=emphasis>late</I> aspossible, that is, when theinterpreter is being exited, even if it is exiting as a result of a<A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> function, or from an internally generated exception such as you'dget when you try to call an undefined function.  (But not if it's isbeing blown out of the water by a signal--you have to trap thatyourself (if you can).)[8]You may have multiple <tt CLASS=literal>END</tt> blocks within a file--they will executein reverse order of definition; that is: last in, first out (LIFO).That is so that related <tt CLASS=literal>BEGIN</tt>s and <tt CLASS=literal>END</tt>s will nest the way you'dexpect, if you pair them up.<blockquote class=footnote><P CLASS=para>[8] See the sigtrap pragmatic module described in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> foran easy way to do this.  For general information on signal handling,see "Signals" in <A HREF="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>.</blockquote><P CLASS=para>When you use the <B>-n</B> and <B>-p</B> switches to Perl, <tt CLASS=literal>BEGIN</tt>and <tt CLASS=literal>END</tt> work just as they do in <I CLASS=emphasis>awk</I> (1), as a degenerate case.For example, the output order of colors if you run the followingprogram is red, green, and blue:<P CLASS=para><DIV CLASS=programlisting><P><PRE>die "green\n";END   { print "blue\n" }BEGIN { print "red\n" }</PRE></DIV><P CLASS=para>Just as <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> provides a way to get compilation behavior during run-time,so too <tt CLASS=literal>BEGIN</tt> provides a way to get run-time behavior during compilation.But note that the compiler must execute <tt CLASS=literal>BEGIN</tt> blocks even if you'rejust checking syntax with the <B>-c</B> switch.  By symmetry, <tt CLASS=literal>END</tt> blocksare also executed when syntax checking.  Your <tt CLASS=literal>END</tt> blocks should notassume that any or all of your main code ran.  (They shouldn't do thisin anyevent, since the interpreter might exit early from an exception.)  Thisis not a bad problem in general.  At worst, it means you should test the"definedness" of a variable before doing anything rash with it.  Inparticular, before saying something like:<P CLASS=para><DIV CLASS=programlisting><P><PRE>system "rm -rf '$dir'"</PRE></DIV><P CLASS=para>you should always check that <tt CLASS=literal>$dir</tt> contains something meaningful, whetheror not you're doing it in an <tt CLASS=literal>END</tt> block.  Caveat destructor.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-5-SECT-1.3">Autoloading</A></h3><P CLASS=para>Normally you can't call a subroutine that isn't defined.  However, ifthere is a subroutine named <tt CLASS=literal>AUTOLOAD</tt> in the undefined subroutine'spackage (or in the case of an object method, in the package of any ofthe object's base classes), then the <tt CLASS=literal>AUTOLOAD</tt> subroutine is calledwith the same arguments as would have been passed to the originalsubroutine.  The fully qualified name of the original subroutinemagically appears in the package-global <tt CLASS=literal>$AUTOLOAD</tt> variable, in thesame package as the <tt CLASS=literal>AUTOLOAD</tt> routine.<P CLASS=para>Most <tt CLASS=literal>AUTOLOAD</tt> routines will load a definition for the undefinedsubroutine in question using <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> or <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>, then execute thatsubroutine using a special form of <A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A> that erases the stack frameof the <tt CLASS=literal>AUTOLOAD</tt> routine without a trace.<P CLASS=para>The standard AutoSplit module is a tool used by module writers tohelp split their modules into separate files (with filenames endingin <I CLASS=emphasis>.al</I>), each holding one routine.  The files are placed inthe <I CLASS=emphasis>auto/</I> directory of the Perl library.  These files can then be loadedon demand by the standard AutoLoader module.  A similar approach istaken by the SelfLoader module, except that it autoloads functions fromthe file's own <tt CLASS=literal>DATA</tt> area (which is less efficient in some ways andmore efficient in others).  Autoloading of Perl functions is analogousto dynamic loading of compiled C functions, except that autoloading (aspracticed by AutoLoader and SelfLoader) is done at the granularity ofthe function call, whereas dynamic loading (as practiced by theDynaLoader module) is done at the granularity of the complete module,and will usually link in many C or C++ functions all at once.  (See alsothe AutoLoader, SelfLoader, and DynaLoader modules in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.)<P CLASS=para>But an <tt CLASS=literal>AUTOLOAD</tt> routine can also just emulate the routine and neverdefine it.   For example, let's pretend that any function that isn't definedshould just call <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A> with its arguments.  All you'd do is this:<DIV CLASS=programlisting><P><PRE>sub AUTOLOAD {    my $program = $AUTOLOAD;    $program =~ s/.*:://;  # trim package name    system($program, @_);} date();who('am', 'i');ls('-l');</PRE></DIV><P CLASS=para>In fact, if you predeclare the functions you want to call that way, you don'teven need the parentheses:<P CLASS=para><DIV CLASS=programlisting><P><PRE>use subs qw(date who ls);date;who "am", "i";ls "-l";</PRE></DIV><P CLASS=para>A more complete example of this is the standard Shell module described in<A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>, which can treat undefined subroutine calls as calls to programs.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch04_07.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch05_02.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Composition of an array of hashes</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Modules</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>