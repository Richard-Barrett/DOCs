<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 5] 5.2 Modules</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:10:18 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch05_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 5</b></td><td width=172 align=right valign=top><A HREF="ch05_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-5-SECT-2">5.2 Modules</A></h2><P CLASS=para><A NAME="CH05.MOD1"></A>A module is just a reusable package that is defined in a library filewhose name is the same as the name of the package (with a <I CLASS=emphasis>.pm</I> on theend).  A module may provide a mechanism for exporting some of itssymbols into the symbol table of any other package using it.  Or it mayfunction as a class definition and make its operations availableimplicitly through method calls on the class and its objects, withoutexplicitly exporting any symbols.  Or it can do a little of both.<P CLASS=para>Most exporter modules rely on the customary exportation semanticssupplied by the Exporter module.For example, to create an exporting module called Fred, createa file called <I CLASS=emphasis>Fred.pm</I> and put this at the start of it:<P CLASS=para><DIV CLASS=programlisting><P><PRE>package      Fred;require      Exporter;@ISA       = qw(Exporter);@EXPORT    = qw(func1 func2);@EXPORT_OK = qw($sally @listabob %harry func3);</PRE></DIV><P CLASS=para>Then go on to declare and use your variables and functions without anyqualifications.  See the Exporter module documentation in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> forfurther information on the mechanics and style issues in modulecreation.<P CLASS=para>Perl modules are included in your program by saying:<DIV CLASS=programlisting><P><PRE>use Module;</PRE></DIV><P CLASS=para>or:<DIV CLASS=programlisting><P><PRE>use Module <tt CLASS=replaceable><i>LIST</i></tt>;</PRE></DIV><P CLASS=para>This preloads Module at compile time, and then imports from it thesymbols you've requested, either implicitly or explicitly.  If you donot supply a list of symbols in a <tt CLASS=replaceable><i>LIST</i></tt>, then the list from the module's<tt CLASS=literal>@EXPORT</tt> array is used.  (And if you do supply a <tt CLASS=replaceable><i>LIST</i></tt>, all your symbolsshould be mentioned in either <tt CLASS=literal>@EXPORT</tt> or <tt CLASS=literal>@EXPORT_OK</tt>, or an errorwill result.) The two declarations above are exactly equivalent to:<DIV CLASS=programlisting><P><PRE>BEGIN {    require "Module.pm";    Module-&gt;import();}</PRE></DIV><P CLASS=para>or:<DIV CLASS=programlisting><P><PRE>BEGIN {    require "Module.pm";    Module-&gt;import(<tt CLASS=replaceable><i>LIST</i></tt>);}</PRE></DIV><P CLASS=para>(We said that the first example abovedefaults to using the module's <tt CLASS=literal>@EXPORT</tt>list, but that is a bit of a fib.  It does this if the module uses thestandard Exporter semantics.  But a module can do anything it jolly wellpleases when you do an import, since <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> just calls the ordinary <tt CLASS=literal>import( )</tt> method for the module, as above, and that method can be defined to do anything.  Well, almost anything.)<P CLASS=para>Sometimes you might not wish to import anything from a module thatexports things by default.  As a special case, you can say:<DIV CLASS=programlisting><P><PRE>use Module ();</PRE></DIV><P CLASS=para>which is exactly equivalent to<DIV CLASS=programlisting><P><PRE>BEGIN { require "Module.pm"; }</PRE></DIV><P CLASS=para>Note that any initialization code in the Module is still run, as itwould be for an ordinary <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>.  It's only the <A HREF="ch03_02.htm#PERL2-CMD-IMPORT">import</A> that issuppressed.  If you really don't care whether the module is pulled in atcompile-time or run-time, you can just say:<DIV CLASS=programlisting><P><PRE>require Module;</PRE></DIV><P CLASS=para>This is slightly preferred over <tt CLASS=literal>require `Module.pm`;</tt> because itintroduces <tt CLASS=literal>Module</tt> as a package, which can clarify certain errormessages that the parser might emit.<P CLASS=para>All Perl module files have the extension <I CLASS=emphasis>.pm</I>.  Both <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> and<A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> will assume this (as well as the quotes) so that you don'thave to spell out <tt CLASS=literal>"Module.pm"</tt>.  This helps to differentiate newmodules from the <I CLASS=emphasis>.pl</I> and <I CLASS=emphasis>.ph</I> files used by prior versions of Perl.Module names are also capitalized unless they're functioning as pragmas.Pragmas are ineffect compiler directives, and such modules are sometimes called "pragmatic modules"--or even "pragmata" if you're a classicist.<P CLASS=para>Because the <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> declaration (in any form) implies a <tt CLASS=literal>BEGIN</tt> block,the module is loaded (and any executable initialization code in it run) assoon as the <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> declaration is compiled, <I CLASS=emphasis>before</I> the rest of thefile is compiled.  This is how <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> is able to function as a pragmamechanism to change the compiler's behavior, and also how modules areable to declare subroutines that are then visible as (unqualified) listoperators for the rest of the current file.  If, on the other hand, youinvoke <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> instead of <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A>, you must explicitly qualify anyinvocation of routines within the required package.<DIV CLASS=programlisting><P><PRE>require Cwd;    # make Cwd:: accessible with qualification$here = Cwd::getcwd();use Cwd;        # import names from Cwd:: -- no qualification necessary$here = getcwd();</PRE></DIV><P CLASS=para>In general, <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> is recommended over <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> because you getyour error messages sooner.  But <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> is useful for pullingin modules lazily at run-time.<P CLASS=para>Perl packages may be nested inside other packages, so we can havepackage names containing "<tt CLASS=literal>::</tt>".  But such compound names don't workwell as filenames on many systems.  Therefore, if a module's name is,say, <tt CLASS=literal>Text::Soundex</tt>, then its definition is actually found in thelibrary file <I CLASS=emphasis>Text/Soundex.pm</I> (or whatever the equivalent pathname ison your system).<P CLASS=para>Perl modules always load a <I CLASS=emphasis>.pm</I> file, but there may also be dynamicallylinked executables or autoloaded subroutine definitions associated withthe module.  If so, these will be entirely transparent to the user ofthe module.  It is the responsibility of the <I CLASS=emphasis>.pm</I> file to load (orarrange to autoload) any additional functionality.  The POSIX modulehappens to do both dynamic loading and autoloading, but the user canjust say<DIV CLASS=programlisting><P><PRE>use POSIX;</PRE></DIV><P CLASS=para>to get it all.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-5-SECT-2.1">Access to Modules</A></h3><P CLASS=para>Perl does not patrol private/public borders within its modules--unlikelanguages such as C++, Ada, and Modula-17, Perl isn't infatuated withenforced privacy.  As we mentioned at the beginning of the chapter, aPerl module would prefer that you stayed out of its living room becauseyou weren't invited, not because it has a shotgun.<P CLASS=para>The module and its user have a contract, part of which is common law andpart of which is written.  Part of the common law contract is that amodule doesn't pollute any namespace it wasn't asked to pollute.  The writtencontract for the module (that is, the documentation) may make otherprovisions.  But then, having read the written contract, you presumablyknow that when you say:<DIV CLASS=programlisting><P><PRE>use RedefineTheWorld;</PRE></DIV><P CLASS=para>you're redefining the world, and you're willing to take the consequences.The next section talks about one way to redefine parts of the world.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-5-SECT-2.2">Overriding Built-in Functions</A></h3><P CLASS=para>Many built-in functions may be <I CLASS=emphasis>overridden</I>, although (like knocking holesin your walls) you should only try this occasionally and for goodreason.  Typically, this might be done by a package attempting toemulate missing built-in functionality on a non-UNIX system.  (Do notconfuse overriding with <I CLASS=emphasis>overloading</I>, which adds additionalobject-oriented meanings to built-in operators, but doesn't override muchof anything.  See the discussion of the overload module in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A> for more on that.)<P CLASS=para>Overriding may be done only by importing the name from amodule--ordinary predeclaration isn't good enough.  To be perfectlyforthcoming, it's the assignment of a code reference to a typeglob thattriggers the override, as in <tt CLASS=literal>*open = \&amp;myopen</tt>, which is how importingof functions is implemented.  Furthermore, the assignment must occur insome other package; this makes unintentional overriding through typeglobaliasing more difficult.  However, if you really want to do your ownoverriding, don't despair, because the <tt CLASS=literal>subs</tt> pragma lets you predeclaresubroutines via the import syntax, and these names may then override thebuilt-in ones:<DIV CLASS=programlisting><P><PRE>use subs qw(chdir chroot chmod chown);chdir $somewhere;sub chdir { ... }</PRE></DIV><P CLASS=para>Library modules should not in general export built-in names like<B>open</B>or <B>chdir</B> as part of their default<tt CLASS=literal>@EXPORT</tt> list, since these names maysneak into someone else's namespace and change the semantics unexpectedly.Instead, if the module adds the name to the <tt CLASS=literal>@EXPORT_OK</tt> list, then it'spossible for users to import the name explicitly, but not implicitly.That is, they could say<DIV CLASS=programlisting><P><PRE>use Module 'open';</PRE></DIV><P CLASS=para>and it would import the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> override, but if they said<DIV CLASS=programlisting><P><PRE>use Module;</PRE></DIV><P CLASS=para>they would get the default imports without the overrides.<P CLASS=para>The original versions of the built-in functions are always accessiblevia the <tt CLASS=literal>CORE</tt> pseudopackage.  Therefore,<tt CLASS=literal>CORE::chdir()</tt> will always be the version that Perl was compiledwith, even if the regular <A HREF="ch03_02.htm#PERL2-CMD-CHDIR">chdir</A> function has been overridden.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch05_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch05_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Packages</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Objects</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>