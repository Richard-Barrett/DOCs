<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 6] Social Engineering</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:11:39 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch05_05.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 6</b></td><td width=172 align=right valign=top><A HREF="ch06_02.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><H1 CLASS=chapter><A CLASS="TITLE" NAME="PERL2-CH-6">Social Engineering</A></H1><DIV CLASS=htmltoc><p><b>Contents:</b><br>Cooperating with Command Interpreters<br><A HREF="ch06_02.htm">Cooperating with Other Processes</A><BR><A HREF="ch06_03.htm">Cooperating with Strangers</A><BR><A HREF="ch06_04.htm">Cooperating with Other Languages</A><BR></DIV><P CLASS=para>Languages have different personalities.  You can classify computerlanguages by how introverted or extroverted they are; for instance, Iconand Lisp are stay-at-home languages, while Tcl and the various shellsare party animals.  Self-sufficient languages prefer to compete with otherlanguages, while social languages prefer to cooperate with otherlanguages.  As usual, Perl tries to do both.<P CLASS=para>So this chapter is about relationships.  Until now we've looked inwardat the competitive nature of Perl, but now we need to look outwardand see the cooperative nature of Perl.  If we really mean what wesay about Perl being a glue language, then we can't just talk aboutglue; we have to talk about the various kinds of things you can gluetogether.  A glob of glue by itself isn't very interesting.<P CLASS=para>Perl doesn't just glue together other computer languages.  It also gluestogether command line interpreters, operating systems, processes,machines, devices, networks, databases, institutions, cultures, Webpages, GUIs, peers, servers, and clients, not to mention people likesystem administrators, users, and of course, hackers, both naughty andnice.  In fact, Perl is rather competitive about being cooperative.<P CLASS=para>So this chapter is about Perl's relationship with everything in the world.Obviously, we can't talk about everything in the world, but we'll try.<DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-1">6.1 Cooperating with Command Interpreters</A></h2><P CLASS=para><A NAME="CH06.INT1"></A><A NAME="CH06.INT2"></A>It is fortunate that Perl grew up in the UNIX world--that meansits invocation syntax works pretty well under the command interpretersof other operating systems too.  Most command interpreters know how todeal with a list of words as arguments, and don't care if an argumentstarts with a minus sign.  There are, of course, some sticky spots whereyou'll get fouled up if you move from one system to another.  You can'tuse single quotes under MS-DOS as you do under UNIX, for instance.  Andon systems like VMS, some wrapper code has to jump through hoops toemulate UNIX I/O redirection.  Once you get past those issues, however,Perl treats its switches and arguments much the same on anyoperating system.<P CLASS=para>Even when you don't have a command interpreter, <I CLASS=emphasis>per se</I>, it's easy to execute a Perl script from another program, such as the <I CLASS=emphasis>inet</I>daemon or a CGI server.  Not only can such a server pass arguments inthe ordinary way, but it can also pass in information via environmentvariables and (under UNIX at least) inherited file descriptors.  Evenmore exotic argument-passing mechanisms may be encapsulated in a modulethat can be brought into the Perl script via a simple <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> directive.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-1.1">Command Processing</A></h3><P CLASS=para><A NAME="CH06.PROC1"></A><A NAME="CH06.PROC2"></A><A NAME="CH06.PROC3"></A>Perl parses command-line switches in the standard fashion.[1]That is, it expects any switches (words beginning with a minus) tocome first on the command line.  After that comes the name of the script(usually), followed by any additional arguments (often filenames) to bepassed into the script.  Some of these additional arguments may beswitches, but if so, they must be processed by the script, since Perlgives up parsing switches as soon as it sees a non-switch, or thespecial "<B>-&nbsp;-</B>" switch that terminates switch processing.<blockquote class=footnote><P CLASS=para>[1] Presuming you agree that UNIX is both standard and fashionable.</blockquote><P CLASS=para>Perl gives you some flexibility in how you supply your program.  Forsmall, quick-and-dirty jobs, you can program Perl entirely from thecommand line.  For larger, more permanent jobs, you can supply a Perlscript as a separate file.  Perl looks for the script to be specified inone of three ways:<P><OL CLASS=orderedlist><li CLASS=listitem>Specified line by line via <B>-e</B> switches on the command line.<P><li CLASS=listitem>Contained in the file specified by the first filename on the command line.(Note that systems supporting the <tt CLASS=literal>#!</tt> shebang notation invokeinterpreters this way on your behalf.)<P><li CLASS=listitem>Passed in implicitly via standard input.  This only works if there areno filename arguments; to pass arguments to a standard-input script youmust explicitly specify a "<B>-</B>" for the script name.  For example,under UNIX:<DIV CLASS=programlisting><P><PRE>echo "print 'Hello, world'" | perl -</PRE></DIV><P CLASS=para>With methods 2 and 3, Perl starts parsing the input file from thebeginning, unless you've specified a <B>-x</B> switch, in which case itscans for the first line starting with <tt CLASS=literal>#!</tt> and containing the word"<tt CLASS=literal>perl</tt>", and starts there instead.  This is useful for running a scriptembedded in a larger message.  (In this case you might indicate the endof the script using the <tt CLASS=literal>_ _END_ _</tt> token.)<P></OL><P CLASS=para>Whether or not you use <B>-x</B>, the <tt CLASS=literal>#!</tt> line is always examined forswitches as the line is being parsed.  Thus, if you're on a machine thatonly allows one argument with the <tt CLASS=literal>#!</tt> line, or worse, doesn't evenrecognize the <tt CLASS=literal>#!</tt> line as special, you still can get consistent switchbehavior regardless of how Perl was invoked, even if <B>-x</B> was used tofind the beginning of the script.<DIV CLASS=warning><P CLASS=warning><BLOCKQUOTE><P><B>WARNING:</B><P CLASS=para>Because many versions of UNIX silently chop off kernel interpretation ofthe <tt CLASS=literal>#!</tt> line after 32 characters, some switches may be passed in on thecommand line, and some may not; you could even get a "<tt CLASS=literal>-</tt>" without itsletter, if you're not careful.  You probably want to make sure that allyour switches fall either before or after that 32-character boundary.Most switches don't actually care if they're processed redundantly, butgetting a "<tt CLASS=literal>-</tt>" instead of a complete switch could cause Perl to try toexecute standard input instead of your script.  And a partial <B>-I</B> switchcould also cause odd results.  Of course, if you're not on a UNIX system,you're guaranteed not to have this problem.</blockquote><P></DIV><P CLASS=para>Parsing of the switches on the <tt CLASS=literal>#!</tt> line starts wherever "<tt CLASS=literal>perl</tt>" ismentioned in the line.  The sequences "<tt CLASS=literal>-*</tt>" and "<tt CLASS=literal>- </tt>" are specificallyignored for the benefit of <I CLASS=emphasis>emacs</I> users, so that, if you'reso inclined, you can say:<DIV CLASS=programlisting><P><PRE>#!/bin/sh -- # -*- perl -*- -peval 'exec perl -S $0 ${1+"$@"}'    if 0;</PRE></DIV><P CLASS=para>and Perl will see only the <B>-p</B> switch.  The fancy "<tt CLASS=literal>-*- perl-*-</tt>" gizmo tells <I CLASS=emphasis>emacs</I> to start up in Perl mode; you don'tneed it if you don't use <I CLASS=emphasis>emacs</I>.  The <B>-S</B> mess is explained below.<P CLASS=para>If the <tt CLASS=literal>#!</tt> line does <I CLASS=emphasis>not</I> contain the word "<tt CLASS=literal>perl</tt>", the programnamed after the <tt CLASS=literal>#!</tt> is executed instead of the Perl interpreter.For example, suppose you have an ordinary Bourne shell script out therethat says:<DIV CLASS=programlisting><P><PRE>#!/bin/shecho "I am a shell script"</PRE></DIV><P CLASS=para>If you feed that file to Perl, then Perl will run <I CLASS=emphasis>/bin/sh</I> for you.This is slightly bizarre, but it helps people on machines that don'trecognize <tt CLASS=literal>#!</tt>, because--by setting their<tt CLASS=literal>SHELL</tt> environmental variable--they can tell a program (such as a mailer)that their shell is <I CLASS=emphasis>/usr/bin/perl</I>, and Perl will then dispatch theprogram to the correct interpreter for them, even though their kernel istoo stupid to do so.  Classify it as a strange form of cooperation.<P CLASS=para>But back to Perl scripts that are really Perl scripts.After locating your script, Perl compiles the entire script to aninternal form.  If any compilation errors arise, execution of thescript is not attempted (unlike the typical shell script,which might run partway through before finding a syntax error).If the script is syntactically correct, it is executed.  If the scriptruns off the end without hitting an <A HREF="ch03_02.htm#PERL2-CMD-EXIT">exit</A> or <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> operator, an implicit<tt CLASS=literal>exit(0)</tt> is provided to indicate successful completion.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-1.2">Switches</A></h3><P CLASS=para>A single-character switch with no argument may be combined (bundled)with the following switch, if any.<A NAME="CH06.PROC4"></A><DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -spi.bak    # same as -s -p -i.bak</PRE></DIV><P CLASS=para>Switches are also known as options, or flags.Perl recognizes these switches:<P><DL CLASS=variablelist><DT CLASS=varlistentry><B>-&nbsp; -</B><DD><P CLASS=para>Terminates switch processing, even if the next argument starts with aminus.  It has no other effect.<p><DT CLASS=varlistentry><B>-0</B>[<I CLASS=emphasis>octnum</I>]<DD><P CLASS=para>Specifies the record separator (<tt CLASS=literal>$/</tt>) as an octal number.  If <I CLASS=emphasis>octnum</I>is not present, the null character is the separator.  Other switches mayprecede or follow the octal number.  For example, if you have a version of<I CLASS=emphasis>find</I> (1) that can print filenames terminated by the null character, youcan say this:<DIV CLASS=programlisting><P><PRE>find . -name '*.bak' -print0 | perl -n0e unlink</PRE></DIV><P CLASS=para>The special value <tt CLASS=literal>00</tt> will cause Perl to slurp files in paragraph mode,equivalent to setting the <B>$/</B> variable to <tt CLASS=literal>""</tt>.The value <tt CLASS=literal>0777</tt> will cause Perl to slurp files whole since there is nolegal ASCII character with that value.  This is equivalent to undefiningthe <B>$/</B> variable.<p><DT CLASS=varlistentry><B>-a    </B><DD><P CLASS=para>Turns on autosplit mode when used with a <B>-n</B> or <B>-p</B>.  An implicit<B>split</B> command to the <B>@F</B> array is done as the first thing inside theimplicit <B>while</B> loop produced by the <B>-n</B> or <B>-p</B>.  So:<DIV CLASS=programlisting><P><PRE>perl -ane 'print pop(@F), "\n";'</PRE></DIV><P CLASS=para>is equivalent to:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    @F = split(' ');    print pop(@F), "\n";}</PRE></DIV><P CLASS=para>A different field delimiter may be specified using <B>-F</B>.<p><DT CLASS=varlistentry><B>-c    </B><DD><P CLASS=para>Causes Perl to check the syntax of the script and then exit withoutexecuting it.  Actually, it will execute any <tt CLASS=literal>BEGIN</tt> blocks and<A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> directives, since these are considered to occur before theexecution of your program.  It also executes any <tt CLASS=literal>END</tt> blocks, in casethey need to clean up something that happened in a corresponding<tt CLASS=literal>BEGIN</tt> block.  The switch is more or less equivalent to having an<tt CLASS=literal>exit(0)</tt> as the first statement in your program.<p><DT CLASS=varlistentry><B>-d    </B><DD><P CLASS=para>Runs the script under the Perl debugger.  See "The Perl Debugger" in<A HREF="ch08_01.htm">Chapter 8, <i>Other Oddments</i></A>.<p><DT CLASS=varlistentry><B>-d:</B><I CLASS=emphasis>foo</I><DD><P CLASS=para>Runs the script under the control of a debugging or tracing moduleinstalled in the Perl library as Devel::<I CLASS=emphasis>foo</I>.  For example,<tt CLASS=literal>-d:DProf</tt> executes the script using theDevel::DProf profiler.  See also the debugging section in <A HREF="ch08_01.htm">Chapter 8, <i>Other Oddments</i></A>.<p><DT CLASS=varlistentry><B>-D</B><I CLASS=emphasis>number</I> <B>-D</B><I CLASS=emphasis>list</I><DD><P CLASS=para>Sets debugging flags.  (This only works if debugging is compiled intoyour version of Perl via the -DDEBUGGING C compiler switch.)  You may specify either a number that is the sum of the bitsyou want, or a list of letters.  To watch how it executes your script,for instance, use <tt CLASS=literal>-D14</tt> or <tt CLASS=literal>-Dslt</tt>.  Another nice value is <tt CLASS=literal>-D1024</tt>or <tt CLASS=literal>-Dx</tt>, which lists your compiled syntax tree.  And <tt CLASS=literal>-D512</tt> or<tt CLASS=literal>-Dr</tt> displays compiled regular expressions.  The numeric value isavailable internally as the special variable <B>$^D</B>.  Here are theassigned bit values:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-6-TAB-1"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="LEFT">Bit</TH><TH ALIGN="left">Letter</TH><TH ALIGN="left">Meaning</TH></TR><TR CLASS=row><TD ALIGN="LEFT">1</TD><TD ALIGN="left"><tt CLASS=literal>p</tt></TD><TD ALIGN="left">Tokenizing and parsing</TD></TR><TR CLASS=row><TD ALIGN="LEFT">2</TD><TD ALIGN="left"><tt CLASS=literal>s</tt></TD><TD ALIGN="left">Stack snapshots</TD></TR><TR CLASS=row><TD ALIGN="LEFT">4</TD><TD ALIGN="left"><tt CLASS=literal>l</tt></TD><TD ALIGN="left">Label stack processing</TD></TR><TR CLASS=row><TD ALIGN="LEFT">8</TD><TD ALIGN="left"><tt CLASS=literal>t</tt></TD><TD ALIGN="left">Trace execution</TD></TR><TR CLASS=row><TD ALIGN="LEFT">16</TD><TD ALIGN="left"><tt CLASS=literal>o</tt></TD><TD ALIGN="left">Object method Lookup</TD></TR><TR CLASS=row><TD ALIGN="LEFT">32</TD><TD ALIGN="left"><tt CLASS=literal>c</tt></TD><TD ALIGN="left">String/numeric conversions</TD></TR><TR CLASS=row><TD ALIGN="LEFT">64</TD><TD ALIGN="left"><tt CLASS=literal>P</tt></TD><TD ALIGN="left">Print preprocessor command for -P</TD></TR><TR CLASS=row><TD ALIGN="LEFT">128</TD><TD ALIGN="left"><tt CLASS=literal>m</tt></TD><TD ALIGN="left">Memory allocation</TD></TR><TR CLASS=row><TD ALIGN="LEFT">256</TD><TD ALIGN="left"><tt CLASS=literal>f</tt></TD><TD ALIGN="left">Format processing</TD></TR><TR CLASS=row><TD ALIGN="LEFT">512</TD><TD ALIGN="left"><tt CLASS=literal>r</tt></TD><TD ALIGN="left">Regular expression processing</TD></TR><TR CLASS=row><TD ALIGN="LEFT">1,024</TD><TD ALIGN="left"><tt CLASS=literal>x</tt></TD><TD ALIGN="left">Syntax tree dump</TD></TR><TR CLASS=row><TD ALIGN="LEFT">2,048</TD><TD ALIGN="left"><tt CLASS=literal>u</tt></TD><TD ALIGN="left">Tainting checks</TD></TR><TR CLASS=row><TD ALIGN="LEFT">4,096</TD><TD ALIGN="left"><tt CLASS=literal>L</tt></TD><TD ALIGN="left">Memory leaks (not supported any more)</TD></TR><TR CLASS=row><TD ALIGN="LEFT">8,192</TD><TD ALIGN="left"><tt CLASS=literal>H</tt></TD><TD ALIGN="left">Hash dump -  - usurps values()</TD></TR><TR CLASS=row><TD ALIGN="LEFT">16,384</TD><TD ALIGN="left"><tt CLASS=literal>X</tt></TD><TD ALIGN="left">Scratchpad allocation</TD></TR><TR CLASS=row><TD ALIGN="LEFT">32,768</TD><TD ALIGN="left"><tt CLASS=literal>D</tt></TD><TD ALIGN="left">Cleaning up</TD></TR></TABLE><P></DIV><p><DT CLASS=varlistentry><B>-e</B> <I CLASS=emphasis>commandline</I><DD><P CLASS=para>May be used to enter one or more lines of script.  If <B>-e</B> isused, Perl will not look for a script filename in the argument list.The <B>-e</B> argument is treated as if it ends with a newline, so multiple<B>-e</B> commands may be given to build up a multi-line script.  (Makesure to use semicolons where you would in a normal program.) Justbecause <B>-e</B> supplies a newline on each argument doesn't mean you haveto use multiple <B>-e</B> switches--if your shell supports multi-linequoting, you may pass a multi-line script as one <B>-e</B> argument, just as<I CLASS=emphasis>awk</I> (1) scripts are typically passed.<p><DT CLASS=varlistentry><B>-F</B><I CLASS=emphasis>pattern</I><DD><P CLASS=para>Specifies the pattern to split on if <B>-a</B> is also in effect.  Thepattern may be surrounded by <tt CLASS=literal>//</tt>,<tt CLASS=literal>""</tt>or <tt CLASS=literal>'&nbsp;'</tt> , otherwise it will beput in single quotes.  (Remember that to pass quotes through a shell,you have to quote the quotes.)<p><DT CLASS=varlistentry><B>-h    </B><DD><P CLASS=para>Prints a summary of Perl's command-line options.<p><DT CLASS=varlistentry><B>-i</B>[<I CLASS=emphasis>extension</I>]<DD><P CLASS=para>Specifies that files processed by the <tt CLASS=literal>&lt; &gt;</tt> construct are to be editedin-place.  It does this by renaming the input file, opening the outputfile by the original name, and selecting that output file as the defaultfor <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> statements.  The extension, if supplied, is added to the nameof the old file to make a backup copy.  If no extension is supplied, nobackup is made.  From the shell, saying:<DIV CLASS=programlisting><P><PRE>$ perl -p -i.bak -e "s/foo/bar/; ... "</PRE></DIV><P CLASS=para>is the same as using the script:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -pi.baks/foo/bar/;</PRE></DIV><P CLASS=para>which is equivalent to:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perlwhile (&lt;&gt;) {    if ($ARGV ne $oldargv) {        rename($ARGV, $ARGV . '.bak');        open(ARGVOUT, "&gt;$ARGV");        select(ARGVOUT);        $oldargv = $ARGV;    }    s/foo/bar/;}continue {    print;        # this prints to original filename}select(STDOUT);</PRE></DIV><P CLASS=para>except that the <B>-i</B> form doesn't need to compare <tt CLASS=literal>$ARGV</tt> to <tt CLASS=literal>$oldargv</tt> toknow when the filename has changed.  It does, however, use <tt CLASS=literal>ARGVOUT</tt> forthe selected filehandle.  Note that <tt CLASS=literal>STDOUT</tt> is restored as thedefault output filehandle after the loop. You can use <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A> without parentheses to locate the end of each input file, in case you want to append to each file, or reset line numbering (see theexamples of <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A> in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>).</DL><P><DL CLASS=variablelist><DT CLASS=varlistentry><B>-I</B><I CLASS=emphasis>directory</I><DD><P CLASS=para>Directories specified by <B>-I</B> are prepended to <B>@INC</B>, whichholds the search path formodules.  <B>-I</B> also tells the C preprocessor where to search forinclude files.  The C preprocessor is invoked with <B>-P</B>; by default itsearches <I CLASS=emphasis>/usr/include</I> and <I CLASS=emphasis>/usr/lib/perl</I>.  Unless you're going to beusing the C preprocessor (and almost no one does any more), you're betteroff using the <tt CLASS=literal>use lib</tt> directive within your script.<p><DT CLASS=varlistentry><B>-l</B>[<I CLASS=emphasis>octnum</I>]<DD><P CLASS=para>Enables automatic line-end processing.  It has two effects:  first, itautomatically <A HREF="ch03_02.htm#PERL2-CMD-CHOMP">chomp</A>s the line terminator when used with <B>-n</B> or<B>-p</B>, and second, it sets <B>$\</B> to the value of <I CLASS=emphasis>octnum</I> so anyprint statements will have a line terminator of ASCII value <I CLASS=emphasis>octnum</I>added back on.  If <I CLASS=emphasis>octnum</I> is omitted, sets <B>$\</B> to the current valueof <B>$/</B>, typically newline.  So, to trim lines to 80 columns, say this:<DIV CLASS=programlisting><P><PRE>perl -lpe 'substr($_, 80) = ""'</PRE></DIV><P CLASS=para>Note that the assignment <tt CLASS=literal>$\ = $/</tt> is done when the switch is processed,so the input record separator can be different from the output recordseparator if the <B>-l</B> switch is followed by a <B>-0</B> switch:<DIV CLASS=programlisting><P><PRE>gnufind / -print0 | perl -ln0e 'print "found $_" if -p'</PRE></DIV><P CLASS=para>This sets <B>$\</B> to newline and later sets <B>$/</B> to the null character.  (Note that<tt CLASS=literal>0</tt> would have been interpreted as part of the <B>-l</B> switchhad it followed the <B>-l</B> directly.  That's why we bundled the <B>-n</B>switch between them.)<p><DT CLASS=varlistentry><B>-m</B>[<B>-</B>]<I CLASS=emphasis>module</I><DD><P CLASS=para><p><DT CLASS=varlistentry><B>-M</B>[<B>-</B>]<I CLASS=emphasis>module</I><DD><P CLASS=para><p><DT CLASS=varlistentry><B>-M</B>[<B>-</B>]<tt CLASS=literal>'</tt><I CLASS=emphasis>module ...</I><tt CLASS=literal>'</tt><DD><P CLASS=para><p><DT CLASS=varlistentry><B>-[mM]</B>[<B>-</B>]<I CLASS=emphasis>module=arg</I>&nbsp;[&nbsp;<I CLASS=emphasis>,arg</I>&nbsp;]&nbsp;<I CLASS=emphasis>...</I><DD><P CLASS=para><p><DT CLASS=varlistentry><B>-m</B><I CLASS=emphasis>module</I><DD><P CLASS=para>Executes <tt CLASS=literal>use</tt> <I CLASS=emphasis>module</I><tt CLASS=literal>()</tt> before executing your script.<p><DT CLASS=varlistentry><B>-M</B><I CLASS=emphasis>module</I><DD><P CLASS=para>Executes <tt CLASS=literal>use</tt> <I CLASS=emphasis>module</I> before executing yourscript.  The command is formed by mere interpolation, so you can usequotes to add extra code after the module name, for example,<tt CLASS=literal>-M'module qw(foo bar)'</tt>.If the first character after the <B>-M</B> or <B>-m</B> is a minus (<B>-</B>),then the <A HREF="ch03_02.htm#PERL2-CMD-USE">use</A> is replaced with <A HREF="ch03_02.htm#PERL2-CMD-NO">no</A>.<P CLASS=para>A little built-in syntactic sugar means you can also say<tt CLASS=literal>-mmodule=foo,bar</tt> or <tt CLASS=literal>-Mmodule=foo,bar</tt> as a shortcut for<tt CLASS=literal>-M'module qw(foo bar)'</tt>.  This avoids the need to use quotes whenimporting symbols.  The actual code generated by <tt CLASS=literal>-Mmodule=foo,bar</tt> is:<DIV CLASS=programlisting><P><PRE>use module split(/,/, q{foo, bar})</PRE></DIV><P CLASS=para>Note that the <tt CLASS=literal>=</tt> formremoves the distinction between <tt CLASS=literal>-m</tt> and <tt CLASS=literal>-M</tt>.<p><DT CLASS=varlistentry><B>-n    </B><DD><P CLASS=para>Causes Perl to assume the following loop around your script, whichmakes it iterate over filename arguments rather as <I CLASS=emphasis>sed -n</I> or<I CLASS=emphasis>awk</I> do:<DIV CLASS=programlisting><P><PRE>LINE:while (&lt;&gt;) {    ...                # your script goes here}</PRE></DIV><P CLASS=para>Note that the lines are not printed by default.  See <B>-p</B> to havelines printed.  Here is an efficient way to delete all files older thana week, assuming you're on UNIX:<DIV CLASS=programlisting><P><PRE>find . -mtime +7 -print | perl -nle unlink</PRE></DIV><P CLASS=para>This is faster than using the <I CLASS=emphasis>-exec</I> switch of <I CLASS=emphasis>find</I> (1) because you don'thave to start a process on every filename found.By an amazing coincidence, <tt CLASS=literal>BEGIN</tt> and <tt CLASS=literal>END</tt> blocks may be used tocapture control before or after the implicit loop, just as in <I CLASS=emphasis>awk</I>.<p><DT CLASS=varlistentry><B>-p    </B><DD><P CLASS=para>Causes Perl to assume the following loop around your script, whichmakes it iterate over filename arguments rather as <I CLASS=emphasis>sed</I> does:<DIV CLASS=programlisting><P><PRE>LINE:while (&lt;&gt;) {    ...                # your script goes here} continue {    print;}</PRE></DIV><P CLASS=para>Note that the lines are printed automatically.  To suppress printinguse the <B>-n</B> switch.  A <B>-p</B> overrides a <B>-n</B> switch. By yet another amazing coincidence, <tt CLASS=literal>BEGIN</tt> and <tt CLASS=literal>END</tt> blocks may beused to capture control before or after the implicit loop, just as in<I CLASS=emphasis>awk</I>.<p><DT CLASS=varlistentry><B>-P    </B><DD><P CLASS=para>Causes your script to be run through the C preprocessor beforecompilation by Perl.  (Since both comments and <I CLASS=emphasis>cpp</I> (1) directives beginwith the <tt CLASS=literal>#</tt> character, you should avoid starting comments with any wordsrecognized by the C preprocessor such as "<tt CLASS=literal>if</tt>", "<tt CLASS=literal>else</tt>" or "<tt CLASS=literal>define</tt>".)<p><DT CLASS=varlistentry><B>-s    </B><DD><P CLASS=para>Enables some rudimentary switch parsing for switches on the command lineafter the script name but before any filename arguments or "<B>- -</B>"switch terminator.  Any switch found there is removed from <B>@ARGV</B>, anda variable of the same name as the switch is set in the Perl script.No switch bundling is allowed, since multi-character switches are allowed.The following script prints "<tt CLASS=literal>true</tt>" if and only if the script is invokedwith a <tt CLASS=literal>-xyz</tt> switch.<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -sif ($xyz) { print "true\n"; }</PRE></DIV><P CLASS=para>If the switch in question is followed by an equals sign, the variable isset to whatever follows the equals sign in that argument.The following script prints "<tt CLASS=literal>true</tt>" if and only if the script is invokedwith a <tt CLASS=literal>-xyz=abc</tt> switch.<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -sif ($xyz eq 'abc') { print "true\n"; }</PRE></DIV><P CLASS=para><p><DT CLASS=varlistentry><B>-S    </B><DD><P CLASS=para>Makes Perl use the <tt CLASS=literal>PATH</tt> environment variable to search for thescript (unless the name of the script starts with a slash).  Typicallythis is used to emulate <tt CLASS=literal>#!</tt> startup on machines that don't support <tt CLASS=literal>#!</tt>,in the following manner:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perleval "exec /usr/bin/perl -S $0 $*"        if $running_under_some_shell;</PRE></DIV><P CLASS=para>The system ignores the first line and feeds the script to <I CLASS=emphasis>/bin/sh</I>,which proceeds to try to execute the Perl script as a shell script.The shell executes the second line as a normal shell command, and thusstarts up the Perl interpreter.  On some systems <B>$0</B> doesn't alwayscontain the full pathname, so <B>-S</B> tells Perl to search for thescript if necessary. After Perl locates the script, it parses thelines and ignores them because the variable <tt CLASS=literal>$running_under_some_shell</tt>is never true.  A better construct than <tt CLASS=literal>$*</tt> would be <tt CLASS=literal>${1+`$@`}</tt>, whichhandles embedded spaces and such in the filenames, but doesn't work ifthe script is being interpreted by <I CLASS=emphasis>csh</I>.  In order to start up <I CLASS=emphasis>sh</I> ratherthan <I CLASS=emphasis>csh</I>, some systems have to replace the <tt CLASS=literal>#!</tt> line with a linecontaining just a colon, which Perl will politely ignore.  Othersystems can't control that, and need a totally devious construct thatwill work under any of <I CLASS=emphasis>csh</I>, <I CLASS=emphasis>sh</I>, or <I CLASS=emphasis>perl</I>, such as the following:<DIV CLASS=programlisting><P><PRE>eval '(exit $?0)' &amp;&amp; eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'    &amp; eval 'exec /usr/bin/perl -S $0 $argv:q'                   if 0;</PRE></DIV><P CLASS=para>Yes, it's ugly, but so are the systems that work[2]this way.<blockquote class=footnote><P CLASS=para>[2] We use the term advisedly.</blockquote><p><DT CLASS=varlistentry><B>-T    </B><DD><P CLASS=para>Forces "taint" checks to be turned on so you can test them.  Ordinarilythese checks are done only when running setuid or setgid.  It's a goodidea to turn them on explicitly for programs run on another's behalf,such as CGI programs.  See "Cooperating with Strangers" later inthis chapter.<p><DT CLASS=varlistentry><B>-u    </B><DD><P CLASS=para>Causes Perl to dump core after compiling your script.  You can thentake this core dump and turn it into an executable file by using the<I CLASS=emphasis>undump</I> program (not supplied).  This speeds startup at the expense ofsome disk space (which you can minimize by stripping the executable).If you want to execute a portion of your script before dumping,use Perl's <A HREF="ch03_02.htm#PERL2-CMD-DUMP">dump</A> operator instead.  Note:  availability of <I CLASS=emphasis>undump</I> isplatform specific; it may not be available for a specific port ofPerl.<p><DT CLASS=varlistentry><B>-U    </B><DD><P CLASS=para>Allows Perl to do unsafe operations.  Currently the only "unsafe"operations are the unlinking of directories while running as superuser,and running setuid programs with fatal taint checks turned intowarnings.<p><DT CLASS=varlistentry><B>-v    </B><DD><P CLASS=para>Prints the version and patchlevel of your Perl executable.<p><DT CLASS=varlistentry><B>-V    </B><DD><P CLASS=para>Prints a summary of the major Perl configuration values and the currentvalue of <B>@INC</B>.<p><DT CLASS=varlistentry><B>-V:</B><I CLASS=emphasis>name</I><DD><P CLASS=para>Prints to <tt CLASS=literal>STDOUT</tt> the value of the named configuration variable.<p><DT CLASS=varlistentry><B>-w</B><DD><P CLASS=para>Prints warnings about identifiers that are mentioned only once, andscalar variables that are used before being set.  Also warns aboutredefined subroutines, and references to undefined filehandles orfilehandles opened read-only that you are attempting to write on.  Alsowarns you if you use a non-number as though it were a number,or if you use an array as though it were a scalar, or if yoursubroutines recurse more than 100 deep, and innumerable other things.See every entry labeled (W) in <A HREF="ch09_01.htm">Chapter 9, <i>Diagnostic Messages</i></A>.<p><DT CLASS=varlistentry><B>-x</B><I CLASS=emphasis>directory</I><DD><P CLASS=para>Tells Perl to extract a script that is embedded in a message.  Leading garbagewill be discarded until the first line that starts with <tt CLASS=literal>#!</tt> andcontains the string "<tt CLASS=literal>perl</tt>".  Any meaningful switches on that line afterthe word "<tt CLASS=literal>perl</tt>" will be applied.  If a directory name is specified, Perlwill switch to that directory before running the script.  The <B>-x</B>switch only controls the disposal of leading garbage.  The scriptmust be terminated with <tt CLASS=literal>_ _END_ _</tt> or <tt CLASS=literal>_ _DATA_ _</tt> if there istrailing garbage to be ignored.  (The script can process any or all of thetrailing garbage via the <tt CLASS=literal>DATA</tt> filehandle if desired.)</DL></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch05_05.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch06_02.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Inheriting a Constructor</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Cooperating with Other Processes</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>