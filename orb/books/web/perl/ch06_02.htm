<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 6] 6.2 Cooperating with Other Processes</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:11:51 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 6</b></td><td width=172 align=right valign=top><A HREF="ch06_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2">6.2 Cooperating with Other Processes</A></h2><P CLASS=para><A NAME="CH06.IPC1"></A><A NAME="CH06.IPC2"></A><A NAME="CH06.IPC3"></A>Processes have almost as many ways of communicating aspeople do.  But the difficulties of interprocess communication (IPC)should not be underestimated.  It doesn't do you any good to listen forverbal cues when your friend is using only body language.  Likewise, twoprocesses can communicate only when they agree on the method ofcommunication, and on the conventions built on top of that method.These layered conventions often gain the weight of "methodhood"themselves, so you'll sometimes hear people talking about <I CLASS=emphasis>stacks</I> ofcommunication methods.  We can't hope to cover all the methods usedin the world today, but we'll discuss some of the methods most commonlyused in Perl.<P CLASS=para>The IPC facilities of Perl range from the very simple to the verycomplex.  Which facility you want to use depends on the complexity ofthe information to be communicated.  The simplest kind of informationis, in a sense, no information at all, but just the awareness that aparticular event has happened at a particular point in time.  In Perl,these events are communicated via a signal mechanism modeled on the UNIXsignal system.<P CLASS=para>At the other extreme, the socket facilities of Perl allow you tocommunicate with any other process on the Internet using any mutuallysupported protocol you like.  Naturally, this freedom comes at a price:you have to go through a number of steps to set up the connections andmake sure you're talking the same language as the process on the otherend, which may in turn require you to adhere to any number of otherstrange customs, depending on the cultural conventions at work.  To beprotocoligorically correct, you might even be required to speak alanguage like HTML, or Java, or Perl.  Horrors.<P CLASS=para>Sandwiched in between are some facilities intended primarily forcommunicating between processes on the same machine.  These includepipes, FIFOs, and the various System V IPC calls.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.1">Signals</A></h3><P CLASS=para><A NAME="CH06.SIG1"></A>Perl uses a simple signal handling model: the <B>%SIG</B> hash containsreferences (either symbolic or hard) to user-defined signal handlers.When an event transpires, the handler corresponding to that event iscalled with one argument containing the name of the signal thattriggered it.  In order to send a signal to another process, you usethe <A HREF="ch03_02.htm#PERL2-CMD-KILL">kill</A> function.  If that process has installed a signal handler,it can execute code when you send the signal, but there's no way toget a return value (other than knowing that the signal was successfullysent).<P CLASS=para>We've classified this facility as a form of IPC, but in fact, signalscan come from various sources, not just other processes.  A signal mightcome from another process, or from your own process, or it might begenerated when the user at the keyboard types a particular sequence likeCTRL-C or CTRL-Z, or it might be manufactured by the kernel whenspecial events transpire, such as when a child process is exiting, orwhen your process is running out of stack space, or hitting a file sizelimit.[3]But your own process can't easily distinguish among thesecases.  A signal is like a package that arrives mysteriously on yourdoorstep with no return address.  You'd best open it carefully.<blockquote class=footnote><P CLASS=para>[3] Nevertheless, these are all examples of cooperation with <I CLASS=emphasis>something</I>,even if it's not another process.  Certainly, you tend to get moreaccomplished when you cooperate with your operating system.</blockquote><P CLASS=para>For example, to unpack an interrupt signal, set up a handler like this:<DIV CLASS=programlisting><P><PRE>sub catch_zap {    my $signame = shift;    $shucks++;    die "Somebody sent me a SIG$signame!";} $SIG{INT} = 'catch_zap';  # could fail outside of package main$SIG{INT} = \&amp;catch_zap;  # best strategy</PRE></DIV><P CLASS=para>Notice how all we do in the signal handleris set a global variable and then raise anexception with <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A>.  We try to avoid anything more complicated thanthat, because on most systems the C library is not re-entrant.  Signalsare delivered asynchronously, so calling any <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> functions (or evenanything that needs to <I CLASS=emphasis>malloc</I> (3) more memory) could in theory triggera memory fault and subsequent core dump if you were already in a relatedC library routine when the signal was delivered.  (Even the <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A>routine is a bit unsafe unless the process is executing withinan <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>, which suppresses the I/O from <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A>, which keeps itfrom calling the C library.  Probably.)<P CLASS=para>The operating system thinks of signals as numbers rather than names.To find the names of the signals, you can use the <tt CLASS=literal>kill -l</tt>command on your system (if you're running UNIX).  Or you can retrievethem from Perl's Config module; the following snippet sets up two arrays: a<tt CLASS=literal>@signame</tt> array indexed by number to get the signal name, and a<tt CLASS=literal>%signo</tt> hash indexed by name to get the signal number:<DIV CLASS=programlisting><P><PRE>use Config;defined $Config{sig_name} or die "No sigs?";$i = 0;     # Config prepends fake 0 signal called "ZERO".foreach $name (split(' ', $Config{sig_name})) {    $signo{$name} = $i;    $signame[$i] = $name;    $i++;}</PRE></DIV><P CLASS=para>So to check whether signal 17 and <tt CLASS=literal>SIGALRM</tt>are the same, you could do this:<DIV CLASS=programlisting><P><PRE>print "signal #17 = $signame[17]\n";if ($signo{ALRM}) {     print "SIGALRM is $signo{ALRM}\n";}</PRE></DIV><P CLASS=para>You may also choose to assign either of the strings <tt CLASS=literal>'IGNORE'</tt>or <tt CLASS=literal>'DEFAULT'</tt> as the handler, in which case Perl will try todiscard the signal or do the default thing.  Some signals can be neithertrapped nor ignored, such as the <tt CLASS=literal>KILL</tt> and<tt CLASS=literal>STOP</tt> signals. You can temporarily ignore other signalsby using a <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> signal handler assignment, which goesout of effect once your block isexited.  (Remember, though, that <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> values are inherited byfunctions called from within that block.)<DIV CLASS=programlisting><P><PRE>sub precious {    local $SIG{INT} = 'IGNORE';    &amp;more_functions;} sub more_functions {    # interrupts still ignored, for now...}</PRE></DIV><P CLASS=para>Sending a signal to a negative process ID means that you send the signalto the entire UNIX process-group.  This code sends a hang-up signal to allprocesses in the current process group except for the current processitself:<DIV CLASS=programlisting><P><PRE>{    local $SIG{HUP} = 'IGNORE';    kill HUP =&gt; -$$;   # snazzy form of: kill('HUP', -$$)}</PRE></DIV><P CLASS=para>Another interesting signal to send is signal number <tt CLASS=literal>0</tt>.  This doesn'tactually affect the other process, but instead checks whether it's aliveor has changed its UID.  That is, it checks whether it's legal to senda signal, without actually sending one.<DIV CLASS=programlisting><P><PRE>unless (kill 0 =&gt; $kid_pid) {    warn "something wicked happened to $kid_pid";}</PRE></DIV><P CLASS=para>Another cute trick is to employ anonymous functions for simple signalhandlers:<DIV CLASS=programlisting><P><PRE>$SIG{INT} = sub { die "\nOutta here!\n" };</PRE></DIV><P CLASS=para>Because it's a subroutine without a name,this approach can be problematic for complicated handlers that need toreinstall themselves.  That's because Perl's signal mechanism washistorically based on the <I CLASS=emphasis>signal</I> (3) function from the C library.On some systems, this function was broken; that is, it behaved in theunreliable System V way rather than the reliable BSD (and POSIX)fashion.  This meant that you had to reinstall the signal handler eachtime it got called.[4]You also had to manually restart interruptedsystem calls.  Careful programmers tend to write self-referentialhandlers that reinstall themselves:<blockquote class=footnote><P CLASS=para>[4] If you were lucky.  The old signal behavior had a race conditionwhereby you couldn't guarantee that you could reset your handler intime before the next signal came in, which is why it was changed.</blockquote><DIV CLASS=programlisting><P><PRE>sub REAPER {     $waitedpid = wait;    $SIG{CHLD} = \&amp;REAPER;  # loathe sysV}$SIG{CHLD} = \&amp;REAPER;# now do something that forks...</PRE></DIV><P CLASS=para>or, somewhat more elaborately:[5]<blockquote class=footnote><P CLASS=para>[5] Although it seems unlikely that you would have POSIX <tt CLASS=literal>WNOHANG</tt> <A HREF="ch03_02.htm#PERL2-CMD-WAITPID">waitpid</A> behavior while lacking proper POSIX signals.</blockquote><DIV CLASS=programlisting><P><PRE>use POSIX "sys_wait_h";sub REAPER {     $SIG{CHLD} = \&amp;REAPER;  # loathe sysV, dream of real POSIX    my $child;    while ($child = waitpid(-1, WNOHANG)) {        $Kid_Status{$child} = $?;    } }$SIG{CHLD} = \&amp;REAPER;# do something that forks...</PRE></DIV><P CLASS=para>And if you're writing code to behave the same way everywhere, even onrather old systems, it all gets more complex yet.  Loops with blockingsystem calls (like <tt CLASS=literal>&lt;FILE&gt;</tt> or <A HREF="ch03_02.htm#PERL2-CMD-ACCEPT">accept</A>) need additional logicto handle system calls that return failure for silly reasons, such aswhen your <tt CLASS=literal>SIGCHLD</tt> handler triggers and you reap a moribund childprocess.<P CLASS=para>Fortunately, you shouldn't have to do that much any more.  That's becausewhenever possible, Perl now uses the reliable <I CLASS=emphasis>sigaction</I> (2)function from POSIX.  If you know you're running on a system that supports<I CLASS=emphasis>sigaction</I> (2), you won't have to reinstall your handlers, and a lotof other things will work out better, too.  For example, "slow" systemcalls (ones that can block, like <A HREF="ch03_02.htm#PERL2-CMD-READ">read</A>, <tt CLASS=literal>&lt;STDIN&gt;</tt>, <A HREF="ch03_02.htm#PERL2-CMD-WAIT">wait</A>,and <A HREF="ch03_02.htm#PERL2-CMD-ACCEPT">accept</A>) will restart automatically now if they get interruptedby a signal. This is generally construed to be a feature.<P CLASS=para>You check whether you have the more rigorous POSIX-style signalbehavior by accessing the Config module, described in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.<DIV CLASS=programlisting><P><PRE>use Config;print "Hurray!\n" if $Config{d_sigaction};</PRE></DIV><P CLASS=para>This will tell you whether you have reliable system calls that don't needto be reinstalled, but it won't tell you whether they're restartable.Perl doesn't provide that information in its Config module, butyou could check out your system's C <I CLASS=emphasis>signal.h</I> include file directly:<DIV CLASS=programlisting><P><PRE>egrep 'S[AV]_(RESTART|INTERRUPT)' /usr/include/*/signal.h</PRE></DIV><P CLASS=para>On some older SysV systems, a simple but nonportable hack for avoidingzombieswas to set <tt CLASS=literal>$SIG{CHLD}</tt> to <tt CLASS=literal>'IGNORE'</tt>.  This approach does not workon systems with <I CLASS=emphasis>sigaction</I> (2).  Instead, the best way to avoid zombieson POSIX systems is to use the <tt CLASS=literal>REAPER()</tt> function above.<P CLASS=para>You can also use signals to impose time limits on long-running operations.  If you'reon a UNIX system (or any other system that supports the <tt CLASS=literal>ALRM</tt> signal),you can ask the kernel to send your process an <tt CLASS=literal>ALRM</tt>at some point in the future:<DIV CLASS=programlisting><P><PRE>eval {     local $SIG{ALRM} = sub { die "alarm clock restart" };    alarm 10;       # schedule alarm in 10 seconds     flock(FH, 2);   # a "write" lock that may block    alarm 0;        # cancel the alarm};if ($@ and $@ !~ /alarm clock restart/) { die }</PRE></DIV><P CLASS=para><A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> and <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A> provide a convenient mechanism for aborting the<A HREF="ch03_02.htm#PERL2-CMD-FLOCK">flock</A> if it hangs.<P CLASS=para>For more complex signal handling, see the POSIX module in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.  Thismodule provides an object-oriented approach to signals that gives youcomplete access to low-level system behavior.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.2">Pipes</A></h3><P CLASS=para><A NAME="CH06.PIPE1"></A><A NAME="CH06.PIPE2"></A><A NAME="CH06.PIPE3"></A>A <I CLASS=emphasis>pipe</I> is a unidirectional I/O channel that can transfer a stream ofbytes from one process to another.  They come in both named and namelessvarieties.  You may be more familiar with nameless pipes, so we'll talkabout those first.<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.2.1">Anonymous pipes</A></h4><P CLASS=para>Perl's <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> function opens a pipe instead of a file when youappend or prepend a pipe symbol to the second argument to <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A>.This turns the rest of the argument into a command, which will beinterpreted as a process (or set of processes) to pipe a stream of dataeither into or out of.  Here's how to start up a child process thatyou intend to write to:<DIV CLASS=programlisting><P><PRE>open SPOOLER, "| cat -v | lpr -h 2&gt;/dev/null"                or die "can't fork: $!";local $SIG{PIPE} = sub { die "spooler pipe broke" };print SPOOLER "stuff\n";close SPOOLER or die "bad spool: $! $?";</PRE></DIV><P CLASS=para>This example is actually starting up two processes, the first of which(running <I CLASS=emphasis>cat</I>) we print to directly.  The second process (running<I CLASS=emphasis>lpr</I>) then receives the output ofthe first process.  In shell programming this is often called a <I CLASS=emphasis>pipeline</I>.A pipeline can have as many processes in a row as you like.<P CLASS=para>And here's how to start up a child process that you intend to read from:<DIV CLASS=programlisting><P><PRE>open STATUS, "netstat -an 2&gt;&amp;1 |"                or die "can't fork: $!";while (&lt;STATUS&gt;) {    next if /^(tcp|udp)/;    print;} close SPOOLER or die "bad netstat: $! $?";</PRE></DIV><P CLASS=para>You can open a pipeline for input just as you can for output, but wedon't show it in this example.<P CLASS=para>You might have noticed that you can use backticks to accomplish thesame effect as opening a pipe for reading:<DIV CLASS=programlisting><P><PRE>print grep { !/^(tcp|udp)/ } `netstat -an 2&gt;&amp;1`;die "bad netstat" if $?;</PRE></DIV><P CLASS=para>While this is true, it's often more efficient to process the file oneline or record at a time, because then Perl doesn't have to read thewhole thing into memory at once. It also gives you finer control of thewhole operation, letting you kill off the child process early if youlike.<P CLASS=para>Be careful to check the return values of both <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> and <A HREF="ch03_02.htm#PERL2-CMD-CLOSE">close</A>.  (Ifyou're writing to a pipe, you should also be prepared to handle thePIPE signal, which is sent to you if the process on the other end diesbefore you're done sending to it.)  The reason you need to check boththe <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> and the <A HREF="ch03_02.htm#PERL2-CMD-CLOSE">close</A> has to do with an idiosyncrasy of UNIX inhow piped commands are started up.  When you do the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A>, yourprocess forks a child process that is in charge of executing the commandyou gave it.  The <I CLASS=emphasis>fork</I> (2) system call, if successful, returnsimmediately within the parent process, and the parent script leaves the<A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> function successfully, even though the child process may nothave even run yet.  By the time the child process actually tries to runthe command, it's already a separately scheduled process.  So if itfails to execute the command, it has no easy way to communicate the factback to the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> statement, which may have already exitedsuccessfully in the parent.  The way the disaster is finallycommunicated back to the parent is the same way that any other disasterin the child process is communicated back: namely, the exit status ofthe child process is harvested by the parent process when it eventuallydoes a <I CLASS=emphasis>wait</I> (2) system call.  But this happens in the <A HREF="ch03_02.htm#PERL2-CMD-CLOSE">close</A>function, not the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> function.  And that's why you have to checkthe return value of your <A HREF="ch03_02.htm#PERL2-CMD-CLOSE">close</A> function.  Whew.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.2.2">Talking to yourself</A></h4><P CLASS=para>Another approach to IPC is to make your program talk to itself, in amanner of speaking.  Actually, your process talks to a forked copy ofitself.  It works much like the piped open we talked about in the lastsection, except that the child process continues executing your scriptinstead of trying to execute some other command.<P CLASS=para>To represent this to the <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> function, you use a pseudo-commandconsisting of a minus.  So the second argument to <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> looks likeeither "<tt CLASS=literal>-|</tt>" or "<tt CLASS=literal>|-</tt>", depending on whether you want to pipe fromyourself or to yourself.  The <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> function returns the child'sprocess ID inthe parent process, but <tt CLASS=literal>0</tt> in the child process.  Another asymmetryis that the filehandle is used only in the parent process.  The child'send of the pipe is hooked to either <tt CLASS=literal>STDIN</tt> or <tt CLASS=literal>STDOUT</tt>as appropriate.That is, if you open a pipe <I CLASS=emphasis>to</I> minus, you can write to the filehandleyou opened and your kid will find it in his <tt CLASS=literal>STDIN</tt>.  If you open a pipe<I CLASS=emphasis>from</I> minus, you can read from the filehandle you opened whatever yourkid writes to her <tt CLASS=literal>STDOUT</tt>.<P CLASS=para>This is useful for safely opening a file when running under anassumed UID or GID, for example:<DIV CLASS=programlisting><P><PRE>use English;my $sleep_count = 0;do {     $pid = open(KID_TO_WRITE, "|-");    unless (defined $pid) {        warn "cannot fork: $!";        die "bailing out" if $sleep_count++ &gt; 6;        sleep 10;    } } until defined $pid;if ($pid) {  # parent    print KID_TO_WRITE @some_data;    close(KID_TO_WRITE) or warn "kid exited $?";}else {       # child    ($EUID, $EGID) = ($UID, $GID); # suid progs only    open (FILE, "&gt; /safe/file")                     or die "can't open /safe/file: $!";    while (&lt;STDIN&gt;) {        print FILE; # child's STDIN is parent's KID    }     exit;  # don't forget this}</PRE></DIV><P CLASS=para>Another common use for this construct is to bypass the shell when youwant to open a pipe from a command.  You might want to do this forsecurity reasons, because you don't want the shell interpreting anymetacharacters in the filenames you're trying to pass to the command.We give an example of this later in the chapter--see "Cleaning Up Your Path".<P CLASS=para>Note that these operations are full UNIX forks, which means they may not becorrectly implemented on alien systems.  Additionally, these are not truemulti-threading.  If you'd like to learn more about threading, seeCPAN.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.2.3">Bidirectional communication</A></h4><P CLASS=para>While pipes work reasonably well for unidirectional communication, whatabout bidirectional communication?  The obvious thing you'd like to dodoesn't actually work:<DIV CLASS=programlisting><P><PRE>open(PROG_FOR_READING_AND_WRITING, "| some program |")  # WRONG!</PRE></DIV><P CLASS=para>and if you forget to use the <B>-w</B> switch, then you'll miss out entirely on the diagnostic message:<DIV CLASS=programlisting><P><PRE>Can't do bidirectional pipe at myprog line 3.</PRE></DIV><P CLASS=para>The <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> function won't allow this because it's rather error prone unlessyou know what you're doing, and can easily result in deadlock, whichwe'll explain later.  But if you really want to do it, you can use thestandard IPC::Open2 library module to attach two pipes to a subprocess's<tt CLASS=literal>STDIN</tt> and <tt CLASS=literal>STDOUT</tt>.  There's also an IPC::Open3 module for tridirectionalI/O (allowing you to catch your child's <tt CLASS=literal>STDERR</tt>), but thisrequires an awkward <B>select</B> loop and doesn't allow youto use normal Perl input operations.<P CLASS=para>If you look at the source, you'll see that Open2 uses low-levelprimitives like <A HREF="ch03_02.htm#PERL2-CMD-PIPE">pipe</A> and <A HREF="ch03_02.htm#PERL2-CMD-EXEC">exec</A> to create all the connections.While it might have been slightly more efficient to use <A HREF="ch03_02.htm#PERL2-CMD-SOCKETPAIR">socketpair</A>,it would have been even less portable.  As it is, the Open2and Open3 modules are unlikely to work anywhere except on a UNIXsystem, or some other system purporting to be POSIX compliant.<P CLASS=para>Here's an example using <tt CLASS=literal>IPC::Open2::open2()</tt>:<DIV CLASS=programlisting><P><PRE>use FileHandle;use IPC::Open2;$pid = open2( \*Reader, \*Writer, "cat -u -n" );Writer-&gt;autoflush();     # This is default, actually.print Writer "stuff\n";$got = &lt;Reader&gt;;</PRE></DIV><P CLASS=para>The problem with this in general is that UNIX buffering is really goingto ruin your day.  Even though your Writer filehandle is autoflushed,and the process on the other end will get your data in a timely manner,you can't usually do anything to force it to actually give it back toyou in a similarly quick fashion.  In this particular case we can,since (on some systems) the <I CLASS=emphasis>cat</I> program has a <B>-u</B> option to make it do unbufferedoutput.  But very few UNIX commands are designed to operate well over pipes,so this seldom works unless you yourself wrote the program on the otherend of the double-ended pipe.<P CLASS=para>A partial solution to this is to use the <I CLASS=emphasis>Comm.pl</I> library (not a standardmodule--see CPAN).  It uses pseudo-ttys to make your program behavemore reasonably, at least on those machines that force standard output to doline-buffering:<DIV CLASS=programlisting><P><PRE>require 'Comm.pl';$ph = open_proc('cat -n');for (1..10) {    print $ph "a line\n";    print "got back ", scalar &lt;$ph&gt;;}</PRE></DIV><P CLASS=para>This way you don't have to have control over the source code of theprogram you're using.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.2.4">Named pipes</A></h4><P CLASS=para>A named pipe (often called a FIFO) is an old UNIX mechanism forsetting up pipes between unrelated processes.  The names in questionexist in the filesystem, which is just a funny way to say that youcan put a special file in the filesystem that has anotherprocess behind it instead of a disk.<P CLASS=para>To create a named pipe, use the UNIX command <I CLASS=emphasis>mknod</I> (1) or, on somesystems, <I CLASS=emphasis>mkfifo</I> (1).  These commands may not be in your normal execution path.<DIV CLASS=programlisting><P><PRE># system() return value is backwards, so "and" not "or"#$ENV{PATH} .= ":/etc:/usr/etc";if  (      system('mknod',  $path, 'p')        and system('mkfifo', $path) ){    die "mk{nod,fifo} $path failed";}</PRE></DIV><P CLASS=para>A FIFO is convenient when you want to connect a process to an unrelatedone.  When you open a FIFO, the program will block until there's somethingon the other end.<P CLASS=para>For example, let's say you'd like to have your <I CLASS=emphasis>.signature</I> file be anamed pipe that has a Perl program on the other end.  Now every time anyprogram (like a mailer, newsreader, finger program, and so on) tries to readfrom that file, the reading program will block and your program willsupply the new signature.  We'll use the pipe-checking file test, <tt CLASS=literal>-p</tt>, to find out whether anyone (or anything) has accidentally removed our FIFO.<DIV CLASS=programlisting><P><PRE>chdir; # go home$FIFO = '.signature';$ENV{PATH} .= ":/etc:/usr/games";</PRE></DIV><DIV CLASS=programlisting><P><PRE>while (1) {    unless (-p $FIFO) {        unlink $FIFO;        system('mknod', $FIFO, 'p')             &amp;&amp; die "can't mknod $FIFO: $!";    }</PRE></DIV><DIV CLASS=programlisting><P><PRE>    # next line blocks until there's a reader    open (FIFO, "&gt; $FIFO") or die "can't write $FIFO: $!";    print FIFO "John Smith (smith\@host.org)\n", `fortune -s`;    close FIFO;    sleep 1;    # to avoid dup sigs}</PRE></DIV><P CLASS=para>If that last comment seems opaque to you, consider how often the<I CLASS=emphasis>fortune</I> program changes its current fortune.<P CLASS=para>Note that a FIFO in an NFS partition won't transfer data across your network.</DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.3">System V IPC</A></h3><P CLASS=para>Although System V IPC is pretty ancient, it still has some valid uses.But you can't use System V shared memory (or the more modern <I CLASS=emphasis>mmap</I> (2)system call, for that matter) to share a variable among severalprocesses.  That's because Perl would reallocate your string when youweren't wanting it to.  Instead, Perl uses a read/write notion.<P CLASS=para>Here's a small example showing shared memory usage:<DIV CLASS=programlisting><P><PRE>$IPC_PRIVATE = 0;$IPC_RMID = 0;$size = 2000;$key = shmget($IPC_PRIVATE, $size , 0777 );die unless defined $key;</PRE></DIV><DIV CLASS=programlisting><P><PRE>$message = "Message #1";shmwrite($key, $message, 0, 60 ) or die "shmwrite: $!";shmread($key,$buff,0,60) or die "shmread: $!";</PRE></DIV><DIV CLASS=programlisting><P><PRE>print $buff,"\n";</PRE></DIV><DIV CLASS=programlisting><P><PRE>print "deleting $key\n";shmctl($key ,$IPC_RMID, 0) or die "shmctl: $!";</PRE></DIV><P CLASS=para>Here's an example of a semaphore:<DIV CLASS=programlisting><P><PRE>$IPC_KEY = 1234;$IPC_RMID = 0;$IPC_CREATE = 0001000;$key = semget($IPC_KEY, $nsems, 0666 | $IPC_CREATE );die if !defined($key);print "$key\n";</PRE></DIV><P CLASS=para>Put this code in a separate file so that more than one process can<A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> and run it.Call the file <I CLASS=emphasis>take</I>:<DIV CLASS=programlisting><P><PRE># create a semaphore</PRE></DIV><DIV CLASS=programlisting><P><PRE>$IPC_KEY = 1234;$key = semget($IPC_KEY, 0, 0 );die if !defined($key);</PRE></DIV><DIV CLASS=programlisting><P><PRE>$semnum = 0;$semflag = 0;</PRE></DIV><DIV CLASS=programlisting><P><PRE># 'take' semaphore# wait for semaphore to be zero$semop = 0;$opstring1 = pack("sss", $semnum, $semop, $semflag);</PRE></DIV><DIV CLASS=programlisting><P><PRE># Increment the semaphore count$semop = 1;$opstring2 = pack("sss", $semnum, $semop,  $semflag);$opstring = $opstring1 . $opstring2;</PRE></DIV><DIV CLASS=programlisting><P><PRE>semop($key,$opstring) or die "semop: $!";</PRE></DIV><P CLASS=para>Put this code in a separate file to be run in more that one process.Call this file <I CLASS=emphasis>give</I>:<DIV CLASS=programlisting><P><PRE># 'give' the semaphore# run this in the original process and you will see# that the second process continues</PRE></DIV><DIV CLASS=programlisting><P><PRE>$IPC_KEY = 1234;$key = semget($IPC_KEY, 0, 0);die if !defined($key);</PRE></DIV><DIV CLASS=programlisting><P><PRE>$semnum = 0;$semflag = 0;</PRE></DIV><DIV CLASS=programlisting><P><PRE># Decrement the semaphore count$semop = -1;$opstring = pack("sss", $semnum, $semop, $semflag);</PRE></DIV><DIV CLASS=programlisting><P><PRE>semop($key,$opstring) or die "semop: $!";</PRE></DIV><P CLASS=para>The code above is rather low-level and clunky.  A better approach wouldbe to use the IPC::SysV module in CPAN.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.4">Sockets</A></h3><P CLASS=para><A NAME="CH06.SOCK1"></A>While sockets were invented under UNIX, nowadays you can find them onmany other operating systems (though sometimes as an unbundled product).If you don't have sockets on your machine, you're going to have difficultycooperating with processes on the Internet.  With sockets, you can doboth virtual circuits (that is, TCP streams) and datagrams (that is, UDPpackets).  You may be able to do even more, depending on your system.<P CLASS=para>The Perl function calls for dealing with sockets have the same names asthe corresponding system calls in C, but their arguments tend to differfor two reasons: first, Perl filehandles work differently from C filedescriptors, and second, Perl already knows the length of its strings, so youdon't need to pass that information.  See <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A> for details on eachcall.<P CLASS=para>Most of these routines quietly but politely return the undefined valuewhen they fail,instead of causing your program to die right then and there due to anuncaught exception.  (Actually, some of the new Socket module conversionfunctions call <tt CLASS=literal>croak()</tt> on bad arguments.)  It is therefore essentialthat you check the return values of these functions.  Always beginyour socket programs this way for optimal success (and don't forget to add<B>-T</B> taint checking switch to the shebang line for servers):<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -wrequire 5.002;use strict;use sigtrap;use Socket;</PRE></DIV><P CLASS=para>All the socket routines create system-specific portability problems.  As notedelsewhere, Perl is at the mercy of your C libraries for much of its systembehavior.  It's probably safest to assume broken System V semantics forsignals and to stick with simple TCP and UDP socket operations; forexample, don'ttry to pass open file descriptors over a local UDP datagram socket if youwant your code to stand a chance of being portable.  (Yes, you can reallydo that on some machines--see BSD in the Glossary.)<P CLASS=para>One of the major problems with ancient socket code in Perl was that it tendedto use hard-coded values for some of the constants, which severely hurtportability.  If you ever see code that does anything like explicitlysetting <tt CLASS=literal>$AF_INET = 2</tt>, you know you're in for big trouble.  Animmeasurably superior approach is to use the Socket module, which morereliably grants access to the various constants and functions you'll need.<P CLASS=para>Below we will present several sample clients and servers without a greatdeal of explanation, since it would mostly duplicate the descriptionswe've already provided in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.  Besides those descriptions, youshould also check out CPAN.  Section 5 of the CPAN <I CLASS=emphasis>modules</I>file is devotedto "Networking, Device Control (modems), and Interprocess Communication",and refers you to numerous unbundled modules having to do with networking,Chat and Expect operations, CGI programming, DCE, FTP, IPC, NNTP, Proxy,Ptty, RPC, SNMP, SMTP, Telnet, Threads, and ToolTalk--just to name afew.<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.4.1">Internet TCP clients and servers</A></h4><P CLASS=para><A NAME="CH06.TCP1"></A><A NAME="CH06.TCP2"></A><A NAME="CH06.TCP3"></A>Use Internet-domain sockets when you want to do client-servercommunication between different machines.<P CLASS=para>Here's a sample TCP client using Internet-domain sockets:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -wrequire 5.002;use strict;use Socket;my ($remote,$port, $iaddr, $paddr, $proto, $line);</PRE></DIV><DIV CLASS=programlisting><P><PRE>$remote  = shift || 'localhost';$port    = shift || 2345;  # random portif ($port =~ /\D/) { $port = getservbyname($port, 'tcp') }die "No port" unless $port;$iaddr   = inet_aton($remote)              or die "no host: $remote";$paddr   = sockaddr_in($port, $iaddr);</PRE></DIV><DIV CLASS=programlisting><P><PRE>$proto   = getprotobyname('tcp');socket(SOCK, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";connect(SOCK, $paddr)                      or die "connect: $!";while ($line = &lt;SOCK&gt;) {    print $line;}</PRE></DIV><DIV CLASS=programlisting><P><PRE>close (SOCK)                               or die "close: $!";exit;</PRE></DIV><P CLASS=para>And here's a corresponding server to go along with it.  The clientdidn't need to bind an address, but the server does.  However, we'llspecify the address as <tt CLASS=literal>INADDR_ANY</tt> so that the kernel can choosethe appropriate interface on multi-homed hosts.  If you want to siton a particular interface (like the external side of a gatewayor firewall machine), you should fill this in with your real addressinstead.<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -Twrequire 5.002;use strict;BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }use Socket;use Carp;</PRE></DIV><DIV CLASS=programlisting><P><PRE>sub logmsg { print "$0 $$: @_ at ", scalar localtime, "\n" }</PRE></DIV><DIV CLASS=programlisting><P><PRE>my $port = shift || 2345;my $proto = getprotobyname('tcp');socket(Server, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))                                             or die "setsockopt: $!";bind(Server, sockaddr_in($port, INADDR_ANY)) or die "bind: $!";listen(Server,SOMAXCONN)                     or die "listen: $!";</PRE></DIV><DIV CLASS=programlisting><P><PRE>logmsg "server started on port $port";</PRE></DIV><DIV CLASS=programlisting><P><PRE>my $paddr;</PRE></DIV><DIV CLASS=programlisting><P><PRE>$SIG{CHLD} = \&amp;REAPER;</PRE></DIV><DIV CLASS=programlisting><P><PRE>for ( ; $paddr = accept(Client,Server); close Client) {    my($port,$iaddr) = sockaddr_in($paddr);    my $name = gethostbyaddr($iaddr,AF_INET);</PRE></DIV><DIV CLASS=programlisting><P><PRE>    logmsg "connection from $name [",             inet_ntoa($iaddr), "] at port $port";</PRE></DIV><DIV CLASS=programlisting><P><PRE>    print Client "Hello there, $name, it's now ",                     scalar localtime, "\n";}</PRE></DIV><P CLASS=para>And here's a multi-threaded version.  It's multi-threaded in the sensethat, like most typical servers, it spawns (forks) a slave server tohandle the client request so that the master server can quickly go backto service the next client.<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -Twrequire 5.002;use strict;BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }use Socket;use Carp;use FileHandle;sub spawn;  # forward declarationsub logmsg { print "$0 $$: @_ at ", scalar localtime, "\n" } my $port = shift || 2345;my $proto = getprotobyname('tcp');socket(Server, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))                                             or die "setsockopt: $!";bind(Server, sockaddr_in($port, INADDR_ANY)) or die "bind: $!";listen(Server,SOMAXCONN)                     or die "listen: $!";logmsg "server started on port $port";my $waitedpid = 0;my $paddr;sub REAPER {     $waitedpid = wait;    $SIG{CHLD} = \&amp;REAPER;  # if you don't have sigaction(2)    logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");}$SIG{CHLD} = \&amp;REAPER;for ( ; $paddr = accept(Client,Server); close Client) {    my($port,$iaddr) = sockaddr_in($paddr);    my $name = gethostbyaddr($iaddr,AF_INET);    logmsg "connection from $name [",             inet_ntoa($iaddr), "] at port $port";    spawn sub {         print "Hello there, $name, it's now ", scalar localtime, "\n";        exec '/usr/games/fortune'             or confess "can't exec fortune: $!";    };} sub spawn {    my $coderef = shift;    unless (@_ == 0 &amp;&amp; $coderef &amp;&amp; ref($coderef) eq 'CODE') {         confess "usage: spawn CODEREF";    }    my $pid;    if (!defined($pid = fork)) {        logmsg "cannot fork: $!";        return;    } elsif ($pid) {        logmsg "begat $pid";        return; # i'm the parent    }    # else i'm the child -- go spawn    open(STDIN,  "&lt;&amp;Client")    or die "can't dup client to stdin";    open(STDOUT, "&gt;&amp;Client")    or die "can't dup client to stdout";    STDOUT-&gt;autoflush();    exit &amp;$coderef();}</PRE></DIV><P CLASS=para>As mentioned, this server takes the trouble to clone off a child versionvia <A HREF="ch03_02.htm#PERL2-CMD-FORK">fork</A> for each incoming request.  That way it can handle manyrequests at once, as long as you can create more processes.  (You mightwant to limit this.)  Even if you don't <A HREF="ch03_02.htm#PERL2-CMD-FORK">fork</A>, the <A HREF="ch03_02.htm#PERL2-CMD-LISTEN">listen</A> willallow up to <tt CLASS=literal>SOMAXCONN</tt> (usually five or more) pending connections.Each connection uses up some resources, although not as muchas a process. Forking servers also have to be particularly careful aboutcleaning up their dead children (called zombies in UNIX),because otherwise they'd quickly fill up your process table.  The <tt CLASS=literal>REAPER</tt>code above will take care of that for you.<P CLASS=para>If you're running on a system without restartable system calls (orif you want to be really careful in case you might someday run onsuch a system), you'll have to write a more elaborate <B>for</B> loop.That's because the act of collecting the zombie child process maycause the <A HREF="ch03_02.htm#PERL2-CMD-ACCEPT">accept</A> to fail and return the undefined value, making yourloop fail prematurely.  Here's a work-around:<DIV CLASS=programlisting><P><PRE>for ( $waitedpid = 0;       ($paddr = accept(Client,Server)) || $waitedpid;       $waitedpid = 0, close Client) {    next if $waitedpid and not $paddr;   # or check $! == EINTR    # the rest is the same...</PRE></DIV><P CLASS=para>We suggest that you use the <B>-T</B> switch to enable taint checking (see "Cooperating with Strangers" and "Cooperating with Other Languages" laterin this chapter)even if you aren't running setuid or setgid.  This is always a good ideafor servers and other programs (like CGI scripts) that run on behalf of someoneelse, because it lessens the chances that people from the outside willbe able to compromise your system.<P CLASS=para>Let's look at another TCP client.  This one connects to the TCP "time"service on a number of different machines and shows how far their clocksdiffer from the system on which the client is being run:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -wrequire 5.002;use strict;use Socket;</PRE></DIV><DIV CLASS=programlisting><P><PRE>my $SECS_of_70_YEARS = 2208988800;sub ctime { scalar localtime(shift) }</PRE></DIV><DIV CLASS=programlisting><P><PRE>my $iaddr = gethostbyname('localhost'); my $proto = getprotobyname('tcp');   my $port = getservbyname('time', 'tcp');  my $paddr = sockaddr_in(0, $iaddr);my($host);</PRE></DIV><DIV CLASS=programlisting><P><PRE>$| = 1;printf "%-24s %8s %s\n",  "localhost", 0, ctime(time());</PRE></DIV><DIV CLASS=programlisting><P><PRE>foreach $host (@ARGV) {    printf "%-24s ", $host;    my $hisiaddr = inet_aton($host)     or die "unknown host";    my $hispaddr = sockaddr_in($port, $hisiaddr);    socket(SOCKET, PF_INET, SOCK_STREAM, $proto)                                        or die "socket: $!";    connect(SOCKET, $hispaddr)          or die "bind: $!";    my $rtime = '    ';    read(SOCKET, $rtime, 4);    close(SOCKET);    my $histime = unpack("N", $rtime) - $SECS_of_70_YEARS ;    printf "%8d %s\n", $histime - time, ctime($histime);}</PRE></DIV></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.4.2">UNIX-domain clients and servers</A></h4><P CLASS=para>That's all fine for Internet-domain clients and servers, but what aboutlocal communications?  While you can just pretend that your localmachine is remote, sometimes you don't want to.  UNIX-domain sockets arelocal to the current host, and are often used internally to implementpipes.  They tend to be a little more efficient than Internet-domainsockets.  Unlike Internet-domain sockets, UNIX domain sockets can showup in the file system with an <I CLASS=emphasis>ls</I> (1) listing.<DIV CLASS=programlisting><P><PRE>$ ls -l /dev/logsrw-rw-rw-  1 root            0 Oct 31 07:23 /dev/log</PRE></DIV><P CLASS=para>You can test for these with Perl's <tt CLASS=literal>-S</tt> file test:<DIV CLASS=programlisting><P><PRE>unless ( -S '/dev/log' ) {    die "something's wicked with the print system";}</PRE></DIV><P CLASS=para>Here's a sample UNIX-domain client:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -wrequire 5.002;use Socket;use strict;my ($rendezvous, $line);$rendezvous = shift || '/tmp/catsock';socket(SOCK, PF_UNIX, SOCK_STREAM, 0)     or die "socket: $!";connect(SOCK, sockaddr_un($rendezvous))   or die "connect: $!";while ($line = &lt;SOCK&gt;) {    print $line;} exit;</PRE></DIV><P CLASS=para>And here's a corresponding server.<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -Twrequire 5.002;use strict;use Socket;use Carp;BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }my $NAME = '/tmp/catsock';my $uaddr = sockaddr_un($NAME);my $proto = getprotobyname('tcp');socket(Server,PF_UNIX,SOCK_STREAM,0)      or die "socket: $!";unlink($NAME);bind  (Server, $uaddr)                    or die "bind: $!";listen(Server,SOMAXCONN)                  or die "listen: $!";logmsg "server started on $NAME";$SIG{CHLD} = \&amp;REAPER;for ( ; $paddr = accept(Client,Server); close Client) {    logmsg "connection on $NAME";    spawn sub {         print "Hello there, it's now ", scalar localtime, "\n";        exec '/usr/games/fortune';        die "can't exec fortune: $!";    };}</PRE></DIV><P CLASS=para>As you see, it's remarkably similar to the Internet-domain TCP server, somuch so, in fact, that we've omitted several duplicate functions--<tt CLASS=literal>spawn()</tt>,<tt CLASS=literal>logmsg()</tt>, <tt CLASS=literal>ctime()</tt>, and <tt CLASS=literal>REAPER()</tt>--which are exactly the same as in theother server.<P CLASS=para>So why would you ever want to use a UNIX domain socket instead of a FIFO?Because a FIFO doesn't give you sessions.  Youcan't tell one process's data from another's.  With socket programming,you get a separate session for each client--that's why <A HREF="ch03_02.htm#PERL2-CMD-ACCEPT">accept</A> takes twoarguments.<P CLASS=para>For example, let's say that you have a long-running database server daemonthat you want folks from the World Wide Web to be able to access, but onlyif they go through a CGI interface.  You'd have a small, simple CGIprogram that does whatever checks and logging you feel like, and then actsas a UNIX-domain client and proxies the request to your private server.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-2.4.3">UDP: message passing</A></h4><P CLASS=para>Another kind of client-server setup is one that uses not connections, butmessages, or datagrams.  UDP communications involve much lower overhead but also provideless reliability, since there are no promises that messages will arrive atall, let alone in order and unmangled.  Still, UDP offers some advantagesover TCP, including being able to broadcast or multicast to a wholebunch of destination hosts at once (usually on your local subnet).  If youfind yourself overly concerned about reliability and start building checksinto your message system, then you probably should just use TCP to startwith.<P CLASS=para>Here's a UDP program similar to the sample Internet TCP client givenabove.  However, instead of checking one host at a time, the UDP versionwill check many of them asynchronously by simulating a multicast and thenusing <B>select</B> to do a timed-out wait for I/O.  To do something similarwith TCP, you'd have to use a different socket handle for each host.<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perl -wuse strict;require 5.002;use Socket;use Sys::Hostname;</PRE></DIV><DIV CLASS=programlisting><P><PRE>my ( $count, $hisiaddr, $hispaddr, $histime,      $host, $iaddr, $paddr, $port, $proto,      $rin, $rout, $rtime, $SECS_of_70_YEARS);</PRE></DIV><DIV CLASS=programlisting><P><PRE>$SECS_of_70_YEARS      = 2208988800;</PRE></DIV><DIV CLASS=programlisting><P><PRE>$iaddr = gethostbyname(hostname());$proto = getprotobyname('udp');$port = getservbyname('time', 'udp');$paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick</PRE></DIV><DIV CLASS=programlisting><P><PRE>socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   or die "socket: $!";bind(SOCKET, $paddr)                          or die "bind: $!";</PRE></DIV><DIV CLASS=programlisting><P><PRE>$| = 1;printf "%-12s %8s %s\n",  "localhost", 0, scalar localtime time;$count = 0;for $host (@ARGV) {    $count++;    $hisiaddr = inet_aton($host)              or die "unknown host";    $hispaddr = sockaddr_in($port, $hisiaddr);    defined(send(SOCKET, 0, 0, $hispaddr))    or die "send $host: $!";}</PRE></DIV><DIV CLASS=programlisting><P><PRE>$rin = "";vec($rin, fileno(SOCKET), 1) = 1;</PRE></DIV><DIV CLASS=programlisting><P><PRE># timeout after 10.0 secondswhile ($count &amp;&amp; select($rout = $rin, undef, undef, 10.0)) {    $rtime = "";    ($hispaddr = recv(SOCKET, $rtime, 4, 0))  or die "recv: $!";    ($port, $hisiaddr) = sockaddr_in($hispaddr);    $host = gethostbyaddr($hisiaddr, AF_INET);    $histime = unpack("N", $rtime) - $SECS_of_70_YEARS ;    printf "%-12s ", $host;    printf "%8d %s\n", $histime - time, scalar localtime($histime);    $count--;}</PRE></DIV></DIV></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch06_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Cooperating with Command Interpreters</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Cooperating with Strangers</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>