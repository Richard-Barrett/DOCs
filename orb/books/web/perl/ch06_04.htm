<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 6] 6.4 Cooperating with Other Languages</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:12:05 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_03.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 6</b></td><td width=172 align=right valign=top><A HREF="ch07_01.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4">6.4 Cooperating with Other Languages</A></h2><P CLASS=para>Just as there are many levels on which languages can compete, so toothere are many levels on which languages can cooperate.  Here we'll talkprimarily about generation, translation and embedding (via linking).<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.1">Program Generation</A></h3><P CLASS=para>Almost from the time people first figured out that they could write programs,they started writing programs that write other programs.  These are called<I CLASS=emphasis>program generators</I>.  (If you're a history buff, you might know thatRPG stood for Report Program Generator long before it stood for RolePlaying Game.)  Now, anyone who has written a program generator knows that itcan make your eyes go crossed even when you're wide awake.  The problemis simply that much of your program's data looks like real code, butisn't (at least not yet).  The same text file contains both stuff that doessomething and similar looking stuff that doesn't.  Perl has variousfeatures that make it easier to mix it together with other languages,textually speaking.<P CLASS=para>Of course, these features also make it easier to write Perl in Perl,but it's rather expected that Perl would cooperate with itself.<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.1.1">Generating other languages in Perl</A></h4><P CLASS=para>Perl is, of course, a text-processing language, and most computerlanguages are textual.  Beyond that, the lack of arbitrary limits together with the various quoting and interpolation mechanisms make it pretty easy to visually isolate the code of the other language you're spitting out.For example, here is a small chunk of <I CLASS=emphasis>s2p</I>, the<I CLASS=emphasis>sed</I>-to-<I CLASS=emphasis>perl</I> translator:<DIV CLASS=programlisting><P><PRE>print &amp;q(&lt;&lt;"EOT");:       #!$bin/perl:       eval 'exec $bin/perl -S \$0 \${1+"\$@"}':               if \$running_under_some_shell;:       EOT</PRE></DIV><P CLASS=para>Here the enclosed text happens to be legal in two languages, both Perland shell.  We've used the trick of putting a colon and a tab on thefront of every line, which visually isolates the enclosed code.  Onevariable, <tt CLASS=literal>$bin</tt>, is interpolated in the multi-line quote in twoplaces, and then the string is passed through a function to strip thecolon and tab.<P CLASS=para>Of course, you aren't required to use multi-line quotes.  One often seesCGI scripts containing millions of <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> statements, one per line.It seems a bit like driving to church in an F-16, but hey, if it getsyou there. . . . <P CLASS=para>When you are embedding a large, multi-line quote containing some otherlanguage (such as HTML), it's sometimes helpful to pretend you'reenclosing Perl into the other language instead:<DIV CLASS=programlisting><P><PRE>print &lt;&lt;"END";stuffblah blah blah ${ \( <tt CLASS=replaceable><i>EXPR</i></tt> ) } blah blah blahblah blah blah @{[ <tt CLASS=replaceable><i>LIST</i></tt> ]} blah blah blahnonsenseEND</PRE></DIV><P CLASS=para>You can use either of those two tricks to interpolate the value of anyscalar <tt CLASS=replaceable><i>EXPR</i></tt> or <tt CLASS=replaceable><i>LIST</i></tt> into a longer string.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.1.2">Generating Perl in other languages</A></h4><P CLASS=para>Perl can easily be generated in other languages because it's both conciseand malleable.  You can pick your quotes not to interfere with the otherlanguage's quoting mechanisms.  You don't have to worry aboutindentation, or where you put your line breaks, or whether to backslashyour backslashes yet again.  You aren't forced to define a package as asingle string in advance, since you can slide into your package's namespacerepeatedly, whenever you want to evaluate more code in that package.</DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.2">Translation from Other Languages</A></h3><P CLASS=para>One of the very first Perl applications was the <I CLASS=emphasis>sed</I>-to-<I CLASS=emphasis>perl</I> translator,<I CLASS=emphasis>s2p</I>.  In fact, Larry delayed the initial release of Perl in order tocomplete <I CLASS=emphasis>s2p</I> and <I CLASS=emphasis>awk-to-perl</I> (<I CLASS=emphasis>a2p</I>), because he thought they'd improve theacceptance of Perl.  Hmm, maybe they did.<DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.2.1">s2p</A></h4><P CLASS=para>The <I CLASS=emphasis>s2p</I> program takes a <I CLASS=emphasis>sed</I> script specified on the command line(or from standard input) and produces a comparable Perl script on thestandard output.<P CLASS=para>Options include:<P><DL CLASS=variablelist><DT CLASS=varlistentry><B>-D</B><I CLASS=emphasis>number</I><DD><P CLASS=para>Sets debugging flags.<p><DT CLASS=varlistentry><B>-n</B>      <DD><P CLASS=para>Specifies that this <I CLASS=emphasis>sed</I> script was <I CLASS=emphasis>always</I> invoked as <I CLASS=emphasis>sed -n</I>.Otherwise a switch parser is prepended to the front of the script.<p><DT CLASS=varlistentry><B>-p</B>      <DD><P CLASS=para>Specifies that this <I CLASS=emphasis>sed</I> script was <I CLASS=emphasis>never</I> invoked as <I CLASS=emphasis>sed -n</I>.Otherwise a switch parser is prepended to the front of the script.</DL><P CLASS=para>The Perl script produced looks very <I CLASS=emphasis>sed</I>-like, and there may very wellbe better ways to express what you want to do in Perl.  For instance,<I CLASS=emphasis>s2p</I> does not make any use of the <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> operator, but you mightwant to.<P CLASS=para>The Perl script you end up with may be either faster or slower than theoriginal <I CLASS=emphasis>sed</I> script.  If you're only interested in speed you'll justhave to try it both ways.  Of course, if you want to do something <I CLASS=emphasis>sed</I>doesn't do, you have no choice.  It's often possible to speed up thePerl script by various methods, such as deleting all references to <B>$\</B>and <A HREF="ch03_02.htm#PERL2-CMD-CHOP">chop</A>.</DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.2.2">a2p</A></h4><P CLASS=para><A NAME="CH06.AWK1"></A><A NAME="CH06.AWK2"></A>The <I CLASS=emphasis>a2p</I> program takes an <I CLASS=emphasis>awk</I> script specified on the command line(or from standard input) and produces a comparable Perl script on thestandard output.<P CLASS=para>Options include:<P><DL CLASS=variablelist><DT CLASS=varlistentry><B>-D</B><I CLASS=emphasis>number</I><DD><P CLASS=para>Sets debugging flags.<p><DT CLASS=varlistentry><B>-F</B><I CLASS=emphasis>character</I><DD><P CLASS=para>Tells <I CLASS=emphasis>a2p</I> that this <I CLASS=emphasis>awk</I> script is always invoked with a <B>-F</B>switch specifying <I CLASS=emphasis>character</I>.<p><DT CLASS=varlistentry><B>-n</B><I CLASS=emphasis>fieldlist</I><DD><P CLASS=para>Specifies the names of the input fields if input does not have to besplit into an array for some programmatic reason.  If you weretranslating an <I CLASS=emphasis>awk</I> script that processes the password file, you mightsay:<DIV CLASS=programlisting><P><PRE>a2p -7 -nlogin.password.uid.gid.gcos.shell.home</PRE></DIV><P CLASS=para>Any delimiter may be used to separate the field names.<p><DT CLASS=varlistentry><B>-</B><I CLASS=emphasis>number</I><DD><P CLASS=para>Causes <I CLASS=emphasis>a2p</I> to assume that input will always have that many fields.</DL><P CLASS=para><I CLASS=emphasis>a2p</I> cannot do as good a job translating as a human would, but itusually does pretty well.  There are some areas where you may want toexamine the Perl script produced and tweak it some.  Here are some ofthem, in no particular order.<P CLASS=para>There is an <I CLASS=emphasis>awk</I> idiom of putting <tt CLASS=literal>int(...)</tt> around a string expression toforce numeric interpretation, even though the argument is always an integeranyway.  This is generally unneeded in Perl, but <I CLASS=emphasis>a2p</I> can't tell ifthe argument is always going to be an integer, so it leaves it in.  You maywish to remove it.<P CLASS=para>Perl differentiates numeric comparison from string comparison.  <I CLASS=emphasis>awk</I> hasone operator for both that decides at run-time which comparison to do.<I CLASS=emphasis>a2p</I> does not try to do a complete job of <I CLASS=emphasis>awk</I> emulation at thispoint.  Instead it guesses which one you want.  It's almost alwaysright, but it can be spoofed.  All such guesses are marked with thecomment <tt CLASS=literal>#???</tt>.  You should go through and check them.  You might wantto run at least once with Perl's <B>-w</B> switch, which warns you ifyou use <tt CLASS=literal>==</tt> where you should have used <B>eq</B>.<P CLASS=para>It would be possible to emulate <I CLASS=emphasis>awk</I>&nbsp;'s behavior in selecting stringversus numeric operations at run-time by inspection of the operands, butit would be gross and inefficient.  Besides, <I CLASS=emphasis>a2p</I> almost alwaysguesses right.<P CLASS=para>Perl does not attempt to emulate the behavior of <I CLASS=emphasis>awk</I> in whichnonexistent array elements spring into existence simply by beingreferenced.  If somehow you are relying on this mechanism to create nullentries for a subsequent <tt CLASS=literal>for</tt> . . . <tt CLASS=literal>in</tt>, they won't be there in Perl.<P CLASS=para>If <I CLASS=emphasis>a2p</I> makes a <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> command that assigns to a list of variablesthat looks like <tt CLASS=literal>($Fld1, $Fld2, $Fld3...)</tt> you may want to rerun <I CLASS=emphasis>a2p</I>using the <B>-n</B> option mentioned above.  This will let you name thefields throughout the script.  If it splits to an array instead, thescript is probably referring to the number of fields somewhere.<P CLASS=para>The "exit" statement in <I CLASS=emphasis>awk</I> doesn't necessarily exit; itgoes to the <tt CLASS=literal>END</tt> block if there is one.  <I CLASS=emphasis>awk</I> scripts thatdo contortions within the <tt CLASS=literal>END</tt> block to bypass the blockunder such circumstances can be simplified by removing theconditional in the <tt CLASS=literal>END</tt> block and just exiting directlyfrom the Perl script.<P CLASS=para>Perl has two kinds of arrays, numerically indexed and associative.<I CLASS=emphasis>awk</I> arrays are usually translated to associative arrays, but if youhappen to know that the index is always going to be numeric, you couldchange the <tt CLASS=literal>{ . . . }</tt> to <tt CLASS=literal>[ . . . ]</tt>.  Remember that iteration over anassociative array is done using the <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> function, but iteration overa numeric array isn't.  You might need to modify any loop that isiterating over the array in question.<P CLASS=para><I CLASS=emphasis>awk</I> starts by assuming OFMT has the value <tt CLASS=literal>%.6g</tt>.  Perl starts byassuming its equivalent, <B>$#</B>, to have the value <tt CLASS=literal>%.20g</tt>.  You'll want toset <B>$#</B> explicitly if you use the default value of OFMT.  (Actually,you probably don't want to set <B>$#</B>, but rather put in <A HREF="ch03_02.htm#PERL2-CMD-PRINTF">printf</A> formatseverywhere it matters.)<P CLASS=para>Near the top of the line loop will be the <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> operator that isimplicit in the <I CLASS=emphasis>awk</I> script.  There are times when you can move this operatordown past some conditionals that test the entire record, so that the<A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> is not done as often.<P CLASS=para>For aesthetic reasons you may wish to change the array base <B>$[</B> from <tt CLASS=literal>1</tt>back to Perl's default of <tt CLASS=literal>0</tt>, but remember to change all array subscriptsand all <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A> and <A HREF="ch03_02.htm#PERL2-CMD-INDEX">index</A> operations to match.<P CLASS=para>Cute comments that say:<DIV CLASS=programlisting><P><PRE># Here's a workaround because awk is so dumb.</PRE></DIV><P CLASS=para>are, of course, passed through unmodified.<P CLASS=para><I CLASS=emphasis>awk</I> scripts are often embedded in a shell script that pipes stuffinto and out of <I CLASS=emphasis>awk</I>.  Often the shell script wrapper can beincorporated into the Perl script, since Perl can start up pipes intoand out of itself, and can do other things that <I CLASS=emphasis>awk</I> can't do byitself.<P CLASS=para>Scripts that refer to the special variables <tt CLASS=literal>RSTART</tt> and <tt CLASS=literal>RLENGTH</tt> can oftenbe simplified by referring to the variables <B>$</B><tt CLASS=userinput>`</tt>, <B>$&amp;</B>, and <B>$</B><tt CLASS=userinput>'</tt>, aslong as they are within the scope of the pattern match that sets them.<P CLASS=para>The produced Perl script may have subroutines defined todeal with <I CLASS=emphasis>awk</I>&nbsp;'s semantics regarding "getline" and "print".Since <I CLASS=emphasis>a2p</I> usually picks correctness over efficiency, itis almost always possible to rewrite such code to be moreefficient by discarding the semantic sugar.<P CLASS=para><tt CLASS=literal>ARGV[0]</tt> translates to <B>$0</B>, but <tt CLASS=literal>ARGV[n]</tt> translates to<tt CLASS=literal>$ARGV[$n]</tt>.  A loop that tries to iterate over <tt CLASS=literal>ARGV[0]</tt> won't find it.<DIV CLASS=note><P CLASS=note><BLOCKQUOTE><P><B>NOTE:</B> <P CLASS=para>Storage for the <I CLASS=emphasis>awk</I> syntax tree is currently static, and can run out.You'll need to recompile <I CLASS=emphasis>a2p</I> if that happens.</blockquote><P></DIV></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.2.3">find2perl</A></h4><P CLASS=para>The <I CLASS=emphasis>find2perl</I> program is really easy to understand if you alreadyunderstand the UNIX <I CLASS=emphasis>find</I> (1) program.  Just type <I CLASS=emphasis>find2perl</I> insteadof <I CLASS=emphasis>find</I>, and give it the same arguments you would give to <I CLASS=emphasis>find</I>.  Itwill spit out an equivalent Perl script.<P CLASS=para>There are a couple of options you can use that your ordinary <I CLASS=emphasis>find</I> (1)command probably doesn't support:<P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>-tar</tt> <I CLASS=emphasis>tarfile</I><DD><P CLASS=para>Outputs a tar file much like the <tt CLASS=literal>-cpio</tt> switch of some versions of <I CLASS=emphasis>find</I>.<p><DT CLASS=varlistentry><tt CLASS=literal>-eval</tt> <I CLASS=emphasis>string</I><DD><P CLASS=para>Evaluates the string as a Perl expression, and continues if true.</DL></DIV><DIV CLASS=sect3><h4 CLASS=sect3><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.2.4">Source filters</A></h4><P CLASS=para>The notion of a source filter started with the idea that a script ormodule should be able to decrypt itself on the fly, like this:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perluse MyDecryptFilter;@*x$]`0uN&amp;k^Zx02jZ^X{.?s!(f;9Q/^A^@~~8H]|,%@^P:q-=...</PRE></DIV><P CLASS=para>But the idea grew from there, and now a source filter can be defined todo any transformation on the input text you like.  One can now even dothings like this:<DIV CLASS=programlisting><P><PRE>#!/usr/bin/perluse Filter::exec "a2p";1,30{print $1}</PRE></DIV><P CLASS=para>Put that together with the notion of the <B>-x</B> switch mentioned at thebeginning of this chapter, and you have a general mechanism for pullingany chunk of program out of an article and executing it, regardless ofwhether it's written in Perl or not.  Now that's cooperation.<P CLASS=para>The Filter module is available from CPAN.</DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.3">Translation to Other Languages</A></h3><P CLASS=para>Historically, the Perl interpreter has been rather self-contained.  WhenPerl was redesigned for Version 5, however, one of the requirements wasthat it be possible to write extension modules that could traverse theparsed syntax tree and emit code in other languages, either low-levelor high-level.  This has now come to pass.<P CLASS=para>More precisely, this is now coming to pass.  Malcolm Beattie has beendeveloping a "real compiler" for Perl.  As of this writing, it's inAlpha 2 state, which means it mostly works, except for the really hardbits.  The compiler consists of an ordinary Perl parser andinterpreter (since you need to be able to execute <tt CLASS=literal>BEGIN</tt> blocks tocompile Perl), plus a set of modules under the name of B, which is shortfor both "Backend" and "Beattie".  You don't actually invoke the Bmodule directly though.  Instead you invoke a particular backend via theO module, which pulls in the B module for you.  Typically you invoke theO module right on the command line with the <B>-M</B> switch, so acompilation command might look like this:<DIV CLASS=programlisting><P><PRE>perl -MO=C foo.pl &gt;foo.c</PRE></DIV><P CLASS=para>There are three backends at the moment.  The C backend rather woodenlyspits out C calls into the ordinary Perl interpreter, but it cantranslate almost anything except the most egregious abuses of thedynamic capabilities of the interpreter.  The Bytecode module is alsofairly complete, and spits out an external Perl bytecode representation,which can then be read back in and executed by a suitably clued versionof Perl.  Finally, the CC backend attempts to translate into moreidiomatic C with a lot of optimization.  Obviously, that's a bit harderto do than the other thing.  Nevertheless, it already works on a majority ofthe Perl regression tests.  It's possible with some care to get C codethat runs considerably faster than Perl 5's interpreter, which is noslouch to begin with.  And Malcolm hasn't put in all the optimizationshe wants to yet.<P CLASS=para>This is an ongoing topic of research, but you'll want to keep track ofit.  You are quite likely to be using this someday soon, if you aren'talready.  Look for it on CPAN of course, if it's not already a partof the standard Perl distribution by the time you read this.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.4">Embedding Perl in C and C++</A></h3><P CLASS=para>Another part of the design of Perl 5 was that it be possible to embed aPerl interpreter in a C or C++ program.  And in fact, the ordinary<I CLASS=emphasis>perl</I> executable pretends to have an embedded interpreter in it; the<tt CLASS=literal>main( )</tt> function essentially does this:<DIV CLASS=programlisting><P><PRE>PerlInterpreter *my_perl;int main(int argc, char **argv){    int exitstatus;    my_perl = perl_alloc();    perl_construct( my_perl );    exitstatus = perl_parse( my_perl, xs_init, argc, argv,                                          (char **) NULL );    if (exitstatus)        exit( exitstatus );    exitstatus = perl_run( my_perl );    perl_destruct( my_perl );    perl_free( my_perl );    exit(exitstatus);}</PRE></DIV><P CLASS=para>The important parts are the calls to <tt CLASS=literal>perl_parse()</tt> and <tt CLASS=literal>perl_run()</tt>, whichrespectively compile and run the program.  If you were embedding Perl inyour own program, you might replace the call to <tt CLASS=literal>perl_run()</tt> with calls to<tt CLASS=literal>perl_call_sv()</tt> function, which calls individual subroutines rather thanthe program as a whole.  Or you can do both, if the main script containsinitialization code as well as subroutine definitions.<P CLASS=para>There are many other useful entry points into the interpreter, such as<tt CLASS=literal>perl_eval_sv()</tt>, which evaluates a string, but this chapter is alreadygetting pretty long, and the fact of the matter is that there isextensive online documentation for the internals of Perl.  To include ithere would make this book even more unwieldy than it is, and most peoplewho would be embedding Perl aren't scared of online documentation.  Seethe <I CLASS=emphasis>perlembed</I> (3) manpage for more on embedding Perl interpreters in yourprogram.<P CLASS=para>A number of programs in the real world already have Perl embedded inthem--the authors know of several proprietary products shipping withembedded Perl interpreters.  There are also a couple of modules for the<I CLASS=emphasis>Apache</I> HTTP servers that use an embedded Perl interpreter to avoidprocess startup costs on CGI-like scripting.  And then there's the versionof Berkeley's <I CLASS=emphasis>nvi</I> editor with a Perl engine in it.  Watch out,<I CLASS=emphasis>emacs</I>, you've got company. <tt CLASS=literal>:-)</tt></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-6-SECT-4.5">Embedding C and C++ in Perl</A></h3><P CLASS=para>If a respectable number of programs embed a Perl interpreter, then averitable flood of extension modules embed C and C++ into Perl.  Again,the Perl distribution itself does this with many of its standardextension modules, including DB_File, DynaLoader, Fcntl, FileHandle,GDBM_File, NDBM_File, ODBM_File, POSIX, Safe, SDBM_File, and Socket.And many of the modules on CPAN do this.  So if you decide to do ityourself, you won't feel like you're researching a Ph.D. dissertation.<P CLASS=para>And again, we only have space to give you teasers for the onlinedocumentation, which is exhaustively extensive.  We recommend you startwith the <I CLASS=emphasis>perlxstut</I> (3) manpage, which is a tutorial on the XSlanguage, a preprocessor that spits out the glue routines you need to dothe "impedance matching" between Perl and C or C++.  You'll also beinterested in <I CLASS=emphasis>perlxs</I> (3), <I CLASS=emphasis>perlguts</I> (3), and <I CLASS=emphasis>perlcall</I> (3).<P CLASS=para>And once again, let us reiterate that your best resource is the Perlcommunity itself.  They invented a lot of this stuff, and are emotionallycommitted to making you like it, whether you like it or not.  You'd bettercooperate.</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch06_03.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch07_01.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Cooperating with Strangers</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>The Standard Perl Library</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>