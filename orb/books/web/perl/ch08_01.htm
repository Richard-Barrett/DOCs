<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 8] Other Oddments</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:19:32 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch07_02.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 8</b></td><td width=172 align=right valign=top><A HREF="ch08_02.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><H1 CLASS=chapter><A CLASS="TITLE" NAME="PERL2-CH-8">Other Oddments</A></H1><DIV CLASS=htmltoc><p><b>Contents:</b><br>The Perl Debugger<br><A HREF="ch08_02.htm">Common Goofs for Novices</A><BR><A HREF="ch08_03.htm">Efficiency</A><BR><A HREF="ch08_04.htm">Programming with Style</A><BR><A HREF="ch08_05.htm">Distribution and Installation</A><BR><A HREF="ch08_06.htm">Perl Poetry</A><BR><A HREF="ch08_07.htm">History Made Practical</A><BR></DIV><P CLASS=para>Did you ever have a junk drawer?  You know, one of those drawerswhere you put everything important enough to keep (like the spare keyto the back door), but not important enough to have a place of its own(like the back door itself).<P CLASS=para>Well, this chapter is the junk drawer of the book.  We stuffed manyimportant (and a few not-so-important) things in this chapter.  Read on.<DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1">8.1 The Perl Debugger</A></h2><P CLASS=para><A NAME="CH08.DEBUG1"></A><A NAME="CH08.DEBUG2"></A><A NAME="CH08.DEBUG3"></A>First of all, have you tried using the <B>-w</B> switch?<P CLASS=para>If you invoke Perl with the <B>-d</B> switch,your script runs under the Perl debugger.  This works like aninteractive Perl environment, prompting for debugger commands that letyou examine source code, set breakpoints, dump out your function-callstack, change the values of variables, and so on.  Any command notrecognized by the debugger[1] is directly executed(<A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A>'d) as Perl code in the currentpackage.[2] This is so wonderfullyconvenient that you often fire up the debugger all by itself just totest out Perl constructs interactively to see what they do.  Here's acommon way to get that:<blockquote class=footnote><P CLASS=para>[1]  Leading whitespace beforea command would cause the debugger to think it's<I CLASS=emphasis>not</I> a command for it, but rather for Perl, so becareful not to do that.  <P CLASS=para>[2]  The debugger uses the DB package for itsown state information.  </blockquote><DIV CLASS=programlisting><P><PRE>perl -d -e 42</PRE></DIV><P CLASS=para>In Perl, the debugger is not a separate program as it usually is in atypical programming environment.  Instead, the <B>-d</B> flag tells the compiler to insert sourceinformation into the parse trees it's about to hand off to theinterpreter.  That means your code must first compile correctly forthe debugger to work on it.  Then when the interpreter starts up, itpre-loads a Perl library file containing the debugger itself.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1.1">Debugger Commands</A></h3><P CLASS=para>The debugger understands the following commands:<P><DL CLASS=variablelist><DT CLASS=varlistentry><tt CLASS=literal>h</tt> [<tt CLASS=replaceable><i>command</i></tt> ]<DD><P CLASS=para>Prints out a help message.  <P CLASS=para>If you supply another debugger command as an argument to the <tt CLASS=literal>h</tt>command, it prints out the description for just that command.  The command "<tt CLASS=literal>h h</tt>" produces a more compact help listing designed tofit on one screen.  If the output of the <tt CLASS=literal>h</tt> command (or any command,for that matter) scrolls past your screen, just precede the command with aleading pipe symbol so it's run through your pager:<DIV CLASS=programlisting><P><PRE>DB&lt;1&gt; |h</PRE></DIV><p><DT CLASS=varlistentry><tt CLASS=literal>p</tt> <tt CLASS=replaceable><i>expr</i></tt><DD><P CLASS=para>Same as "<tt CLASS=literal>print DB::OUT</tt> <tt CLASS=replaceable><i>expr</i></tt>" in the current package.  In particular,since this is just Perl's own <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> function, this means that nesteddata structures and objects are not dumped, unlike with the <tt CLASS=literal>x</tt> command.The <tt CLASS=literal>DB::OUT</tt> handle is opened to <I CLASS=emphasis>/dev/tty</I> (or perhaps an editorwindow) no matter where standard output may have been redirected to.<p><DT CLASS=varlistentry><tt CLASS=literal>x</tt> <tt CLASS=replaceable><i>expr</i></tt><DD><P CLASS=para>Evals its expression in a list context and dumps out the result in a pretty-printed fashion.  Nested data structures are printed outrecursively, unlike with the print command above.<p><DT CLASS=varlistentry><tt CLASS=literal>V</tt> [<tt CLASS=replaceable><i>pkg</i></tt> [<tt CLASS=replaceable><i>vars</i></tt>]]<DD><P CLASS=para>Display all (or some) variables in package (defaulting to the mainpackage) using a data pretty-printer.  (Hashes show their keys and values soyou see what's what, control characters are made printable, nested datastructures print out in a legible fashion, and so on.)  Make sure you typethe identifiers without a type specifier such as <tt CLASS=literal>$</tt> or<tt CLASS=literal>@</tt>, like this:<DIV CLASS=programlisting><P><PRE>V DB filename line</PRE></DIV><P CLASS=para>In place of a variable name, you can use<tt CLASS=literal>~</tt><tt CLASS=replaceable><i>pattern</i></tt> or<tt CLASS=literal>!</tt><tt CLASS=replaceable><i>pattern</i></tt> to print existing variableswhose names either match or don't match the specified regularexpression.<p><DT CLASS=varlistentry><tt CLASS=literal>X</tt> [<tt CLASS=replaceable><i>vars</i></tt>]<DD><P CLASS=para>Same as <tt CLASS=literal>V</tt> <tt CLASS=replaceable><i>currentpackage</i></tt>[<tt CLASS=replaceable><i>vars</i></tt>].  <p><DT CLASS=varlistentry><tt CLASS=literal>T</tt>      <DD><P CLASS=para>Produce a stack backtrace.  See below for details on its output.<p><DT CLASS=varlistentry><tt CLASS=literal>s</tt> [<tt CLASS=replaceable><i>expr</i></tt>]<DD><P CLASS=para>Single step.  Executes until it reaches the beginning of anotherstatement, descending into subroutine calls.  If an expression issupplied that includes function calls, it, too, will be single-stepped.<p><DT CLASS=varlistentry><tt CLASS=literal>n</tt>      <DD><P CLASS=para>Next.  Executes over subroutine calls, until it reaches the beginningof the next statement at this same level.<p><DT CLASS=varlistentry><tt CLASS=literal>&lt;CR&gt;</tt><DD><P CLASS=para>Repeat last <tt CLASS=literal>n</tt> or <tt CLASS=literal>s</tt> command.<p><DT CLASS=varlistentry><tt CLASS=literal>c</tt> [<tt CLASS=replaceable><i>line</i></tt>]<DD><P CLASS=para>Continue, optionally inserting a one-time-only breakpointat the specified line.<p><DT CLASS=varlistentry><tt CLASS=literal>l</tt>      <DD><P CLASS=para>List next few lines.<p><DT CLASS=varlistentry><tt CLASS=literal>l</tt> <tt CLASS=replaceable><i>min+incr</i></tt><DD><P CLASS=para>List <tt CLASS=replaceable><i>incr</i></tt><tt CLASS=literal>+1</tt> lines starting at<tt CLASS=replaceable><i>min</i></tt>.<p><DT CLASS=varlistentry><tt CLASS=literal>l</tt> <tt CLASS=replaceable><i>min-max</i></tt><DD><P CLASS=para>List lines <tt CLASS=replaceable><i>min</i></tt> through <tt CLASS=replaceable><i>max</i></tt>.<p><DT CLASS=varlistentry><tt CLASS=literal>l</tt> <tt CLASS=replaceable><i>line</i></tt><DD><P CLASS=para>List a single line.<p><DT CLASS=varlistentry><tt CLASS=literal>l</tt> <tt CLASS=replaceable><i>subname</i></tt><DD><P CLASS=para>List first few lines from subroutine.<p><DT CLASS=varlistentry><tt CLASS=literal>-</tt>      <DD><P CLASS=para>List previous few lines.<p><DT CLASS=varlistentry><tt CLASS=literal>w</tt> [<tt CLASS=replaceable><i>line</i></tt>]<DD><P CLASS=para>List window (a few lines) around the given <tt CLASS=replaceable><i>line</i></tt>, orthe current one if no <tt CLASS=replaceable><i>line</i></tt> is supplied.<p><DT CLASS=varlistentry>.      <DD><P CLASS=para>Return debugger pointer to the last-executed line andprint it out.<p><DT CLASS=varlistentry><tt CLASS=literal>f</tt> <tt CLASS=replaceable><i>filename</i></tt><DD><P CLASS=para>Switch to viewing a different file.<p><DT CLASS=varlistentry>/<tt CLASS=replaceable><i>pattern</i></tt>/<DD><P CLASS=para>Search forward for <tt CLASS=replaceable><i>pattern</i></tt>; final / is optional.<p><DT CLASS=varlistentry>?<tt CLASS=replaceable><i>pattern</i></tt>?<DD><P CLASS=para>Search backward for <tt CLASS=replaceable><i>pattern</i></tt>; final ? is optional.<p><DT CLASS=varlistentry><tt CLASS=literal>L</tt>      <DD><P CLASS=para>List all breakpoints and actions for the current file.<p><DT CLASS=varlistentry><tt CLASS=literal>S</tt> [&nbsp;[&nbsp;!&nbsp;]&nbsp;<tt CLASS=replaceable><i>pattern</i></tt>]<DD><P CLASS=para>List subroutine names matching (or not matching with "!") <tt CLASS=replaceable><i>pattern</i></tt>.If no <tt CLASS=replaceable><i>pattern</i></tt> is given, all subroutines are listed.<p><DT CLASS=varlistentry><tt CLASS=literal>t</tt>      <DD><P CLASS=para>Toggle trace mode.<p><DT CLASS=varlistentry><tt CLASS=literal>t</tt> <tt CLASS=replaceable><i>expr</i></tt><DD><P CLASS=para>Trace through execution of <tt CLASS=replaceable><i>expr</i></tt>.  <p><DT CLASS=varlistentry><tt CLASS=literal>b</tt> [<tt CLASS=replaceable><i>line</i></tt>] [<tt CLASS=replaceable><i>condition</i></tt>]<DD><P CLASS=para>Set a breakpoint at <tt CLASS=replaceable><i>line</i></tt>.  If <tt CLASS=replaceable><i>line</i></tt> is omitted, set abreakpoint on the line that is about to be executed.  <tt CLASS=replaceable><i>condition</i></tt>,if given, is evaluated each time the statement is reached, and abreakpoint is taken only if <tt CLASS=replaceable><i>condition</i></tt> is true.  Breakpointsmay only be set on linesthat begin an executable statement.  Conditions don't use <B>if</B>:<DIV CLASS=programlisting><P><PRE>b 237 $x &gt; 30b 33 /pattern/i</PRE></DIV><P CLASS=para><p><DT CLASS=varlistentry><tt CLASS=literal>b</tt> <tt CLASS=replaceable><i>subname</i></tt> [<tt CLASS=replaceable><i>condition</i></tt>]<DD><P CLASS=para>Set a (possibly conditional) breakpoint at the first line of the namedsubroutine.<p><DT CLASS=varlistentry><tt CLASS=literal>d</tt> [<tt CLASS=replaceable><i>line</i></tt>]<DD><P CLASS=para>Delete a breakpoint at the specified <tt CLASS=replaceable><i>line</i></tt>.  If<tt CLASS=replaceable><i>line</i></tt> is omitted, deletes the breakpoint on the linethat is about to be executed.<p><DT CLASS=varlistentry><tt CLASS=literal>D</tt>      <DD><P CLASS=para>Delete all installed breakpoints.<DT CLASS=varlistentry><tt CLASS=literal>a</tt> [<tt CLASS=replaceable><i>line</i></tt>] <tt CLASS=replaceable><i>command</i></tt><DD><P CLASS=para>Set an action to be done before the <tt CLASS=replaceable><i>line</i></tt> isexecuted.  The sequence of steps taken by the debugger is:<P><UL CLASS=itemizedlist><li CLASS=listitem>Check for a breakpoint at this line.<P><li CLASS=listitem>Print the line if necessary (tracing).<P><li CLASS=listitem>Do any actions associated with that line.<P><li CLASS=listitem>Prompt the user if at a breakpoint or in single-step.<P><li CLASS=listitem>Evaluate the line.<P></UL><P CLASS=para>For example, this will print out <tt CLASS=literal>$foo</tt> every time line53 is passed:<DIV CLASS=programlisting><P><PRE>a 53 print "DB FOUND $foo\n"</PRE></DIV><P CLASS=para><p><DT CLASS=varlistentry><tt CLASS=literal>A</tt>      <DD><P CLASS=para>Delete all installed actions.<p><DT CLASS=varlistentry><tt CLASS=literal>O</tt><tt CLASS=literal> [</tt><tt CLASS=replaceable><i>opt</i></tt><tt CLASS=literal>[=</tt><tt CLASS=replaceable><i>val</i></tt><tt CLASS=literal>]]</tt><DD><P CLASS=para>Set or query values of options.  <tt CLASS=replaceable><i>val</i></tt> defaults to1.  <tt CLASS=replaceable><i>opt</i></tt> can be abbreviated to the shortest uniquestring, which is why some options are uppercase and others arelowercase.  Options are:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-8-TAB-1"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Option</TH><TH ALIGN="LEFT">Value</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>recallCommand ShellBang</tt></TD><TD ALIGN="LEFT"><P CLASS=para>The characters used to recall command or spawn shell.  Bydefault, these are both set to "!" (see below).</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>pager</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Program to use for output of pager-piped commands (thosebeginning with a <tt CLASS=literal>|</tt> character). By default,<tt CLASS=literal>$ENV{PAGER}</tt> will be used.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>PrintRet</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Enables printing of return value after <tt CLASS=literal>r</tt> command.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>frame</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Enables printing messages on entry and exit from subroutines.</TD></TR></TABLE><P></DIV><P CLASS=para>The following options affect what happens with <tt CLASS=literal>V</tt>,<tt CLASS=literal>X</tt>, and <tt CLASS=literal>x</tt> commands:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-8-TAB-2"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left">Option</TH><TH ALIGN="LEFT">Value</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>arrayDepth hashDepth</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Print only to depth <tt CLASS=replaceable><i>n</i></tt> (`` for all).</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>compactDump veryCompact</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Change style of array and hash dump.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>globPrint</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Whether to print contents of globs.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>DumpDBFiles</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Dump arrays holding debugged files.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>DumpPackages</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Dump symbol tables of packages.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>quote HighBit undefPrint</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Change style of string dump.</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>tkRunning</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Run Tk while prompting (with ReadLine).[1]</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>signalLevel warnLevel dieLevel</tt></TD><TD ALIGN="LEFT"><P CLASS=para>Level of verbosity.</TD></TR><tr><td colspan=2><p><b>Footnotes:</b><p><blockquote>[1] <P CLASS=para>A Perl application isusually frozen when sitting at the debugger prompt. Tksupport keeps the event loop of Tk running while reading the prompt.</blockquote></td></tr></TABLE><P></DIV><P CLASS=para>During startup, options are initialized from<tt CLASS=literal>$ENV{PERLDB_OPTS}</tt>.  You can put additionalinitialization options <tt CLASS=literal>TTY</tt>,<tt CLASS=literal>noTTY</tt>, <tt CLASS=literal>ReadLine</tt>, and<tt CLASS=literal>NonStop</tt> there.  Here's an example using the<tt CLASS=literal>$ENV{PERLDB_OPTS}</tt> variable:<DIV CLASS=programlisting><P><PRE>$ PERLDB_OPTS="N f=2" perl -d myprogram</PRE></DIV><P CLASS=para>This will run the script <tt CLASS=literal>myprogram</tt> without human intervention,printing out the call tree with entry and exit points.  Note that"<tt CLASS=literal>N f=2</tt>" is equivalent to"<tt CLASS=literal>NonStop=1 frame=2</tt>".<p><DT CLASS=varlistentry>&lt; <tt CLASS=replaceable><i>command</i></tt><DD><P CLASS=para>Set an action to happen before every debugger prompt.  A multi-line<tt CLASS=replaceable><i>command</i></tt> may be entered by backslashing the newlines.  <tt CLASS=replaceable><i>command</i></tt>should be Perl code.<p><DT CLASS=varlistentry>&gt; <tt CLASS=replaceable><i>command</i></tt><DD><P CLASS=para>Set an action to happen after the prompt when you've just given acommand to return to executing the script.  A multi-line <tt CLASS=replaceable><i>command</i></tt> may beentered by backslashing the newlines.  <tt CLASS=replaceable><i>command</i></tt> should be Perlcode.<p><DT CLASS=varlistentry>! <tt CLASS=replaceable><i>number</i></tt><DD><P CLASS=para>Redo a previous command (defaults to previous command).<p><DT CLASS=varlistentry>! -<tt CLASS=replaceable><i>number</i></tt><DD><P CLASS=para>Redo <tt CLASS=replaceable><i>number</i></tt>'th-to-last command.<p><DT CLASS=varlistentry>! <tt CLASS=replaceable><i>pattern</i></tt><DD><P CLASS=para>Redo last command that started with <tt CLASS=replaceable><i>pattern</i></tt>.See "<tt CLASS=literal>O recallCommand</tt>", too.<p><DT CLASS=varlistentry>!! <tt CLASS=replaceable><i>cmd</i></tt><DD><P CLASS=para>Run <tt CLASS=replaceable><i>cmd</i></tt> in a subprocess (which will read from<tt CLASS=literal>DB::IN</tt>, write to <tt CLASS=literal>DB::OUT</tt>).See "<tt CLASS=literal>O shellBang</tt>", too.<p><DT CLASS=varlistentry><tt CLASS=literal>H -</tt><tt CLASS=replaceable><i>number</i></tt><DD><P CLASS=para>Display last <tt CLASS=replaceable><i>number</i></tt> commands.  Only commands longerthan one character are listed.  If <tt CLASS=replaceable><i>number</i></tt> is omitted,lists them all.<p><DT CLASS=varlistentry><tt CLASS=literal>q</tt> or <tt CLASS=literal>^D</tt><DD><P CLASS=para>Quit.  ("<tt CLASS=literal>quit</tt>" doesn't quite work for this.)<p><DT CLASS=varlistentry><tt CLASS=literal>R</tt>      <DD><P CLASS=para>Restart the debugger by <A HREF="ch03_02.htm#PERL2-CMD-EXEC">exec</A>ing a new session.  It tries to maintainyour history across this, but internal settings and command line optionsmay be lost.<p><DT CLASS=varlistentry>|<tt CLASS=replaceable><i>dbcmd</i></tt><DD><P CLASS=para>Run debugger command, piping <tt CLASS=literal>DB::OUT</tt> to <tt CLASS=literal>$ENV{PAGER}</tt>.<p><DT CLASS=varlistentry>||<tt CLASS=replaceable><i>dbcmd</i></tt><DD><P CLASS=para>Same as |<tt CLASS=replaceable><i>dbcmd</i></tt> but <tt CLASS=literal>DB::OUT</tt>is temporarily <B>select</B>ed as well.Often used with commands that would otherwise produce longoutput, such as<DIV CLASS=programlisting><P><PRE>|V main</PRE></DIV><P CLASS=para><p><DT CLASS=varlistentry><tt CLASS=literal>= [</tt><tt CLASS=replaceable><i>alias value</i></tt><tt CLASS=literal>]</tt><DD><P CLASS=para>Define a command alias, or list current aliases.<p><DT CLASS=varlistentry><tt CLASS=replaceable><i>command</i></tt><DD><P CLASS=para>Execute <tt CLASS=replaceable><i>command</i></tt> as a Perl statement.  A semicolon isnot needed at the end.</DL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1.2">Using the Debugger</A></h3><P CLASS=para>If you have any compile-time executable statements (code within a<tt CLASS=literal>BEGIN</tt> block or a <tt CLASS=literal>use</tt> statement),they will not be stopped by the debugger,although <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A>s will.<P CLASS=para>The debugger prompt is something like:<DIV CLASS=programlisting><P><PRE>DB&lt;8&gt;</PRE></DIV><P CLASS=para>or even:<DIV CLASS=programlisting><P><PRE>DB&lt;&lt;17&gt;&gt;</PRE></DIV><P CLASS=para>where that number is the command number.  A <I CLASS=emphasis>csh</I>-like historymechanism allows you to access previous commands by number.  For example,<tt CLASS=literal>!17</tt> would repeatcommand number 17.  The number of angle brackets indicates the depth ofthe debugger.  You get more than one set of brackets, for example, ifyou're already at a breakpoint and then print out the result of afunction call that itself also has a breakpoint.<P CLASS=para>If you want to enter a multi-line command, such as a subroutinedefinition with several statements, you may escape the newline that wouldnormally end the debugger command with a backslash.  Here's an example:<DIV CLASS=programlisting><P><PRE>DB&lt;1&gt; <B>for (1..4) {         \</B>  cont:     <B>print "ok\n";    \</B>  cont: <B>}</B>  ok  ok  ok  ok</PRE></DIV><P CLASS=para>Note that this business of escaping a newline is specific to interactivecommands typed into the debugger.<P CLASS=para>Let's say you want to fire up the debugger on a little program of yours (let's call it <I CLASS=emphasis>camel_flea</I>), and stop it as soon as it gets down to a function named <tt CLASS=literal>infested</tt>.  Here's howyou'd do that:<DIV CLASS=programlisting><P><PRE><tt CLASS=replaceable><i>shell_prompt%</i></tt> <B>perl -d camel_flea</B>Stack dump during die enabled outside of evals.Loading DB routines from perl5db.pl patch level 0.94Emacs support available.Enter h or `h h' for help.main::(camel_flea:3):   $a = 1;  DB&lt;1&gt;</PRE></DIV><P CLASS=para>The debugger halts your program right before the first run-timeexecutable statement (but see above regarding compile-time statements) andasks you to enter a command.  Contrary to popular expectations,whenever the debugger stops to show you a line of code, it displays the line it's <I CLASS=emphasis>about</I> to execute, not the one itjust executed.<P CLASS=para>Now, you'd like to stop as soon as your program gets to the<tt CLASS=literal>infested</tt> function, so you enter a breakpoint there like so:<DIV CLASS=programlisting><P><PRE>DB&lt;1&gt; <B>b infested</B>DB&lt;2&gt; <B>c</B></PRE></DIV><P CLASS=para>The debugger now continues until it hits that function, at which pointit does this:<DIV CLASS=programlisting><P><PRE>main::infested(camel_flea:12):      my bugs;</PRE></DIV><P CLASS=para>It might be nice to look at a window of source code around thebreakpoint, so you use the <tt CLASS=literal>w</tt> command:<DIV CLASS=programlisting><P><PRE>DB&lt;2&gt; <B>w</B>9:      } 10:11:     sub infested {12==&gt;b      my $bugs;13:         return 3.5;14:     } DB&lt;2&gt;</PRE></DIV><P CLASS=para>As you see, your current line is line 12, and it has a breakpointon it.<P CLASS=para>Now, you'd like to see who called whom, so you ask for a stack backtrace:<DIV CLASS=programlisting><P><PRE>DB&lt;2&gt; <B>T</B>$ = main::infested called from file `Ambulation.pm' line 10@ = Ambulation::legs(1, 2, 3, 4) called from file `camel_flea' line 7$ = main::pests('bactrian', 4) called from file `camel_flea' line 4</PRE></DIV><P CLASS=para>The left-hand character up there (<tt CLASS=literal>$</tt> or <tt CLASS=literal>@</tt>)tells whether the function was called in a scalar or list context (we bet youcan tell which is which).  There are three lines because you were threefunctions deep when you ran the stack backtrace.  Here's what each line means:<P><UL CLASS=itemizedlist><li CLASS=listitem>Line number one says you were in the function <tt CLASS=literal>main::infested</tt> whenyou ran the stack dump.  It tells you the function was called in a scalarcontext from line 10 of the file <I CLASS=emphasis>Ambulation.pm</I>.  It also shows thatit was called without any arguments whatsoever, meaning it was called as<tt CLASS=literal>&amp;infested</tt>.<P><li CLASS=listitem>Line number two shows that the function <tt CLASS=literal>Ambulation::legs</tt> wascalled in a list context from the <I CLASS=emphasis>camel_flea</I> file with fourarguments.<P><li CLASS=listitem>Line number three shows that <tt CLASS=literal>main::pests</tt> was called in a scalarcontext, also from <I CLASS=emphasis>camel_flea</I>, but from line 4.<P></UL><P CLASS=para>Limited control over the Perl debugger can also be managed from within your Perlscript itself.  You might do this, for example, to set an automatic breakpointat a certain subroutine whenever a particular program is run under the debugger.Setting <tt CLASS=literal>$DB::single</tt> to 1 will stop at the next statement asthough you'd used the debugger's <tt CLASS=literal>s</tt> command.  If you set<tt CLASS=literal>$DB::single</tt> to 2, it's equivalent to having just typed the<tt CLASS=literal>n</tt> command.  The <tt CLASS=literal>$DB::trace</tt> variable can beset to 1 to simulate having typed the <tt CLASS=literal>t</tt> command.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1.3">Debugger Customization</A></h3><P CLASS=para>To modify the debugger, copy <I CLASS=emphasis>perl5db.pl</I> from the Perllibrary to another file and modify it as necessary.  You'll also wantto set your <tt CLASS=literal>PERL5DB</tt> environment variable to say something like this:<DIV CLASS=programlisting><P><PRE>BEGIN { require "myperl5db.pl" }</PRE></DIV><P CLASS=para>You can do some customization by setting up a <I CLASS=emphasis>.perldb</I> file withinitialization code.  For instance, you could make aliaseslike these (the last one is one people expect to be there):<DIV CLASS=programlisting><P><PRE>$DB::alias{'len'}  = 's/^len(.*)/p length($1)/';$DB::alias{'stop'} = 's/^stop (at|in)/b/';$DB::alias{'ps'}   = 's/^ps\b/p scalar /';$DB::alias{'quit'} = 's/^quit\b.*/exit/';</PRE></DIV></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1.4">Readline Support</A></h3><P CLASS=para>As shipped, the only command-line history mechanism supplied is a simplistic onethat checks for leading exclamation points.  This is fine for casual use.However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN,you will have full editing capabilities much like GNU<I CLASS=emphasis>readline</I> (3) provides.  Look for these in the<I CLASS=emphasis>modules/by-module/Term</I> directory on CPAN.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1.5">Editor Support for Debugging</A></h3><P CLASS=para>If you have GNU <I CLASS=emphasis>emacs</I> installed on your system, it caninteract with the Perl debugger to provide an integrated software developmentenvironment reminiscent of its interactions with C debuggers.<P CLASS=para>Perl is also delivered with a start file for making <I CLASS=emphasis>emacs</I>act like a syntax-directed editor that understands (some of) Perl's syntax.Look in the <I CLASS=emphasis>emacs/</I> directory of the Perl sourcedistribution.<P CLASS=para>(Historically, a similar setup for interacting with <I CLASS=emphasis>vi</I> and theX11 window system had also been available, but at the time of thiswriting, no debugger support for <I CLASS=emphasis>vi</I> currently exists.)  </DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1.6">Debugger Internals</A></h3><P CLASS=para>When you call the <A HREF="ch03_02.htm#PERL2-CMD-CALLER">caller</A> function frompackage DB, Perl sets the <tt CLASS=literal>@DB::args</tt> array to the argumentsthat stack frame was called with.  It also maintains other magical internalvariables, such as <tt CLASS=literal>@DB::dbline</tt>, an array of the source codelines for the currently selected (with the debugger's <tt CLASS=literal>f</tt>command) file.  Perl effectively inserts a call to the function<tt CLASS=literal>DB::DB</tt>(<tt CLASS=replaceable><i>linenum</i></tt>) in front of everyplace that can have a breakpoint. Instead of a subroutine call it calls<tt CLASS=literal>DB::sub</tt>, setting <tt CLASS=literal>$DB::sub</tt> to the name ofthe called subroutine. It also inserts a <tt CLASS=literal>BEGIN {require'perl5db.pl'}</tt> before the first line, since no subroutine call ispossible until <tt CLASS=literal>&amp;DB::sub</tt> is defined (for subroutinesdefined outside this file).  In fact, the same is true if<tt CLASS=literal>$DB::deep</tt> (how many levels of recursion deep into thedebugger you are) is not defined.<P CLASS=para>At the start, the debugger reads your config file(<I CLASS=emphasis>.&nbsp;/.perldb</I> or <I CLASS=emphasis>~/.perldb</I> underUNIX), which can set important options.  This file may define a subroutine<tt CLASS=literal>&amp;afterinit</tt> to be executed after the debugger isinitialized.<P CLASS=para>After the config file is processed, the debugger consults the environment variablePERLDB_OPTS and parses it as arguments to the <tt CLASS=literal>O</tt><tt CLASS=replaceable><i>opt=val</i></tt> debugger command.<P CLASS=para>The following options can only be specified at startup.  To set them in yourconfig file, call <tt CLASS=literal>&amp;parse_options(`</tt><tt CLASS=replaceable><i>opt</i></tt><tt CLASS=literal>=</tt><tt CLASS=replaceable><i>val</i></tt><tt CLASS=literal>`)</tt>.<P><DL CLASS=variablelist><DT CLASS=varlistentry>TTY<DD><P CLASS=para>The TTY to use for debugging I/O.<p><DT CLASS=varlistentry>noTTY<DD><P CLASS=para>If set, goes in <tt CLASS=literal>NonStop</tt> mode.  On an interrupt, if TTY isnot set, it uses the value of <tt CLASS=literal>noTTY</tt> or <I CLASS=emphasis>/tmp/perldbtty$$</I> to findTTY using <tt CLASS=literal>Term::Rendezvous</tt>.  The current variant is to have thename of TTY in this file.<p><DT CLASS=varlistentry>ReadLine<DD><P CLASS=para>If false, a dummy ReadLine is used so that you can debugReadLine applications.<p><DT CLASS=varlistentry>NonStop<DD><P CLASS=para>If true, no interaction is performed until an interrupt.<p><DT CLASS=varlistentry>LineInfo<DD><P CLASS=para>File or pipe to print line number info to.  If it's apipe, then a short, <I CLASS=emphasis>emacs</I>-like message is used.Example config file:<DIV CLASS=programlisting><P><PRE>&amp;parse_options("NonStop=1 LineInfo=db.out");sub afterinit { $trace = 1; }</PRE></DIV><P CLASS=para>The script will run without human intervention, putting trace informationinto the file <I CLASS=emphasis>db.out</I>.  (If you interrupt it, you had better reset<tt CLASS=literal>LineInfo</tt> to something "interactive"!)</DL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1.7">Debugger Bugs</A></h3><P CLASS=para>If your program <A HREF="ch03_02.htm#PERL2-CMD-EXIT">exit</A>s or <A HREF="ch03_02.htm#PERL2-CMD-DIE">die</A>s, so too does the debugger.<P CLASS=para>You cannot get the stack frame information or otherwise debug functionsthat were not compiled by Perl, such as C or C++ extensions.<P CLASS=para>If you alter your <B>@_</B> arguments in asubroutine (such as with <A HREF="ch03_02.htm#PERL2-CMD-SHIFT">shift</A> or<A HREF="ch03_02.htm#PERL2-CMD-POP">pop</A>), the stack backtrace will not showthe original values.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1.8">Alternative Debuggers: The Perl Profiler</A></h3><P CLASS=para>If you wish to supply an alternative debugger for Perl to run, just invokeyour script with the <tt CLASS=literal>-d:</tt><I CLASS=emphasis>module</I> switch.One of the most popular alternative debuggers for Perl isDProf, the Perl profiler.   As of this writing, DProf was notincluded with the standard Perl distribution, but it is expected to beincluded "real soon now."<P CLASS=para>Meanwhile, you can fetch the Devel::DProf module from CPAN.  Assumingit's properly installed on your system, you can use it to profile thePerl program in <I CLASS=emphasis>mycode.pl</I> by typing:<DIV CLASS=programlisting><P><PRE>perl -d:DProf mycode.pl</PRE></DIV><P CLASS=para>When the script terminates, the profiler will dump the profileinformation to a file called <I CLASS=emphasis>tmon.out</I>.  A toollike <I CLASS=emphasis>dprofpp</I> (also supplied with the Devel::DProfpackage) interprets the profile.</DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-1.9">Other Debugging Resources</A></h3><P CLASS=para>You did try the <B>-w</B> switch, didn't you?</DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch07_02.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch08_02.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>DBM comparisons</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Common Goofs for Novices</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>