<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 8] 8.2 Common Goofs for Novices</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:19:55 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch08_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 8</b></td><td width=172 align=right valign=top><A HREF="ch08_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-2">8.2 Common Goofs for Novices</A></h2><P CLASS=para><A NAME="CH08.TROUBLE1"></A><A NAME="CH08.TROUBLE2"></A>The biggest goof of all is forgetting to use the <B>-w</B> switch, which points out many errors.  The secondbiggest goof is not using <tt CLASS=literal>use strict</tt> when it's appropriate.<P CLASS=para>Apart from those, there are certain traps that almost everyone falls into, andother traps you'll fall into only if you come from a particular culture.  We'veseparated these out in the following sections.<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-2.1">Universal Blunders</A></h3><UL CLASS=itemizedlist><li CLASS=listitem>Putting a comma after the filehandle in a <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> statement.Although it looks extremely regular and pretty to say:<DIV CLASS=programlisting><P><PRE>print STDOUT, "goodbye", $adj, "world!\n";    # WRONG</PRE></DIV><P CLASS=para>this is nonetheless incorrect, because of that first comma.  What youwant instead is:<DIV CLASS=programlisting><P><PRE>print STDOUT "goodbye", $adj, "world!\n";     # ok</PRE></DIV><P CLASS=para>The syntax is this way so that you can say:<DIV CLASS=programlisting><P><PRE>print $filehandle "goodbye", $adj, "world!\n";</PRE></DIV><P CLASS=para>where <tt CLASS=literal>$filehandle</tt> is a scalar holding the name of a filehandle atrun-time.  This is distinct from:<DIV CLASS=programlisting><P><PRE>print $notafilehandle, "goodbye", $adj, "world!\n";</PRE></DIV><P CLASS=para>where <tt CLASS=literal>$notafilehandle</tt> is simply a string that is added to the listof things to be printed.  See Indirect Object in the glossary.<P><li CLASS=listitem>Using <tt CLASS=literal>==</tt> instead of <B>eq</B> and <tt CLASS=literal>!=</tt> instead of <B>ne</B>.  The <tt CLASS=literal>==</tt> and<tt CLASS=literal>!=</tt> operators are<I CLASS=emphasis>numeric</I> tests.  The other two are<I CLASS=emphasis>string</I> tests.  The strings<tt CLASS=literal>"123"</tt> and <tt CLASS=literal>"123.00"</tt> areequal as numbers, but not equal as strings.  Also, any non-numericstring is numerically equal to zero.  Unless you are dealing withnumbers, you almost always want the string comparison operatorsinstead.<P><li CLASS=listitem> Forgetting the trailing semicolon. Every statement inPerl is terminated by a semicolon or the end of a block.  Newlinesaren't statement terminators as they are in <I CLASS=emphasis>awk</I>or Python.  <P><li CLASS=listitem>Forgetting that a <tt CLASS=replaceable><i>BLOCK</i></tt> requires braces.  Nakedstatements are not <tt CLASS=replaceable><i>BLOCK</i></tt>s.  If you are creating acontrol structure such as a <B>while</B> or an<B>if</B> that requires one or more<tt CLASS=replaceable><i>BLOCK</i></tt>s, you <I CLASS=emphasis>must</I> use bracesaround each <tt CLASS=replaceable><i>BLOCK</i></tt>.<P><li CLASS=listitem>Not saving <B>$1</B>, <B>$2</B>, and so on, across regular expressions.Remember that every new <tt CLASS=literal>m/atch/</tt> or<tt CLASS=literal>s/ubsti/tute/</tt> will set (or clear, or mangle) your<B>$1</B>, <B>$2</B> . . .  variables, as well as <B>$</B><tt CLASS=literal>`</tt>, <B>$</B><tt CLASS=literal>'</tt>, and<B>$&amp;</B>.  One way to save them rightaway is to evaluate the match within a list context, as in:<DIV CLASS=programlisting><P><PRE>($one,$two) = /(\w+) (\w+)/;</PRE></DIV><P><li CLASS=listitem>Not realizing that a <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> also changesthe variable's value within other subroutines called within the scopeof the local.  It's easy to forget that <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> is a run-time statement that does dynamicscoping, because there's no equivalent in languages like C.  See<A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> in <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A>.Usually you wanted a <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> anyway.<P><li CLASS=listitem>Losing track of brace pairings.A good text editor will help you find the pairs.  Get one.<P><li CLASS=listitem>Using loop control statements in <tt CLASS=literal>do {} while</tt>.Although the braces in this control structure look suspiciouslylike part of a loop <tt CLASS=replaceable><i>BLOCK</i></tt>, they aren't.<P><li CLASS=listitem>Saying <tt CLASS=literal>@foo[1]</tt> when you mean <tt CLASS=literal>$foo[1]</tt>.The <tt CLASS=literal>@foo[1]</tt> reference is an array <I CLASS=emphasis>slice</I>, and means anarray consisting of the single element <tt CLASS=literal>$foo[1]</tt>.Sometimes, this doesn't make any difference, as in:<DIV CLASS=programlisting><P><PRE>print "the answer is @foo[1]\n";</PRE></DIV><P CLASS=para>but it makes a big difference for things like:<DIV CLASS=programlisting><P><PRE>@foo[1] = &lt;STDIN&gt;;</PRE></DIV><P CLASS=para>which will slurp up all the rest of <tt CLASS=literal>STDIN</tt>,assign the <I CLASS=emphasis>first</I> line to<tt CLASS=literal>$foo[1]</tt>, and discard everything else. This is probably not what youintended.  Get into the habit of thinking that <tt CLASS=literal>$</tt> means a singlevalue, while <tt CLASS=literal>@</tt> means a list of values, and you'll do okay.<P><li CLASS=listitem>Forgetting to select the right filehandle before setting <B>$^</B>, <B>$~</B>, or<B>$|</B>.  These variables depend on thecurrently selected filehandle, as determined by<tt CLASS=literal>select</tt>(<tt CLASS=replaceable><i>FILEHANDLE</i></tt>).The initial filehandle so selected is <tt CLASS=literal>STDOUT</tt>.  Youshould really be using the filehandle methods from the FileHandlemodule instead.  See <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-2.2">Frequently Ignored Advice</A></h3><P CLASS=para>Practicing Perl Programmers should take note of the following:<P><UL CLASS=itemizedlist><li CLASS=listitem>Remember that many operations behave differently in a list contextthan they do in a scalar one.  <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A> has all the details.<P><li CLASS=listitem>Avoid barewords if you can, especially all lowercase ones.You can't tell just by looking at it whether a word is a function or a bareword string.  By using quotes on strings and parentheses around function call arguments, you won't ever get them confused.In fact, the pragma <tt CLASS=literal>use strict</tt> at the beginning of your programmakes barewords a compile-time error--probably a good thing.<P><li CLASS=listitem>You can't tell just by looking which built-in functions are unaryoperators (like <A HREF="ch03_02.htm#PERL2-CMD-CHOP">chop</A> and <A HREF="ch03_02.htm#PERL2-CMD-CHDIR">chdir</A>), which are list operators (like <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> and <A HREF="ch03_02.htm#PERL2-CMD-UNLINK">unlink</A>),and which are argumentless (like <A HREF="ch03_02.htm#PERL2-CMD-TIME">time</A>).You'll want to learn them from <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.  Note alsothat user-defined subroutines are by default list operators, but canbe declared as unary operators with a prototype of <tt CLASS=literal>($)</tt>.<P><li CLASS=listitem>People have a hard time remembering that some functions default to<B>$_</B>, or <B>@ARGV</B>, or whatever, while others do not.  Takethe time to learn which are which, or avoid default arguments.<P><li CLASS=listitem><tt CLASS=literal>&lt;</tt><tt CLASS=replaceable><i>FH</i></tt><tt CLASS=literal>&gt;</tt> is not thename of a filehandle, but an angle operator that does a line-inputoperation on the handle.  This confusion usually manifests itself whenpeople try to <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> to the angleoperator:<DIV CLASS=programlisting><P><PRE>print &lt;FH&gt; "hi";    # WRONG, omit angles</PRE></DIV><P CLASS=para><P><li CLASS=listitem>Remember also that data read by the angle operator is assigned to<B>$_</B> only when the file read is the solecondition in a <B>while</B> loop:<DIV CLASS=programlisting><P><PRE>while (&lt;FH&gt;)      { }while ($_ = &lt;FH&gt;) { }..&lt;FH&gt;;  # data discarded!</PRE></DIV><P CLASS=para><P><li CLASS=listitem>Remember not to use <tt CLASS=literal>=</tt> when you need <tt CLASS=literal>=~</tt>;the two constructs are quite different:<DIV CLASS=programlisting><P><PRE>$x =  /foo/;  # searches $_, puts result in $x$x =~ /foo/;  # searches $x, discards result</PRE></DIV><P CLASS=para><P><li CLASS=listitem>Use <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> for local variables whenever you can get away with it (but see "Formats" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A> for where you can't).  Using <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> actually gives a local value to a global variable, which leaves you open to unforeseen side effectsof dynamic scoping.<P><li CLASS=listitem>Don't localize a module's exported variables.  If you localize anexported variable, its exported value will not change.  The local namebecomes an alias to a new value but the external name is still an aliasfor the original.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-2.3">Awk Traps</A></h3><P CLASS=para>Accustomed <I CLASS=emphasis>awk</I> users should take special note of the following:<P><UL CLASS=itemizedlist><li CLASS=listitem>The English module, loaded via<DIV CLASS=programlisting><P><PRE>use English;</PRE></DIV><P CLASS=para>allows you to refer to special variables (like <tt CLASS=literal>$RS</tt>) using their <I CLASS=emphasis>awk</I> names; see the end of <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A> for details.<P><li CLASS=listitem>Semicolons are required after all simple statements in Perl (exceptat the end of a block).  Newline is not a statement delimiter.<P><li CLASS=listitem>Curlies are required on <B>if</B> and <B>while</B> blocks.<P><li CLASS=listitem>Variables begin with <tt CLASS=literal>$</tt> or <tt CLASS=literal>@</tt> in Perl.<P><li CLASS=listitem>Arrays index from <tt CLASS=literal>0</tt>, as do string positions in <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A> and<A HREF="ch03_02.htm#PERL2-CMD-INDEX">index</A>.<P><li CLASS=listitem>You have to decide whether your array has numeric or string indices.<P><li CLASS=listitem>You have to decide whether you want numeric or string comparisons.<P><li CLASS=listitem>Hash values do not spring into existence upon reference.<P><li CLASS=listitem>Reading an input line does not split it for you.  You get to split ityourself to an array.  And the <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> operator has differentarguments than you might guess.<P><li CLASS=listitem>The current input line is normally in <B>$_</B>, not <B>$0</B>.  Itgenerally does not have the newline stripped.  (<B>$0</B> is the name of the program executed.)  See<A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.<P><li CLASS=listitem> <B>$1</B>, <B>$2</B>, and so on, do not refer to fields--theyrefer to substrings matched by the last pattern match.<P><li CLASS=listitem> The <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> operatordoes not add field and record separators unless you set <B>$,</B> and <B>$\</B>.(<tt CLASS=literal>$OFS</tt> and <tt CLASS=literal>$ORS</tt> if you're usingEnglish.)  <P><li CLASS=listitem> You must <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> yourfiles before you <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> to them.<P><li CLASS=listitem>The range operator is <tt CLASS=literal>..</tt> rather than comma.  The comma operator works (more or less) as in does C.<P><li CLASS=listitem> The match binding operator is<tt CLASS=literal>=~</tt>, not <tt CLASS=literal>~</tt>.(<tt CLASS=literal>~</tt> is the 1's complement operator, as in C.)<P><li CLASS=listitem> The exponentiation operator is<tt CLASS=literal>**</tt>, not <tt CLASS=literal>^</tt>.<tt CLASS=literal>^</tt> is the bitwise XOR operator, as in C.  (Youknow, one could get the feeling that <I CLASS=emphasis>awk</I> isbasically incompatible with C.)  <P><li CLASS=listitem> The concatenation operator is dot(<tt CLASS=literal>.</tt>), not "nothing".  (Using "nothing" as anoperator would render <tt CLASS=literal>/pat/ /pat/</tt> unparsable, sincethe third slash would be interpreted as a division operator--thetokener is in fact slightly context sensitive for operators like<tt CLASS=literal>/</tt>, <tt CLASS=literal>?</tt>, and<tt CLASS=literal>&lt;</tt>.  And, in fact, a dot itself can be thebeginning of a number.)  <P><li CLASS=listitem>The <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A>, <A HREF="ch03_02.htm#PERL2-CMD-EXIT">exit</A>, and <B>continue</B>keywords work differently.  <P><li CLASS=listitem>The following variables work differently:<DIV CLASS=informaltable><P><A NAME="PERL2-CH-8-TAB-3"></A><TABLE CLASS=INFORMALTABLE><TR CLASS=row><TH ALIGN="left"><I CLASS=emphasis>awk</I></TH><TH ALIGN="left">Perl</TH></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>ARGC</tt></TD><TD ALIGN="left"><P CLASS=para><tt CLASS=literal>$#ARGV</tt> or scalar <tt CLASS=literal>@ARGV</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>ARGV[0]</tt></TD><TD ALIGN="left"><tt CLASS=literal>$0</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>FILENAME</tt></TD><TD ALIGN="left"><tt CLASS=literal>$ARGV</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>FNR</tt></TD><TD ALIGN="left"><tt CLASS=literal>$.</tt> - something</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>FS</tt></TD><TD ALIGN="left">(whatever you like)</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>NF</tt></TD><TD ALIGN="left"><tt CLASS=literal>$#Fld</tt>, or some such</TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>NR</tt></TD><TD ALIGN="left"><tt CLASS=literal>$.</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>OFMT</tt></TD><TD ALIGN="left"><tt CLASS=literal>$#</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>OFS</tt></TD><TD ALIGN="left"><tt CLASS=literal>$,</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>ORS</tt></TD><TD ALIGN="left"><tt CLASS=literal>$\</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>RLENGTH</tt></TD><TD ALIGN="left"><tt CLASS=literal>length($&amp;)</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>RS</tt></TD><TD ALIGN="left"><tt CLASS=literal>$/</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>RSTART</tt></TD><TD ALIGN="left"><tt CLASS=literal>length($`)</tt></TD></TR><TR CLASS=row><TD ALIGN="left"><tt CLASS=literal>SUBSEP</tt></TD><TD ALIGN="left"><tt CLASS=literal>$;</tt></TD></TR></TABLE><P></DIV><P><li CLASS=listitem>You cannot set <tt CLASS=literal>$RS</tt> to a pattern, only a string.<P><li CLASS=listitem>When in doubt, run the <I CLASS=emphasis>awk</I> construct through <I CLASS=emphasis>a2p</I> and see what itgives you.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-2.4">C Traps</A></h3><P CLASS=para>Cerebral C programmers should take note of the following:<P><UL CLASS=itemizedlist><li CLASS=listitem>Curlies are required for <B>if</B> and <B>while</B> blocks.<P><li CLASS=listitem>You must use <B>elsif</B> rather than "else if" or "elif".  Syntax like:<DIV CLASS=programlisting><P><PRE>if (expression) {    block;}else if (another_expression) {    another_block;}</PRE></DIV><P CLASS=para>is illegal.  The <B>else</B> part is always ablock, and a naked <B>if</B> is not a block.You mustn't expect Perl to be exactly the same as C.  What you wantinstead is:<DIV CLASS=programlisting><P><PRE>if (expression) {    block;}elsif (another_expression) {    another_block;}</PRE></DIV><P CLASS=para>Note also that "elif" is "file" spelled backward.  OnlyAlgol-ers would want a keyword that was the same as another word spelledbackward.<P><li CLASS=listitem>The <tt CLASS=literal>break</tt> and <tt CLASS=literal>continue</tt> keywords from C become in Perl <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A> and <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A>, respectively.Unlike in C, these do <I CLASS=emphasis>not</I> work within a <tt CLASS=literal>do { } while</tt> construct.<P><li CLASS=listitem>There's no switch statement.  (But it's easy to build one on the fly; see "Bare Blocks and Case Structures" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A>.)<P><li CLASS=listitem>Variables begin with <tt CLASS=literal>$</tt>, <tt CLASS=literal>@</tt>, or <tt CLASS=literal>%</tt> in Perl.<P><li CLASS=listitem><A HREF="ch03_02.htm#PERL2-CMD-PRINTF">printf</A> does not implement the<tt CLASS=literal>*</tt> format for interpolating field widths, but it'strivial to use interpolation of double-quoted strings to achieve thesame effect.  <P><li CLASS=listitem>Comments begin with <tt CLASS=literal>#</tt>, not <tt CLASS=literal>/*</tt>.<P><li CLASS=listitem>You can't take the address of anything, although a similar operatorin Perl is the backslash, which creates a reference.<P><li CLASS=listitem><tt CLASS=literal>ARGV</tt> must be capitalized.<tt CLASS=literal>$ARGV[0]</tt> is C's <tt CLASS=literal>argv[1]</tt>, and C's<tt CLASS=literal>argv[0]</tt> ends up in <B>$0</B>.  <P><li CLASS=listitem>Functions such as <A HREF="ch03_02.htm#PERL2-CMD-LINK">link</A>,<A HREF="ch03_02.htm#PERL2-CMD-UNLINK">unlink</A>, and <A HREF="ch03_02.htm#PERL2-CMD-RENAME">rename</A> return true for success, not <tt CLASS=literal>0</tt>.<P><li CLASS=listitem>Signal handlers deal with signal names, not numbers.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-2.5">Sed Traps</A></h3><P CLASS=para>Seasoned <I CLASS=emphasis>sed</I> programmers should take note of thefollowing:<P><UL CLASS=itemizedlist><li CLASS=listitem>Backreferences in substitutions use <tt CLASS=literal>$</tt> rather than <tt CLASS=literal>\</tt>.<P><li CLASS=listitem> The pattern matching metacharacters<tt CLASS=literal>(</tt>, <tt CLASS=literal>)</tt>, and <tt CLASS=literal>|</tt>do not have backslashes in front.  The corresponding literalcharacters do.  <P><li CLASS=listitem>The range operator in Perl is . . . ratherthan a comma.  <P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-2.6">Shell Traps</A></h3><P CLASS=para>Sharp shell programmers should take note of the following:<P><UL CLASS=itemizedlist><li CLASS=listitem>Variables are prefixed with <tt CLASS=literal>$</tt> or <tt CLASS=literal>@</tt> on the left side ofthe assignment as well as the right.  A shellish assignment like:<DIV CLASS=programlisting><P><PRE>camel='dromedary';      # WRONG</PRE></DIV><P CLASS=para>won't be parsed the way you expect.  You need:<DIV CLASS=programlisting><P><PRE>$camel='dromedary';     # ok</PRE></DIV><P CLASS=para><P><li CLASS=listitem>The loop variable of a <B>foreach</B> also requires a <tt CLASS=literal>$</tt>.Although <I CLASS=emphasis>csh</I> likes:<DIV CLASS=programlisting><P><PRE>foreach hump (one two)stuff_it $humpend</PRE></DIV><P CLASS=para>in Perl this is written as:<DIV CLASS=programlisting><P><PRE>foreach $hump ("one", "two") {    stuff_it($hump);}</PRE></DIV><P CLASS=para><P><li CLASS=listitem>The backtick operator does variable interpretation without regard tothe presence of single quotes in the command.<P><li CLASS=listitem>The backtick operator does no translation of the return value.In Perl, you have to trim the newline explicitly, like this:<DIV CLASS=programlisting><P><PRE>chop($thishost = `hostname`);</PRE></DIV><P CLASS=para><P><li CLASS=listitem>Shells (especially <I CLASS=emphasis>csh</I>) do several levels of substitution on eachcommand line.  Perl does substitution only within certain constructssuch as double quotes, backticks, angle brackets, and search patterns.<P><li CLASS=listitem>Shells tend to interpret scripts a little bit at a time.  Perl compilesthe entire program before executing it (except for <tt CLASS=literal>BEGIN</tt> blocks,which execute at compile time).<P><li CLASS=listitem> The arguments are available via <B>@ARGV</B>, not <B>$1</B>,<B>$2</B>, and so on.  <P><li CLASS=listitem>The environment is not automatically made available as separate scalarvariables.  But see the Env module.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-2.7">Previous Perl Traps</A></h3><P CLASS=para><A NAME="CH08.PERLOLD1"></A><A NAME="CH08.PERLOLD2"></A>Penitent Perl 4 (and Prior) Programmers should take note of the followingchanges between Release 4 and Release 5 that might affect old scripts:<P><UL CLASS=itemizedlist><li CLASS=listitem><tt CLASS=literal>@</tt> now always interpolates an array in double-quotish strings.Some programs may now need to use backslash to protect any <tt CLASS=literal>@</tt>that shouldn't interpolate.<P><li CLASS=listitem>Barewords that used to look like strings to Perl will now look likesubroutine calls if a subroutine by that name is defined before thecompiler sees them.  For example:<DIV CLASS=programlisting><P><PRE>sub SeeYa { die "Hasta la vista, baby!" }$SIG{'QUIT'} = SeeYa;</PRE></DIV><P CLASS=para>In prior versions of Perl, that code would set the signal handler.  Now, itactually calls the function!  You may use the <B>-w</B> switch to find such risky usage.<P><li CLASS=listitem>Symbols starting with "_" are no longer forced into package main, exceptfor <B>$_</B> itself (and <B>@_</B>, and so on).<P><li CLASS=listitem>Double-colon is now a valid package separator in an identifier.  Thus,the statement:<DIV CLASS=programlisting><P><PRE>print "$a::$b::$c\n";</PRE></DIV><P CLASS=para>now parses <tt CLASS=literal>$a::</tt> as the variable reference, where inprior versions only the <tt CLASS=literal>$a</tt> was considered to be the variablereference.  Similarly,<DIV CLASS=programlisting><P><PRE>print "$var::abc::xyz\n";</PRE></DIV><P CLASS=para>is now interpreted as a single variable <tt CLASS=literal>$var::abc::xyz</tt>,whereas in prior versions, the variable <tt CLASS=literal>$var</tt> would have beenfollowed by the constant text <tt CLASS=literal>::abc::xyz</tt>.<P><li CLASS=listitem><tt CLASS=literal>s'$lhs'$rhs'</tt> now does no interpolation on either side.  It used tointerpolate <tt CLASS=literal>$lhs</tt> but not <tt CLASS=literal>$rhs</tt>.<P><li CLASS=listitem>The second and third arguments of <A HREF="ch03_02.htm#PERL2-CMD-SPLICE">splice</A> arenow evaluated in scalar context (as documented) rather than list context.<P><li CLASS=listitem>These are now semantic errors because of precedence:<DIV CLASS=programlisting><P><PRE>shift @list + 20; # now parses like shift(@list + 20), illegal!$n = keys %map + 20; # now parses like keys(%map + 20), illegal!</PRE></DIV><P CLASS=para>Because if those were to work, then this couldn't:<DIV CLASS=programlisting><P><PRE>sleep $dormancy + 20;</PRE></DIV><P CLASS=para><P><li CLASS=listitem>The precedence of assignment operators is now the same as the precedenceof assignment.  Previous versions of Perl mistakenly gave them theprecedence of the associated operator.  So you now must parenthesizethem in expressions like<DIV CLASS=programlisting><P><PRE>/foo/ ? ($a += 2) : ($a -= 2);</PRE></DIV><P CLASS=para>Otherwise:<DIV CLASS=programlisting><P><PRE>/foo/ ? $a += 2 : $a -= 2;</PRE></DIV><P CLASS=para>would be erroneously parsed as:<DIV CLASS=programlisting><P><PRE>(/foo/ ? $a += 2 : $a) -= 2;</PRE></DIV><P CLASS=para>On the other hand,<DIV CLASS=programlisting><P><PRE>$a += /foo/ ? 1 : 2;</PRE></DIV><P CLASS=para>now works as a C programmer would expect.<P><li CLASS=listitem><tt CLASS=literal>open FOO || die</tt> is now incorrect.  You need parentheses aroundthe filehandle, because <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A> has the precedence of a list operator.<P><li CLASS=listitem>The elements of argument lists for formats are now evaluated in listcontext.  This means you can interpolate list values now.<P><li CLASS=listitem>You can't do a <A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A> into a block that is optimized away.  Darn.<P><li CLASS=listitem>It is no longer syntactically legal to use whitespace as the nameof a variable, or as a delimiter for any kind of quote construct.Double darn.<P><li CLASS=listitem>The <A HREF="ch03_02.htm#PERL2-CMD-CALLER">caller</A> function now returns a false value in a scalar contextif there is no caller.  This lets library modules determine whetherthey're being required or run directly.<P><li CLASS=listitem><tt CLASS=literal>m//g</tt> now attaches its state to the searched string rather thanthe regular expression.  See "Regular Expressions" in <A HREF="ch02_01.htm">Chapter 2, <i>The Gory Details</i></A> forfurther details.<P><li CLASS=listitem><tt CLASS=literal>reverse</tt> is no longer allowed as the name of a <A HREF="ch03_02.htm#PERL2-CMD-SORT">sort</A> subroutine.<P><li CLASS=listitem><I CLASS=emphasis>taintperl</I> is no longer a separate executable.  There is now a <B>-T</B>switch to turn on tainting when it isn't turned on automatically.<P><li CLASS=listitem>Double-quoted strings may no longer end with an unescaped <tt CLASS=literal>$</tt> or<tt CLASS=literal>@</tt>.<P><li CLASS=listitem>The archaic <B>if</B> <tt CLASS=replaceable><i>BLOCK BLOCK</i></tt> syntax is no longer supported.<P><li CLASS=listitem>Negative array subscripts now count from the end of the array.<P><li CLASS=listitem>The comma operator in a scalar context is now guaranteed to give ascalar context to its arguments.<P><li CLASS=listitem>The <tt CLASS=literal>**</tt> operator now binds more tightly than unary minus.  It was documented to work this way before, but didn't.<P><li CLASS=listitem>Setting <tt CLASS=literal>$#array</tt> lower now discards array elements immediately.<P><li CLASS=listitem><A HREF="ch03_02.htm#PERL2-CMD-DELETE">delete</A> is not guaranteed to return the deleted value for<A HREF="ch03_02.htm#PERL2-CMD-TIE">tie</A>d arrays, since this capability may be onerous for some modulesto implement.<P><li CLASS=listitem>The construct <tt CLASS=literal>"this is $$x"</tt>, which used to interpolate the pid at thatpoint, now tries to dereference <tt CLASS=literal>$x</tt>.  <B>$$</B> by itself stillworks fine, however.<P><li CLASS=listitem>The meaning of <B>foreach</B> has changed slightly when it is iterating over alist which is not an array.  This used to assign the list to atemporary array, but for efficiency it no longer does so.  This meansthat you'll now be iterating over the actual values, not over copies ofthe values.  Modifications to the loop variable can change the originalvalues.  To retain prior Perl semantics you'd need to assign your listexplicitly to a temporary array and then iterate over that.  Forexample, you might need to change:<DIV CLASS=programlisting><P><PRE>foreach $var (grep /x/, @list) { ... }</PRE></DIV><P CLASS=para>to:<DIV CLASS=programlisting><P><PRE>foreach $var (my @tmp = grep /x/, @list) { ... }</PRE></DIV><P CLASS=para>Otherwise changing <tt CLASS=literal>$var</tt> will clobber the values of<tt CLASS=literal>@list</tt>.  (This most often happens when you use <B>$_</B> for theloop variable, and call subroutines in the loop that don't properlylocalize <B>$_</B>.)<P><li CLASS=listitem>Some error messages will be different.<P><li CLASS=listitem>Some bugs may have been inadvertently removed.[3]<blockquote class=footnote><P CLASS=para>[3] Much to the consternation of Perl poets.</blockquote><P></UL></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch08_01.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch08_03.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>The Perl Debugger</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Efficiency</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>