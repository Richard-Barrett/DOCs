<!DOCTYPE HTML PUBLIC "-//ORA//DTD CD HTML 3.2//EN"><HTML><HEAD><TITLE>[Chapter 8] 8.3 Efficiency</TITLE><META NAME="author" CONTENT="Larry Wall, Tom Christiansen, and Randal Schwartz"><META NAME="date" CONTENT="Mon Mar 17 13:20:11 1997"><META NAME="form" CONTENT="html"><META NAME="metadata" CONTENT="dublincore.0.1"><META NAME="objecttype" CONTENT="book part"><META NAME="otheragent" CONTENT="gmat dbtohtml"><META NAME="publisher" CONTENT="O'Reilly &amp; Associates, Inc."><META NAME="source" CONTENT="SGML"><META NAME="subject" CONTENT="Perl"><META NAME="title" CONTENT="Programming Perl, Second Edition"><!-- JavaScript: pathcont.js --></HEAD><BODY BGCOLOR="#FFFFFF"><DIV CLASS=htmlnav><H1><IMG SRC="gifs/smbanner.gif"     ALT="Programming Perl, Second Edition"></H1><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch08_02.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><b>Chapter 8</b></td><td width=172 align=right valign=top><A HREF="ch08_04.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --><hr align=left width=515></DIV><DIV CLASS=sect1><h2 CLASS=sect1><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-3">8.3 Efficiency</A></h2><P CLASS=para><A NAME="CH08.PERF1"></A>While most of the work of programming may be simply getting a programworking properly, you may find yourself wanting more bang for the buckout of your Perl program.  Perl's rich set of operators, datatypes, andcontrol constructs are not necessarily intuitive when it comes to speedand space optimization.  Many trade-offs were made during Perl's design,and such decisions are buried in the guts of the code.  In general, theshorter and simpler your code is, the faster it runs, but there areexceptions.  This section attempts to help you make it work just a weebit better.<P CLASS=para>(If you want it to work a lot better, you can play with the new Perl-to-Ctranslation modules, or rewrite your inner loop as a C extension.)<P CLASS=para>You'll note that sometimes optimizing for time may cost you in space orprogrammer efficiency (indicated by conflicting hints below).  Them'sthe breaks.  If programming were easy, they wouldn't need something ascomplicated as a human being to do it, now would they?<DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-3.1">Time Efficiency</A></h3><UL CLASS=itemizedlist><li CLASS=listitem>Use hashes instead of linear searches.For example, instead of searching through <tt CLASS=literal>@keywords</tt> to see if<B>$_</B> is a keyword, construct a hash with:<DIV CLASS=programlisting><P><PRE>my %keywords;for (@keywords) {    $keywords{$_}++;}</PRE></DIV><P CLASS=para>Then, you can quickly tell if <B>$_</B> contains a keyword by testing<tt CLASS=literal>$keyword{$_}</tt> for a non-zero value.<P><li CLASS=listitem> Avoid subscripting when a <B>foreach</B> or list operator will do.  Subscriptingsometimes forces conversion from floating point to integer, andthere's often a better way to do it.  Consider using <B>foreach</B>, <A HREF="ch03_02.htm#PERL2-CMD-SHIFT">shift</A>,and <A HREF="ch03_02.htm#PERL2-CMD-SPLICE">splice</A> operations.  Consider saying<tt CLASS=literal>use integer</tt>.  <P><li CLASS=listitem>Avoid <A HREF="ch03_02.htm#PERL2-CMD-GOTO">goto</A>.It scans outward from your current location for the indicated label.<P><li CLASS=listitem>Avoid <A HREF="ch03_02.htm#PERL2-CMD-PRINTF">printf</A> if <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> will work.Quite apart from the extra overhead of <A HREF="ch03_02.htm#PERL2-CMD-PRINTF">printf</A>, someimplementations have field length limitations that <A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A> getsaround.<P><li CLASS=listitem>Avoid <B>$&amp;</B>, <B>$</B><tt CLASS=literal>`</tt>, and <B>$</B><tt CLASS=literal>'</tt>.Any occurrence in your program causes all matches to save the searchedstring for possible future reference.  (However, once you've blown it, itdoesn't hurt to have more of them.)<P><li CLASS=listitem>Avoid using <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> on a string.  An <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> of a string (not of a<tt CLASS=replaceable><i>BLOCK</i></tt>) forces recompilation every time through.  ThePerl parser is pretty fast for a parser, but that's not saying much.  Nowadaysthere's almost always a better way to do what you want anyway.  In particular,any code that uses <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> merely to constructvariable names is obsolete, since you can now do the same directly usingsymbolic references:<DIV CLASS=programlisting><P><PRE>${$pkg . '::' . $varname} = &amp;{ "fix_" . $varname }($pkg);</PRE></DIV><P CLASS=para><P><li CLASS=listitem>Avoid string <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> inside a loop.Put the loop into the <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> instead, to avoid redundantrecompilations of the code.  See the <A HREF="ch03_02.htm#PERL2-CMD-STUDY">study</A> operatorin <A HREF="ch03_01.htm">Chapter 3, <i>Functions</i></A> for an example of this.<P><li CLASS=listitem> Avoid run-time-compiled patterns. Use the<tt CLASS=literal>/</tt><tt CLASS=replaceable><i>pattern</i></tt><tt CLASS=literal>/o</tt>(once only) pattern modifier to avoid pattern recompilation when thepattern doesn't change over the life of the process.For patterns that changeoccasionally, you can use the fact that a null pattern refers back tothe previous pattern, like this:<DIV CLASS=programlisting><P><PRE>"foundstring" =~ /$currentpattern/;        # Dummy match (must succeed).while (&lt;&gt;) {    print if //;}</PRE></DIV><P CLASS=para>You can also use <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> to recompile a subroutine that does the match (ifyou only recompile occasionally).<P><li CLASS=listitem>Short-circuit alternation is often faster than the correspondingregular expression.  So:<DIV CLASS=programlisting><P><PRE>print if /one-hump/ || /two/;</PRE></DIV><P CLASS=para>is likely to be faster than:<DIV CLASS=programlisting><P><PRE>print if /one-hump|two/;</PRE></DIV><P CLASS=para>at least for certain values of one-hump and two.This is because the optimizer likes to hoist certain simple matchingoperations up into higher parts of the syntax tree and do very fastmatching with a Boyer-Moore algorithm.  A complicated pattern defeatsthis.<P><li CLASS=listitem>Reject common cases early with <tt CLASS=literal>next if</tt>.As with simple regular expressions, the optimizer likes this.  And it justmakes sense to avoid unnecessary work.  You can typically discard commentlines and blank lines even before you do a <B>split</B> or <B>chop</B>:<DIV CLASS=programlisting><P><PRE>while (&lt;&gt;) {    next if /^#/;    next if /^$/;    chop;    @piggies = split(/,/);    ...}</PRE></DIV><P CLASS=para><P><li CLASS=listitem> Avoid regular expressions with many quantifiers, or with big<tt CLASS=literal>{</tt><tt CLASS=replaceable><i>m,n</i></tt><tt CLASS=literal>}</tt>numbers on parenthesized expressions.  Such patterns can result inexponentially slow backtracking behavior unless the quantifiedsubpatterns match on their first "pass".  <P><li CLASS=listitem>Try to maximize the length of any non-optional literal strings inregular expressions.  This is counterintuitive, but longer patternsoften match faster than shorter patterns.  That's because theoptimizer looks for constant strings and hands them off to aBoyer-Moore search, which benefits from longer strings.  Compile yourpattern with the <tt CLASS=literal>-Dr</tt> debugging switch to see whatPerl thinks the longest literal string is.<P><li CLASS=listitem>Avoid expensive subroutine calls in tight loops.There is overhead associated with calling subroutines, especially whenyou pass lengthy parameter lists, or return lengthy values.  Inincreasing order of desperation, try passing values by reference,passing values as dynamically scoped globals, inlining the subroutine,or rewriting the whole loop in C.<P><li CLASS=listitem>Avoid <A HREF="ch03_02.htm#PERL2-CMD-GETC">getc</A> for anything but single-character terminal I/O.In fact, don't use it for that either.  Use <A HREF="ch03_02.htm#PERL2-CMD-SYSREAD">sysread</A>.<P><li CLASS=listitem>Use <A HREF="ch03_02.htm#PERL2-CMD-READDIR">readdir</A> rather than <tt CLASS=literal>&lt;*&gt;</tt>.To get all the non-dot files within a directory, say something like:<DIV CLASS=programlisting><P><PRE>opendir(DIR,".");@files = sort grep(!/^\./, readdir(DIR));closedir(DIR);</PRE></DIV><P CLASS=para><P><li CLASS=listitem>Avoid frequent <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A> on long strings.<P><li CLASS=listitem>Use <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A> and <A HREF="ch03_02.htm#PERL2-CMD-UNPACK">unpack</A> instead of multiple <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A>invocations.<P><li CLASS=listitem>Use <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A> as an lvalue rather thanconcatenating substrings. For example, to replace the fourth through sixthcharacters of <tt CLASS=literal>$foo</tt> with the contents of the variable<tt CLASS=literal>$bar</tt>, don't do:<DIV CLASS=programlisting><P><PRE>$foo = substr($foo,0,3) . $bar . substr($foo,6);</PRE></DIV><P CLASS=para>Instead, simply identify the part of the string to be replaced,and assign into it, as in:<DIV CLASS=programlisting><P><PRE>substr($foo,3,3) = $bar;</PRE></DIV><P CLASS=para>But be aware that if <tt CLASS=literal>$foo</tt> is a huge string, and <tt CLASS=literal>$bar</tt>isn't exactly <tt CLASS=literal>3</tt> characters long, this can do a lot of copying too.<P><li CLASS=listitem>Use <tt CLASS=literal>s///</tt> rather than concatenating substrings.This is especially true if you can replace one constant with another ofthe same size.  This results in an in-place substitution.<P><li CLASS=listitem>Use modifiers and equivalent <B>and</B> and <B>or</B>, instead offull-blown conditionals.Statement modifiers and logical operators avoid the overhead of enteringand leaving a block.  They can often be more readable too.<P><li CLASS=listitem>Use <tt CLASS=literal>$foo = $a || $b || $c</tt>.This is much faster (and shorter to say) than:<DIV CLASS=programlisting><P><PRE>if ($a) {    $foo = $a;}elsif ($b) {    $foo = $b;}elsif ($c) {    $foo = $c;}</PRE></DIV><P CLASS=para>Similarly, set default values with:<DIV CLASS=programlisting><P><PRE>$pi ||= 3;</PRE></DIV><P CLASS=para><P><li CLASS=listitem>Group together any tests that want the same initial string.When testing a string for various prefixes in anything resembling aswitch structure, put together all the <tt CLASS=literal>/^a/</tt> patterns, all the<tt CLASS=literal>/^b/</tt> patterns, and so on.<P><li CLASS=listitem>Don't test things you know won't match.Use <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A> or <B>elsif</B> to avoid falling through to the nextcase in your switch statement.<P><li CLASS=listitem>Use special operators like <A HREF="ch03_02.htm#PERL2-CMD-STUDY">study</A>, logical string operations,<tt CLASS=literal>unpack 'u'</tt> and <tt CLASS=literal>pack '%'</tt> formats.<P><li CLASS=listitem>Beware of the tail wagging the dog.Misstatements resembling <tt CLASS=literal>(&lt;STDIN&gt;)[0]</tt> and <tt CLASS=literal>0.. 2000000</tt> cancause Perl much unnecessary work.  In accord with UNIX philosophy, Perlgives you enough rope to hang yourself.<P><li CLASS=listitem>Factor operations out of loops. The Perl optimizer does not attempt toremove invariant code from loops. It expects you to exercise some sense.<P><li CLASS=listitem>Slinging strings can be faster than slinging arrays.<P><li CLASS=listitem>Slinging arrays can be faster than slinging strings.It all depends on whether you're going to reuse the strings or arrays,and on which operations you're going to perform.  Heavy modification of eachelement implies that arrays will be better, and occasional modification ofsome elements implies that strings will be better.  But you just have totry it and see.<P><li CLASS=listitem><A HREF="ch03_02.htm#PERL2-CMD-MY">my</A> variables are normally faster than <A HREF="ch03_02.htm#PERL2-CMD-LOCAL">local</A> variables.<P><li CLASS=listitem>Sorting on a manufactured key array may be faster than using a fancy sortsubroutine.A given array value may participate in several sort comparisons, so ifthe sort subroutine has to do much recalculation, it's better tofactor out that calculation to a separate pass before the actual sort.<P><li CLASS=listitem><tt CLASS=literal>tr/abc//d</tt> is faster than <tt CLASS=literal>s/[abc]//g</tt>.<P><li CLASS=listitem><A HREF="ch03_02.htm#PERL2-CMD-PRINT">print</A>with a comma separator may be faster than concatenating strings.For example:<DIV CLASS=programlisting><P><PRE>print $fullname{$name} . " has a new home directory " .    $home{$name} . "\n";</PRE></DIV><P CLASS=para>has to glue together the two hashes and the twofixed strings before passing them to the low-level print routines, whereas:<DIV CLASS=programlisting><P><PRE>print $fullname{$name}, " has a new home directory ",    $home{$name}, "\n";</PRE></DIV><P CLASS=para>doesn't.  On the other hand, depending on the values and the architecture,the concatenation may be faster.  Try it.<P><li CLASS=listitem>Prefer <tt CLASS=literal>join(``, ...)</tt> to a series of concatenated strings.Multiple concatenations may cause strings to be copied back andforth multiple times.  The <A HREF="ch03_02.htm#PERL2-CMD-JOIN">join</A> operator avoids this.<P><li CLASS=listitem><A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> on a fixed string is generally faster than <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> on apattern.That is, use <tt CLASS=literal>split(/ /,...)</tt> rather than<tt CLASS=literal>split(/ +/,...)</tt> if you know there will only be one space.However, the patterns <tt CLASS=literal>/\s+/</tt>, <tt CLASS=literal>/^/</tt> and <tt CLASS=literal>/ /</tt> arespecially optimized, as is the <A HREF="ch03_02.htm#PERL2-CMD-SPLIT">split</A> on whitespace.<P><li CLASS=listitem>Pre-extending an array or string can save some time.As strings and arrays grow, Perl extends them by allocating a new copywith some room for growth and copying in the old value.  Pre-extending astring with the <B>x</B> operator or an array by setting <tt CLASS=literal>$#array</tt>can prevent this occasional overhead, as well as minimize memoryfragmentation.<P><li CLASS=listitem>Don't <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> long strings and arrays if they'll be reused for thesame purpose.This helps prevent reallocation when the string or array must be re-extended.<P><li CLASS=listitem>Prefer <tt CLASS=literal>`\0` x 8192</tt> over <tt CLASS=literal>unpack(`x8192`,())</tt>.<P><li CLASS=listitem><tt CLASS=literal>system(`mkdir...`)</tt> may be faster on multiple directories if<I CLASS=emphasis>mkdir</I> (2) isn't available.<P><li CLASS=listitem>Avoid using <A HREF="ch03_02.htm#PERL2-CMD-EOF">eof</A> if return values will already indicate it.<P><li CLASS=listitem>Cache entries from passwd and group (and so on) that are apt to be reused.For example, to cache the return value from <A HREF="ch03_02.htm#PERL2-CMD-GETHOSTBYADDR">gethostbyaddr</A> whenyou are converting numeric addresses (like <tt CLASS=literal>198.112.208.11</tt>) to names(like "www.ora.com"), you can use something like:<DIV CLASS=programlisting><P><PRE>sub numtoname {    local($_) = @_;    unless (defined $numtoname{$_}) {        local(@a) = gethostbyaddr(pack('C4', split(/\./)),2);        $numtoname{$_} = @a &gt; 0 ? $a[0] : $_;    }    $numtoname{$_};}</PRE></DIV><P CLASS=para><P><li CLASS=listitem>Avoid unnecessary system calls.Operating system calls tend to be rather expensive.  So for example,don't call the <A HREF="ch03_02.htm#PERL2-CMD-TIME">time</A> operator when a cached value of <tt CLASS=literal>$now</tt>would do.  Use the special <B>_</B> filehandle to avoid unnecessary<I CLASS=emphasis>stat</I> (2) calls.  On some systems, even a minimal system call mayexecute a thousand instructions.<P><li CLASS=listitem>Avoid unnecessary <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A> calls.The <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A> operator has to fork a subprocess and execute theprogram you specify.  Or worse, execute a shell to execute the programyou specify.  This can easily execute a million instructions.<P><li CLASS=listitem>Worry about starting subprocesses, but only if they're frequent.Starting a single <I CLASS=emphasis>pwd</I>, <I CLASS=emphasis>hostname</I>, or <I CLASS=emphasis>find</I> process isn'tgoing to hurt you much--after all, a shell starts subprocesses all daylong.  We do occasionally encourage the toolbox approach, believe it or not.<P><li CLASS=listitem>Keep track of your working directory yourself rather than calling<I CLASS=emphasis>pwd</I> repeatedly.(A package is provided in the standard library for this.See the Cwd module in <A HREF="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.)<P><li CLASS=listitem>Avoid shell metacharacters in commands--pass lists to <A HREF="ch03_02.htm#PERL2-CMD-SYSTEM">system</A> and<A HREF="ch03_02.htm#PERL2-CMD-EXEC">exec</A> where appropriate.<P><li CLASS=listitem>Set the sticky bit on the Perl interpreter on machines without demand paging.<DIV CLASS=programlisting><P><PRE>chmod +t /usr/bin/perl</PRE></DIV><P><li CLASS=listitem>Using defaults doesn't make your program faster.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-3.2">Space Efficiency</A></h3><UL CLASS=itemizedlist><li CLASS=listitem>Use <A HREF="ch03_02.htm#PERL2-CMD-VEC">vec</A> for compact integer array storage.<P><li CLASS=listitem>Prefer numeric values over string values--they require little additionalspace over that allocated for the scalar header structure.<P><li CLASS=listitem>Use <A HREF="ch03_02.htm#PERL2-CMD-SUBSTR">substr</A> to store constant-length strings in a longer string.<P><li CLASS=listitem>Use the Tie::SubstrHash module for very compact storage of a hash array,if the key and value lengths are fixed.<P><li CLASS=listitem>Use <tt CLASS=literal>_ _END_ _</tt> and the <tt CLASS=literal>DATA</tt>filehandle to avoid storing program data as both a string and an array.<P><li CLASS=listitem>Prefer <A HREF="ch03_02.htm#PERL2-CMD-EACH">each</A> to <A HREF="ch03_02.htm#PERL2-CMD-KEYS">keys</A> where order doesn't matter.<P><li CLASS=listitem>Delete or <A HREF="ch03_02.htm#PERL2-CMD-UNDEF">undef</A> globals that are no longer in use.<P><li CLASS=listitem>Use some kind of DBM to store hashes.<P><li CLASS=listitem>Use temp files to store arrays.<P><li CLASS=listitem>Use pipes to offload processing to other tools.<P><li CLASS=listitem>Avoid list operations and file slurps.<P><li CLASS=listitem>Avoid using <tt CLASS=literal>tr///</tt>, each of which must store a translationtable of 256 short integers (not characters, since we have to rememberwhich characters are to be deleted).<P><li CLASS=listitem>Don't unroll your loops or inline your subroutines.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-3.3">Programmer Efficiency</A></h3><UL CLASS=itemizedlist><li CLASS=listitem>Use defaults.<P><li CLASS=listitem>Use funky shortcut command-line switches like<B>-a, -n, -p, -s, -i</B>.<P><li CLASS=listitem>Use <B>for</B> to mean <B>foreach</B>.<P><li CLASS=listitem>Sling UNIX commands around with backticks.<P><li CLASS=listitem>Use <tt CLASS=literal>&lt;*&gt;</tt> and such.<P><li CLASS=listitem>Use run-time-compiled patterns.<P><li CLASS=listitem>Use patterns with lots of <tt CLASS=literal>*</tt>, <tt CLASS=literal>+</tt>,and <tt CLASS=literal>{}</tt>.  <P><li CLASS=listitem>Sling whole arrays and slurp entire files.<P><li CLASS=listitem>Use <A HREF="ch03_02.htm#PERL2-CMD-GETC">getc</A>.<P><li CLASS=listitem>Use <B>$&amp;</B>, <B>$</B><tt CLASS=literal>`</tt>, and <B>$</B><tt CLASS=literal>'</tt>.<P><li CLASS=listitem>Don't check error values on <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A>, since<tt CLASS=literal>&lt;</tt><tt CLASS=replaceable><i>HANDLE</i></tt><tt CLASS=literal>&gt;</tt>and <tt CLASS=literal>print</tt> <tt CLASS=replaceable><i>HANDLE</i></tt> will simplyno-op when given an invalid handle.  <P><li CLASS=listitem>Don't <A HREF="ch03_02.htm#PERL2-CMD-CLOSE">close</A> your files--they'll beclosed on the next <A HREF="ch03_02.htm#PERL2-CMD-OPEN">open</A>.<P><li CLASS=listitem>Pass subroutine arguments as globals.<P><li CLASS=listitem>Don't name your subroutine parameters.You can access them directly as<tt CLASS=literal>$_[</tt><tt CLASS=replaceable><i>EXPR</i></tt><tt CLASS=literal>]</tt>.<P><li CLASS=listitem>Use whatever you think of first.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-3.4">Maintainer Efficiency</A></h3><UL CLASS=itemizedlist><li CLASS=listitem>Don't use defaults.<P><li CLASS=listitem>Use <B>foreach</B> to mean <B>foreach</B>.<P><li CLASS=listitem>Use meaningful loop labels with <A HREF="ch03_02.htm#PERL2-CMD-NEXT">next</A> and <A HREF="ch03_02.htm#PERL2-CMD-LAST">last</A>.<P><li CLASS=listitem>Use meaningful variable names.<P><li CLASS=listitem>Use meaningful subroutine names.<P><li CLASS=listitem>Put the important thing first on the line using <B>and</B>, <B>or</B>,and statement modifiers.<P><li CLASS=listitem>Close your files as soon as you're done with them.<P><li CLASS=listitem>Use packages, modules, and classes to hide your implementation details.<P><li CLASS=listitem>Pass arguments as subroutine parameters.<P><li CLASS=listitem>Name your subroutine parameters using <A HREF="ch03_02.htm#PERL2-CMD-MY">my</A>.<P><li CLASS=listitem>Parenthesize for clarity.<P><li CLASS=listitem>Put in lots of (useful) comments.<P><li CLASS=listitem>Write the script as its own POD document.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-3.5">Porter Efficiency</A></h3><UL CLASS=itemizedlist><li CLASS=listitem>Wave a handsome tip under his nose.<P><li CLASS=listitem>Avoid functions that aren't implemented everywhere.You can use <A HREF="ch03_02.htm#PERL2-CMD-EVAL">eval</A> tests to see what's available.<P><li CLASS=listitem>Don't expect native float and double to <A HREF="ch03_02.htm#PERL2-CMD-PACK">pack</A> and <A HREF="ch03_02.htm#PERL2-CMD-UNPACK">unpack</A> onforeign machines.<P><li CLASS=listitem>Use network byte order when sending binary data over the network.<P><li CLASS=listitem>Don't send binary data over the network.<P><li CLASS=listitem>Check <B>$]</B> to see if the current version supports all the featuresyou use.<P><li CLASS=listitem>Don't use <B>$]</B>: use <A HREF="ch03_02.htm#PERL2-CMD-REQUIRE">require</A> with a version number.<P><li CLASS=listitem>Put in the <tt CLASS=literal>eval exec</tt> hack even if you don't use it.<P><li CLASS=listitem>Put the <tt CLASS=literal>#!/usr/bin/perl</tt> line in even if you don't use it.<P><li CLASS=listitem>Test for variants of UNIX commands.Some <I CLASS=emphasis>find</I>s can't handle <I CLASS=emphasis>-xdev</I>, for example.<P><li CLASS=listitem>Avoid variant UNIX commands if you can do it internally.UNIX commands don't work too well on MS-DOS or VMS.<P><li CLASS=listitem>Use the Config module or the <B>$^O</B> variable to find out what kind ofmachine you're running on.<P><li CLASS=listitem>Put all your scripts and manpages into a single NFS filesystem that'smounted everywhere.<P></UL></DIV><DIV CLASS=sect2><h3 CLASS=sect2><A CLASS="TITLE" NAME="PERL2-CH-8-SECT-3.6">User Efficiency</A></h3><UL CLASS=itemizedlist><li CLASS=listitem>Avoid forcing prompt order--pop users into their favorite editor with a form.<P><li CLASS=listitem>Better yet, use a GUI like the Perl Tk extension, where users can control the order of events.<P><li CLASS=listitem>Put up something for users to read while you continue doing work.<P><li CLASS=listitem>Use autoloading so that the program <I CLASS=emphasis>appears</I> to run faster.<P><li CLASS=listitem>Give the option of helpful messages at every prompt.<P><li CLASS=listitem>Give a helpful usage message if users don't give correct input.<P><li CLASS=listitem>Display the default action at every prompt, and maybe a few alternatives.<P><li CLASS=listitem>Choose defaults for beginners.  Allow experts to change the defaults.<P><li CLASS=listitem>Use single character input where it makes sense.<P><li CLASS=listitem>Pattern the interaction after other things the user is familiar with.<P><li CLASS=listitem>Make error messages clear about what needs fixing.  Include allpertinent information such as filename and <tt CLASS=literal>errno</tt>, like this:<DIV CLASS=programlisting><P><PRE>open(FILE, $file) or die "$0: Can't open $file for reading: $!\n";</PRE></DIV><P CLASS=para><P><li CLASS=listitem>Use <A HREF="ch03_02.htm#PERL2-CMD-FORK">fork</A> and <A HREF="ch03_02.htm#PERL2-CMD-EXIT">exit</A> to detach when the rest of the script is batch processing.<P><li CLASS=listitem>Allow arguments to come either from the command line or via standardinput.<P><li CLASS=listitem>Use text-oriented network protocols.<P><li CLASS=listitem>Don't put arbitrary limitations into your program.<P><li CLASS=listitem>Prefer variable-length fields over fixed-length fields.<P><li CLASS=listitem>Be vicariously lazy.<P><li CLASS=listitem>Be nice.<P></UL></DIV></DIV><DIV CLASS=htmlnav><P><HR align=left width=515><table width=515 border=0 cellpadding=0 cellspacing=0><tr><td width=172 align=left valign=top><A HREF="ch08_02.htm"><IMG SRC="gifs/txtpreva.gif"     ALT="Previous" border=0></A></td><td width=171 align=center valign=top><a href="index.htm"><IMG SRC="gifs/txthome.gif" ALT="Home" border=0></a></td><td width=172 align=right valign=top><A HREF="ch08_04.htm"><IMG SRC="gifs/txtnexta.gif"     ALT="Next" border=0></A></td></tr><tr><td width=172 align=left valign=top>Common Goofs for Novices</td><td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td><td width=172 align=right valign=top>Programming with Style</td></tr></table><!-- JavaScript: prev.js -->&nbsp;<!-- JavaScript: next.js --></DIV></BODY></HTML>